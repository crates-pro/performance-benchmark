// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn simpchinese::<impl at src/codec/simpchinese.rs:547:1: 562:2>::is_ascii_compatible(_1: &HZDecoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:549:28: 549:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/simpchinese.rs:549:38: 549:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/simpchinese.rs:549:45: 549:49
        return;                          // scope 0 at src/codec/simpchinese.rs:549:51: 549:51
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:69:1: 97:2>::from_self(_1: &ASCIIDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:70:18: 70:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/ascii.rs:70:28: 70:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/ascii.rs:70:46: 70:65
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/ascii.rs:70:46: 70:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/ascii.rs:70:46: 70:65
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:70:46: 70:65
        _3 = ASCIIDecoder::new() -> bb1; // scope 0 at src/codec/ascii.rs:70:46: 70:65
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:70:46: 70:63
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::ascii::ASCIIDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:70:46: 70:65
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:70:64: 70:65
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:70:46: 70:65
        StorageDead(_2);                 // scope 0 at src/codec/ascii.rs:70:66: 70:67
        return;                          // scope 0 at src/codec/ascii.rs:70:67: 70:67
    }
}

const ISO_8859_15: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:53:66: 53:79
    let _5: &str;                        // in scope 0 at src/all.rs:53:66: 53:79
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_15::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_15, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1261 ~ encoding[5d2c]::all::ISO_8859_15), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_15: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:53:66: 53:79
    let mut _4: &str;                    // in scope 0 at src/all.rs:53:66: 53:79
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-15";        // scope 0 at src/all.rs:53:66: 53:79
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:53:66: 53:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:53:66: 53:79
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_15::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_15::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_15::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_15::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-15"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:53:66: 53:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::gb18030::transient::S2(_1: &mut StatefulDecoderHelper<simpchinese::gb18030::State, T>, _2: u8, _3: u8) -> simpchinese::gb18030::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug first => _2;                   // in scope 0 at src/util.rs:223:61: 223:65
    debug second => _3;                  // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _4: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _5: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _6: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _7: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let mut _8: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _9: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _10: bool;                   // in scope 0 at src/codec/simpchinese.rs:230:18: 230:29
    let mut _11: bool;                   // in scope 0 at src/codec/simpchinese.rs:230:18: 230:29
    let mut _13: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:230:36: 230:39
    let mut _14: u8;                     // in scope 0 at src/codec/simpchinese.rs:230:41: 230:46
    let mut _15: u8;                     // in scope 0 at src/codec/simpchinese.rs:230:48: 230:54
    let mut _16: u8;                     // in scope 0 at src/codec/simpchinese.rs:230:56: 230:57
    let mut _17: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:231:19: 231:22
    scope 1 {
        debug c => _9;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _12: u8;                     // in scope 1 at src/codec/simpchinese.rs:230:14: 230:29
        scope 2 {
            debug b => _12;              // in scope 2 at src/codec/simpchinese.rs:230:14: 230:29
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_5);                 // scope 0 at src/util.rs:224:31: 224:38
        _5 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::read(move _5) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_5);                 // scope 0 at src/util.rs:224:44: 224:45
        _6 = discriminant(_4);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _6) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_9);                 // scope 0 at src/util.rs:226:34: 226:35
        _9 = ((_4 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        _10 = Le(const 129_u8, _9);      // scope 1 at src/codec/simpchinese.rs:230:18: 230:29
        switchInt(move _10) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/simpchinese.rs:230:18: 230:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_7);                 // scope 0 at src/util.rs:225:55: 225:59
        _7 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        StorageLive(_8);                 // scope 0 at src/util.rs:225:55: 225:59
        _8 = _3;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S2).1: u8) = move _7;    // scope 0 at src/util.rs:225:44: 225:62
        ((_0 as S2).2: u8) = move _8;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 2;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_8);                 // scope 0 at src/util.rs:225:61: 225:62
        StorageDead(_7);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb11;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _11 = Le(_9, const 254_u8);      // scope 1 at src/codec/simpchinese.rs:230:18: 230:29
        switchInt(move _11) -> [false: bb6, otherwise: bb7]; // scope 1 at src/codec/simpchinese.rs:230:18: 230:29
    }

    bb6: {
        StorageLive(_17);                // scope 1 at src/codec/simpchinese.rs:231:19: 231:22
        _17 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:231:19: 231:22
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::backup_and_err(move _17, const 2_usize, const "invalid sequence") -> bb9; // scope 1 at src/codec/simpchinese.rs:231:19: 231:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:231:23: 231:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, usize, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:231:41: 231:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb7: {
        StorageLive(_12);                // scope 1 at src/codec/simpchinese.rs:230:14: 230:29
        _12 = _9;                        // scope 1 at src/codec/simpchinese.rs:230:14: 230:29
        StorageLive(_13);                // scope 2 at src/codec/simpchinese.rs:230:36: 230:39
        _13 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:230:36: 230:39
        StorageLive(_14);                // scope 2 at src/codec/simpchinese.rs:230:41: 230:46
        _14 = _2;                        // scope 2 at src/codec/simpchinese.rs:230:41: 230:46
        StorageLive(_15);                // scope 2 at src/codec/simpchinese.rs:230:48: 230:54
        _15 = _3;                        // scope 2 at src/codec/simpchinese.rs:230:48: 230:54
        StorageLive(_16);                // scope 2 at src/codec/simpchinese.rs:230:56: 230:57
        _16 = _12;                       // scope 2 at src/codec/simpchinese.rs:230:56: 230:57
        _0 = simpchinese::gb18030::transient::S3::<T>(move _13, move _14, move _15, move _16) -> bb8; // scope 2 at src/codec/simpchinese.rs:230:33: 230:58
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:230:33: 230:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>, u8, u8, u8) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::transient::S3::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_16);                // scope 2 at src/codec/simpchinese.rs:230:57: 230:58
        StorageDead(_15);                // scope 2 at src/codec/simpchinese.rs:230:57: 230:58
        StorageDead(_14);                // scope 2 at src/codec/simpchinese.rs:230:57: 230:58
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:230:57: 230:58
        StorageDead(_12);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb10;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb9: {
        StorageDead(_17);                // scope 1 at src/codec/simpchinese.rs:231:59: 231:60
        goto -> bb10;                    // scope 1 at src/codec/simpchinese.rs:231:59: 231:60
    }

    bb10: {
        StorageDead(_9);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb11;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb11: {
        StorageDead(_4);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:49:1: 54:2>::raw_encoder(_1: &UTF8Encoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:52:20: 52:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_8.rs:52:30: 52:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_8.rs:52:48: 52:66
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_8.rs:52:48: 52:66

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:52:48: 52:66
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:52:48: 52:66
        _3 = UTF8Encoder::new() -> bb1;  // scope 0 at src/codec/utf_8.rs:52:48: 52:66
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:52:48: 52:64
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::utf_8::UTF8Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:52:48: 52:66
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:52:65: 52:66
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:52:48: 52:66
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:52:67: 52:68
        return;                          // scope 0 at src/codec/utf_8.rs:52:68: 52:68
    }
}

fn japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::from_self(_1: &ISO2022JPEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:799:18: 799:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:799:28: 799:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:799:46: 799:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:799:46: 799:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:799:46: 799:69
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:799:46: 799:69
        _3 = ISO2022JPEncoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:799:46: 799:69
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:799:46: 799:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::japanese::ISO2022JPEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:799:46: 799:69
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:799:68: 799:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:799:46: 799:69
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:799:70: 799:71
        return;                          // scope 0 at src/codec/japanese.rs:799:71: 799:71
    }
}

fn iso2022jp::start::ASCII(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/japanese.rs:912:18: 912:29
    let mut _7: bool;                    // in scope 0 at src/codec/japanese.rs:912:18: 912:29
    let mut _8: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:911:34: 911:37
    let _10: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:912:33: 912:51
    let mut _11: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:912:33: 912:36
    let mut _12: u32;                    // in scope 0 at src/codec/japanese.rs:912:42: 912:50
    let mut _13: u8;                     // in scope 0 at src/codec/japanese.rs:912:42: 912:43
    let mut _14: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:912:59: 912:62
    let _15: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:913:19: 913:46
    let mut _16: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:913:19: 913:22
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:913:54: 913:57
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _9: u8;                      // in scope 1 at src/codec/japanese.rs:912:14: 912:29
        scope 2 {
            debug b => _9;               // in scope 2 at src/codec/japanese.rs:912:14: 912:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        switchInt(_5) -> [27_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:187:36: 187:43
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb16;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _6 = Le(const 0_u8, _5);         // scope 1 at src/codec/japanese.rs:912:18: 912:29
        switchInt(move _6) -> [false: bb7, otherwise: bb6]; // scope 1 at src/codec/japanese.rs:912:18: 912:29
    }

    bb6: {
        _7 = Le(_5, const 127_u8);       // scope 1 at src/codec/japanese.rs:912:18: 912:29
        switchInt(move _7) -> [false: bb7, otherwise: bb10]; // scope 1 at src/codec/japanese.rs:912:18: 912:29
    }

    bb7: {
        StorageLive(_15);                // scope 1 at src/codec/japanese.rs:913:19: 913:46
        StorageLive(_16);                // scope 1 at src/codec/japanese.rs:913:19: 913:22
        _16 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:913:19: 913:22
        _15 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _16, const "invalid sequence") -> bb13; // scope 1 at src/codec/japanese.rs:913:19: 913:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:913:23: 913:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:913:27: 913:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb8: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:911:34: 911:37
        _8 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:911:34: 911:37
        _0 = iso2022jp::transient::EscapeStart::<T>(move _8) -> bb9; // scope 1 at src/codec/japanese.rs:911:22: 911:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:911:22: 911:33
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeStart::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_8);                 // scope 1 at src/codec/japanese.rs:911:37: 911:38
        goto -> bb15;                    // scope 1 at src/codec/japanese.rs:911:37: 911:38
    }

    bb10: {
        StorageLive(_9);                 // scope 1 at src/codec/japanese.rs:912:14: 912:29
        _9 = _5;                         // scope 1 at src/codec/japanese.rs:912:14: 912:29
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:912:33: 912:51
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:912:33: 912:36
        _11 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:912:33: 912:36
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:912:42: 912:50
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:912:42: 912:43
        _13 = _9;                        // scope 2 at src/codec/japanese.rs:912:42: 912:43
        _12 = move _13 as u32 (Misc);    // scope 2 at src/codec/japanese.rs:912:42: 912:50
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:912:49: 912:50
        _10 = StatefulDecoderHelper::<iso2022jp::State, T>::emit(move _11, move _12) -> bb11; // scope 2 at src/codec/japanese.rs:912:33: 912:51
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:912:37: 912:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, u32) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:912:50: 912:51
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:912:50: 912:51
        StorageDead(_10);                // scope 2 at src/util.rs:187:74: 187:75
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:912:59: 912:62
        _14 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:912:59: 912:62
        _0 = iso2022jp::transient::ASCII::<T>(move _14) -> bb12; // scope 2 at src/codec/japanese.rs:912:53: 912:63
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:912:53: 912:58
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::ASCII::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:912:62: 912:63
        StorageDead(_9);                 // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb15;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb13: {
        StorageDead(_16);                // scope 1 at src/codec/japanese.rs:913:45: 913:46
        StorageDead(_15);                // scope 1 at src/util.rs:187:74: 187:75
        StorageLive(_17);                // scope 1 at src/codec/japanese.rs:913:54: 913:57
        _17 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:913:54: 913:57
        _0 = iso2022jp::transient::ASCII::<T>(move _17) -> bb14; // scope 1 at src/codec/japanese.rs:913:48: 913:58
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:913:48: 913:53
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::ASCII::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_17);                // scope 1 at src/codec/japanese.rs:913:57: 913:58
        goto -> bb15;                    // scope 1 at src/codec/japanese.rs:913:57: 913:58
    }

    bb15: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb16;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb16: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

fn eucjp::transient::S3(_1: &mut StatefulDecoderHelper<eucjp::State, T>, _2: u8) -> eucjp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _8: bool;                    // in scope 0 at src/codec/japanese.rs:170:18: 170:29
    let mut _9: bool;                    // in scope 0 at src/codec/japanese.rs:170:18: 170:29
    let mut _11: u32;                    // in scope 0 at src/codec/japanese.rs:170:39: 170:66
    let mut _12: u8;                     // in scope 0 at src/codec/japanese.rs:170:58: 170:62
    let mut _13: u8;                     // in scope 0 at src/codec/japanese.rs:170:64: 170:65
    let mut _14: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:172:23: 172:26
    let mut _16: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:173:19: 173:22
    let mut _17: u32;                    // in scope 0 at src/codec/japanese.rs:173:28: 173:37
    let mut _18: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:175:19: 175:22
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _10: u8;                     // in scope 1 at src/codec/japanese.rs:170:14: 170:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/japanese.rs:170:14: 170:29
            let _15: u32;                // in scope 2 at src/codec/japanese.rs:173:13: 173:15
            scope 3 {
                debug ch => _15;         // in scope 3 at src/codec/japanese.rs:173:13: 173:15
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<eucjp::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        _8 = Le(const 161_u8, _7);       // scope 1 at src/codec/japanese.rs:170:18: 170:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/japanese.rs:170:18: 170:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S3).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 3;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb16;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _9 = Le(_7, const 254_u8);       // scope 1 at src/codec/japanese.rs:170:18: 170:29
        switchInt(move _9) -> [false: bb6, otherwise: bb7]; // scope 1 at src/codec/japanese.rs:170:18: 170:29
    }

    bb6: {
        StorageLive(_18);                // scope 1 at src/codec/japanese.rs:175:19: 175:22
        _18 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:175:19: 175:22
        _0 = StatefulDecoderHelper::<eucjp::State, T>::backup_and_err(move _18, const 1_usize, const "invalid sequence") -> bb14; // scope 1 at src/codec/japanese.rs:175:19: 175:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:175:23: 175:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, usize, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:175:41: 175:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb7: {
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:170:14: 170:29
        _10 = _7;                        // scope 1 at src/codec/japanese.rs:170:14: 170:29
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:170:39: 170:66
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:170:58: 170:62
        _12 = _2;                        // scope 2 at src/codec/japanese.rs:170:58: 170:62
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:170:64: 170:65
        _13 = _10;                       // scope 2 at src/codec/japanese.rs:170:64: 170:65
        _11 = eucjp::internal::map_two_0208_bytes(move _12, move _13) -> bb8; // scope 2 at src/codec/japanese.rs:170:39: 170:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:170:39: 170:57
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::japanese::eucjp::internal::map_two_0208_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:170:65: 170:66
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:170:65: 170:66
        switchInt(_11) -> [65535_u32: bb10, otherwise: bb9]; // scope 2 at src/codec/japanese.rs:170:33: 170:66
    }

    bb9: {
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:173:13: 173:15
        _15 = _11;                       // scope 2 at src/codec/japanese.rs:173:13: 173:15
        StorageLive(_16);                // scope 3 at src/codec/japanese.rs:173:19: 173:22
        _16 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:173:19: 173:22
        StorageLive(_17);                // scope 3 at src/codec/japanese.rs:173:28: 173:37
        _17 = _15;                       // scope 3 at src/codec/japanese.rs:173:28: 173:30
        _0 = StatefulDecoderHelper::<eucjp::State, T>::emit(move _16, move _17) -> bb12; // scope 3 at src/codec/japanese.rs:173:19: 173:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:173:23: 173:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, u32) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:172:23: 172:26
        _14 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:172:23: 172:26
        _0 = StatefulDecoderHelper::<eucjp::State, T>::err(move _14, const "invalid sequence") -> bb11; // scope 2 at src/codec/japanese.rs:172:23: 172:50
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:172:27: 172:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:172:31: 172:49
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb11: {
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:172:49: 172:50
        goto -> bb13;                    // scope 2 at src/codec/japanese.rs:172:49: 172:50
    }

    bb12: {
        StorageDead(_17);                // scope 3 at src/codec/japanese.rs:173:37: 173:38
        StorageDead(_16);                // scope 3 at src/codec/japanese.rs:173:37: 173:38
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:173:37: 173:38
        goto -> bb13;                    // scope 2 at src/codec/japanese.rs:173:37: 173:38
    }

    bb13: {
        StorageDead(_11);                // scope 2 at src/util.rs:226:77: 226:78
        StorageDead(_10);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb15;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb14: {
        StorageDead(_18);                // scope 1 at src/codec/japanese.rs:175:59: 175:60
        goto -> bb15;                    // scope 1 at src/codec/japanese.rs:175:59: 175:60
    }

    bb15: {
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb16;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb16: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:159:1: 163:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:160:21: 160:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:161:9: 161:60
    let mut _2: std::boxed::Box<codec::simpchinese::GB18030Decoder>; // in scope 0 at src/codec/simpchinese.rs:161:9: 161:60
    let mut _3: codec::simpchinese::GB18030Decoder; // in scope 0 at src/codec/simpchinese.rs:161:18: 161:59
    let mut _4: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:161:39: 161:57

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/simpchinese.rs:161:9: 161:60
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:161:9: 161:60
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:161:18: 161:59
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:161:39: 161:57
        _4 = <simpchinese::gb18030::State as Default>::default() -> bb1; // scope 0 at src/codec/simpchinese.rs:161:39: 161:57
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:161:39: 161:55
                                         // + literal: Const { ty: fn() -> codec::simpchinese::gb18030::State {<codec::simpchinese::gb18030::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::simpchinese::gb18030::State) = move _4; // scope 0 at src/codec/simpchinese.rs:161:18: 161:59
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:161:58: 161:59
        _2 = Box::<GB18030Decoder>::new(move _3) -> bb2; // scope 0 at src/codec/simpchinese.rs:161:9: 161:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:161:9: 161:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::simpchinese::GB18030Decoder) -> std::boxed::Box<codec::simpchinese::GB18030Decoder> {std::boxed::Box::<codec::simpchinese::GB18030Decoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:161:9: 161:60
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:161:59: 161:60
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:161:59: 161:60
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:161:9: 161:60
        StorageDead(_1);                 // scope 0 at src/codec/simpchinese.rs:162:5: 162:6
        return;                          // scope 0 at src/codec/simpchinese.rs:162:6: 162:6
    }
}

fn codec::error::<impl at src/codec/error.rs:53:1: 68:2>::raw_finish(_1: &mut ErrorDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:65:19: 65:28
    debug _output => _2;                 // in scope 0 at src/codec/error.rs:65:30: 65:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/error.rs:65:61: 65:79

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/error.rs:66:9: 66:13
        return;                          // scope 0 at src/codec/error.rs:67:6: 67:6
    }
}

fn korean::<impl at src/codec/korean.rs:42:1: 70:2>::raw_feed(_1: &mut Windows949Encoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:46:17: 46:26
    debug input => _2;                   // in scope 0 at src/codec/korean.rs:46:28: 46:33
    debug output => _3;                  // in scope 0 at src/codec/korean.rs:46:41: 46:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/korean.rs:46:69: 46:96
    let _4: ();                          // in scope 0 at src/codec/korean.rs:47:9: 47:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/korean.rs:47:9: 47:15
    let mut _6: usize;                   // in scope 0 at src/codec/korean.rs:47:28: 47:39
    let mut _7: &str;                    // in scope 0 at src/codec/korean.rs:47:28: 47:33
    let mut _8: util::StrCharIndexIterator; // in scope 0 at src/codec/korean.rs:49:28: 49:46
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/korean.rs:49:28: 49:46
    let mut _10: &&str;                  // in scope 0 at src/codec/korean.rs:49:28: 49:33
    let mut _11: util::StrCharIndexIterator; // in scope 0 at src/codec/korean.rs:49:28: 49:46
    let mut _13: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/korean.rs:49:28: 49:46
    let mut _14: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/korean.rs:49:28: 49:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/korean.rs:49:28: 49:46
    let mut _16: isize;                  // in scope 0 at src/codec/korean.rs:49:13: 49:24
    let mut _18: ((usize, usize), char); // in scope 0 at src/codec/korean.rs:49:13: 49:24
    let mut _22: bool;                   // in scope 0 at src/codec/korean.rs:50:16: 50:30
    let mut _23: char;                   // in scope 0 at src/codec/korean.rs:50:16: 50:18
    let _24: ();                         // in scope 0 at src/codec/korean.rs:51:17: 51:44
    let mut _25: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/korean.rs:51:17: 51:23
    let mut _26: u8;                     // in scope 0 at src/codec/korean.rs:51:35: 51:43
    let mut _27: char;                   // in scope 0 at src/codec/korean.rs:51:35: 51:37
    let mut _29: u32;                    // in scope 0 at src/codec/korean.rs:53:51: 53:60
    let mut _30: char;                   // in scope 0 at src/codec/korean.rs:53:51: 53:53
    let mut _31: u16;                    // in scope 0 at src/codec/korean.rs:54:20: 54:23
    let mut _32: usize;                  // in scope 0 at src/codec/korean.rs:55:29: 55:30
    let mut _33: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/korean.rs:55:32: 57:23
    let mut _34: encoding_types::CodecError; // in scope 0 at src/codec/korean.rs:55:37: 57:22
    let mut _35: isize;                  // in scope 0 at src/codec/korean.rs:56:31: 56:41
    let mut _36: usize;                  // in scope 0 at src/codec/korean.rs:56:31: 56:32
    let mut _37: std::borrow::Cow<str>;  // in scope 0 at src/codec/korean.rs:56:50: 56:84
    let mut _38: &str;                   // in scope 0 at src/codec/korean.rs:56:50: 56:77
    let _39: &str;                       // in scope 0 at src/codec/korean.rs:56:50: 56:77
    let _40: ();                         // in scope 0 at src/codec/korean.rs:59:21: 59:64
    let mut _41: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/korean.rs:59:21: 59:27
    let mut _42: u8;                     // in scope 0 at src/codec/korean.rs:59:39: 59:63
    let mut _43: u16;                    // in scope 0 at src/codec/korean.rs:59:39: 59:57
    let mut _44: u16;                    // in scope 0 at src/codec/korean.rs:59:40: 59:49
    let mut _45: u16;                    // in scope 0 at src/codec/korean.rs:59:40: 59:43
    let _46: ();                         // in scope 0 at src/codec/korean.rs:60:21: 60:64
    let mut _47: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/korean.rs:60:21: 60:27
    let mut _48: u8;                     // in scope 0 at src/codec/korean.rs:60:39: 60:63
    let mut _49: u16;                    // in scope 0 at src/codec/korean.rs:60:39: 60:57
    let mut _50: u16;                    // in scope 0 at src/codec/korean.rs:60:40: 60:49
    let mut _51: u16;                    // in scope 0 at src/codec/korean.rs:60:40: 60:43
    let mut _52: usize;                  // in scope 0 at src/codec/korean.rs:64:10: 64:21
    let mut _53: &str;                   // in scope 0 at src/codec/korean.rs:64:10: 64:15
    let mut _54: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/korean.rs:64:23: 64:27
    scope 1 {
        debug iter => _11;               // in scope 1 at src/codec/korean.rs:49:28: 49:46
        let mut _12: ((usize, usize), char); // in scope 1 at src/codec/korean.rs:49:28: 49:46
        scope 2 {
            debug __next => _12;         // in scope 2 at src/codec/korean.rs:49:28: 49:46
            let _17: ((usize, usize), char); // in scope 2 at src/codec/korean.rs:49:13: 49:24
            let _19: usize;              // in scope 2 at src/codec/korean.rs:49:15: 49:16
            let _20: usize;              // in scope 2 at src/codec/korean.rs:49:17: 49:18
            let _21: char;               // in scope 2 at src/codec/korean.rs:49:21: 49:23
            scope 3 {
                debug val => _17;        // in scope 3 at src/codec/korean.rs:49:13: 49:24
            }
            scope 4 {
                debug i => _19;          // in scope 4 at src/codec/korean.rs:49:15: 49:16
                debug j => _20;          // in scope 4 at src/codec/korean.rs:49:17: 49:18
                debug ch => _21;         // in scope 4 at src/codec/korean.rs:49:21: 49:23
                let _28: u16;            // in scope 4 at src/codec/korean.rs:53:21: 53:24
                scope 5 {
                    debug ptr => _28;    // in scope 5 at src/codec/korean.rs:53:21: 53:24
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/korean.rs:47:9: 47:40
        StorageLive(_5);                 // scope 0 at src/codec/korean.rs:47:9: 47:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/korean.rs:47:9: 47:15
        StorageLive(_6);                 // scope 0 at src/codec/korean.rs:47:28: 47:39
        StorageLive(_7);                 // scope 0 at src/codec/korean.rs:47:28: 47:33
        _7 = _2;                         // scope 0 at src/codec/korean.rs:47:28: 47:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/korean.rs:47:28: 47:39
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:47:34: 47:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/korean.rs:47:38: 47:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/korean.rs:47:9: 47:40
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:47:16: 47:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/korean.rs:47:39: 47:40
        StorageDead(_5);                 // scope 0 at src/codec/korean.rs:47:39: 47:40
        StorageDead(_4);                 // scope 0 at src/codec/korean.rs:47:40: 47:41
        StorageLive(_8);                 // scope 0 at src/codec/korean.rs:49:28: 49:46
        StorageLive(_9);                 // scope 0 at src/codec/korean.rs:49:28: 49:46
        StorageLive(_10);                // scope 0 at src/codec/korean.rs:49:28: 49:33
        _10 = &_2;                       // scope 0 at src/codec/korean.rs:49:28: 49:33
        _9 = <&str as StrCharIndex>::index_iter(move _10) -> bb3; // scope 0 at src/codec/korean.rs:49:28: 49:46
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:49:34: 49:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_10);                // scope 0 at src/codec/korean.rs:49:45: 49:46
        _8 = <StrCharIndexIterator as IntoIterator>::into_iter(move _9) -> bb4; // scope 0 at src/codec/korean.rs:49:28: 49:46
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:49:28: 49:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_9);                 // scope 0 at src/codec/korean.rs:49:45: 49:46
        StorageLive(_11);                // scope 0 at src/codec/korean.rs:49:28: 49:46
        _11 = move _8;                   // scope 0 at src/codec/korean.rs:49:28: 49:46
        goto -> bb5;                     // scope 1 at src/codec/korean.rs:49:9: 63:10
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/korean.rs:49:28: 49:46
        StorageLive(_13);                // scope 2 at src/codec/korean.rs:49:28: 49:46
        StorageLive(_14);                // scope 2 at src/codec/korean.rs:49:28: 49:46
        StorageLive(_15);                // scope 2 at src/codec/korean.rs:49:28: 49:46
        _15 = &mut _11;                  // scope 2 at src/codec/korean.rs:49:28: 49:46
        _14 = &mut (*_15);               // scope 2 at src/codec/korean.rs:49:28: 49:46
        _13 = <StrCharIndexIterator as Iterator>::next(move _14) -> bb6; // scope 2 at src/codec/korean.rs:49:28: 49:46
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:49:28: 49:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_14);                // scope 2 at src/codec/korean.rs:49:45: 49:46
        _16 = discriminant(_13);         // scope 2 at src/codec/korean.rs:49:28: 49:46
        switchInt(move _16) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/korean.rs:49:28: 49:46
    }

    bb7: {
        StorageDead(_15);                // scope 2 at src/codec/korean.rs:49:45: 49:46
        StorageDead(_13);                // scope 2 at src/codec/korean.rs:49:45: 49:46
        StorageDead(_12);                // scope 1 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_11);                // scope 0 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_8);                 // scope 0 at src/codec/korean.rs:49:45: 49:46
        StorageLive(_52);                // scope 0 at src/codec/korean.rs:64:10: 64:21
        StorageLive(_53);                // scope 0 at src/codec/korean.rs:64:10: 64:15
        _53 = _2;                        // scope 0 at src/codec/korean.rs:64:10: 64:15
        _52 = core::str::<impl str>::len(move _53) -> bb20; // scope 0 at src/codec/korean.rs:64:10: 64:21
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:64:16: 64:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/korean.rs:49:28: 49:46
    }

    bb9: {
        StorageLive(_17);                // scope 2 at src/codec/korean.rs:49:13: 49:24
        _17 = ((_13 as Some).0: ((usize, usize), char)); // scope 2 at src/codec/korean.rs:49:13: 49:24
        StorageLive(_18);                // scope 3 at src/codec/korean.rs:49:13: 49:24
        _18 = _17;                       // scope 3 at src/codec/korean.rs:49:13: 49:24
        _12 = move _18;                  // scope 3 at src/codec/korean.rs:49:13: 49:24
        StorageDead(_18);                // scope 3 at src/codec/korean.rs:49:23: 49:24
        StorageDead(_17);                // scope 2 at src/codec/korean.rs:49:23: 49:24
        StorageDead(_15);                // scope 2 at src/codec/korean.rs:49:45: 49:46
        StorageDead(_13);                // scope 2 at src/codec/korean.rs:49:45: 49:46
        StorageLive(_19);                // scope 2 at src/codec/korean.rs:49:15: 49:16
        _19 = ((_12.0: (usize, usize)).0: usize); // scope 2 at src/codec/korean.rs:49:15: 49:16
        StorageLive(_20);                // scope 2 at src/codec/korean.rs:49:17: 49:18
        _20 = ((_12.0: (usize, usize)).1: usize); // scope 2 at src/codec/korean.rs:49:17: 49:18
        StorageLive(_21);                // scope 2 at src/codec/korean.rs:49:21: 49:23
        _21 = (_12.1: char);             // scope 2 at src/codec/korean.rs:49:21: 49:23
        StorageLive(_22);                // scope 4 at src/codec/korean.rs:50:16: 50:30
        StorageLive(_23);                // scope 4 at src/codec/korean.rs:50:16: 50:18
        _23 = _21;                       // scope 4 at src/codec/korean.rs:50:16: 50:18
        _22 = Le(move _23, const '\u{7f}'); // scope 4 at src/codec/korean.rs:50:16: 50:30
        StorageDead(_23);                // scope 4 at src/codec/korean.rs:50:29: 50:30
        switchInt(move _22) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/korean.rs:50:16: 50:30
    }

    bb10: {
        StorageLive(_24);                // scope 4 at src/codec/korean.rs:51:17: 51:44
        StorageLive(_25);                // scope 4 at src/codec/korean.rs:51:17: 51:23
        _25 = &mut (*_3);                // scope 4 at src/codec/korean.rs:51:17: 51:23
        StorageLive(_26);                // scope 4 at src/codec/korean.rs:51:35: 51:43
        StorageLive(_27);                // scope 4 at src/codec/korean.rs:51:35: 51:37
        _27 = _21;                       // scope 4 at src/codec/korean.rs:51:35: 51:37
        _26 = move _27 as u8 (Misc);     // scope 4 at src/codec/korean.rs:51:35: 51:43
        StorageDead(_27);                // scope 4 at src/codec/korean.rs:51:42: 51:43
        _24 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _25, move _26) -> bb12; // scope 4 at src/codec/korean.rs:51:17: 51:44
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:51:24: 51:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageLive(_28);                // scope 4 at src/codec/korean.rs:53:21: 53:24
        StorageLive(_29);                // scope 4 at src/codec/korean.rs:53:51: 53:60
        StorageLive(_30);                // scope 4 at src/codec/korean.rs:53:51: 53:53
        _30 = _21;                       // scope 4 at src/codec/korean.rs:53:51: 53:53
        _29 = move _30 as u32 (Misc);    // scope 4 at src/codec/korean.rs:53:51: 53:60
        StorageDead(_30);                // scope 4 at src/codec/korean.rs:53:59: 53:60
        _28 = index_korean::euc_kr::backward(move _29) -> bb13; // scope 4 at src/codec/korean.rs:53:27: 53:61
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:53:27: 53:50
                                         // + literal: Const { ty: fn(u32) -> u16 {index_korean::euc_kr::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_26);                // scope 4 at src/codec/korean.rs:51:43: 51:44
        StorageDead(_25);                // scope 4 at src/codec/korean.rs:51:43: 51:44
        StorageDead(_24);                // scope 4 at src/codec/korean.rs:51:44: 51:45
        goto -> bb19;                    // scope 4 at src/codec/korean.rs:50:13: 62:14
    }

    bb13: {
        StorageDead(_29);                // scope 4 at src/codec/korean.rs:53:60: 53:61
        StorageLive(_31);                // scope 5 at src/codec/korean.rs:54:20: 54:23
        _31 = _28;                       // scope 5 at src/codec/korean.rs:54:20: 54:23
        switchInt(move _31) -> [u16::MAX: bb14, otherwise: bb16]; // scope 5 at src/codec/korean.rs:54:20: 54:33
    }

    bb14: {
        StorageDead(_31);                // scope 5 at src/codec/korean.rs:54:20: 54:33
        StorageLive(_32);                // scope 5 at src/codec/korean.rs:55:29: 55:30
        _32 = _19;                       // scope 5 at src/codec/korean.rs:55:29: 55:30
        StorageLive(_33);                // scope 5 at src/codec/korean.rs:55:32: 57:23
        StorageLive(_34);                // scope 5 at src/codec/korean.rs:55:37: 57:22
        StorageLive(_35);                // scope 5 at src/codec/korean.rs:56:31: 56:41
        StorageLive(_36);                // scope 5 at src/codec/korean.rs:56:31: 56:32
        _36 = _20;                       // scope 5 at src/codec/korean.rs:56:31: 56:32
        _35 = move _36 as isize (Misc);  // scope 5 at src/codec/korean.rs:56:31: 56:41
        StorageDead(_36);                // scope 5 at src/codec/korean.rs:56:40: 56:41
        StorageLive(_37);                // scope 5 at src/codec/korean.rs:56:50: 56:84
        StorageLive(_38);                // scope 5 at src/codec/korean.rs:56:50: 56:77
        StorageLive(_39);                // scope 5 at src/codec/korean.rs:56:50: 56:77
        _39 = const "unrepresentable character"; // scope 5 at src/codec/korean.rs:56:50: 56:77
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:56:50: 56:77
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _38 = _39;                       // scope 5 at src/codec/korean.rs:56:50: 56:77
        _37 = <&str as Into<Cow<str>>>::into(move _38) -> bb15; // scope 5 at src/codec/korean.rs:56:50: 56:84
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:56:78: 56:82
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_38);                // scope 5 at src/codec/korean.rs:56:83: 56:84
        (_34.0: isize) = move _35;       // scope 5 at src/codec/korean.rs:55:37: 57:22
        (_34.1: std::borrow::Cow<str>) = move _37; // scope 5 at src/codec/korean.rs:55:37: 57:22
        StorageDead(_37);                // scope 5 at src/codec/korean.rs:57:21: 57:22
        StorageDead(_35);                // scope 5 at src/codec/korean.rs:57:21: 57:22
        ((_33 as Some).0: encoding_types::CodecError) = move _34; // scope 5 at src/codec/korean.rs:55:32: 57:23
        discriminant(_33) = 1;           // scope 5 at src/codec/korean.rs:55:32: 57:23
        StorageDead(_34);                // scope 5 at src/codec/korean.rs:57:22: 57:23
        (_0.0: usize) = move _32;        // scope 5 at src/codec/korean.rs:55:28: 57:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _33; // scope 5 at src/codec/korean.rs:55:28: 57:24
        StorageDead(_33);                // scope 5 at src/codec/korean.rs:57:23: 57:24
        StorageDead(_32);                // scope 5 at src/codec/korean.rs:57:23: 57:24
        StorageDead(_39);                // scope 5 at src/codec/korean.rs:57:24: 57:25
        StorageDead(_28);                // scope 4 at src/codec/korean.rs:62:13: 62:14
        StorageDead(_22);                // scope 4 at src/codec/korean.rs:62:13: 62:14
        StorageDead(_21);                // scope 2 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_20);                // scope 2 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_19);                // scope 2 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_12);                // scope 1 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_11);                // scope 0 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_8);                 // scope 0 at src/codec/korean.rs:49:45: 49:46
        goto -> bb21;                    // scope 0 at src/codec/korean.rs:65:6: 65:6
    }

    bb16: {
        StorageDead(_31);                // scope 5 at src/codec/korean.rs:54:20: 54:33
        StorageLive(_40);                // scope 5 at src/codec/korean.rs:59:21: 59:64
        StorageLive(_41);                // scope 5 at src/codec/korean.rs:59:21: 59:27
        _41 = &mut (*_3);                // scope 5 at src/codec/korean.rs:59:21: 59:27
        StorageLive(_42);                // scope 5 at src/codec/korean.rs:59:39: 59:63
        StorageLive(_43);                // scope 5 at src/codec/korean.rs:59:39: 59:57
        StorageLive(_44);                // scope 5 at src/codec/korean.rs:59:40: 59:49
        StorageLive(_45);                // scope 5 at src/codec/korean.rs:59:40: 59:43
        _45 = _28;                       // scope 5 at src/codec/korean.rs:59:40: 59:43
        _44 = Div(move _45, const 190_u16); // scope 5 at src/codec/korean.rs:59:40: 59:49
        StorageDead(_45);                // scope 5 at src/codec/korean.rs:59:48: 59:49
        _43 = Add(move _44, const 129_u16); // scope 5 at src/codec/korean.rs:59:39: 59:57
        StorageDead(_44);                // scope 5 at src/codec/korean.rs:59:56: 59:57
        _42 = move _43 as u8 (Misc);     // scope 5 at src/codec/korean.rs:59:39: 59:63
        StorageDead(_43);                // scope 5 at src/codec/korean.rs:59:62: 59:63
        _40 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _41, move _42) -> bb17; // scope 5 at src/codec/korean.rs:59:21: 59:64
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:59:28: 59:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_42);                // scope 5 at src/codec/korean.rs:59:63: 59:64
        StorageDead(_41);                // scope 5 at src/codec/korean.rs:59:63: 59:64
        StorageDead(_40);                // scope 5 at src/codec/korean.rs:59:64: 59:65
        StorageLive(_46);                // scope 5 at src/codec/korean.rs:60:21: 60:64
        StorageLive(_47);                // scope 5 at src/codec/korean.rs:60:21: 60:27
        _47 = &mut (*_3);                // scope 5 at src/codec/korean.rs:60:21: 60:27
        StorageLive(_48);                // scope 5 at src/codec/korean.rs:60:39: 60:63
        StorageLive(_49);                // scope 5 at src/codec/korean.rs:60:39: 60:57
        StorageLive(_50);                // scope 5 at src/codec/korean.rs:60:40: 60:49
        StorageLive(_51);                // scope 5 at src/codec/korean.rs:60:40: 60:43
        _51 = _28;                       // scope 5 at src/codec/korean.rs:60:40: 60:43
        _50 = Rem(move _51, const 190_u16); // scope 5 at src/codec/korean.rs:60:40: 60:49
        StorageDead(_51);                // scope 5 at src/codec/korean.rs:60:48: 60:49
        _49 = Add(move _50, const 65_u16); // scope 5 at src/codec/korean.rs:60:39: 60:57
        StorageDead(_50);                // scope 5 at src/codec/korean.rs:60:56: 60:57
        _48 = move _49 as u8 (Misc);     // scope 5 at src/codec/korean.rs:60:39: 60:63
        StorageDead(_49);                // scope 5 at src/codec/korean.rs:60:62: 60:63
        _46 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _47, move _48) -> bb18; // scope 5 at src/codec/korean.rs:60:21: 60:64
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:60:28: 60:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb18: {
        StorageDead(_48);                // scope 5 at src/codec/korean.rs:60:63: 60:64
        StorageDead(_47);                // scope 5 at src/codec/korean.rs:60:63: 60:64
        StorageDead(_46);                // scope 5 at src/codec/korean.rs:60:64: 60:65
        StorageDead(_28);                // scope 4 at src/codec/korean.rs:62:13: 62:14
        goto -> bb19;                    // scope 4 at src/codec/korean.rs:50:13: 62:14
    }

    bb19: {
        StorageDead(_22);                // scope 4 at src/codec/korean.rs:62:13: 62:14
        StorageDead(_21);                // scope 2 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_20);                // scope 2 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_19);                // scope 2 at src/codec/korean.rs:63:9: 63:10
        StorageDead(_12);                // scope 1 at src/codec/korean.rs:63:9: 63:10
        goto -> bb5;                     // scope 1 at src/codec/korean.rs:49:9: 63:10
    }

    bb20: {
        StorageDead(_53);                // scope 0 at src/codec/korean.rs:64:20: 64:21
        StorageLive(_54);                // scope 0 at src/codec/korean.rs:64:23: 64:27
        discriminant(_54) = 0;           // scope 0 at src/codec/korean.rs:64:23: 64:27
        (_0.0: usize) = move _52;        // scope 0 at src/codec/korean.rs:64:9: 64:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _54; // scope 0 at src/codec/korean.rs:64:9: 64:28
        StorageDead(_54);                // scope 0 at src/codec/korean.rs:64:27: 64:28
        StorageDead(_52);                // scope 0 at src/codec/korean.rs:64:27: 64:28
        goto -> bb21;                    // scope 0 at src/codec/korean.rs:65:6: 65:6
    }

    bb21: {
        return;                          // scope 0 at src/codec/korean.rs:65:6: 65:6
    }
}

fn windows31j::internal::map_two_0208_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/japanese.rs:540:40: 540:44
    debug trail => _2;                   // in scope 0 at src/codec/japanese.rs:540:50: 540:55
    let mut _0: u32;                     // return place in scope 0 at src/codec/japanese.rs:540:64: 540:67
    let _3: u16;                         // in scope 0 at src/codec/japanese.rs:543:13: 543:17
    let mut _4: u8;                      // in scope 0 at src/codec/japanese.rs:543:20: 543:24
    let mut _6: u8;                      // in scope 0 at src/codec/japanese.rs:544:21: 544:26
    let mut _8: bool;                    // in scope 0 at src/codec/japanese.rs:545:29: 545:40
    let mut _9: u16;                     // in scope 0 at src/codec/japanese.rs:545:29: 545:33
    let mut _11: bool;                   // in scope 0 at src/codec/japanese.rs:546:30: 546:42
    let mut _12: u16;                    // in scope 0 at src/codec/japanese.rs:546:30: 546:35
    let mut _14: (u16, u16);             // in scope 0 at src/codec/japanese.rs:547:27: 547:40
    let mut _15: u16;                    // in scope 0 at src/codec/japanese.rs:547:28: 547:32
    let mut _16: u16;                    // in scope 0 at src/codec/japanese.rs:547:34: 547:39
    let mut _17: bool;                   // in scope 0 at src/codec/japanese.rs:548:56: 548:67
    let mut _18: bool;                   // in scope 0 at src/codec/japanese.rs:548:56: 548:67
    let mut _19: bool;                   // in scope 0 at src/codec/japanese.rs:548:27: 548:38
    let mut _20: bool;                   // in scope 0 at src/codec/japanese.rs:548:27: 548:38
    let mut _21: bool;                   // in scope 0 at src/codec/japanese.rs:550:56: 550:67
    let mut _22: bool;                   // in scope 0 at src/codec/japanese.rs:550:56: 550:67
    let mut _23: bool;                   // in scope 0 at src/codec/japanese.rs:550:27: 550:38
    let mut _24: bool;                   // in scope 0 at src/codec/japanese.rs:550:27: 550:38
    let mut _25: bool;                   // in scope 0 at src/codec/japanese.rs:550:14: 550:25
    let mut _26: bool;                   // in scope 0 at src/codec/japanese.rs:550:14: 550:25
    let mut _27: bool;                   // in scope 0 at src/codec/japanese.rs:551:56: 551:67
    let mut _28: bool;                   // in scope 0 at src/codec/japanese.rs:551:56: 551:67
    let mut _29: bool;                   // in scope 0 at src/codec/japanese.rs:551:27: 551:38
    let mut _30: bool;                   // in scope 0 at src/codec/japanese.rs:551:27: 551:38
    let mut _31: bool;                   // in scope 0 at src/codec/japanese.rs:551:14: 551:25
    let mut _32: bool;                   // in scope 0 at src/codec/japanese.rs:551:14: 551:25
    let mut _33: bool;                   // in scope 0 at src/codec/japanese.rs:548:14: 548:25
    let mut _34: bool;                   // in scope 0 at src/codec/japanese.rs:548:14: 548:25
    let mut _35: u16;                    // in scope 0 at src/codec/japanese.rs:549:24: 549:76
    let mut _36: u16;                    // in scope 0 at src/codec/japanese.rs:549:25: 549:61
    let mut _37: u16;                    // in scope 0 at src/codec/japanese.rs:549:25: 549:53
    let mut _38: u16;                    // in scope 0 at src/codec/japanese.rs:549:34: 549:53
    let mut _39: u16;                    // in scope 0 at src/codec/japanese.rs:549:34: 549:47
    let mut _40: u16;                    // in scope 0 at src/codec/japanese.rs:549:35: 549:39
    let mut _41: u16;                    // in scope 0 at src/codec/japanese.rs:549:56: 549:61
    let mut _42: u16;                    // in scope 0 at src/codec/japanese.rs:549:64: 549:75
    let mut _43: u16;                    // in scope 0 at src/codec/japanese.rs:552:17: 552:50
    let mut _44: u16;                    // in scope 0 at src/codec/japanese.rs:552:17: 552:42
    let mut _45: u16;                    // in scope 0 at src/codec/japanese.rs:552:17: 552:36
    let mut _46: u16;                    // in scope 0 at src/codec/japanese.rs:552:18: 552:22
    let mut _47: u16;                    // in scope 0 at src/codec/japanese.rs:552:25: 552:35
    let mut _48: u16;                    // in scope 0 at src/codec/japanese.rs:552:45: 552:50
    let mut _49: u16;                    // in scope 0 at src/codec/japanese.rs:552:53: 552:64
    let mut _50: u16;                    // in scope 0 at src/codec/japanese.rs:555:33: 555:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/japanese.rs:543:13: 543:17
        let _5: u16;                     // in scope 1 at src/codec/japanese.rs:544:13: 544:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/japanese.rs:544:13: 544:18
            let _7: u16;                 // in scope 2 at src/codec/japanese.rs:545:13: 545:23
            scope 3 {
                debug leadoffset => _7;  // in scope 3 at src/codec/japanese.rs:545:13: 545:23
                let _10: u16;            // in scope 3 at src/codec/japanese.rs:546:13: 546:24
                scope 4 {
                    debug trailoffset => _10; // in scope 4 at src/codec/japanese.rs:546:13: 546:24
                    let _13: u16;        // in scope 4 at src/codec/japanese.rs:547:13: 547:18
                    scope 5 {
                        debug index => _13; // in scope 5 at src/codec/japanese.rs:547:13: 547:18
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:543:13: 543:17
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:543:20: 543:24
        _4 = _1;                         // scope 0 at src/codec/japanese.rs:543:20: 543:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/japanese.rs:543:20: 543:31
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:543:30: 543:31
        StorageLive(_5);                 // scope 1 at src/codec/japanese.rs:544:13: 544:18
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:544:21: 544:26
        _6 = _2;                         // scope 1 at src/codec/japanese.rs:544:21: 544:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/japanese.rs:544:21: 544:33
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:544:32: 544:33
        StorageLive(_7);                 // scope 2 at src/codec/japanese.rs:545:13: 545:23
        StorageLive(_8);                 // scope 2 at src/codec/japanese.rs:545:29: 545:40
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:545:29: 545:33
        _9 = _3;                         // scope 2 at src/codec/japanese.rs:545:29: 545:33
        _8 = Lt(move _9, const 160_u16); // scope 2 at src/codec/japanese.rs:545:29: 545:40
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:545:39: 545:40
        switchInt(move _8) -> [false: bb2, otherwise: bb1]; // scope 2 at src/codec/japanese.rs:545:29: 545:40
    }

    bb1: {
        _7 = const 129_u16;              // scope 2 at src/codec/japanese.rs:545:42: 545:46
        goto -> bb3;                     // scope 2 at src/codec/japanese.rs:545:26: 545:59
    }

    bb2: {
        _7 = const 193_u16;              // scope 2 at src/codec/japanese.rs:545:54: 545:58
        goto -> bb3;                     // scope 2 at src/codec/japanese.rs:545:26: 545:59
    }

    bb3: {
        StorageDead(_8);                 // scope 2 at src/codec/japanese.rs:545:58: 545:59
        StorageLive(_10);                // scope 3 at src/codec/japanese.rs:546:13: 546:24
        StorageLive(_11);                // scope 3 at src/codec/japanese.rs:546:30: 546:42
        StorageLive(_12);                // scope 3 at src/codec/japanese.rs:546:30: 546:35
        _12 = _5;                        // scope 3 at src/codec/japanese.rs:546:30: 546:35
        _11 = Lt(move _12, const 127_u16); // scope 3 at src/codec/japanese.rs:546:30: 546:42
        StorageDead(_12);                // scope 3 at src/codec/japanese.rs:546:41: 546:42
        switchInt(move _11) -> [false: bb5, otherwise: bb4]; // scope 3 at src/codec/japanese.rs:546:30: 546:42
    }

    bb4: {
        _10 = const 64_u16;              // scope 3 at src/codec/japanese.rs:546:44: 546:48
        goto -> bb6;                     // scope 3 at src/codec/japanese.rs:546:27: 546:61
    }

    bb5: {
        _10 = const 65_u16;              // scope 3 at src/codec/japanese.rs:546:56: 546:60
        goto -> bb6;                     // scope 3 at src/codec/japanese.rs:546:27: 546:61
    }

    bb6: {
        StorageDead(_11);                // scope 3 at src/codec/japanese.rs:546:60: 546:61
        StorageLive(_13);                // scope 4 at src/codec/japanese.rs:547:13: 547:18
        StorageLive(_14);                // scope 4 at src/codec/japanese.rs:547:27: 547:40
        StorageLive(_15);                // scope 4 at src/codec/japanese.rs:547:28: 547:32
        _15 = _3;                        // scope 4 at src/codec/japanese.rs:547:28: 547:32
        StorageLive(_16);                // scope 4 at src/codec/japanese.rs:547:34: 547:39
        _16 = _5;                        // scope 4 at src/codec/japanese.rs:547:34: 547:39
        (_14.0: u16) = move _15;         // scope 4 at src/codec/japanese.rs:547:27: 547:40
        (_14.1: u16) = move _16;         // scope 4 at src/codec/japanese.rs:547:27: 547:40
        StorageDead(_16);                // scope 4 at src/codec/japanese.rs:547:39: 547:40
        StorageDead(_15);                // scope 4 at src/codec/japanese.rs:547:39: 547:40
        _33 = Le(const 240_u16, (_14.0: u16)); // scope 4 at src/codec/japanese.rs:548:14: 548:25
        switchInt(move _33) -> [false: bb13, otherwise: bb7]; // scope 4 at src/codec/japanese.rs:548:14: 548:25
    }

    bb7: {
        _34 = Le((_14.0: u16), const 249_u16); // scope 4 at src/codec/japanese.rs:548:14: 548:25
        switchInt(move _34) -> [false: bb13, otherwise: bb8]; // scope 4 at src/codec/japanese.rs:548:14: 548:25
    }

    bb8: {
        _19 = Le(const 64_u16, (_14.1: u16)); // scope 4 at src/codec/japanese.rs:548:27: 548:38
        switchInt(move _19) -> [false: bb10, otherwise: bb9]; // scope 4 at src/codec/japanese.rs:548:27: 548:38
    }

    bb9: {
        _20 = Le((_14.1: u16), const 126_u16); // scope 4 at src/codec/japanese.rs:548:27: 548:38
        switchInt(move _20) -> [false: bb10, otherwise: bb25]; // scope 4 at src/codec/japanese.rs:548:27: 548:38
    }

    bb10: {
        _17 = Le(const 128_u16, (_14.1: u16)); // scope 4 at src/codec/japanese.rs:548:56: 548:67
        switchInt(move _17) -> [false: bb12, otherwise: bb11]; // scope 4 at src/codec/japanese.rs:548:56: 548:67
    }

    bb11: {
        _18 = Le((_14.1: u16), const 252_u16); // scope 4 at src/codec/japanese.rs:548:56: 548:67
        switchInt(move _18) -> [false: bb12, otherwise: bb25]; // scope 4 at src/codec/japanese.rs:548:56: 548:67
    }

    bb12: {
        _31 = Le(const 224_u16, (_14.0: u16)); // scope 4 at src/codec/japanese.rs:551:14: 551:25
        switchInt(move _31) -> [false: bb24, otherwise: bb19]; // scope 4 at src/codec/japanese.rs:551:14: 551:25
    }

    bb13: {
        _25 = Le(const 129_u16, (_14.0: u16)); // scope 4 at src/codec/japanese.rs:550:14: 550:25
        switchInt(move _25) -> [false: bb12, otherwise: bb14]; // scope 4 at src/codec/japanese.rs:550:14: 550:25
    }

    bb14: {
        _26 = Le((_14.0: u16), const 159_u16); // scope 4 at src/codec/japanese.rs:550:14: 550:25
        switchInt(move _26) -> [false: bb12, otherwise: bb15]; // scope 4 at src/codec/japanese.rs:550:14: 550:25
    }

    bb15: {
        _23 = Le(const 64_u16, (_14.1: u16)); // scope 4 at src/codec/japanese.rs:550:27: 550:38
        switchInt(move _23) -> [false: bb17, otherwise: bb16]; // scope 4 at src/codec/japanese.rs:550:27: 550:38
    }

    bb16: {
        _24 = Le((_14.1: u16), const 126_u16); // scope 4 at src/codec/japanese.rs:550:27: 550:38
        switchInt(move _24) -> [false: bb17, otherwise: bb26]; // scope 4 at src/codec/japanese.rs:550:27: 550:38
    }

    bb17: {
        _21 = Le(const 128_u16, (_14.1: u16)); // scope 4 at src/codec/japanese.rs:550:56: 550:67
        switchInt(move _21) -> [false: bb12, otherwise: bb18]; // scope 4 at src/codec/japanese.rs:550:56: 550:67
    }

    bb18: {
        _22 = Le((_14.1: u16), const 252_u16); // scope 4 at src/codec/japanese.rs:550:56: 550:67
        switchInt(move _22) -> [false: bb12, otherwise: bb26]; // scope 4 at src/codec/japanese.rs:550:56: 550:67
    }

    bb19: {
        _32 = Le((_14.0: u16), const 252_u16); // scope 4 at src/codec/japanese.rs:551:14: 551:25
        switchInt(move _32) -> [false: bb24, otherwise: bb20]; // scope 4 at src/codec/japanese.rs:551:14: 551:25
    }

    bb20: {
        _29 = Le(const 64_u16, (_14.1: u16)); // scope 4 at src/codec/japanese.rs:551:27: 551:38
        switchInt(move _29) -> [false: bb22, otherwise: bb21]; // scope 4 at src/codec/japanese.rs:551:27: 551:38
    }

    bb21: {
        _30 = Le((_14.1: u16), const 126_u16); // scope 4 at src/codec/japanese.rs:551:27: 551:38
        switchInt(move _30) -> [false: bb22, otherwise: bb26]; // scope 4 at src/codec/japanese.rs:551:27: 551:38
    }

    bb22: {
        _27 = Le(const 128_u16, (_14.1: u16)); // scope 4 at src/codec/japanese.rs:551:56: 551:67
        switchInt(move _27) -> [false: bb24, otherwise: bb23]; // scope 4 at src/codec/japanese.rs:551:56: 551:67
    }

    bb23: {
        _28 = Le((_14.1: u16), const 252_u16); // scope 4 at src/codec/japanese.rs:551:56: 551:67
        switchInt(move _28) -> [false: bb24, otherwise: bb26]; // scope 4 at src/codec/japanese.rs:551:56: 551:67
    }

    bb24: {
        _13 = const u16::MAX;            // scope 4 at src/codec/japanese.rs:553:18: 553:24
        goto -> bb27;                    // scope 4 at src/codec/japanese.rs:553:18: 553:24
    }

    bb25: {
        StorageLive(_35);                // scope 4 at src/codec/japanese.rs:549:24: 549:76
        StorageLive(_36);                // scope 4 at src/codec/japanese.rs:549:25: 549:61
        StorageLive(_37);                // scope 4 at src/codec/japanese.rs:549:25: 549:53
        StorageLive(_38);                // scope 4 at src/codec/japanese.rs:549:34: 549:53
        StorageLive(_39);                // scope 4 at src/codec/japanese.rs:549:34: 549:47
        StorageLive(_40);                // scope 4 at src/codec/japanese.rs:549:35: 549:39
        _40 = _3;                        // scope 4 at src/codec/japanese.rs:549:35: 549:39
        _39 = Sub(move _40, const 240_u16); // scope 4 at src/codec/japanese.rs:549:34: 549:47
        StorageDead(_40);                // scope 4 at src/codec/japanese.rs:549:46: 549:47
        _38 = Mul(move _39, const 188_u16); // scope 4 at src/codec/japanese.rs:549:34: 549:53
        StorageDead(_39);                // scope 4 at src/codec/japanese.rs:549:52: 549:53
        _37 = Add(const 57344_u16, move _38); // scope 4 at src/codec/japanese.rs:549:25: 549:53
        StorageDead(_38);                // scope 4 at src/codec/japanese.rs:549:52: 549:53
        StorageLive(_41);                // scope 4 at src/codec/japanese.rs:549:56: 549:61
        _41 = _5;                        // scope 4 at src/codec/japanese.rs:549:56: 549:61
        _36 = Add(move _37, move _41);   // scope 4 at src/codec/japanese.rs:549:25: 549:61
        StorageDead(_41);                // scope 4 at src/codec/japanese.rs:549:60: 549:61
        StorageDead(_37);                // scope 4 at src/codec/japanese.rs:549:60: 549:61
        StorageLive(_42);                // scope 4 at src/codec/japanese.rs:549:64: 549:75
        _42 = _10;                       // scope 4 at src/codec/japanese.rs:549:64: 549:75
        _35 = Sub(move _36, move _42);   // scope 4 at src/codec/japanese.rs:549:24: 549:76
        StorageDead(_42);                // scope 4 at src/codec/japanese.rs:549:75: 549:76
        StorageDead(_36);                // scope 4 at src/codec/japanese.rs:549:75: 549:76
        _0 = move _35 as u32 (Misc);     // scope 4 at src/codec/japanese.rs:549:24: 549:83
        StorageDead(_35);                // scope 4 at src/codec/japanese.rs:549:82: 549:83
        StorageDead(_14);                // scope 4 at src/codec/japanese.rs:554:10: 554:11
        StorageDead(_13);                // scope 4 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_10);                // scope 3 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_7);                 // scope 2 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_5);                 // scope 1 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:556:5: 556:6
        goto -> bb29;                    // scope 0 at src/codec/japanese.rs:556:6: 556:6
    }

    bb26: {
        StorageLive(_43);                // scope 4 at src/codec/japanese.rs:552:17: 552:50
        StorageLive(_44);                // scope 4 at src/codec/japanese.rs:552:17: 552:42
        StorageLive(_45);                // scope 4 at src/codec/japanese.rs:552:17: 552:36
        StorageLive(_46);                // scope 4 at src/codec/japanese.rs:552:18: 552:22
        _46 = _3;                        // scope 4 at src/codec/japanese.rs:552:18: 552:22
        StorageLive(_47);                // scope 4 at src/codec/japanese.rs:552:25: 552:35
        _47 = _7;                        // scope 4 at src/codec/japanese.rs:552:25: 552:35
        _45 = Sub(move _46, move _47);   // scope 4 at src/codec/japanese.rs:552:17: 552:36
        StorageDead(_47);                // scope 4 at src/codec/japanese.rs:552:35: 552:36
        StorageDead(_46);                // scope 4 at src/codec/japanese.rs:552:35: 552:36
        _44 = Mul(move _45, const 188_u16); // scope 4 at src/codec/japanese.rs:552:17: 552:42
        StorageDead(_45);                // scope 4 at src/codec/japanese.rs:552:41: 552:42
        StorageLive(_48);                // scope 4 at src/codec/japanese.rs:552:45: 552:50
        _48 = _5;                        // scope 4 at src/codec/japanese.rs:552:45: 552:50
        _43 = Add(move _44, move _48);   // scope 4 at src/codec/japanese.rs:552:17: 552:50
        StorageDead(_48);                // scope 4 at src/codec/japanese.rs:552:49: 552:50
        StorageDead(_44);                // scope 4 at src/codec/japanese.rs:552:49: 552:50
        StorageLive(_49);                // scope 4 at src/codec/japanese.rs:552:53: 552:64
        _49 = _10;                       // scope 4 at src/codec/japanese.rs:552:53: 552:64
        _13 = Sub(move _43, move _49);   // scope 4 at src/codec/japanese.rs:552:17: 552:64
        StorageDead(_49);                // scope 4 at src/codec/japanese.rs:552:63: 552:64
        StorageDead(_43);                // scope 4 at src/codec/japanese.rs:552:63: 552:64
        goto -> bb27;                    // scope 4 at src/codec/japanese.rs:552:63: 552:64
    }

    bb27: {
        StorageDead(_14);                // scope 4 at src/codec/japanese.rs:554:10: 554:11
        StorageLive(_50);                // scope 5 at src/codec/japanese.rs:555:33: 555:38
        _50 = _13;                       // scope 5 at src/codec/japanese.rs:555:33: 555:38
        _0 = index_japanese::jis0208::forward(move _50) -> bb28; // scope 5 at src/codec/japanese.rs:555:9: 555:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:555:9: 555:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_japanese::jis0208::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb28: {
        StorageDead(_50);                // scope 5 at src/codec/japanese.rs:555:38: 555:39
        StorageDead(_13);                // scope 4 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_10);                // scope 3 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_7);                 // scope 2 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_5);                 // scope 1 at src/codec/japanese.rs:556:5: 556:6
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:556:5: 556:6
        goto -> bb29;                    // scope 0 at src/codec/japanese.rs:556:6: 556:6
    }

    bb29: {
        return;                          // scope 0 at src/codec/japanese.rs:556:6: 556:6
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:75:1: 79:2>::new(_1: fn(u8) -> u16) -> Box<dyn encoding_types::RawDecoder> {
    debug index_forward => _1;           // in scope 0 at src/codec/singlebyte.rs:76:16: 76:29
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/singlebyte.rs:76:63: 76:78
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/singlebyte.rs:77:9: 77:69
    let mut _3: std::boxed::Box<codec::singlebyte::SingleByteDecoder>; // in scope 0 at src/codec/singlebyte.rs:77:9: 77:69
    let mut _4: codec::singlebyte::SingleByteDecoder; // in scope 0 at src/codec/singlebyte.rs:77:18: 77:68
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/codec/singlebyte.rs:77:53: 77:66

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:77:9: 77:69
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:77:9: 77:69
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:77:18: 77:68
        StorageLive(_5);                 // scope 0 at src/codec/singlebyte.rs:77:53: 77:66
        _5 = _1;                         // scope 0 at src/codec/singlebyte.rs:77:53: 77:66
        (_4.0: fn(u8) -> u16) = move _5; // scope 0 at src/codec/singlebyte.rs:77:18: 77:68
        StorageDead(_5);                 // scope 0 at src/codec/singlebyte.rs:77:67: 77:68
        _3 = Box::<SingleByteDecoder>::new(move _4) -> bb1; // scope 0 at src/codec/singlebyte.rs:77:9: 77:69
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:77:9: 77:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::singlebyte::SingleByteDecoder) -> std::boxed::Box<codec::singlebyte::SingleByteDecoder> {std::boxed::Box::<codec::singlebyte::SingleByteDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:77:9: 77:69
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:77:68: 77:69
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:77:68: 77:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:77:9: 77:69
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:78:5: 78:6
        return;                          // scope 0 at src/codec/singlebyte.rs:78:6: 78:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:452:1: 457:2>::raw_encoder(_1: &Windows31JEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:455:20: 455:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:455:30: 455:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:455:48: 455:72
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:455:48: 455:72

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:455:48: 455:72
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:455:48: 455:72
        _3 = Windows31JEncoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:455:48: 455:72
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:455:48: 455:70
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::japanese::Windows31JEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:455:48: 455:72
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:455:71: 455:72
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:455:48: 455:72
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:455:73: 455:74
        return;                          // scope 0 at src/codec/japanese.rs:455:74: 455:74
    }
}

fn simpchinese::gb18030::<impl at src/util.rs:168:13: 170:14>::default() -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn simpchinese::gb18030::<impl at src/util.rs:157:33: 157:38>::clone(_1: &simpchinese::gb18030::State) -> simpchinese::gb18030::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                    scope 5 {
                        scope 6 {
                            scope 7 {
                                scope 8 {
                                    scope 9 {
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 9 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:40:1: 45:2>::raw_encoder(_1: &GB18030Encoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:43:20: 43:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:43:30: 43:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:43:48: 43:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:43:48: 43:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:43:48: 43:69
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:43:48: 43:69
        _3 = GB18030Encoder::new() -> bb1; // scope 0 at src/codec/simpchinese.rs:43:48: 43:69
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:43:48: 43:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::simpchinese::GB18030Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:43:48: 43:69
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:43:68: 43:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:43:48: 43:69
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:43:70: 43:71
        return;                          // scope 0 at src/codec/simpchinese.rs:43:71: 43:71
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:27:10: 27:15>::clone(_1: &BigFive2003Encoding) -> BigFive2003Encoding {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:27:10: 27:15
    let mut _0: codec::tradchinese::BigFive2003Encoding; // return place in scope 0 at src/codec/tradchinese.rs:27:10: 27:15

    bb0: {
        return;                          // scope 0 at src/codec/tradchinese.rs:27:15: 27:15
    }
}

const WINDOWS_1251: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:60:68: 60:82
    let _5: &str;                        // in scope 0 at src/all.rs:60:68: 60:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1251::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1251, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1268 ~ encoding[5d2c]::all::WINDOWS_1251), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1251: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:60:68: 60:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:60:68: 60:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1251";       // scope 0 at src/all.rs:60:68: 60:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:60:68: 60:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:60:68: 60:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1251::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1251::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1251::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1251::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1251"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:60:68: 60:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn iso2022jp::State::Katakana(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as Katakana).0: ()) = move _1; // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 3;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

// MIR FOR CTFE
fn iso2022jp::State::Katakana(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as Katakana).0: ()) = move _1; // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 3;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

fn bigfive2003::transient::S0(_1: &mut StatefulDecoderHelper<bigfive2003::State, T>) -> bigfive2003::State {
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

fn windows31j::<impl at src/util.rs:157:33: 157:38>::clone(_1: &windows31j::State) -> windows31j::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 2 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:64:1: 78:2>::raw_feed(_1: &mut UTF8Encoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:68:17: 68:26
    debug input => _2;                   // in scope 0 at src/codec/utf_8.rs:68:28: 68:33
    debug output => _3;                  // in scope 0 at src/codec/utf_8.rs:68:41: 68:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_8.rs:68:69: 68:96
    let _4: &[u8];                       // in scope 0 at src/codec/utf_8.rs:69:13: 69:18
    let _5: &[u8];                       // in scope 0 at src/codec/utf_8.rs:69:28: 69:44
    let mut _6: &str;                    // in scope 0 at src/codec/utf_8.rs:69:28: 69:33
    let mut _7: bool;                    // in scope 0 at src/codec/utf_8.rs:70:9: 70:48
    let mut _8: bool;                    // in scope 0 at src/codec/utf_8.rs:70:17: 70:46
    let mut _9: &std::result::Result<&str, std::str::Utf8Error>; // in scope 0 at src/codec/utf_8.rs:70:17: 70:38
    let _10: std::result::Result<&str, std::str::Utf8Error>; // in scope 0 at src/codec/utf_8.rs:70:17: 70:38
    let mut _11: &[u8];                  // in scope 0 at src/codec/utf_8.rs:70:32: 70:37
    let _12: ();                         // in scope 0 at src/codec/utf_8.rs:71:9: 71:34
    let mut _13: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_8.rs:71:9: 71:15
    let mut _14: &[u8];                  // in scope 0 at src/codec/utf_8.rs:71:28: 71:33
    let mut _15: usize;                  // in scope 0 at src/codec/utf_8.rs:72:10: 72:21
    let mut _16: &[u8];                  // in scope 0 at src/codec/utf_8.rs:72:10: 72:15
    let mut _17: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_8.rs:72:23: 72:27
    scope 1 {
        debug input => _4;               // in scope 1 at src/codec/utf_8.rs:69:13: 69:18
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_8.rs:69:13: 69:18
        StorageLive(_5);                 // scope 0 at src/codec/utf_8.rs:69:28: 69:44
        StorageLive(_6);                 // scope 0 at src/codec/utf_8.rs:69:28: 69:33
        _6 = _2;                         // scope 0 at src/codec/utf_8.rs:69:28: 69:33
        _5 = core::str::<impl str>::as_bytes(move _6) -> bb1; // scope 0 at src/codec/utf_8.rs:69:28: 69:44
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:69:34: 69:42
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> &'r [u8] {core::str::<impl str>::as_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _4 = _5;                         // scope 0 at src/codec/utf_8.rs:69:28: 69:44
        StorageDead(_6);                 // scope 0 at src/codec/utf_8.rs:69:43: 69:44
        StorageDead(_5);                 // scope 0 at src/codec/utf_8.rs:69:44: 69:45
        StorageLive(_7);                 // scope 1 at src/codec/utf_8.rs:70:9: 70:48
        StorageLive(_8);                 // scope 1 at src/codec/utf_8.rs:70:17: 70:46
        StorageLive(_9);                 // scope 1 at src/codec/utf_8.rs:70:17: 70:38
        StorageLive(_10);                // scope 1 at src/codec/utf_8.rs:70:17: 70:38
        StorageLive(_11);                // scope 1 at src/codec/utf_8.rs:70:32: 70:37
        _11 = _4;                        // scope 1 at src/codec/utf_8.rs:70:32: 70:37
        _10 = std::str::from_utf8(move _11) -> bb2; // scope 1 at src/codec/utf_8.rs:70:17: 70:38
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:70:17: 70:31
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> std::result::Result<&'r str, std::str::Utf8Error> {std::str::from_utf8}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _9 = &_10;                       // scope 1 at src/codec/utf_8.rs:70:17: 70:38
        StorageDead(_11);                // scope 1 at src/codec/utf_8.rs:70:37: 70:38
        _8 = Result::<&str, Utf8Error>::is_ok(move _9) -> bb3; // scope 1 at src/codec/utf_8.rs:70:17: 70:46
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:70:39: 70:44
                                         // + literal: Const { ty: for<'r> fn(&'r std::result::Result<&str, std::str::Utf8Error>) -> bool {std::result::Result::<&str, std::str::Utf8Error>::is_ok}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_9);                 // scope 1 at src/codec/utf_8.rs:70:45: 70:46
        _7 = Not(move _8);               // scope 1 at src/codec/utf_8.rs:70:9: 70:48
        StorageDead(_10);                // scope 1 at src/codec/utf_8.rs:70:47: 70:48
        StorageDead(_8);                 // scope 1 at src/codec/utf_8.rs:70:47: 70:48
        switchInt(move _7) -> [false: bb5, otherwise: bb4]; // scope 1 at src/codec/utf_8.rs:70:9: 70:48
    }

    bb4: {
        core::panicking::panic(const "assertion failed: str::from_utf8(input).is_ok()"); // scope 1 at src/codec/utf_8.rs:70:9: 70:48
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:70:9: 70:48
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 115, 116, 114, 58, 58, 102, 114, 111, 109, 95, 117, 116, 102, 56, 40, 105, 110, 112, 117, 116, 41, 46, 105, 115, 95, 111, 107, 40, 41], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [140737488355327], len: Size { raw: 47 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 47 })
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 115, 116, 114, 58, 58, 102, 114, 111, 109, 95, 117, 116, 102, 56, 40, 105, 110, 112, 117, 116, 41, 46, 105, 115, 95, 111, 107, 40, 41], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [140737488355327], len: Size { raw: 47 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 47 }) }
    }

    bb5: {
        StorageDead(_7);                 // scope 1 at src/codec/utf_8.rs:70:47: 70:48
        StorageLive(_12);                // scope 1 at src/codec/utf_8.rs:71:9: 71:34
        StorageLive(_13);                // scope 1 at src/codec/utf_8.rs:71:9: 71:15
        _13 = &mut (*_3);                // scope 1 at src/codec/utf_8.rs:71:9: 71:15
        StorageLive(_14);                // scope 1 at src/codec/utf_8.rs:71:28: 71:33
        _14 = _4;                        // scope 1 at src/codec/utf_8.rs:71:28: 71:33
        _12 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _13, move _14) -> bb6; // scope 1 at src/codec/utf_8.rs:71:9: 71:34
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:71:16: 71:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_14);                // scope 1 at src/codec/utf_8.rs:71:33: 71:34
        StorageDead(_13);                // scope 1 at src/codec/utf_8.rs:71:33: 71:34
        StorageDead(_12);                // scope 1 at src/codec/utf_8.rs:71:34: 71:35
        StorageLive(_15);                // scope 1 at src/codec/utf_8.rs:72:10: 72:21
        StorageLive(_16);                // scope 1 at src/codec/utf_8.rs:72:10: 72:15
        _16 = _4;                        // scope 1 at src/codec/utf_8.rs:72:10: 72:15
        _15 = Len((*_16));               // scope 1 at src/codec/utf_8.rs:72:10: 72:21
        StorageDead(_16);                // scope 1 at src/codec/utf_8.rs:72:20: 72:21
        StorageLive(_17);                // scope 1 at src/codec/utf_8.rs:72:23: 72:27
        discriminant(_17) = 0;           // scope 1 at src/codec/utf_8.rs:72:23: 72:27
        (_0.0: usize) = move _15;        // scope 1 at src/codec/utf_8.rs:72:9: 72:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _17; // scope 1 at src/codec/utf_8.rs:72:9: 72:28
        StorageDead(_17);                // scope 1 at src/codec/utf_8.rs:72:27: 72:28
        StorageDead(_15);                // scope 1 at src/codec/utf_8.rs:72:27: 72:28
        StorageDead(_4);                 // scope 0 at src/codec/utf_8.rs:73:5: 73:6
        return;                          // scope 0 at src/codec/utf_8.rs:73:6: 73:6
    }
}

fn windows949::<impl at src/util.rs:157:22: 157:31>::ne(_1: &windows949::State, _2: &windows949::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::korean::windows949::State, &codec::korean::windows949::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _26: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _27: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _18: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _19: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _18;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _19;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _20;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _21;  // in scope 3 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb10, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::korean::windows949::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::korean::windows949::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _17 = discriminant((*(_13.0: &codec::korean::windows949::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [1_isize: bb3, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::korean::windows949::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb4, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        StorageLive(_18);                // scope 2 at src/util.rs:164:25: 164:27
        _18 = &(((*(_13.0: &codec::korean::windows949::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_19);                // scope 2 at src/util.rs:164:32: 164:35
        _19 = &(((*(_13.0: &codec::korean::windows949::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.1: &codec::korean::windows949::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.1: &codec::korean::windows949::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _18;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        _22 = <() as PartialEq>::ne(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        _0 = const true;                 // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb6: {
        StorageLive(_25);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_26);                // scope 3 at src/util.rs:164:32: 164:35
        _26 = (*_19);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        _27 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        _25 = Ne(move _26, move _27);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_26);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _25;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb7: {
        StorageDead(_25);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_22);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_19);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_18);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:30: 157:31
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _22) -> [false: bb6, otherwise: bb5]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn hz::start::A0(_1: &mut StatefulDecoderHelper<hz::State, T>) -> hz::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/simpchinese.rs:583:18: 583:29
    let mut _7: bool;                    // in scope 0 at src/codec/simpchinese.rs:583:18: 583:29
    let mut _8: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:582:25: 582:28
    let mut _10: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:583:33: 583:36
    let mut _11: u32;                    // in scope 0 at src/codec/simpchinese.rs:583:42: 583:50
    let mut _12: u8;                     // in scope 0 at src/codec/simpchinese.rs:583:42: 583:43
    let mut _13: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:584:19: 584:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _9: u8;                      // in scope 1 at src/codec/simpchinese.rs:583:14: 583:29
        scope 2 {
            debug b => _9;               // in scope 2 at src/codec/simpchinese.rs:583:14: 583:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<hz::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        switchInt(_5) -> [126_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:187:36: 187:43
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb14;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _6 = Le(const 0_u8, _5);         // scope 1 at src/codec/simpchinese.rs:583:18: 583:29
        switchInt(move _6) -> [false: bb7, otherwise: bb6]; // scope 1 at src/codec/simpchinese.rs:583:18: 583:29
    }

    bb6: {
        _7 = Le(_5, const 127_u8);       // scope 1 at src/codec/simpchinese.rs:583:18: 583:29
        switchInt(move _7) -> [false: bb7, otherwise: bb10]; // scope 1 at src/codec/simpchinese.rs:583:18: 583:29
    }

    bb7: {
        StorageLive(_13);                // scope 1 at src/codec/simpchinese.rs:584:19: 584:22
        _13 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:584:19: 584:22
        _0 = StatefulDecoderHelper::<hz::State, T>::err(move _13, const "invalid sequence") -> bb12; // scope 1 at src/codec/simpchinese.rs:584:19: 584:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:584:23: 584:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:584:27: 584:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb8: {
        StorageLive(_8);                 // scope 1 at src/codec/simpchinese.rs:582:25: 582:28
        _8 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:582:25: 582:28
        _0 = hz::transient::A1::<T>(move _8) -> bb9; // scope 1 at src/codec/simpchinese.rs:582:22: 582:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:582:22: 582:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_8);                 // scope 1 at src/codec/simpchinese.rs:582:28: 582:29
        goto -> bb13;                    // scope 1 at src/codec/simpchinese.rs:582:28: 582:29
    }

    bb10: {
        StorageLive(_9);                 // scope 1 at src/codec/simpchinese.rs:583:14: 583:29
        _9 = _5;                         // scope 1 at src/codec/simpchinese.rs:583:14: 583:29
        StorageLive(_10);                // scope 2 at src/codec/simpchinese.rs:583:33: 583:36
        _10 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:583:33: 583:36
        StorageLive(_11);                // scope 2 at src/codec/simpchinese.rs:583:42: 583:50
        StorageLive(_12);                // scope 2 at src/codec/simpchinese.rs:583:42: 583:43
        _12 = _9;                        // scope 2 at src/codec/simpchinese.rs:583:42: 583:43
        _11 = move _12 as u32 (Misc);    // scope 2 at src/codec/simpchinese.rs:583:42: 583:50
        StorageDead(_12);                // scope 2 at src/codec/simpchinese.rs:583:49: 583:50
        _0 = StatefulDecoderHelper::<hz::State, T>::emit(move _10, move _11) -> bb11; // scope 2 at src/codec/simpchinese.rs:583:33: 583:51
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:583:37: 583:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, u32) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_11);                // scope 2 at src/codec/simpchinese.rs:583:50: 583:51
        StorageDead(_10);                // scope 2 at src/codec/simpchinese.rs:583:50: 583:51
        StorageDead(_9);                 // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb13;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb12: {
        StorageDead(_13);                // scope 1 at src/codec/simpchinese.rs:584:45: 584:46
        goto -> bb13;                    // scope 1 at src/codec/simpchinese.rs:584:45: 584:46
    }

    bb13: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb14;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb14: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

const WINDOWS_1258: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:67:68: 67:82
    let _5: &str;                        // in scope 0 at src/all.rs:67:68: 67:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1258::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1258, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1275 ~ encoding[5d2c]::all::WINDOWS_1258), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1258: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:67:68: 67:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:67:68: 67:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1258";       // scope 0 at src/all.rs:67:68: 67:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:67:68: 67:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:67:68: 67:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1258::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1258::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1258::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1258::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1258"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:67:68: 67:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:465:1: 470:2>::name(_1: &HZEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:466:13: 466:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/simpchinese.rs:466:23: 466:35

    bb0: {
        _0 = const "hz";                 // scope 0 at src/codec/simpchinese.rs:466:38: 466:42
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [104, 122], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:466:38: 466:42
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [104, 122], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
        return;                          // scope 0 at src/codec/simpchinese.rs:466:44: 466:44
    }
}

fn korean::<impl at src/codec/korean.rs:84:1: 99:2>::raw_feed(_1: &mut Windows949Decoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:88:17: 88:26
    debug input => _2;                   // in scope 0 at src/codec/korean.rs:88:28: 88:33
    debug output => _3;                  // in scope 0 at src/codec/korean.rs:88:42: 88:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/korean.rs:88:72: 88:99
    let _4: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:89:14: 89:16
    let _5: usize;                       // in scope 0 at src/codec/korean.rs:89:18: 89:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/korean.rs:89:29: 89:32
    let mut _7: (codec::korean::windows949::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/korean.rs:89:36: 89:85
    let mut _8: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:89:57: 89:64
    let mut _9: &[u8];                   // in scope 0 at src/codec/korean.rs:89:66: 89:71
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/korean.rs:89:73: 89:79
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/korean.rs:89:73: 89:79
    let mut _12: &();                    // in scope 0 at src/codec/korean.rs:89:81: 89:84
    let _13: &();                        // in scope 0 at src/codec/korean.rs:89:81: 89:84
    let mut _14: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:90:19: 90:21
    let mut _15: usize;                  // in scope 0 at src/codec/korean.rs:91:10: 91:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/korean.rs:91:21: 91:24
    let mut _17: &();                    // in scope 0 at src/codec/korean.rs:89:81: 89:84
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/korean.rs:89:14: 89:16
        debug processed => _5;           // in scope 1 at src/codec/korean.rs:89:18: 89:27
        debug err => _6;                 // in scope 1 at src/codec/korean.rs:89:29: 89:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/korean.rs:89:36: 89:85
        StorageLive(_8);                 // scope 0 at src/codec/korean.rs:89:57: 89:64
        _8 = ((*_1).0: codec::korean::windows949::State); // scope 0 at src/codec/korean.rs:89:57: 89:64
        StorageLive(_9);                 // scope 0 at src/codec/korean.rs:89:66: 89:71
        _9 = _2;                         // scope 0 at src/codec/korean.rs:89:66: 89:71
        StorageLive(_10);                // scope 0 at src/codec/korean.rs:89:73: 89:79
        StorageLive(_11);                // scope 0 at src/codec/korean.rs:89:73: 89:79
        _11 = &mut (*_3);                // scope 0 at src/codec/korean.rs:89:73: 89:79
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:89:73: 89:79
        StorageDead(_11);                // scope 0 at src/codec/korean.rs:89:78: 89:79
        StorageLive(_12);                // scope 0 at src/codec/korean.rs:89:81: 89:84
        StorageLive(_13);                // scope 0 at src/codec/korean.rs:89:81: 89:84
        _17 = const <Windows949Decoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/korean.rs:89:81: 89:84
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<Windows949Decoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:89:81: 89:84
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:361 ~ encoding[5d2c]::codec::korean::{impl#4}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/korean.rs:89:81: 89:84
        _12 = _13;                       // scope 0 at src/codec/korean.rs:89:81: 89:84
        _7 = windows949::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/korean.rs:89:36: 89:85
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:89:36: 89:56
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::korean::windows949::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::korean::windows949::State, usize, std::option::Option<encoding_types::CodecError>) {codec::korean::windows949::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/korean.rs:89:84: 89:85
        StorageDead(_10);                // scope 0 at src/codec/korean.rs:89:84: 89:85
        StorageDead(_9);                 // scope 0 at src/codec/korean.rs:89:84: 89:85
        StorageDead(_8);                 // scope 0 at src/codec/korean.rs:89:84: 89:85
        StorageLive(_4);                 // scope 0 at src/codec/korean.rs:89:14: 89:16
        _4 = (_7.0: codec::korean::windows949::State); // scope 0 at src/codec/korean.rs:89:14: 89:16
        StorageLive(_5);                 // scope 0 at src/codec/korean.rs:89:18: 89:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/korean.rs:89:18: 89:27
        StorageLive(_6);                 // scope 0 at src/codec/korean.rs:89:29: 89:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/korean.rs:89:29: 89:32
        StorageDead(_13);                // scope 0 at src/codec/korean.rs:89:85: 89:86
        StorageDead(_7);                 // scope 0 at src/codec/korean.rs:89:85: 89:86
        StorageLive(_14);                // scope 1 at src/codec/korean.rs:90:19: 90:21
        _14 = _4;                        // scope 1 at src/codec/korean.rs:90:19: 90:21
        ((*_1).0: codec::korean::windows949::State) = move _14; // scope 1 at src/codec/korean.rs:90:9: 90:21
        StorageDead(_14);                // scope 1 at src/codec/korean.rs:90:20: 90:21
        StorageLive(_15);                // scope 1 at src/codec/korean.rs:91:10: 91:19
        _15 = _5;                        // scope 1 at src/codec/korean.rs:91:10: 91:19
        StorageLive(_16);                // scope 1 at src/codec/korean.rs:91:21: 91:24
        _16 = move _6;                   // scope 1 at src/codec/korean.rs:91:21: 91:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/korean.rs:91:9: 91:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/korean.rs:91:9: 91:25
        StorageDead(_16);                // scope 1 at src/codec/korean.rs:91:24: 91:25
        StorageDead(_15);                // scope 1 at src/codec/korean.rs:91:24: 91:25
        StorageDead(_6);                 // scope 0 at src/codec/korean.rs:92:5: 92:6
        StorageDead(_5);                 // scope 0 at src/codec/korean.rs:92:5: 92:6
        StorageDead(_4);                 // scope 0 at src/codec/korean.rs:92:5: 92:6
        return;                          // scope 0 at src/codec/korean.rs:92:6: 92:6
    }
}

promoted[0] in korean::<impl at src/codec/korean.rs:84:1: 99:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/korean.rs:89:81: 89:84
    let mut _1: ();                      // in scope 0 at src/codec/korean.rs:89:82: 89:84

    bb0: {
        nop;                             // scope 0 at src/codec/korean.rs:89:82: 89:84
        _0 = &_1;                        // scope 0 at src/codec/korean.rs:89:81: 89:84
        return;                          // scope 0 at src/codec/korean.rs:89:81: 89:84
    }
}

fn iso_8859_1::forward(_1: u8) -> u16 {
    debug code => _1;                    // in scope 0 at src/codec/singlebyte.rs:115:30: 115:34
    let mut _0: u16;                     // return place in scope 0 at src/codec/singlebyte.rs:115:43: 115:46
    let mut _2: u8;                      // in scope 0 at src/codec/singlebyte.rs:115:49: 115:53

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:115:49: 115:53
        _2 = _1;                         // scope 0 at src/codec/singlebyte.rs:115:49: 115:53
        _0 = move _2 as u16 (Misc);      // scope 0 at src/codec/singlebyte.rs:115:49: 115:60
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:115:59: 115:60
        return;                          // scope 0 at src/codec/singlebyte.rs:115:62: 115:62
    }
}

fn japanese::<impl at src/codec/japanese.rs:467:1: 506:2>::raw_feed(_1: &mut Windows31JEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:471:17: 471:26
    debug input => _2;                   // in scope 0 at src/codec/japanese.rs:471:28: 471:33
    debug output => _3;                  // in scope 0 at src/codec/japanese.rs:471:41: 471:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/japanese.rs:471:69: 471:96
    let _4: ();                          // in scope 0 at src/codec/japanese.rs:472:9: 472:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:472:9: 472:15
    let mut _6: usize;                   // in scope 0 at src/codec/japanese.rs:472:28: 472:39
    let mut _7: &str;                    // in scope 0 at src/codec/japanese.rs:472:28: 472:33
    let mut _8: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:474:28: 474:46
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:474:28: 474:46
    let mut _10: &&str;                  // in scope 0 at src/codec/japanese.rs:474:28: 474:33
    let mut _11: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:474:28: 474:46
    let mut _13: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/japanese.rs:474:28: 474:46
    let mut _14: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:474:28: 474:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:474:28: 474:46
    let mut _16: isize;                  // in scope 0 at src/codec/japanese.rs:474:13: 474:24
    let mut _18: ((usize, usize), char); // in scope 0 at src/codec/japanese.rs:474:13: 474:24
    let mut _22: bool;                   // in scope 0 at src/codec/japanese.rs:479:17: 479:40
    let mut _23: bool;                   // in scope 0 at src/codec/japanese.rs:479:17: 479:40
    let mut _24: bool;                   // in scope 0 at src/codec/japanese.rs:476:17: 476:35
    let mut _25: bool;                   // in scope 0 at src/codec/japanese.rs:476:17: 476:35
    let _26: ();                         // in scope 0 at src/codec/japanese.rs:476:41: 476:68
    let mut _27: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:476:41: 476:47
    let mut _28: u8;                     // in scope 0 at src/codec/japanese.rs:476:59: 476:67
    let mut _29: char;                   // in scope 0 at src/codec/japanese.rs:476:59: 476:61
    let _30: ();                         // in scope 0 at src/codec/japanese.rs:477:31: 477:54
    let mut _31: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:477:31: 477:37
    let _32: ();                         // in scope 0 at src/codec/japanese.rs:478:33: 478:56
    let mut _33: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:478:33: 478:39
    let _34: ();                         // in scope 0 at src/codec/japanese.rs:480:21: 480:75
    let mut _35: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:480:21: 480:27
    let mut _36: u8;                     // in scope 0 at src/codec/japanese.rs:480:39: 480:74
    let mut _37: usize;                  // in scope 0 at src/codec/japanese.rs:480:39: 480:68
    let mut _38: usize;                  // in scope 0 at src/codec/japanese.rs:480:40: 480:60
    let mut _39: usize;                  // in scope 0 at src/codec/japanese.rs:480:40: 480:51
    let mut _40: char;                   // in scope 0 at src/codec/japanese.rs:480:40: 480:42
    let mut _42: u32;                    // in scope 0 at src/codec/japanese.rs:484:65: 484:74
    let mut _43: char;                   // in scope 0 at src/codec/japanese.rs:484:65: 484:67
    let mut _44: u16;                    // in scope 0 at src/codec/japanese.rs:485:24: 485:27
    let mut _45: usize;                  // in scope 0 at src/codec/japanese.rs:486:33: 486:34
    let mut _46: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:486:36: 488:27
    let mut _47: encoding_types::CodecError; // in scope 0 at src/codec/japanese.rs:486:41: 488:26
    let mut _48: isize;                  // in scope 0 at src/codec/japanese.rs:487:35: 487:45
    let mut _49: usize;                  // in scope 0 at src/codec/japanese.rs:487:35: 487:36
    let mut _50: std::borrow::Cow<str>;  // in scope 0 at src/codec/japanese.rs:487:54: 487:88
    let mut _51: &str;                   // in scope 0 at src/codec/japanese.rs:487:54: 487:81
    let _52: &str;                       // in scope 0 at src/codec/japanese.rs:487:54: 487:81
    let mut _54: u16;                    // in scope 0 at src/codec/japanese.rs:490:36: 490:39
    let mut _56: bool;                   // in scope 0 at src/codec/japanese.rs:491:45: 491:56
    let mut _57: u16;                    // in scope 0 at src/codec/japanese.rs:491:45: 491:49
    let mut _59: u16;                    // in scope 0 at src/codec/japanese.rs:492:37: 492:40
    let mut _61: bool;                   // in scope 0 at src/codec/japanese.rs:493:46: 493:58
    let mut _62: u16;                    // in scope 0 at src/codec/japanese.rs:493:46: 493:51
    let _63: ();                         // in scope 0 at src/codec/japanese.rs:494:25: 494:69
    let mut _64: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:494:25: 494:31
    let mut _65: u8;                     // in scope 0 at src/codec/japanese.rs:494:43: 494:68
    let mut _66: u16;                    // in scope 0 at src/codec/japanese.rs:494:43: 494:62
    let mut _67: u16;                    // in scope 0 at src/codec/japanese.rs:494:44: 494:48
    let mut _68: u16;                    // in scope 0 at src/codec/japanese.rs:494:51: 494:61
    let _69: ();                         // in scope 0 at src/codec/japanese.rs:495:25: 495:71
    let mut _70: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:495:25: 495:31
    let mut _71: u8;                     // in scope 0 at src/codec/japanese.rs:495:43: 495:70
    let mut _72: u16;                    // in scope 0 at src/codec/japanese.rs:495:43: 495:64
    let mut _73: u16;                    // in scope 0 at src/codec/japanese.rs:495:44: 495:49
    let mut _74: u16;                    // in scope 0 at src/codec/japanese.rs:495:52: 495:63
    let mut _75: usize;                  // in scope 0 at src/codec/japanese.rs:500:10: 500:21
    let mut _76: &str;                   // in scope 0 at src/codec/japanese.rs:500:10: 500:15
    let mut _77: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:500:23: 500:27
    scope 1 {
        debug iter => _11;               // in scope 1 at src/codec/japanese.rs:474:28: 474:46
        let mut _12: ((usize, usize), char); // in scope 1 at src/codec/japanese.rs:474:28: 474:46
        scope 2 {
            debug __next => _12;         // in scope 2 at src/codec/japanese.rs:474:28: 474:46
            let _17: ((usize, usize), char); // in scope 2 at src/codec/japanese.rs:474:13: 474:24
            let _19: usize;              // in scope 2 at src/codec/japanese.rs:474:15: 474:16
            let _20: usize;              // in scope 2 at src/codec/japanese.rs:474:17: 474:18
            let _21: char;               // in scope 2 at src/codec/japanese.rs:474:21: 474:23
            scope 3 {
                debug val => _17;        // in scope 3 at src/codec/japanese.rs:474:13: 474:24
            }
            scope 4 {
                debug i => _19;          // in scope 4 at src/codec/japanese.rs:474:15: 474:16
                debug j => _20;          // in scope 4 at src/codec/japanese.rs:474:17: 474:18
                debug ch => _21;         // in scope 4 at src/codec/japanese.rs:474:21: 474:23
                let _41: u16;            // in scope 4 at src/codec/japanese.rs:484:25: 484:28
                scope 5 {
                    debug ptr => _41;    // in scope 5 at src/codec/japanese.rs:484:25: 484:28
                    let _53: u16;        // in scope 5 at src/codec/japanese.rs:490:29: 490:33
                    scope 6 {
                        debug lead => _53; // in scope 6 at src/codec/japanese.rs:490:29: 490:33
                        let _55: u16;    // in scope 6 at src/codec/japanese.rs:491:29: 491:39
                        scope 7 {
                            debug leadoffset => _55; // in scope 7 at src/codec/japanese.rs:491:29: 491:39
                            let _58: u16; // in scope 7 at src/codec/japanese.rs:492:29: 492:34
                            scope 8 {
                                debug trail => _58; // in scope 8 at src/codec/japanese.rs:492:29: 492:34
                                let _60: u16; // in scope 8 at src/codec/japanese.rs:493:29: 493:40
                                scope 9 {
                                    debug trailoffset => _60; // in scope 9 at src/codec/japanese.rs:493:29: 493:40
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:472:9: 472:40
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:472:9: 472:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/japanese.rs:472:9: 472:15
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:472:28: 472:39
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:472:28: 472:33
        _7 = _2;                         // scope 0 at src/codec/japanese.rs:472:28: 472:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/japanese.rs:472:28: 472:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:472:34: 472:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:472:38: 472:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/japanese.rs:472:9: 472:40
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:472:16: 472:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:472:39: 472:40
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:472:39: 472:40
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:472:40: 472:41
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:474:28: 474:46
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:474:28: 474:46
        StorageLive(_10);                // scope 0 at src/codec/japanese.rs:474:28: 474:33
        _10 = &_2;                       // scope 0 at src/codec/japanese.rs:474:28: 474:33
        _9 = <&str as StrCharIndex>::index_iter(move _10) -> bb3; // scope 0 at src/codec/japanese.rs:474:28: 474:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:474:34: 474:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_10);                // scope 0 at src/codec/japanese.rs:474:45: 474:46
        _8 = <StrCharIndexIterator as IntoIterator>::into_iter(move _9) -> bb4; // scope 0 at src/codec/japanese.rs:474:28: 474:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:474:28: 474:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:474:45: 474:46
        StorageLive(_11);                // scope 0 at src/codec/japanese.rs:474:28: 474:46
        _11 = move _8;                   // scope 0 at src/codec/japanese.rs:474:28: 474:46
        goto -> bb5;                     // scope 1 at src/codec/japanese.rs:474:9: 499:10
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/japanese.rs:474:28: 474:46
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:474:28: 474:46
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:474:28: 474:46
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:474:28: 474:46
        _15 = &mut _11;                  // scope 2 at src/codec/japanese.rs:474:28: 474:46
        _14 = &mut (*_15);               // scope 2 at src/codec/japanese.rs:474:28: 474:46
        _13 = <StrCharIndexIterator as Iterator>::next(move _14) -> bb6; // scope 2 at src/codec/japanese.rs:474:28: 474:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:474:28: 474:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:474:45: 474:46
        _16 = discriminant(_13);         // scope 2 at src/codec/japanese.rs:474:28: 474:46
        switchInt(move _16) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/japanese.rs:474:28: 474:46
    }

    bb7: {
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:474:45: 474:46
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:474:45: 474:46
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:474:45: 474:46
        StorageLive(_75);                // scope 0 at src/codec/japanese.rs:500:10: 500:21
        StorageLive(_76);                // scope 0 at src/codec/japanese.rs:500:10: 500:15
        _76 = _2;                        // scope 0 at src/codec/japanese.rs:500:10: 500:15
        _75 = core::str::<impl str>::len(move _76) -> bb36; // scope 0 at src/codec/japanese.rs:500:10: 500:21
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:500:16: 500:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/japanese.rs:474:28: 474:46
    }

    bb9: {
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:474:13: 474:24
        _17 = ((_13 as Some).0: ((usize, usize), char)); // scope 2 at src/codec/japanese.rs:474:13: 474:24
        StorageLive(_18);                // scope 3 at src/codec/japanese.rs:474:13: 474:24
        _18 = _17;                       // scope 3 at src/codec/japanese.rs:474:13: 474:24
        _12 = move _18;                  // scope 3 at src/codec/japanese.rs:474:13: 474:24
        StorageDead(_18);                // scope 3 at src/codec/japanese.rs:474:23: 474:24
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:474:23: 474:24
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:474:45: 474:46
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:474:45: 474:46
        StorageLive(_19);                // scope 2 at src/codec/japanese.rs:474:15: 474:16
        _19 = ((_12.0: (usize, usize)).0: usize); // scope 2 at src/codec/japanese.rs:474:15: 474:16
        StorageLive(_20);                // scope 2 at src/codec/japanese.rs:474:17: 474:18
        _20 = ((_12.0: (usize, usize)).1: usize); // scope 2 at src/codec/japanese.rs:474:17: 474:18
        StorageLive(_21);                // scope 2 at src/codec/japanese.rs:474:21: 474:23
        _21 = (_12.1: char);             // scope 2 at src/codec/japanese.rs:474:21: 474:23
        _24 = Le(const '\u{0}', _21);    // scope 4 at src/codec/japanese.rs:476:17: 476:35
        switchInt(move _24) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/japanese.rs:476:17: 476:35
    }

    bb10: {
        _25 = Le(_21, const '\u{80}');   // scope 4 at src/codec/japanese.rs:476:17: 476:35
        switchInt(move _25) -> [false: bb11, otherwise: bb15]; // scope 4 at src/codec/japanese.rs:476:17: 476:35
    }

    bb11: {
        switchInt(_21) -> ['': bb17, '': bb19, otherwise: bb12]; // scope 4 at src/codec/japanese.rs:475:13: 475:21
    }

    bb12: {
        _22 = Le(const '', _21);        // scope 4 at src/codec/japanese.rs:479:17: 479:40
        switchInt(move _22) -> [false: bb14, otherwise: bb13]; // scope 4 at src/codec/japanese.rs:479:17: 479:40
    }

    bb13: {
        _23 = Le(_21, const '\u{ff9f}'); // scope 4 at src/codec/japanese.rs:479:17: 479:40
        switchInt(move _23) -> [false: bb14, otherwise: bb21]; // scope 4 at src/codec/japanese.rs:479:17: 479:40
    }

    bb14: {
        StorageLive(_41);                // scope 4 at src/codec/japanese.rs:484:25: 484:28
        StorageLive(_42);                // scope 4 at src/codec/japanese.rs:484:65: 484:74
        StorageLive(_43);                // scope 4 at src/codec/japanese.rs:484:65: 484:67
        _43 = _21;                       // scope 4 at src/codec/japanese.rs:484:65: 484:67
        _42 = move _43 as u32 (Misc);    // scope 4 at src/codec/japanese.rs:484:65: 484:74
        StorageDead(_43);                // scope 4 at src/codec/japanese.rs:484:73: 484:74
        _41 = backward_remapped(move _42) -> bb23; // scope 4 at src/codec/japanese.rs:484:31: 484:75
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:484:31: 484:64
                                         // + literal: Const { ty: fn(u32) -> u16 {index_japanese::jis0208::backward_remapped}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageLive(_26);                // scope 4 at src/codec/japanese.rs:476:41: 476:68
        StorageLive(_27);                // scope 4 at src/codec/japanese.rs:476:41: 476:47
        _27 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:476:41: 476:47
        StorageLive(_28);                // scope 4 at src/codec/japanese.rs:476:59: 476:67
        StorageLive(_29);                // scope 4 at src/codec/japanese.rs:476:59: 476:61
        _29 = _21;                       // scope 4 at src/codec/japanese.rs:476:59: 476:61
        _28 = move _29 as u8 (Misc);     // scope 4 at src/codec/japanese.rs:476:59: 476:67
        StorageDead(_29);                // scope 4 at src/codec/japanese.rs:476:66: 476:67
        _26 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _27, move _28) -> bb16; // scope 4 at src/codec/japanese.rs:476:41: 476:68
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:476:48: 476:58
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_28);                // scope 4 at src/codec/japanese.rs:476:67: 476:68
        StorageDead(_27);                // scope 4 at src/codec/japanese.rs:476:67: 476:68
        StorageDead(_26);                // scope 4 at src/codec/japanese.rs:476:68: 476:69
        goto -> bb35;                    // scope 4 at src/codec/japanese.rs:476:39: 476:71
    }

    bb17: {
        StorageLive(_30);                // scope 4 at src/codec/japanese.rs:477:31: 477:54
        StorageLive(_31);                // scope 4 at src/codec/japanese.rs:477:31: 477:37
        _31 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:477:31: 477:37
        _30 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _31, const 92_u8) -> bb18; // scope 4 at src/codec/japanese.rs:477:31: 477:54
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:477:38: 477:48
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb18: {
        StorageDead(_31);                // scope 4 at src/codec/japanese.rs:477:53: 477:54
        StorageDead(_30);                // scope 4 at src/codec/japanese.rs:477:54: 477:55
        goto -> bb35;                    // scope 4 at src/codec/japanese.rs:477:29: 477:57
    }

    bb19: {
        StorageLive(_32);                // scope 4 at src/codec/japanese.rs:478:33: 478:56
        StorageLive(_33);                // scope 4 at src/codec/japanese.rs:478:33: 478:39
        _33 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:478:33: 478:39
        _32 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _33, const 126_u8) -> bb20; // scope 4 at src/codec/japanese.rs:478:33: 478:56
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:478:40: 478:50
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_33);                // scope 4 at src/codec/japanese.rs:478:55: 478:56
        StorageDead(_32);                // scope 4 at src/codec/japanese.rs:478:56: 478:57
        goto -> bb35;                    // scope 4 at src/codec/japanese.rs:478:31: 478:59
    }

    bb21: {
        StorageLive(_34);                // scope 4 at src/codec/japanese.rs:480:21: 480:75
        StorageLive(_35);                // scope 4 at src/codec/japanese.rs:480:21: 480:27
        _35 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:480:21: 480:27
        StorageLive(_36);                // scope 4 at src/codec/japanese.rs:480:39: 480:74
        StorageLive(_37);                // scope 4 at src/codec/japanese.rs:480:39: 480:68
        StorageLive(_38);                // scope 4 at src/codec/japanese.rs:480:40: 480:60
        StorageLive(_39);                // scope 4 at src/codec/japanese.rs:480:40: 480:51
        StorageLive(_40);                // scope 4 at src/codec/japanese.rs:480:40: 480:42
        _40 = _21;                       // scope 4 at src/codec/japanese.rs:480:40: 480:42
        _39 = move _40 as usize (Misc);  // scope 4 at src/codec/japanese.rs:480:40: 480:51
        StorageDead(_40);                // scope 4 at src/codec/japanese.rs:480:50: 480:51
        _38 = Sub(move _39, const 65377_usize); // scope 4 at src/codec/japanese.rs:480:40: 480:60
        StorageDead(_39);                // scope 4 at src/codec/japanese.rs:480:59: 480:60
        _37 = Add(move _38, const 161_usize); // scope 4 at src/codec/japanese.rs:480:39: 480:68
        StorageDead(_38);                // scope 4 at src/codec/japanese.rs:480:67: 480:68
        _36 = move _37 as u8 (Misc);     // scope 4 at src/codec/japanese.rs:480:39: 480:74
        StorageDead(_37);                // scope 4 at src/codec/japanese.rs:480:73: 480:74
        _34 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _35, move _36) -> bb22; // scope 4 at src/codec/japanese.rs:480:21: 480:75
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:480:28: 480:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb22: {
        StorageDead(_36);                // scope 4 at src/codec/japanese.rs:480:74: 480:75
        StorageDead(_35);                // scope 4 at src/codec/japanese.rs:480:74: 480:75
        StorageDead(_34);                // scope 4 at src/codec/japanese.rs:480:75: 480:76
        goto -> bb35;                    // scope 4 at src/codec/japanese.rs:479:44: 481:18
    }

    bb23: {
        StorageDead(_42);                // scope 4 at src/codec/japanese.rs:484:74: 484:75
        StorageLive(_44);                // scope 5 at src/codec/japanese.rs:485:24: 485:27
        _44 = _41;                       // scope 5 at src/codec/japanese.rs:485:24: 485:27
        switchInt(move _44) -> [u16::MAX: bb24, otherwise: bb26]; // scope 5 at src/codec/japanese.rs:485:24: 485:37
    }

    bb24: {
        StorageDead(_44);                // scope 5 at src/codec/japanese.rs:485:24: 485:37
        StorageLive(_45);                // scope 5 at src/codec/japanese.rs:486:33: 486:34
        _45 = _19;                       // scope 5 at src/codec/japanese.rs:486:33: 486:34
        StorageLive(_46);                // scope 5 at src/codec/japanese.rs:486:36: 488:27
        StorageLive(_47);                // scope 5 at src/codec/japanese.rs:486:41: 488:26
        StorageLive(_48);                // scope 5 at src/codec/japanese.rs:487:35: 487:45
        StorageLive(_49);                // scope 5 at src/codec/japanese.rs:487:35: 487:36
        _49 = _20;                       // scope 5 at src/codec/japanese.rs:487:35: 487:36
        _48 = move _49 as isize (Misc);  // scope 5 at src/codec/japanese.rs:487:35: 487:45
        StorageDead(_49);                // scope 5 at src/codec/japanese.rs:487:44: 487:45
        StorageLive(_50);                // scope 5 at src/codec/japanese.rs:487:54: 487:88
        StorageLive(_51);                // scope 5 at src/codec/japanese.rs:487:54: 487:81
        StorageLive(_52);                // scope 5 at src/codec/japanese.rs:487:54: 487:81
        _52 = const "unrepresentable character"; // scope 5 at src/codec/japanese.rs:487:54: 487:81
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:487:54: 487:81
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _51 = _52;                       // scope 5 at src/codec/japanese.rs:487:54: 487:81
        _50 = <&str as Into<Cow<str>>>::into(move _51) -> bb25; // scope 5 at src/codec/japanese.rs:487:54: 487:88
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:487:82: 487:86
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb25: {
        StorageDead(_51);                // scope 5 at src/codec/japanese.rs:487:87: 487:88
        (_47.0: isize) = move _48;       // scope 5 at src/codec/japanese.rs:486:41: 488:26
        (_47.1: std::borrow::Cow<str>) = move _50; // scope 5 at src/codec/japanese.rs:486:41: 488:26
        StorageDead(_50);                // scope 5 at src/codec/japanese.rs:488:25: 488:26
        StorageDead(_48);                // scope 5 at src/codec/japanese.rs:488:25: 488:26
        ((_46 as Some).0: encoding_types::CodecError) = move _47; // scope 5 at src/codec/japanese.rs:486:36: 488:27
        discriminant(_46) = 1;           // scope 5 at src/codec/japanese.rs:486:36: 488:27
        StorageDead(_47);                // scope 5 at src/codec/japanese.rs:488:26: 488:27
        (_0.0: usize) = move _45;        // scope 5 at src/codec/japanese.rs:486:32: 488:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _46; // scope 5 at src/codec/japanese.rs:486:32: 488:28
        StorageDead(_46);                // scope 5 at src/codec/japanese.rs:488:27: 488:28
        StorageDead(_45);                // scope 5 at src/codec/japanese.rs:488:27: 488:28
        StorageDead(_52);                // scope 5 at src/codec/japanese.rs:488:28: 488:29
        StorageDead(_41);                // scope 4 at src/codec/japanese.rs:497:17: 497:18
        StorageDead(_21);                // scope 2 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_20);                // scope 2 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:474:45: 474:46
        goto -> bb37;                    // scope 0 at src/codec/japanese.rs:501:6: 501:6
    }

    bb26: {
        StorageDead(_44);                // scope 5 at src/codec/japanese.rs:485:24: 485:37
        StorageLive(_53);                // scope 5 at src/codec/japanese.rs:490:29: 490:33
        StorageLive(_54);                // scope 5 at src/codec/japanese.rs:490:36: 490:39
        _54 = _41;                       // scope 5 at src/codec/japanese.rs:490:36: 490:39
        _53 = Div(move _54, const 188_u16); // scope 5 at src/codec/japanese.rs:490:36: 490:45
        StorageDead(_54);                // scope 5 at src/codec/japanese.rs:490:44: 490:45
        StorageLive(_55);                // scope 6 at src/codec/japanese.rs:491:29: 491:39
        StorageLive(_56);                // scope 6 at src/codec/japanese.rs:491:45: 491:56
        StorageLive(_57);                // scope 6 at src/codec/japanese.rs:491:45: 491:49
        _57 = _53;                       // scope 6 at src/codec/japanese.rs:491:45: 491:49
        _56 = Lt(move _57, const 31_u16); // scope 6 at src/codec/japanese.rs:491:45: 491:56
        StorageDead(_57);                // scope 6 at src/codec/japanese.rs:491:55: 491:56
        switchInt(move _56) -> [false: bb28, otherwise: bb27]; // scope 6 at src/codec/japanese.rs:491:45: 491:56
    }

    bb27: {
        _55 = const 129_u16;             // scope 6 at src/codec/japanese.rs:491:58: 491:62
        goto -> bb29;                    // scope 6 at src/codec/japanese.rs:491:42: 491:75
    }

    bb28: {
        _55 = const 193_u16;             // scope 6 at src/codec/japanese.rs:491:70: 491:74
        goto -> bb29;                    // scope 6 at src/codec/japanese.rs:491:42: 491:75
    }

    bb29: {
        StorageDead(_56);                // scope 6 at src/codec/japanese.rs:491:74: 491:75
        StorageLive(_58);                // scope 7 at src/codec/japanese.rs:492:29: 492:34
        StorageLive(_59);                // scope 7 at src/codec/japanese.rs:492:37: 492:40
        _59 = _41;                       // scope 7 at src/codec/japanese.rs:492:37: 492:40
        _58 = Rem(move _59, const 188_u16); // scope 7 at src/codec/japanese.rs:492:37: 492:46
        StorageDead(_59);                // scope 7 at src/codec/japanese.rs:492:45: 492:46
        StorageLive(_60);                // scope 8 at src/codec/japanese.rs:493:29: 493:40
        StorageLive(_61);                // scope 8 at src/codec/japanese.rs:493:46: 493:58
        StorageLive(_62);                // scope 8 at src/codec/japanese.rs:493:46: 493:51
        _62 = _58;                       // scope 8 at src/codec/japanese.rs:493:46: 493:51
        _61 = Lt(move _62, const 63_u16); // scope 8 at src/codec/japanese.rs:493:46: 493:58
        StorageDead(_62);                // scope 8 at src/codec/japanese.rs:493:57: 493:58
        switchInt(move _61) -> [false: bb31, otherwise: bb30]; // scope 8 at src/codec/japanese.rs:493:46: 493:58
    }

    bb30: {
        _60 = const 64_u16;              // scope 8 at src/codec/japanese.rs:493:60: 493:64
        goto -> bb32;                    // scope 8 at src/codec/japanese.rs:493:43: 493:77
    }

    bb31: {
        _60 = const 65_u16;              // scope 8 at src/codec/japanese.rs:493:72: 493:76
        goto -> bb32;                    // scope 8 at src/codec/japanese.rs:493:43: 493:77
    }

    bb32: {
        StorageDead(_61);                // scope 8 at src/codec/japanese.rs:493:76: 493:77
        StorageLive(_63);                // scope 9 at src/codec/japanese.rs:494:25: 494:69
        StorageLive(_64);                // scope 9 at src/codec/japanese.rs:494:25: 494:31
        _64 = &mut (*_3);                // scope 9 at src/codec/japanese.rs:494:25: 494:31
        StorageLive(_65);                // scope 9 at src/codec/japanese.rs:494:43: 494:68
        StorageLive(_66);                // scope 9 at src/codec/japanese.rs:494:43: 494:62
        StorageLive(_67);                // scope 9 at src/codec/japanese.rs:494:44: 494:48
        _67 = _53;                       // scope 9 at src/codec/japanese.rs:494:44: 494:48
        StorageLive(_68);                // scope 9 at src/codec/japanese.rs:494:51: 494:61
        _68 = _55;                       // scope 9 at src/codec/japanese.rs:494:51: 494:61
        _66 = Add(move _67, move _68);   // scope 9 at src/codec/japanese.rs:494:43: 494:62
        StorageDead(_68);                // scope 9 at src/codec/japanese.rs:494:61: 494:62
        StorageDead(_67);                // scope 9 at src/codec/japanese.rs:494:61: 494:62
        _65 = move _66 as u8 (Misc);     // scope 9 at src/codec/japanese.rs:494:43: 494:68
        StorageDead(_66);                // scope 9 at src/codec/japanese.rs:494:67: 494:68
        _63 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _64, move _65) -> bb33; // scope 9 at src/codec/japanese.rs:494:25: 494:69
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:494:32: 494:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb33: {
        StorageDead(_65);                // scope 9 at src/codec/japanese.rs:494:68: 494:69
        StorageDead(_64);                // scope 9 at src/codec/japanese.rs:494:68: 494:69
        StorageDead(_63);                // scope 9 at src/codec/japanese.rs:494:69: 494:70
        StorageLive(_69);                // scope 9 at src/codec/japanese.rs:495:25: 495:71
        StorageLive(_70);                // scope 9 at src/codec/japanese.rs:495:25: 495:31
        _70 = &mut (*_3);                // scope 9 at src/codec/japanese.rs:495:25: 495:31
        StorageLive(_71);                // scope 9 at src/codec/japanese.rs:495:43: 495:70
        StorageLive(_72);                // scope 9 at src/codec/japanese.rs:495:43: 495:64
        StorageLive(_73);                // scope 9 at src/codec/japanese.rs:495:44: 495:49
        _73 = _58;                       // scope 9 at src/codec/japanese.rs:495:44: 495:49
        StorageLive(_74);                // scope 9 at src/codec/japanese.rs:495:52: 495:63
        _74 = _60;                       // scope 9 at src/codec/japanese.rs:495:52: 495:63
        _72 = Add(move _73, move _74);   // scope 9 at src/codec/japanese.rs:495:43: 495:64
        StorageDead(_74);                // scope 9 at src/codec/japanese.rs:495:63: 495:64
        StorageDead(_73);                // scope 9 at src/codec/japanese.rs:495:63: 495:64
        _71 = move _72 as u8 (Misc);     // scope 9 at src/codec/japanese.rs:495:43: 495:70
        StorageDead(_72);                // scope 9 at src/codec/japanese.rs:495:69: 495:70
        _69 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _70, move _71) -> bb34; // scope 9 at src/codec/japanese.rs:495:25: 495:71
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:495:32: 495:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb34: {
        StorageDead(_71);                // scope 9 at src/codec/japanese.rs:495:70: 495:71
        StorageDead(_70);                // scope 9 at src/codec/japanese.rs:495:70: 495:71
        StorageDead(_69);                // scope 9 at src/codec/japanese.rs:495:71: 495:72
        StorageDead(_60);                // scope 8 at src/codec/japanese.rs:496:21: 496:22
        StorageDead(_58);                // scope 7 at src/codec/japanese.rs:496:21: 496:22
        StorageDead(_55);                // scope 6 at src/codec/japanese.rs:496:21: 496:22
        StorageDead(_53);                // scope 5 at src/codec/japanese.rs:496:21: 496:22
        StorageDead(_41);                // scope 4 at src/codec/japanese.rs:497:17: 497:18
        goto -> bb35;                    // scope 4 at src/codec/japanese.rs:497:17: 497:18
    }

    bb35: {
        StorageDead(_21);                // scope 2 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_20);                // scope 2 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:499:9: 499:10
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:499:9: 499:10
        goto -> bb5;                     // scope 1 at src/codec/japanese.rs:474:9: 499:10
    }

    bb36: {
        StorageDead(_76);                // scope 0 at src/codec/japanese.rs:500:20: 500:21
        StorageLive(_77);                // scope 0 at src/codec/japanese.rs:500:23: 500:27
        discriminant(_77) = 0;           // scope 0 at src/codec/japanese.rs:500:23: 500:27
        (_0.0: usize) = move _75;        // scope 0 at src/codec/japanese.rs:500:9: 500:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _77; // scope 0 at src/codec/japanese.rs:500:9: 500:28
        StorageDead(_77);                // scope 0 at src/codec/japanese.rs:500:27: 500:28
        StorageDead(_75);                // scope 0 at src/codec/japanese.rs:500:27: 500:28
        goto -> bb37;                    // scope 0 at src/codec/japanese.rs:501:6: 501:6
    }

    bb37: {
        return;                          // scope 0 at src/codec/japanese.rs:501:6: 501:6
    }
}

const ISO_8859_2: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:43:64: 43:76
    let _5: &str;                        // in scope 0 at src/all.rs:43:64: 43:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_2::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_2, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1251 ~ encoding[5d2c]::all::ISO_8859_2), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_2: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:43:64: 43:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:43:64: 43:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-2";         // scope 0 at src/all.rs:43:64: 43:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:43:64: 43:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:43:64: 43:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_2::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_2::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_2::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_2::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-2"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:43:64: 43:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn eucjp::internal::map_two_0212_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/japanese.rs:130:40: 130:44
    debug trail => _2;                   // in scope 0 at src/codec/japanese.rs:130:50: 130:55
    let mut _0: u32;                     // return place in scope 0 at src/codec/japanese.rs:130:64: 130:67
    let _3: u16;                         // in scope 0 at src/codec/japanese.rs:133:13: 133:17
    let mut _4: u8;                      // in scope 0 at src/codec/japanese.rs:133:20: 133:24
    let mut _6: u8;                      // in scope 0 at src/codec/japanese.rs:134:21: 134:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/japanese.rs:135:27: 135:40
    let mut _9: u16;                     // in scope 0 at src/codec/japanese.rs:135:28: 135:32
    let mut _10: u16;                    // in scope 0 at src/codec/japanese.rs:135:34: 135:39
    let mut _11: bool;                   // in scope 0 at src/codec/japanese.rs:136:27: 136:38
    let mut _12: bool;                   // in scope 0 at src/codec/japanese.rs:136:27: 136:38
    let mut _13: bool;                   // in scope 0 at src/codec/japanese.rs:136:14: 136:25
    let mut _14: bool;                   // in scope 0 at src/codec/japanese.rs:136:14: 136:25
    let mut _15: u16;                    // in scope 0 at src/codec/japanese.rs:136:43: 136:69
    let mut _16: u16;                    // in scope 0 at src/codec/japanese.rs:136:43: 136:61
    let mut _17: u16;                    // in scope 0 at src/codec/japanese.rs:136:43: 136:56
    let mut _18: u16;                    // in scope 0 at src/codec/japanese.rs:136:44: 136:48
    let mut _19: u16;                    // in scope 0 at src/codec/japanese.rs:136:64: 136:69
    let mut _20: u16;                    // in scope 0 at src/codec/japanese.rs:139:33: 139:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/japanese.rs:133:13: 133:17
        let _5: u16;                     // in scope 1 at src/codec/japanese.rs:134:13: 134:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/japanese.rs:134:13: 134:18
            let _7: u16;                 // in scope 2 at src/codec/japanese.rs:135:13: 135:18
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/japanese.rs:135:13: 135:18
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:133:13: 133:17
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:133:20: 133:24
        _4 = _1;                         // scope 0 at src/codec/japanese.rs:133:20: 133:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/japanese.rs:133:20: 133:31
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:133:30: 133:31
        StorageLive(_5);                 // scope 1 at src/codec/japanese.rs:134:13: 134:18
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:134:21: 134:26
        _6 = _2;                         // scope 1 at src/codec/japanese.rs:134:21: 134:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/japanese.rs:134:21: 134:33
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:134:32: 134:33
        StorageLive(_7);                 // scope 2 at src/codec/japanese.rs:135:13: 135:18
        StorageLive(_8);                 // scope 2 at src/codec/japanese.rs:135:27: 135:40
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:135:28: 135:32
        _9 = _3;                         // scope 2 at src/codec/japanese.rs:135:28: 135:32
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:135:34: 135:39
        _10 = _5;                        // scope 2 at src/codec/japanese.rs:135:34: 135:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/japanese.rs:135:27: 135:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/japanese.rs:135:27: 135:40
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:135:39: 135:40
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:135:39: 135:40
        _13 = Le(const 161_u16, (_8.0: u16)); // scope 2 at src/codec/japanese.rs:136:14: 136:25
        switchInt(move _13) -> [false: bb4, otherwise: bb1]; // scope 2 at src/codec/japanese.rs:136:14: 136:25
    }

    bb1: {
        _14 = Le((_8.0: u16), const 254_u16); // scope 2 at src/codec/japanese.rs:136:14: 136:25
        switchInt(move _14) -> [false: bb4, otherwise: bb2]; // scope 2 at src/codec/japanese.rs:136:14: 136:25
    }

    bb2: {
        _11 = Le(const 161_u16, (_8.1: u16)); // scope 2 at src/codec/japanese.rs:136:27: 136:38
        switchInt(move _11) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/japanese.rs:136:27: 136:38
    }

    bb3: {
        _12 = Le((_8.1: u16), const 254_u16); // scope 2 at src/codec/japanese.rs:136:27: 136:38
        switchInt(move _12) -> [false: bb4, otherwise: bb5]; // scope 2 at src/codec/japanese.rs:136:27: 136:38
    }

    bb4: {
        _7 = const u16::MAX;             // scope 2 at src/codec/japanese.rs:137:18: 137:24
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:137:18: 137:24
    }

    bb5: {
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:136:43: 136:69
        StorageLive(_16);                // scope 2 at src/codec/japanese.rs:136:43: 136:61
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:136:43: 136:56
        StorageLive(_18);                // scope 2 at src/codec/japanese.rs:136:44: 136:48
        _18 = _3;                        // scope 2 at src/codec/japanese.rs:136:44: 136:48
        _17 = Sub(move _18, const 161_u16); // scope 2 at src/codec/japanese.rs:136:43: 136:56
        StorageDead(_18);                // scope 2 at src/codec/japanese.rs:136:55: 136:56
        _16 = Mul(move _17, const 94_u16); // scope 2 at src/codec/japanese.rs:136:43: 136:61
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:136:60: 136:61
        StorageLive(_19);                // scope 2 at src/codec/japanese.rs:136:64: 136:69
        _19 = _5;                        // scope 2 at src/codec/japanese.rs:136:64: 136:69
        _15 = Add(move _16, move _19);   // scope 2 at src/codec/japanese.rs:136:43: 136:69
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:136:68: 136:69
        StorageDead(_16);                // scope 2 at src/codec/japanese.rs:136:68: 136:69
        _7 = Sub(move _15, const 161_u16); // scope 2 at src/codec/japanese.rs:136:43: 136:76
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:136:75: 136:76
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:136:75: 136:76
    }

    bb6: {
        StorageDead(_8);                 // scope 2 at src/codec/japanese.rs:138:10: 138:11
        StorageLive(_20);                // scope 3 at src/codec/japanese.rs:139:33: 139:38
        _20 = _7;                        // scope 3 at src/codec/japanese.rs:139:33: 139:38
        _0 = index_japanese::jis0212::forward(move _20) -> bb7; // scope 3 at src/codec/japanese.rs:139:9: 139:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:139:9: 139:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_japanese::jis0212::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:139:38: 139:39
        StorageDead(_7);                 // scope 2 at src/codec/japanese.rs:140:5: 140:6
        StorageDead(_5);                 // scope 1 at src/codec/japanese.rs:140:5: 140:6
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:140:5: 140:6
        return;                          // scope 0 at src/codec/japanese.rs:140:6: 140:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:55:1: 62:2>::raw_feed(_1: &mut GB18030Encoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:58:17: 58:26
    debug input => _2;                   // in scope 0 at src/codec/simpchinese.rs:58:28: 58:33
    debug output => _3;                  // in scope 0 at src/codec/simpchinese.rs:58:41: 58:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/simpchinese.rs:58:69: 58:96
    let mut _4: &mut codec::simpchinese::GBEncoder; // in scope 0 at src/codec/simpchinese.rs:59:9: 59:18
    let mut _5: codec::simpchinese::GBEncoder; // in scope 0 at src/codec/simpchinese.rs:59:9: 59:18
    let mut _6: &str;                    // in scope 0 at src/codec/simpchinese.rs:59:28: 59:33
    let mut _7: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:59:35: 59:41
    let mut _8: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:59:35: 59:41

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:59:9: 59:18
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:59:9: 59:18
        _4 = &mut _5;                    // scope 0 at src/codec/simpchinese.rs:59:9: 59:18
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:59:28: 59:33
        _6 = _2;                         // scope 0 at src/codec/simpchinese.rs:59:28: 59:33
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:59:35: 59:41
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:59:35: 59:41
        _8 = &mut (*_3);                 // scope 0 at src/codec/simpchinese.rs:59:35: 59:41
        _7 = move _8 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:59:35: 59:41
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:59:40: 59:41
        _0 = GBEncoder::raw_feed(move _4, move _6, move _7, const false) -> bb1; // scope 0 at src/codec/simpchinese.rs:59:9: 59:49
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:59:19: 59:27
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut codec::simpchinese::GBEncoder, &'s str, &'t0 mut (dyn encoding_types::ByteWriter + 't0), bool) -> (usize, std::option::Option<encoding_types::CodecError>) {codec::simpchinese::GBEncoder::raw_feed}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:59:48: 59:49
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:59:48: 59:49
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:59:48: 59:49
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:60:5: 60:6
        return;                          // scope 0 at src/codec/simpchinese.rs:60:6: 60:6
    }
}

fn as_char(_1: u32) -> char {
    debug ch => _1;                      // in scope 0 at src/util.rs:14:16: 14:18
    let mut _0: char;                    // return place in scope 0 at src/util.rs:14:28: 14:32
    let mut _2: u32;                     // in scope 0 at src/util.rs:16:29: 16:31
    scope 1 {
    }

    bb0: {
        StorageLive(_2);                 // scope 1 at src/util.rs:16:29: 16:31
        _2 = _1;                         // scope 1 at src/util.rs:16:29: 16:31
        _0 = transmute::<u32, char>(move _2) -> bb1; // scope 1 at src/util.rs:16:14: 16:32
                                         // mir::Constant
                                         // + span: src/util.rs:16:14: 16:28
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(u32) -> char {std::intrinsics::transmute::<u32, char>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_2);                 // scope 1 at src/util.rs:16:31: 16:32
        return;                          // scope 0 at src/util.rs:17:2: 17:2
    }
}

static STATE_TRANSITIONS: [u8; 110] = {
    let mut _0: [u8; 110];               // return place in scope 0 at src/codec/utf_8.rs:118:27: 118:36

    bb0: {
        _0 = [const 0_u8, const 98_u8, const 12_u8, const 24_u8, const 48_u8, const 84_u8, const 72_u8, const 98_u8, const 98_u8, const 98_u8, const 36_u8, const 60_u8, const 86_u8, const 0_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 0_u8, const 86_u8, const 0_u8, const 86_u8, const 86_u8, const 86_u8, const 12_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 12_u8, const 86_u8, const 12_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 12_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 12_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 12_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 24_u8, const 86_u8, const 24_u8, const 86_u8, const 86_u8, const 86_u8, const 24_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 24_u8, const 86_u8, const 24_u8, const 86_u8, const 86_u8, const 86_u8, const 24_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 86_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8, const 98_u8]; // scope 0 at src/codec/utf_8.rs:118:39: 129:2
        return;                          // scope 0 at src/codec/utf_8.rs:118:1: 129:3
    }
}

const ENCODINGS: &[&dyn encoding_types::Encoding + Send + Sync] = {
    let mut _0: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync]; // return place in scope 0 at src/all.rs:95:22: 95:44
    let mut _1: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]; // in scope 0 at src/all.rs:95:47: 140:6
    let _2: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]; // in scope 0 at src/all.rs:95:47: 140:6
    let _3: [&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]; // in scope 0 at src/all.rs:95:48: 140:6
    let mut _4: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:96:9: 96:14
    let mut _5: &codec::error::ErrorEncoding; // in scope 0 at src/all.rs:96:9: 96:14
    let _6: &codec::error::ErrorEncoding; // in scope 0 at src/all.rs:96:9: 96:14
    let mut _7: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:97:9: 97:14
    let mut _8: &codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:97:9: 97:14
    let _9: &codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:97:9: 97:14
    let mut _10: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:98:9: 98:15
    let mut _11: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:98:9: 98:15
    let _12: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:98:9: 98:15
    let mut _13: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:99:9: 99:19
    let mut _14: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:99:9: 99:19
    let _15: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:99:9: 99:19
    let mut _16: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:100:9: 100:19
    let mut _17: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:100:9: 100:19
    let _18: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:100:9: 100:19
    let mut _19: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:101:9: 101:19
    let mut _20: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:101:9: 101:19
    let _21: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:101:9: 101:19
    let mut _22: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:102:9: 102:19
    let mut _23: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:102:9: 102:19
    let _24: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:102:9: 102:19
    let mut _25: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:103:9: 103:19
    let mut _26: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:103:9: 103:19
    let _27: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:103:9: 103:19
    let mut _28: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:104:9: 104:19
    let mut _29: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:104:9: 104:19
    let _30: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:104:9: 104:19
    let mut _31: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:105:9: 105:19
    let mut _32: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:105:9: 105:19
    let _33: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:105:9: 105:19
    let mut _34: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:106:9: 106:19
    let mut _35: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:106:9: 106:19
    let _36: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:106:9: 106:19
    let mut _37: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:107:9: 107:20
    let mut _38: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:107:9: 107:20
    let _39: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:107:9: 107:20
    let mut _40: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:108:9: 108:20
    let mut _41: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:108:9: 108:20
    let _42: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:108:9: 108:20
    let mut _43: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:109:9: 109:20
    let mut _44: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:109:9: 109:20
    let _45: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:109:9: 109:20
    let mut _46: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:110:9: 110:20
    let mut _47: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:110:9: 110:20
    let _48: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:110:9: 110:20
    let mut _49: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:111:9: 111:20
    let mut _50: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:111:9: 111:20
    let _51: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:111:9: 111:20
    let mut _52: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:112:9: 112:15
    let mut _53: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:112:9: 112:15
    let _54: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:112:9: 112:15
    let mut _55: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:113:9: 113:15
    let mut _56: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:113:9: 113:15
    let _57: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:113:9: 113:15
    let mut _58: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:114:9: 114:18
    let mut _59: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:114:9: 114:18
    let _60: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:114:9: 114:18
    let mut _61: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:115:9: 115:20
    let mut _62: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:115:9: 115:20
    let _63: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:115:9: 115:20
    let mut _64: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:116:9: 116:21
    let mut _65: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:116:9: 116:21
    let _66: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:116:9: 116:21
    let mut _67: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:117:9: 117:21
    let mut _68: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:117:9: 117:21
    let _69: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:117:9: 117:21
    let mut _70: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:118:9: 118:21
    let mut _71: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:118:9: 118:21
    let _72: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:118:9: 118:21
    let mut _73: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:119:9: 119:21
    let mut _74: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:119:9: 119:21
    let _75: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:119:9: 119:21
    let mut _76: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:120:9: 120:21
    let mut _77: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:120:9: 120:21
    let _78: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:120:9: 120:21
    let mut _79: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:121:9: 121:21
    let mut _80: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:121:9: 121:21
    let _81: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:121:9: 121:21
    let mut _82: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:122:9: 122:21
    let mut _83: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:122:9: 122:21
    let _84: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:122:9: 122:21
    let mut _85: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:123:9: 123:21
    let mut _86: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:123:9: 123:21
    let _87: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:123:9: 123:21
    let mut _88: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:124:9: 124:21
    let mut _89: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:124:9: 124:21
    let _90: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:124:9: 124:21
    let mut _91: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:125:9: 125:21
    let mut _92: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:125:9: 125:21
    let _93: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:125:9: 125:21
    let mut _94: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:126:9: 126:14
    let mut _95: &codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:126:9: 126:14
    let _96: &codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:126:9: 126:14
    let mut _97: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:127:9: 127:17
    let mut _98: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:127:9: 127:17
    let _99: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:127:9: 127:17
    let mut _100: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:128:9: 128:17
    let mut _101: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:128:9: 128:17
    let _102: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:128:9: 128:17
    let mut _103: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:129:9: 129:20
    let mut _104: &codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:129:9: 129:20
    let _105: &codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:129:9: 129:20
    let mut _106: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:130:9: 130:15
    let mut _107: &codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:130:9: 130:15
    let _108: &codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:130:9: 130:15
    let mut _109: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:131:9: 131:20
    let mut _110: &codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:131:9: 131:20
    let _111: &codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:131:9: 131:20
    let mut _112: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:132:9: 132:20
    let mut _113: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:132:9: 132:20
    let _114: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:132:9: 132:20
    let mut _115: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:133:9: 133:12
    let mut _116: &codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:133:9: 133:12
    let _117: &codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:133:9: 133:12
    let mut _118: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:134:9: 134:16
    let mut _119: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:134:9: 134:16
    let _120: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:134:9: 134:16
    let mut _121: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:135:9: 135:11
    let mut _122: &codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:135:9: 135:11
    let _123: &codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:135:9: 135:11
    let mut _124: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:136:9: 136:18
    let mut _125: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:136:9: 136:18
    let _126: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:136:9: 136:18
    let mut _127: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:137:9: 137:31
    let mut _128: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:137:9: 137:31
    let _129: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:137:9: 137:31
    let mut _130: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:138:9: 138:29
    let mut _131: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:138:9: 138:29
    let _132: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:138:9: 138:29
    let mut _133: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:139:9: 139:28
    let mut _134: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:139:9: 139:28
    let _135: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:139:9: 139:28
    let mut _136: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]; // in scope 0 at src/all.rs:95:47: 140:6

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:95:47: 140:6
        StorageLive(_2);                 // scope 0 at src/all.rs:95:47: 140:6
        _136 = const ENCODINGS::promoted[0]; // scope 0 at src/all.rs:95:47: 140:6
                                         // ty::Const
                                         // + ty: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]
                                         // + val: Unevaluated(ENCODINGS, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:95:47: 140:6
                                         // + literal: Const { ty: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:581 ~ encoding[5d2c]::all::encodings::ENCODINGS), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _2 = &(*_136);                   // scope 0 at src/all.rs:95:47: 140:6
        _1 = &(*_2);                     // scope 0 at src/all.rs:95:47: 140:6
        _0 = move _1 as &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync] (Pointer(Unsize)); // scope 0 at src/all.rs:95:47: 140:6
        StorageDead(_2);                 // scope 0 at src/all.rs:140:5: 140:6
        StorageDead(_1);                 // scope 0 at src/all.rs:140:5: 140:6
        return;                          // scope 0 at src/all.rs:95:5: 140:7
    }
}

promoted[0] in ENCODINGS: &[&dyn encoding_types::Encoding + Send + Sync; 44] = {
    let mut _0: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]; // return place in scope 0 at src/all.rs:95:47: 140:6
    let mut _1: [&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; 44]; // in scope 0 at src/all.rs:95:48: 140:6
    let mut _2: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:96:9: 96:14
    let mut _3: &codec::error::ErrorEncoding; // in scope 0 at src/all.rs:96:9: 96:14
    let mut _4: &codec::error::ErrorEncoding; // in scope 0 at src/all.rs:96:9: 96:14
    let mut _5: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:97:9: 97:14
    let mut _6: &codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:97:9: 97:14
    let mut _7: &codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:97:9: 97:14
    let mut _8: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:98:9: 98:15
    let mut _9: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:98:9: 98:15
    let mut _10: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:98:9: 98:15
    let mut _11: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:99:9: 99:19
    let mut _12: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:99:9: 99:19
    let mut _13: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:99:9: 99:19
    let mut _14: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:100:9: 100:19
    let mut _15: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:100:9: 100:19
    let mut _16: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:100:9: 100:19
    let mut _17: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:101:9: 101:19
    let mut _18: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:101:9: 101:19
    let mut _19: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:101:9: 101:19
    let mut _20: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:102:9: 102:19
    let mut _21: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:102:9: 102:19
    let mut _22: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:102:9: 102:19
    let mut _23: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:103:9: 103:19
    let mut _24: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:103:9: 103:19
    let mut _25: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:103:9: 103:19
    let mut _26: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:104:9: 104:19
    let mut _27: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:104:9: 104:19
    let mut _28: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:104:9: 104:19
    let mut _29: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:105:9: 105:19
    let mut _30: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:105:9: 105:19
    let mut _31: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:105:9: 105:19
    let mut _32: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:106:9: 106:19
    let mut _33: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:106:9: 106:19
    let mut _34: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:106:9: 106:19
    let mut _35: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:107:9: 107:20
    let mut _36: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:107:9: 107:20
    let mut _37: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:107:9: 107:20
    let mut _38: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:108:9: 108:20
    let mut _39: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:108:9: 108:20
    let mut _40: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:108:9: 108:20
    let mut _41: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:109:9: 109:20
    let mut _42: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:109:9: 109:20
    let mut _43: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:109:9: 109:20
    let mut _44: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:110:9: 110:20
    let mut _45: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:110:9: 110:20
    let mut _46: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:110:9: 110:20
    let mut _47: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:111:9: 111:20
    let mut _48: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:111:9: 111:20
    let mut _49: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:111:9: 111:20
    let mut _50: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:112:9: 112:15
    let mut _51: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:112:9: 112:15
    let mut _52: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:112:9: 112:15
    let mut _53: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:113:9: 113:15
    let mut _54: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:113:9: 113:15
    let mut _55: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:113:9: 113:15
    let mut _56: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:114:9: 114:18
    let mut _57: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:114:9: 114:18
    let mut _58: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:114:9: 114:18
    let mut _59: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:115:9: 115:20
    let mut _60: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:115:9: 115:20
    let mut _61: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:115:9: 115:20
    let mut _62: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:116:9: 116:21
    let mut _63: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:116:9: 116:21
    let mut _64: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:116:9: 116:21
    let mut _65: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:117:9: 117:21
    let mut _66: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:117:9: 117:21
    let mut _67: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:117:9: 117:21
    let mut _68: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:118:9: 118:21
    let mut _69: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:118:9: 118:21
    let mut _70: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:118:9: 118:21
    let mut _71: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:119:9: 119:21
    let mut _72: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:119:9: 119:21
    let mut _73: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:119:9: 119:21
    let mut _74: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:120:9: 120:21
    let mut _75: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:120:9: 120:21
    let mut _76: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:120:9: 120:21
    let mut _77: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:121:9: 121:21
    let mut _78: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:121:9: 121:21
    let mut _79: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:121:9: 121:21
    let mut _80: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:122:9: 122:21
    let mut _81: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:122:9: 122:21
    let mut _82: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:122:9: 122:21
    let mut _83: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:123:9: 123:21
    let mut _84: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:123:9: 123:21
    let mut _85: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:123:9: 123:21
    let mut _86: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:124:9: 124:21
    let mut _87: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:124:9: 124:21
    let mut _88: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:124:9: 124:21
    let mut _89: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:125:9: 125:21
    let mut _90: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:125:9: 125:21
    let mut _91: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:125:9: 125:21
    let mut _92: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:126:9: 126:14
    let mut _93: &codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:126:9: 126:14
    let mut _94: &codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:126:9: 126:14
    let mut _95: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:127:9: 127:17
    let mut _96: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:127:9: 127:17
    let mut _97: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:127:9: 127:17
    let mut _98: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:128:9: 128:17
    let mut _99: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:128:9: 128:17
    let mut _100: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:128:9: 128:17
    let mut _101: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:129:9: 129:20
    let mut _102: &codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:129:9: 129:20
    let mut _103: &codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:129:9: 129:20
    let mut _104: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:130:9: 130:15
    let mut _105: &codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:130:9: 130:15
    let mut _106: &codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:130:9: 130:15
    let mut _107: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:131:9: 131:20
    let mut _108: &codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:131:9: 131:20
    let mut _109: &codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:131:9: 131:20
    let mut _110: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:132:9: 132:20
    let mut _111: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:132:9: 132:20
    let mut _112: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:132:9: 132:20
    let mut _113: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:133:9: 133:12
    let mut _114: &codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:133:9: 133:12
    let mut _115: &codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:133:9: 133:12
    let mut _116: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:134:9: 134:16
    let mut _117: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:134:9: 134:16
    let mut _118: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:134:9: 134:16
    let mut _119: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:135:9: 135:11
    let mut _120: &codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:135:9: 135:11
    let mut _121: &codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:135:9: 135:11
    let mut _122: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:136:9: 136:18
    let mut _123: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:136:9: 136:18
    let mut _124: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:136:9: 136:18
    let mut _125: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:137:9: 137:31
    let mut _126: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:137:9: 137:31
    let mut _127: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:137:9: 137:31
    let mut _128: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:138:9: 138:29
    let mut _129: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:138:9: 138:29
    let mut _130: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:138:9: 138:29
    let mut _131: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/all.rs:139:9: 139:28
    let mut _132: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:139:9: 139:28
    let mut _133: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:139:9: 139:28

    bb0: {
        _4 = const ERROR;                // scope 0 at src/all.rs:96:9: 96:14
                                         // ty::Const
                                         // + ty: &codec::error::ErrorEncoding
                                         // + val: Unevaluated(ERROR, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:96:9: 96:14
                                         // + literal: Const { ty: &codec::error::ErrorEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1247 ~ encoding[5d2c]::all::ERROR), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:96:9: 96:14
        _2 = move _3 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:96:9: 96:14
        _7 = const all::ASCII;           // scope 0 at src/all.rs:97:9: 97:14
                                         // ty::Const
                                         // + ty: &codec::ascii::ASCIIEncoding
                                         // + val: Unevaluated(all::ASCII, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:97:9: 97:14
                                         // + literal: Const { ty: &codec::ascii::ASCIIEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1248 ~ encoding[5d2c]::all::ASCII), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _6 = &(*_7);                     // scope 0 at src/all.rs:97:9: 97:14
        _5 = move _6 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:97:9: 97:14
        _10 = const IBM866;              // scope 0 at src/all.rs:98:9: 98:15
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(IBM866, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:98:9: 98:15
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1249 ~ encoding[5d2c]::all::IBM866), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _9 = &(*_10);                    // scope 0 at src/all.rs:98:9: 98:15
        _8 = move _9 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:98:9: 98:15
        _13 = const ISO_8859_1;          // scope 0 at src/all.rs:99:9: 99:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_1, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:99:9: 99:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1250 ~ encoding[5d2c]::all::ISO_8859_1), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _12 = &(*_13);                   // scope 0 at src/all.rs:99:9: 99:19
        _11 = move _12 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:99:9: 99:19
        _16 = const ISO_8859_2;          // scope 0 at src/all.rs:100:9: 100:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_2, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:100:9: 100:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1251 ~ encoding[5d2c]::all::ISO_8859_2), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _15 = &(*_16);                   // scope 0 at src/all.rs:100:9: 100:19
        _14 = move _15 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:100:9: 100:19
        _19 = const ISO_8859_3;          // scope 0 at src/all.rs:101:9: 101:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_3, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:101:9: 101:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1252 ~ encoding[5d2c]::all::ISO_8859_3), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _18 = &(*_19);                   // scope 0 at src/all.rs:101:9: 101:19
        _17 = move _18 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:101:9: 101:19
        _22 = const ISO_8859_4;          // scope 0 at src/all.rs:102:9: 102:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_4, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:102:9: 102:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1253 ~ encoding[5d2c]::all::ISO_8859_4), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _21 = &(*_22);                   // scope 0 at src/all.rs:102:9: 102:19
        _20 = move _21 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:102:9: 102:19
        _25 = const ISO_8859_5;          // scope 0 at src/all.rs:103:9: 103:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_5, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:103:9: 103:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1254 ~ encoding[5d2c]::all::ISO_8859_5), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _24 = &(*_25);                   // scope 0 at src/all.rs:103:9: 103:19
        _23 = move _24 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:103:9: 103:19
        _28 = const ISO_8859_6;          // scope 0 at src/all.rs:104:9: 104:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_6, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:104:9: 104:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1255 ~ encoding[5d2c]::all::ISO_8859_6), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _27 = &(*_28);                   // scope 0 at src/all.rs:104:9: 104:19
        _26 = move _27 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:104:9: 104:19
        _31 = const ISO_8859_7;          // scope 0 at src/all.rs:105:9: 105:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_7, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:105:9: 105:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1256 ~ encoding[5d2c]::all::ISO_8859_7), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _30 = &(*_31);                   // scope 0 at src/all.rs:105:9: 105:19
        _29 = move _30 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:105:9: 105:19
        _34 = const ISO_8859_8;          // scope 0 at src/all.rs:106:9: 106:19
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:106:9: 106:19
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1257 ~ encoding[5d2c]::all::ISO_8859_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _33 = &(*_34);                   // scope 0 at src/all.rs:106:9: 106:19
        _32 = move _33 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:106:9: 106:19
        _37 = const ISO_8859_10;         // scope 0 at src/all.rs:107:9: 107:20
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_10, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:107:9: 107:20
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1258 ~ encoding[5d2c]::all::ISO_8859_10), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _36 = &(*_37);                   // scope 0 at src/all.rs:107:9: 107:20
        _35 = move _36 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:107:9: 107:20
        _40 = const ISO_8859_13;         // scope 0 at src/all.rs:108:9: 108:20
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_13, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:108:9: 108:20
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1259 ~ encoding[5d2c]::all::ISO_8859_13), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _39 = &(*_40);                   // scope 0 at src/all.rs:108:9: 108:20
        _38 = move _39 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:108:9: 108:20
        _43 = const ISO_8859_14;         // scope 0 at src/all.rs:109:9: 109:20
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_14, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:109:9: 109:20
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1260 ~ encoding[5d2c]::all::ISO_8859_14), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _42 = &(*_43);                   // scope 0 at src/all.rs:109:9: 109:20
        _41 = move _42 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:109:9: 109:20
        _46 = const ISO_8859_15;         // scope 0 at src/all.rs:110:9: 110:20
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_15, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:110:9: 110:20
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1261 ~ encoding[5d2c]::all::ISO_8859_15), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _45 = &(*_46);                   // scope 0 at src/all.rs:110:9: 110:20
        _44 = move _45 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:110:9: 110:20
        _49 = const ISO_8859_16;         // scope 0 at src/all.rs:111:9: 111:20
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_16, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:111:9: 111:20
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1262 ~ encoding[5d2c]::all::ISO_8859_16), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _48 = &(*_49);                   // scope 0 at src/all.rs:111:9: 111:20
        _47 = move _48 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:111:9: 111:20
        _52 = const KOI8_R;              // scope 0 at src/all.rs:112:9: 112:15
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_R, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:112:9: 112:15
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1263 ~ encoding[5d2c]::all::KOI8_R), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _51 = &(*_52);                   // scope 0 at src/all.rs:112:9: 112:15
        _50 = move _51 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:112:9: 112:15
        _55 = const KOI8_U;              // scope 0 at src/all.rs:113:9: 113:15
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_U, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:113:9: 113:15
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1264 ~ encoding[5d2c]::all::KOI8_U), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _54 = &(*_55);                   // scope 0 at src/all.rs:113:9: 113:15
        _53 = move _54 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:113:9: 113:15
        _58 = const MAC_ROMAN;           // scope 0 at src/all.rs:114:9: 114:18
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_ROMAN, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:114:9: 114:18
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1265 ~ encoding[5d2c]::all::MAC_ROMAN), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _57 = &(*_58);                   // scope 0 at src/all.rs:114:9: 114:18
        _56 = move _57 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:114:9: 114:18
        _61 = const WINDOWS_874;         // scope 0 at src/all.rs:115:9: 115:20
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_874, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:115:9: 115:20
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1266 ~ encoding[5d2c]::all::WINDOWS_874), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _60 = &(*_61);                   // scope 0 at src/all.rs:115:9: 115:20
        _59 = move _60 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:115:9: 115:20
        _64 = const WINDOWS_1250;        // scope 0 at src/all.rs:116:9: 116:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1250, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:116:9: 116:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1267 ~ encoding[5d2c]::all::WINDOWS_1250), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _63 = &(*_64);                   // scope 0 at src/all.rs:116:9: 116:21
        _62 = move _63 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:116:9: 116:21
        _67 = const WINDOWS_1251;        // scope 0 at src/all.rs:117:9: 117:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1251, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:117:9: 117:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1268 ~ encoding[5d2c]::all::WINDOWS_1251), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _66 = &(*_67);                   // scope 0 at src/all.rs:117:9: 117:21
        _65 = move _66 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:117:9: 117:21
        _70 = const WINDOWS_1252;        // scope 0 at src/all.rs:118:9: 118:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1252, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:118:9: 118:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1269 ~ encoding[5d2c]::all::WINDOWS_1252), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _69 = &(*_70);                   // scope 0 at src/all.rs:118:9: 118:21
        _68 = move _69 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:118:9: 118:21
        _73 = const WINDOWS_1253;        // scope 0 at src/all.rs:119:9: 119:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1253, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:119:9: 119:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1270 ~ encoding[5d2c]::all::WINDOWS_1253), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _72 = &(*_73);                   // scope 0 at src/all.rs:119:9: 119:21
        _71 = move _72 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:119:9: 119:21
        _76 = const WINDOWS_1254;        // scope 0 at src/all.rs:120:9: 120:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1254, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:120:9: 120:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1271 ~ encoding[5d2c]::all::WINDOWS_1254), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _75 = &(*_76);                   // scope 0 at src/all.rs:120:9: 120:21
        _74 = move _75 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:120:9: 120:21
        _79 = const WINDOWS_1255;        // scope 0 at src/all.rs:121:9: 121:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1255, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:121:9: 121:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1272 ~ encoding[5d2c]::all::WINDOWS_1255), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _78 = &(*_79);                   // scope 0 at src/all.rs:121:9: 121:21
        _77 = move _78 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:121:9: 121:21
        _82 = const WINDOWS_1256;        // scope 0 at src/all.rs:122:9: 122:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1256, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:122:9: 122:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1273 ~ encoding[5d2c]::all::WINDOWS_1256), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _81 = &(*_82);                   // scope 0 at src/all.rs:122:9: 122:21
        _80 = move _81 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:122:9: 122:21
        _85 = const WINDOWS_1257;        // scope 0 at src/all.rs:123:9: 123:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1257, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:123:9: 123:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1274 ~ encoding[5d2c]::all::WINDOWS_1257), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _84 = &(*_85);                   // scope 0 at src/all.rs:123:9: 123:21
        _83 = move _84 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:123:9: 123:21
        _88 = const WINDOWS_1258;        // scope 0 at src/all.rs:124:9: 124:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1258, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:124:9: 124:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1275 ~ encoding[5d2c]::all::WINDOWS_1258), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _87 = &(*_88);                   // scope 0 at src/all.rs:124:9: 124:21
        _86 = move _87 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:124:9: 124:21
        _91 = const MAC_CYRILLIC;        // scope 0 at src/all.rs:125:9: 125:21
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_CYRILLIC, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:125:9: 125:21
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1276 ~ encoding[5d2c]::all::MAC_CYRILLIC), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _90 = &(*_91);                   // scope 0 at src/all.rs:125:9: 125:21
        _89 = move _90 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:125:9: 125:21
        _94 = const UTF_8;               // scope 0 at src/all.rs:126:9: 126:14
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(UTF_8, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:126:9: 126:14
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1277 ~ encoding[5d2c]::all::UTF_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _93 = &(*_94);                   // scope 0 at src/all.rs:126:9: 126:14
        _92 = move _93 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:126:9: 126:14
        _97 = const UTF_16LE;            // scope 0 at src/all.rs:127:9: 127:17
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16LEEncoding
                                         // + val: Unevaluated(UTF_16LE, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:127:9: 127:17
                                         // + literal: Const { ty: &codec::utf_16::UTF16LEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1278 ~ encoding[5d2c]::all::UTF_16LE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _96 = &(*_97);                   // scope 0 at src/all.rs:127:9: 127:17
        _95 = move _96 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:127:9: 127:17
        _100 = const UTF_16BE;           // scope 0 at src/all.rs:128:9: 128:17
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16BEEncoding
                                         // + val: Unevaluated(UTF_16BE, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:128:9: 128:17
                                         // + literal: Const { ty: &codec::utf_16::UTF16BEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1279 ~ encoding[5d2c]::all::UTF_16BE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _99 = &(*_100);                  // scope 0 at src/all.rs:128:9: 128:17
        _98 = move _99 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:128:9: 128:17
        _103 = const WINDOWS_949;        // scope 0 at src/all.rs:129:9: 129:20
                                         // ty::Const
                                         // + ty: &codec::korean::Windows949Encoding
                                         // + val: Unevaluated(WINDOWS_949, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:129:9: 129:20
                                         // + literal: Const { ty: &codec::korean::Windows949Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1280 ~ encoding[5d2c]::all::WINDOWS_949), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _102 = &(*_103);                 // scope 0 at src/all.rs:129:9: 129:20
        _101 = move _102 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:129:9: 129:20
        _106 = const EUC_JP;             // scope 0 at src/all.rs:130:9: 130:15
                                         // ty::Const
                                         // + ty: &codec::japanese::EUCJPEncoding
                                         // + val: Unevaluated(EUC_JP, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:130:9: 130:15
                                         // + literal: Const { ty: &codec::japanese::EUCJPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1281 ~ encoding[5d2c]::all::EUC_JP), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _105 = &(*_106);                 // scope 0 at src/all.rs:130:9: 130:15
        _104 = move _105 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:130:9: 130:15
        _109 = const WINDOWS_31J;        // scope 0 at src/all.rs:131:9: 131:20
                                         // ty::Const
                                         // + ty: &codec::japanese::Windows31JEncoding
                                         // + val: Unevaluated(WINDOWS_31J, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:131:9: 131:20
                                         // + literal: Const { ty: &codec::japanese::Windows31JEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1282 ~ encoding[5d2c]::all::WINDOWS_31J), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _108 = &(*_109);                 // scope 0 at src/all.rs:131:9: 131:20
        _107 = move _108 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:131:9: 131:20
        _112 = const ISO_2022_JP;        // scope 0 at src/all.rs:132:9: 132:20
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPEncoding
                                         // + val: Unevaluated(ISO_2022_JP, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:132:9: 132:20
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1283 ~ encoding[5d2c]::all::ISO_2022_JP), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _111 = &(*_112);                 // scope 0 at src/all.rs:132:9: 132:20
        _110 = move _111 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:132:9: 132:20
        _115 = const GBK;                // scope 0 at src/all.rs:133:9: 133:12
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GBKEncoding
                                         // + val: Unevaluated(GBK, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:133:9: 133:12
                                         // + literal: Const { ty: &codec::simpchinese::GBKEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1284 ~ encoding[5d2c]::all::GBK), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _114 = &(*_115);                 // scope 0 at src/all.rs:133:9: 133:12
        _113 = move _114 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:133:9: 133:12
        _118 = const GB18030;            // scope 0 at src/all.rs:134:9: 134:16
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GB18030Encoding
                                         // + val: Unevaluated(GB18030, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:134:9: 134:16
                                         // + literal: Const { ty: &codec::simpchinese::GB18030Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1285 ~ encoding[5d2c]::all::GB18030), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _117 = &(*_118);                 // scope 0 at src/all.rs:134:9: 134:16
        _116 = move _117 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:134:9: 134:16
        _121 = const HZ;                 // scope 0 at src/all.rs:135:9: 135:11
                                         // ty::Const
                                         // + ty: &codec::simpchinese::HZEncoding
                                         // + val: Unevaluated(HZ, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:135:9: 135:11
                                         // + literal: Const { ty: &codec::simpchinese::HZEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1286 ~ encoding[5d2c]::all::HZ), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _120 = &(*_121);                 // scope 0 at src/all.rs:135:9: 135:11
        _119 = move _120 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:135:9: 135:11
        _124 = const BIG5_2003;          // scope 0 at src/all.rs:136:9: 136:18
                                         // ty::Const
                                         // + ty: &codec::tradchinese::BigFive2003Encoding
                                         // + val: Unevaluated(BIG5_2003, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:136:9: 136:18
                                         // + literal: Const { ty: &codec::tradchinese::BigFive2003Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1287 ~ encoding[5d2c]::all::BIG5_2003), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _123 = &(*_124);                 // scope 0 at src/all.rs:136:9: 136:18
        _122 = move _123 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:136:9: 136:18
        _127 = const X_USER_DEFINED;     // scope 0 at src/all.rs:137:9: 137:31
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(X_USER_DEFINED, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:137:9: 137:31
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1288 ~ encoding[5d2c]::all::whatwg::X_USER_DEFINED), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _126 = &(*_127);                 // scope 0 at src/all.rs:137:9: 137:31
        _125 = move _126 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:137:9: 137:31
        _130 = const ISO_8859_8_I;       // scope 0 at src/all.rs:138:9: 138:29
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8_I, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:138:9: 138:29
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1289 ~ encoding[5d2c]::all::whatwg::ISO_8859_8_I), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _129 = &(*_130);                 // scope 0 at src/all.rs:138:9: 138:29
        _128 = move _129 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:138:9: 138:29
        _133 = const REPLACEMENT;        // scope 0 at src/all.rs:139:9: 139:28
                                         // ty::Const
                                         // + ty: &codec::whatwg::EncoderOnlyUTF8Encoding
                                         // + val: Unevaluated(REPLACEMENT, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:139:9: 139:28
                                         // + literal: Const { ty: &codec::whatwg::EncoderOnlyUTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1290 ~ encoding[5d2c]::all::whatwg::REPLACEMENT), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _132 = &(*_133);                 // scope 0 at src/all.rs:139:9: 139:28
        _131 = move _132 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/all.rs:139:9: 139:28
        _1 = [move _2, move _5, move _8, move _11, move _14, move _17, move _20, move _23, move _26, move _29, move _32, move _35, move _38, move _41, move _44, move _47, move _50, move _53, move _56, move _59, move _62, move _65, move _68, move _71, move _74, move _77, move _80, move _83, move _86, move _89, move _92, move _95, move _98, move _101, move _104, move _107, move _110, move _113, move _116, move _119, move _122, move _125, move _128, move _131]; // scope 0 at src/all.rs:95:48: 140:6
        _0 = &_1;                        // scope 0 at src/all.rs:95:47: 140:6
        return;                          // scope 0 at src/all.rs:95:47: 140:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:29:10: 29:15>::clone(_1: &EUCJPEncoding) -> EUCJPEncoding {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:29:10: 29:15
    let mut _0: codec::japanese::EUCJPEncoding; // return place in scope 0 at src/codec/japanese.rs:29:10: 29:15

    bb0: {
        return;                          // scope 0 at src/codec/japanese.rs:29:15: 29:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:122:1: 258:2>::raw_feed(_1: &mut UTF16Decoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: F) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:127:20: 127:29
    debug input => _2;                   // in scope 0 at src/codec/utf_16.rs:127:31: 127:36
    debug output => _3;                  // in scope 0 at src/codec/utf_16.rs:127:45: 127:51
    debug concat_two_bytes => _4;        // in scope 0 at src/codec/utf_16.rs:128:20: 128:36
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_16.rs:128:44: 128:71
    let _5: ();                          // in scope 0 at src/codec/utf_16.rs:130:9: 130:44
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:130:9: 130:15
    let mut _7: usize;                   // in scope 0 at src/codec/utf_16.rs:130:28: 130:43
    let mut _8: usize;                   // in scope 0 at src/codec/utf_16.rs:130:28: 130:39
    let mut _9: &[u8];                   // in scope 0 at src/codec/utf_16.rs:130:28: 130:33
    let mut _10: usize;                  // in scope 0 at src/codec/utf_16.rs:132:13: 132:18
    let mut _13: &[u8];                  // in scope 0 at src/codec/utf_16.rs:134:19: 134:24
    let mut _14: bool;                   // in scope 0 at src/codec/utf_16.rs:136:12: 136:20
    let mut _15: usize;                  // in scope 0 at src/codec/utf_16.rs:136:12: 136:13
    let mut _16: usize;                  // in scope 0 at src/codec/utf_16.rs:136:17: 136:20
    let mut _17: usize;                  // in scope 0 at src/codec/utf_16.rs:136:31: 136:40
    let mut _18: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:136:42: 136:46
    let mut _19: u16;                    // in scope 0 at src/codec/utf_16.rs:138:12: 138:25
    let mut _21: &F;                     // in scope 0 at src/codec/utf_16.rs:139:22: 139:38
    let mut _22: (u16, u8);              // in scope 0 at src/codec/utf_16.rs:139:22: 139:63
    let mut _23: u16;                    // in scope 0 at src/codec/utf_16.rs:139:39: 139:52
    let mut _24: u8;                     // in scope 0 at src/codec/utf_16.rs:139:54: 139:62
    let _25: usize;                      // in scope 0 at src/codec/utf_16.rs:139:60: 139:61
    let mut _26: usize;                  // in scope 0 at src/codec/utf_16.rs:139:54: 139:62
    let mut _27: bool;                   // in scope 0 at src/codec/utf_16.rs:139:54: 139:62
    let mut _28: u16;                    // in scope 0 at src/codec/utf_16.rs:142:16: 142:34
    let mut _30: bool;                   // in scope 0 at src/codec/utf_16.rs:146:21: 146:36
    let mut _31: bool;                   // in scope 0 at src/codec/utf_16.rs:146:21: 146:36
    let mut _33: u32;                    // in scope 0 at src/codec/utf_16.rs:147:34: 147:65
    let mut _34: u32;                    // in scope 0 at src/codec/utf_16.rs:147:35: 147:58
    let mut _35: u32;                    // in scope 0 at src/codec/utf_16.rs:147:36: 147:48
    let mut _36: u16;                    // in scope 0 at src/codec/utf_16.rs:147:36: 147:41
    let mut _37: u32;                    // in scope 0 at src/codec/utf_16.rs:147:68: 147:88
    let mut _38: u32;                    // in scope 0 at src/codec/utf_16.rs:147:69: 147:78
    let mut _39: u16;                    // in scope 0 at src/codec/utf_16.rs:147:69: 147:71
    let _40: ();                         // in scope 0 at src/codec/utf_16.rs:148:25: 148:65
    let mut _41: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:148:25: 148:31
    let mut _42: char;                   // in scope 0 at src/codec/utf_16.rs:148:43: 148:64
    let mut _43: u32;                    // in scope 0 at src/codec/utf_16.rs:148:51: 148:63
    let mut _44: u32;                    // in scope 0 at src/codec/utf_16.rs:148:51: 148:53
    let mut _45: usize;                  // in scope 0 at src/codec/utf_16.rs:149:37: 149:38
    let mut _46: usize;                  // in scope 0 at src/codec/utf_16.rs:152:33: 152:42
    let mut _47: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:152:44: 154:27
    let mut _48: encoding_types::CodecError; // in scope 0 at src/codec/utf_16.rs:152:49: 154:26
    let mut _49: isize;                  // in scope 0 at src/codec/utf_16.rs:153:35: 153:49
    let mut _50: isize;                  // in scope 0 at src/codec/utf_16.rs:153:35: 153:45
    let mut _51: usize;                  // in scope 0 at src/codec/utf_16.rs:153:35: 153:36
    let mut _52: std::borrow::Cow<str>;  // in scope 0 at src/codec/utf_16.rs:153:58: 153:83
    let mut _53: &str;                   // in scope 0 at src/codec/utf_16.rs:153:58: 153:76
    let _54: &str;                       // in scope 0 at src/codec/utf_16.rs:153:58: 153:76
    let mut _55: bool;                   // in scope 0 at src/codec/utf_16.rs:163:21: 163:36
    let mut _56: bool;                   // in scope 0 at src/codec/utf_16.rs:163:21: 163:36
    let mut _57: bool;                   // in scope 0 at src/codec/utf_16.rs:159:21: 159:36
    let mut _58: bool;                   // in scope 0 at src/codec/utf_16.rs:159:21: 159:36
    let mut _59: u16;                    // in scope 0 at src/codec/utf_16.rs:160:46: 160:48
    let mut _60: usize;                  // in scope 0 at src/codec/utf_16.rs:164:33: 164:42
    let mut _61: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:164:44: 166:27
    let mut _62: encoding_types::CodecError; // in scope 0 at src/codec/utf_16.rs:164:49: 166:26
    let mut _63: isize;                  // in scope 0 at src/codec/utf_16.rs:165:35: 165:45
    let mut _64: usize;                  // in scope 0 at src/codec/utf_16.rs:165:35: 165:36
    let mut _65: std::borrow::Cow<str>;  // in scope 0 at src/codec/utf_16.rs:165:54: 165:79
    let mut _66: &str;                   // in scope 0 at src/codec/utf_16.rs:165:54: 165:72
    let _67: &str;                       // in scope 0 at src/codec/utf_16.rs:165:54: 165:72
    let _68: ();                         // in scope 0 at src/codec/utf_16.rs:169:25: 169:62
    let mut _69: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:169:25: 169:31
    let mut _70: char;                   // in scope 0 at src/codec/utf_16.rs:169:43: 169:61
    let mut _71: u32;                    // in scope 0 at src/codec/utf_16.rs:169:51: 169:60
    let mut _72: u16;                    // in scope 0 at src/codec/utf_16.rs:169:51: 169:53
    let mut _73: usize;                  // in scope 0 at src/codec/utf_16.rs:170:37: 170:38
    let mut _74: bool;                   // in scope 0 at src/codec/utf_16.rs:174:16: 174:24
    let mut _75: usize;                  // in scope 0 at src/codec/utf_16.rs:174:16: 174:17
    let mut _76: usize;                  // in scope 0 at src/codec/utf_16.rs:174:21: 174:24
    let mut _77: usize;                  // in scope 0 at src/codec/utf_16.rs:174:35: 174:44
    let mut _78: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:174:46: 174:50
    let mut _79: u16;                    // in scope 0 at src/codec/utf_16.rs:177:12: 177:30
    let mut _80: bool;                   // in scope 0 at src/codec/utf_16.rs:179:16: 179:24
    let mut _81: usize;                  // in scope 0 at src/codec/utf_16.rs:179:16: 179:17
    let mut _82: usize;                  // in scope 0 at src/codec/utf_16.rs:179:21: 179:24
    let mut _83: u8;                     // in scope 0 at src/codec/utf_16.rs:180:33: 180:43
    let _84: usize;                      // in scope 0 at src/codec/utf_16.rs:180:39: 180:42
    let mut _85: usize;                  // in scope 0 at src/codec/utf_16.rs:180:39: 180:40
    let mut _86: usize;                  // in scope 0 at src/codec/utf_16.rs:180:33: 180:43
    let mut _87: bool;                   // in scope 0 at src/codec/utf_16.rs:180:33: 180:43
    let mut _88: usize;                  // in scope 0 at src/codec/utf_16.rs:181:25: 181:34
    let mut _89: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:181:36: 181:40
    let mut _92: &F;                     // in scope 0 at src/codec/utf_16.rs:184:22: 184:38
    let mut _93: (u16, u8);              // in scope 0 at src/codec/utf_16.rs:184:22: 184:67
    let mut _94: u16;                    // in scope 0 at src/codec/utf_16.rs:184:39: 184:56
    let mut _95: u8;                     // in scope 0 at src/codec/utf_16.rs:184:39: 184:49
    let _96: usize;                      // in scope 0 at src/codec/utf_16.rs:184:45: 184:48
    let mut _97: usize;                  // in scope 0 at src/codec/utf_16.rs:184:45: 184:46
    let mut _98: usize;                  // in scope 0 at src/codec/utf_16.rs:184:39: 184:49
    let mut _99: bool;                   // in scope 0 at src/codec/utf_16.rs:184:39: 184:49
    let mut _100: u8;                    // in scope 0 at src/codec/utf_16.rs:184:58: 184:66
    let _101: usize;                     // in scope 0 at src/codec/utf_16.rs:184:64: 184:65
    let mut _102: usize;                 // in scope 0 at src/codec/utf_16.rs:184:58: 184:66
    let mut _103: bool;                  // in scope 0 at src/codec/utf_16.rs:184:58: 184:66
    let mut _104: bool;                  // in scope 0 at src/codec/utf_16.rs:187:17: 187:32
    let mut _105: bool;                  // in scope 0 at src/codec/utf_16.rs:187:17: 187:32
    let mut _107: u32;                   // in scope 0 at src/codec/utf_16.rs:188:30: 188:61
    let mut _108: u32;                   // in scope 0 at src/codec/utf_16.rs:188:31: 188:54
    let mut _109: u32;                   // in scope 0 at src/codec/utf_16.rs:188:32: 188:44
    let mut _110: u16;                   // in scope 0 at src/codec/utf_16.rs:188:32: 188:37
    let mut _111: u32;                   // in scope 0 at src/codec/utf_16.rs:188:64: 188:84
    let mut _112: u32;                   // in scope 0 at src/codec/utf_16.rs:188:65: 188:74
    let mut _113: u16;                   // in scope 0 at src/codec/utf_16.rs:188:65: 188:67
    let _114: ();                        // in scope 0 at src/codec/utf_16.rs:189:21: 189:61
    let mut _115: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:189:21: 189:27
    let mut _116: char;                  // in scope 0 at src/codec/utf_16.rs:189:39: 189:60
    let mut _117: u32;                   // in scope 0 at src/codec/utf_16.rs:189:47: 189:59
    let mut _118: u32;                   // in scope 0 at src/codec/utf_16.rs:189:47: 189:49
    let mut _119: usize;                 // in scope 0 at src/codec/utf_16.rs:194:29: 194:38
    let mut _120: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:194:40: 196:23
    let mut _121: encoding_types::CodecError; // in scope 0 at src/codec/utf_16.rs:194:45: 196:22
    let mut _122: isize;                 // in scope 0 at src/codec/utf_16.rs:195:31: 195:45
    let mut _123: isize;                 // in scope 0 at src/codec/utf_16.rs:195:31: 195:41
    let mut _124: usize;                 // in scope 0 at src/codec/utf_16.rs:195:31: 195:32
    let mut _125: std::borrow::Cow<str>; // in scope 0 at src/codec/utf_16.rs:195:54: 195:79
    let mut _126: &str;                  // in scope 0 at src/codec/utf_16.rs:195:54: 195:72
    let _127: &str;                      // in scope 0 at src/codec/utf_16.rs:195:54: 195:72
    let mut _128: usize;                 // in scope 0 at src/codec/utf_16.rs:203:21: 203:22
    let mut _129: bool;                  // in scope 0 at src/codec/utf_16.rs:204:15: 204:22
    let mut _130: usize;                 // in scope 0 at src/codec/utf_16.rs:204:15: 204:16
    let mut _131: usize;                 // in scope 0 at src/codec/utf_16.rs:204:19: 204:22
    let mut _132: bool;                  // in scope 0 at src/codec/utf_16.rs:206:16: 206:24
    let mut _133: usize;                 // in scope 0 at src/codec/utf_16.rs:206:16: 206:17
    let mut _134: usize;                 // in scope 0 at src/codec/utf_16.rs:206:21: 206:24
    let mut _135: u8;                    // in scope 0 at src/codec/utf_16.rs:207:33: 207:43
    let _136: usize;                     // in scope 0 at src/codec/utf_16.rs:207:39: 207:42
    let mut _137: usize;                 // in scope 0 at src/codec/utf_16.rs:207:39: 207:40
    let mut _138: usize;                 // in scope 0 at src/codec/utf_16.rs:207:33: 207:43
    let mut _139: bool;                  // in scope 0 at src/codec/utf_16.rs:207:33: 207:43
    let mut _141: &F;                    // in scope 0 at src/codec/utf_16.rs:210:22: 210:38
    let mut _142: (u16, u8);             // in scope 0 at src/codec/utf_16.rs:210:22: 210:67
    let mut _143: u16;                   // in scope 0 at src/codec/utf_16.rs:210:39: 210:56
    let mut _144: u8;                    // in scope 0 at src/codec/utf_16.rs:210:39: 210:49
    let _145: usize;                     // in scope 0 at src/codec/utf_16.rs:210:45: 210:48
    let mut _146: usize;                 // in scope 0 at src/codec/utf_16.rs:210:45: 210:46
    let mut _147: usize;                 // in scope 0 at src/codec/utf_16.rs:210:39: 210:49
    let mut _148: bool;                  // in scope 0 at src/codec/utf_16.rs:210:39: 210:49
    let mut _149: u8;                    // in scope 0 at src/codec/utf_16.rs:210:58: 210:66
    let _150: usize;                     // in scope 0 at src/codec/utf_16.rs:210:64: 210:65
    let mut _151: usize;                 // in scope 0 at src/codec/utf_16.rs:210:58: 210:66
    let mut _152: bool;                  // in scope 0 at src/codec/utf_16.rs:210:58: 210:66
    let mut _153: bool;                  // in scope 0 at src/codec/utf_16.rs:232:17: 232:32
    let mut _154: bool;                  // in scope 0 at src/codec/utf_16.rs:232:17: 232:32
    let mut _155: bool;                  // in scope 0 at src/codec/utf_16.rs:212:17: 212:32
    let mut _156: bool;                  // in scope 0 at src/codec/utf_16.rs:212:17: 212:32
    let mut _157: bool;                  // in scope 0 at src/codec/utf_16.rs:214:24: 214:32
    let mut _158: usize;                 // in scope 0 at src/codec/utf_16.rs:214:24: 214:25
    let mut _159: usize;                 // in scope 0 at src/codec/utf_16.rs:214:29: 214:32
    let mut _160: u16;                   // in scope 0 at src/codec/utf_16.rs:215:46: 215:48
    let mut _161: bool;                  // in scope 0 at src/codec/utf_16.rs:216:28: 216:37
    let mut _162: usize;                 // in scope 0 at src/codec/utf_16.rs:216:28: 216:31
    let mut _163: usize;                 // in scope 0 at src/codec/utf_16.rs:216:28: 216:29
    let mut _164: usize;                 // in scope 0 at src/codec/utf_16.rs:216:34: 216:37
    let mut _165: u8;                    // in scope 0 at src/codec/utf_16.rs:216:56: 216:66
    let _166: usize;                     // in scope 0 at src/codec/utf_16.rs:216:62: 216:65
    let mut _167: usize;                 // in scope 0 at src/codec/utf_16.rs:216:62: 216:63
    let mut _168: usize;                 // in scope 0 at src/codec/utf_16.rs:216:56: 216:66
    let mut _169: bool;                  // in scope 0 at src/codec/utf_16.rs:216:56: 216:66
    let mut _171: &F;                    // in scope 0 at src/codec/utf_16.rs:219:31: 219:47
    let mut _172: (u16, u8);             // in scope 0 at src/codec/utf_16.rs:219:31: 219:76
    let mut _173: u16;                   // in scope 0 at src/codec/utf_16.rs:219:48: 219:65
    let mut _174: u8;                    // in scope 0 at src/codec/utf_16.rs:219:48: 219:58
    let _175: usize;                     // in scope 0 at src/codec/utf_16.rs:219:54: 219:57
    let mut _176: usize;                 // in scope 0 at src/codec/utf_16.rs:219:54: 219:55
    let mut _177: usize;                 // in scope 0 at src/codec/utf_16.rs:219:48: 219:58
    let mut _178: bool;                  // in scope 0 at src/codec/utf_16.rs:219:48: 219:58
    let mut _179: u8;                    // in scope 0 at src/codec/utf_16.rs:219:67: 219:75
    let _180: usize;                     // in scope 0 at src/codec/utf_16.rs:219:73: 219:74
    let mut _181: usize;                 // in scope 0 at src/codec/utf_16.rs:219:67: 219:75
    let mut _182: bool;                  // in scope 0 at src/codec/utf_16.rs:219:67: 219:75
    let mut _183: bool;                  // in scope 0 at src/codec/utf_16.rs:221:25: 221:40
    let mut _184: bool;                  // in scope 0 at src/codec/utf_16.rs:221:25: 221:40
    let mut _186: u32;                   // in scope 0 at src/codec/utf_16.rs:222:38: 222:66
    let mut _187: u32;                   // in scope 0 at src/codec/utf_16.rs:222:39: 222:59
    let mut _188: u32;                   // in scope 0 at src/codec/utf_16.rs:222:40: 222:49
    let mut _189: u16;                   // in scope 0 at src/codec/utf_16.rs:222:40: 222:42
    let mut _190: u32;                   // in scope 0 at src/codec/utf_16.rs:222:69: 222:90
    let mut _191: u32;                   // in scope 0 at src/codec/utf_16.rs:222:70: 222:80
    let mut _192: u16;                   // in scope 0 at src/codec/utf_16.rs:222:70: 222:73
    let _193: ();                        // in scope 0 at src/codec/utf_16.rs:223:29: 223:69
    let mut _194: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:223:29: 223:35
    let mut _195: char;                  // in scope 0 at src/codec/utf_16.rs:223:47: 223:68
    let mut _196: u32;                   // in scope 0 at src/codec/utf_16.rs:223:55: 223:67
    let mut _197: u32;                   // in scope 0 at src/codec/utf_16.rs:223:55: 223:57
    let mut _198: usize;                 // in scope 0 at src/codec/utf_16.rs:226:37: 226:46
    let mut _199: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:226:48: 228:31
    let mut _200: encoding_types::CodecError; // in scope 0 at src/codec/utf_16.rs:226:53: 228:30
    let mut _201: isize;                 // in scope 0 at src/codec/utf_16.rs:227:39: 227:53
    let mut _202: isize;                 // in scope 0 at src/codec/utf_16.rs:227:39: 227:49
    let mut _203: usize;                 // in scope 0 at src/codec/utf_16.rs:227:39: 227:40
    let mut _204: std::borrow::Cow<str>; // in scope 0 at src/codec/utf_16.rs:227:62: 227:87
    let mut _205: &str;                  // in scope 0 at src/codec/utf_16.rs:227:62: 227:80
    let _206: &str;                      // in scope 0 at src/codec/utf_16.rs:227:62: 227:80
    let mut _207: usize;                 // in scope 0 at src/codec/utf_16.rs:233:29: 233:38
    let mut _208: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:233:40: 235:23
    let mut _209: encoding_types::CodecError; // in scope 0 at src/codec/utf_16.rs:233:45: 235:22
    let mut _210: isize;                 // in scope 0 at src/codec/utf_16.rs:234:31: 234:45
    let mut _211: isize;                 // in scope 0 at src/codec/utf_16.rs:234:31: 234:41
    let mut _212: usize;                 // in scope 0 at src/codec/utf_16.rs:234:31: 234:32
    let mut _213: std::borrow::Cow<str>; // in scope 0 at src/codec/utf_16.rs:234:54: 234:79
    let mut _214: &str;                  // in scope 0 at src/codec/utf_16.rs:234:54: 234:72
    let _215: &str;                      // in scope 0 at src/codec/utf_16.rs:234:54: 234:72
    let _216: ();                        // in scope 0 at src/codec/utf_16.rs:238:21: 238:58
    let mut _217: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:238:21: 238:27
    let mut _218: char;                  // in scope 0 at src/codec/utf_16.rs:238:39: 238:57
    let mut _219: u32;                   // in scope 0 at src/codec/utf_16.rs:238:47: 238:56
    let mut _220: u16;                   // in scope 0 at src/codec/utf_16.rs:238:47: 238:49
    let mut _221: usize;                 // in scope 0 at src/codec/utf_16.rs:242:25: 242:26
    let mut _222: usize;                 // in scope 0 at src/codec/utf_16.rs:244:10: 244:19
    let mut _223: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:244:21: 244:25
    scope 1 {
        debug i => _10;                  // in scope 1 at src/codec/utf_16.rs:132:13: 132:18
        let mut _11: usize;              // in scope 1 at src/codec/utf_16.rs:133:13: 133:26
        scope 2 {
            debug processed => _11;      // in scope 2 at src/codec/utf_16.rs:133:13: 133:26
            let _12: usize;              // in scope 2 at src/codec/utf_16.rs:134:13: 134:16
            scope 3 {
                debug len => _12;        // in scope 3 at src/codec/utf_16.rs:134:13: 134:16
                let _20: u16;            // in scope 3 at src/codec/utf_16.rs:139:17: 139:19
                let _90: u16;            // in scope 3 at src/codec/utf_16.rs:183:17: 183:22
                let _140: u16;           // in scope 3 at src/codec/utf_16.rs:210:17: 210:19
                scope 4 {
                    debug ch => _20;     // in scope 4 at src/codec/utf_16.rs:139:17: 139:19
                    let _29: u16;        // in scope 4 at src/codec/utf_16.rs:143:21: 143:26
                    scope 5 {
                        debug upper => _29; // in scope 5 at src/codec/utf_16.rs:143:21: 143:26
                        let _32: u32;    // in scope 5 at src/codec/utf_16.rs:147:29: 147:31
                        scope 6 {
                            debug ch => _32; // in scope 6 at src/codec/utf_16.rs:147:29: 147:31
                        }
                    }
                }
                scope 7 {
                    debug upper => _90;  // in scope 7 at src/codec/utf_16.rs:183:17: 183:22
                    let _91: u16;        // in scope 7 at src/codec/utf_16.rs:184:17: 184:19
                    scope 8 {
                        debug ch => _91; // in scope 8 at src/codec/utf_16.rs:184:17: 184:19
                        let _106: u32;   // in scope 8 at src/codec/utf_16.rs:188:25: 188:27
                        scope 9 {
                            debug ch => _106; // in scope 9 at src/codec/utf_16.rs:188:25: 188:27
                        }
                    }
                }
                scope 10 {
                    debug ch => _140;    // in scope 10 at src/codec/utf_16.rs:210:17: 210:19
                    let _170: u16;       // in scope 10 at src/codec/utf_16.rs:219:25: 219:28
                    scope 11 {
                        debug ch2 => _170; // in scope 11 at src/codec/utf_16.rs:219:25: 219:28
                        let _185: u32;   // in scope 11 at src/codec/utf_16.rs:222:33: 222:35
                        scope 12 {
                            debug ch => _185; // in scope 12 at src/codec/utf_16.rs:222:33: 222:35
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:130:9: 130:44
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:130:9: 130:15
        _6 = &mut (*_3);                 // scope 0 at src/codec/utf_16.rs:130:9: 130:15
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:130:28: 130:43
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:130:28: 130:39
        StorageLive(_9);                 // scope 0 at src/codec/utf_16.rs:130:28: 130:33
        _9 = _2;                         // scope 0 at src/codec/utf_16.rs:130:28: 130:33
        _8 = core::slice::<impl [u8]>::len(move _9) -> [return: bb1, unwind: bb86]; // scope 0 at src/codec/utf_16.rs:130:28: 130:39
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:130:34: 130:37
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_9);                 // scope 0 at src/codec/utf_16.rs:130:38: 130:39
        _7 = Div(move _8, const 2_usize); // scope 0 at src/codec/utf_16.rs:130:28: 130:43
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:130:42: 130:43
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> [return: bb2, unwind: bb86]; // scope 0 at src/codec/utf_16.rs:130:9: 130:44
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:130:16: 130:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:130:43: 130:44
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:130:43: 130:44
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:130:44: 130:45
        StorageLive(_10);                // scope 0 at src/codec/utf_16.rs:132:13: 132:18
        _10 = const 0_usize;             // scope 0 at src/codec/utf_16.rs:132:21: 132:22
        StorageLive(_11);                // scope 1 at src/codec/utf_16.rs:133:13: 133:26
        _11 = const 0_usize;             // scope 1 at src/codec/utf_16.rs:133:29: 133:30
        StorageLive(_12);                // scope 2 at src/codec/utf_16.rs:134:13: 134:16
        StorageLive(_13);                // scope 2 at src/codec/utf_16.rs:134:19: 134:24
        _13 = _2;                        // scope 2 at src/codec/utf_16.rs:134:19: 134:24
        _12 = core::slice::<impl [u8]>::len(move _13) -> [return: bb3, unwind: bb86]; // scope 2 at src/codec/utf_16.rs:134:19: 134:30
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:134:25: 134:28
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_13);                // scope 2 at src/codec/utf_16.rs:134:29: 134:30
        StorageLive(_14);                // scope 3 at src/codec/utf_16.rs:136:12: 136:20
        StorageLive(_15);                // scope 3 at src/codec/utf_16.rs:136:12: 136:13
        _15 = _10;                       // scope 3 at src/codec/utf_16.rs:136:12: 136:13
        StorageLive(_16);                // scope 3 at src/codec/utf_16.rs:136:17: 136:20
        _16 = _12;                       // scope 3 at src/codec/utf_16.rs:136:17: 136:20
        _14 = Ge(move _15, move _16);    // scope 3 at src/codec/utf_16.rs:136:12: 136:20
        StorageDead(_16);                // scope 3 at src/codec/utf_16.rs:136:19: 136:20
        StorageDead(_15);                // scope 3 at src/codec/utf_16.rs:136:19: 136:20
        switchInt(move _14) -> [false: bb5, otherwise: bb4]; // scope 3 at src/codec/utf_16.rs:136:12: 136:20
    }

    bb4: {
        StorageLive(_17);                // scope 3 at src/codec/utf_16.rs:136:31: 136:40
        _17 = _11;                       // scope 3 at src/codec/utf_16.rs:136:31: 136:40
        StorageLive(_18);                // scope 3 at src/codec/utf_16.rs:136:42: 136:46
        discriminant(_18) = 0;           // scope 3 at src/codec/utf_16.rs:136:42: 136:46
        (_0.0: usize) = move _17;        // scope 3 at src/codec/utf_16.rs:136:30: 136:47
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _18; // scope 3 at src/codec/utf_16.rs:136:30: 136:47
        StorageDead(_18);                // scope 3 at src/codec/utf_16.rs:136:46: 136:47
        StorageDead(_17);                // scope 3 at src/codec/utf_16.rs:136:46: 136:47
        StorageDead(_14);                // scope 3 at src/codec/utf_16.rs:136:49: 136:50
        goto -> bb84;                    // scope 3 at no-location
    }

    bb5: {
        StorageDead(_14);                // scope 3 at src/codec/utf_16.rs:136:49: 136:50
        StorageLive(_19);                // scope 3 at src/codec/utf_16.rs:138:12: 138:25
        _19 = ((*_1).0: u16);            // scope 3 at src/codec/utf_16.rs:138:12: 138:25
        switchInt(move _19) -> [u16::MAX: bb7, otherwise: bb6]; // scope 3 at src/codec/utf_16.rs:138:12: 138:35
    }

    bb6: {
        StorageDead(_19);                // scope 3 at src/codec/utf_16.rs:138:12: 138:35
        StorageLive(_20);                // scope 3 at src/codec/utf_16.rs:139:17: 139:19
        StorageLive(_21);                // scope 3 at src/codec/utf_16.rs:139:22: 139:38
        _21 = &_4;                       // scope 3 at src/codec/utf_16.rs:139:22: 139:38
        StorageLive(_22);                // scope 3 at src/codec/utf_16.rs:139:22: 139:63
        StorageLive(_23);                // scope 3 at src/codec/utf_16.rs:139:39: 139:52
        _23 = ((*_1).0: u16);            // scope 3 at src/codec/utf_16.rs:139:39: 139:52
        StorageLive(_24);                // scope 3 at src/codec/utf_16.rs:139:54: 139:62
        StorageLive(_25);                // scope 3 at src/codec/utf_16.rs:139:60: 139:61
        _25 = _10;                       // scope 3 at src/codec/utf_16.rs:139:60: 139:61
        _26 = Len((*_2));                // scope 3 at src/codec/utf_16.rs:139:54: 139:62
        _27 = Lt(_25, _26);              // scope 3 at src/codec/utf_16.rs:139:54: 139:62
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb8, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:139:54: 139:62
    }

    bb7: {
        StorageDead(_19);                // scope 3 at src/codec/utf_16.rs:138:12: 138:35
        goto -> bb30;                    // scope 3 at src/codec/utf_16.rs:138:9: 175:10
    }

    bb8: {
        _24 = (*_2)[_25];                // scope 3 at src/codec/utf_16.rs:139:54: 139:62
        (_22.0: u16) = move _23;         // scope 3 at src/codec/utf_16.rs:139:22: 139:63
        (_22.1: u8) = move _24;          // scope 3 at src/codec/utf_16.rs:139:22: 139:63
        _20 = <F as Fn<(u16, u8)>>::call(move _21, move _22) -> [return: bb9, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:139:22: 139:63
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:139:22: 139:38
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (u16, u8)) -> <F as std::ops::FnOnce<(u16, u8)>>::Output {<F as std::ops::Fn<(u16, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_24);                // scope 3 at src/codec/utf_16.rs:139:62: 139:63
        StorageDead(_23);                // scope 3 at src/codec/utf_16.rs:139:62: 139:63
        StorageDead(_22);                // scope 3 at src/codec/utf_16.rs:139:62: 139:63
        StorageDead(_21);                // scope 3 at src/codec/utf_16.rs:139:62: 139:63
        StorageDead(_25);                // scope 3 at src/codec/utf_16.rs:139:63: 139:64
        _10 = Add(_10, const 1_usize);   // scope 4 at src/codec/utf_16.rs:140:13: 140:19
        ((*_1).0: u16) = const u16::MAX; // scope 4 at src/codec/utf_16.rs:141:13: 141:35
        StorageLive(_28);                // scope 4 at src/codec/utf_16.rs:142:16: 142:34
        _28 = ((*_1).1: u16);            // scope 4 at src/codec/utf_16.rs:142:16: 142:34
        switchInt(move _28) -> [u16::MAX: bb17, otherwise: bb10]; // scope 4 at src/codec/utf_16.rs:142:16: 142:44
    }

    bb10: {
        StorageDead(_28);                // scope 4 at src/codec/utf_16.rs:142:16: 142:44
        StorageLive(_29);                // scope 4 at src/codec/utf_16.rs:143:21: 143:26
        _29 = ((*_1).1: u16);            // scope 4 at src/codec/utf_16.rs:143:29: 143:47
        ((*_1).1: u16) = const u16::MAX; // scope 5 at src/codec/utf_16.rs:144:17: 144:44
        _30 = Le(const 56320_u16, _20);  // scope 5 at src/codec/utf_16.rs:146:21: 146:36
        switchInt(move _30) -> [false: bb12, otherwise: bb11]; // scope 5 at src/codec/utf_16.rs:146:21: 146:36
    }

    bb11: {
        _31 = Le(_20, const 57343_u16);  // scope 5 at src/codec/utf_16.rs:146:21: 146:36
        switchInt(move _31) -> [false: bb12, otherwise: bb13]; // scope 5 at src/codec/utf_16.rs:146:21: 146:36
    }

    bb12: {
        StorageLive(_46);                // scope 5 at src/codec/utf_16.rs:152:33: 152:42
        _46 = _11;                       // scope 5 at src/codec/utf_16.rs:152:33: 152:42
        StorageLive(_47);                // scope 5 at src/codec/utf_16.rs:152:44: 154:27
        StorageLive(_48);                // scope 5 at src/codec/utf_16.rs:152:49: 154:26
        StorageLive(_49);                // scope 5 at src/codec/utf_16.rs:153:35: 153:49
        StorageLive(_50);                // scope 5 at src/codec/utf_16.rs:153:35: 153:45
        StorageLive(_51);                // scope 5 at src/codec/utf_16.rs:153:35: 153:36
        _51 = _10;                       // scope 5 at src/codec/utf_16.rs:153:35: 153:36
        _50 = move _51 as isize (Misc);  // scope 5 at src/codec/utf_16.rs:153:35: 153:45
        StorageDead(_51);                // scope 5 at src/codec/utf_16.rs:153:44: 153:45
        _49 = Sub(move _50, const 2_isize); // scope 5 at src/codec/utf_16.rs:153:35: 153:49
        StorageDead(_50);                // scope 5 at src/codec/utf_16.rs:153:48: 153:49
        StorageLive(_52);                // scope 5 at src/codec/utf_16.rs:153:58: 153:83
        StorageLive(_53);                // scope 5 at src/codec/utf_16.rs:153:58: 153:76
        StorageLive(_54);                // scope 5 at src/codec/utf_16.rs:153:58: 153:76
        _54 = const "invalid sequence";  // scope 5 at src/codec/utf_16.rs:153:58: 153:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:153:58: 153:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _53 = _54;                       // scope 5 at src/codec/utf_16.rs:153:58: 153:76
        _52 = <&str as Into<Cow<str>>>::into(move _53) -> [return: bb16, unwind: bb86]; // scope 5 at src/codec/utf_16.rs:153:58: 153:83
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:153:77: 153:81
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageLive(_32);                // scope 5 at src/codec/utf_16.rs:147:29: 147:31
        StorageLive(_33);                // scope 5 at src/codec/utf_16.rs:147:34: 147:65
        StorageLive(_34);                // scope 5 at src/codec/utf_16.rs:147:35: 147:58
        StorageLive(_35);                // scope 5 at src/codec/utf_16.rs:147:36: 147:48
        StorageLive(_36);                // scope 5 at src/codec/utf_16.rs:147:36: 147:41
        _36 = _29;                       // scope 5 at src/codec/utf_16.rs:147:36: 147:41
        _35 = move _36 as u32 (Misc);    // scope 5 at src/codec/utf_16.rs:147:36: 147:48
        StorageDead(_36);                // scope 5 at src/codec/utf_16.rs:147:47: 147:48
        _34 = Sub(move _35, const 55296_u32); // scope 5 at src/codec/utf_16.rs:147:35: 147:58
        StorageDead(_35);                // scope 5 at src/codec/utf_16.rs:147:57: 147:58
        _33 = Shl(move _34, const 10_i32); // scope 5 at src/codec/utf_16.rs:147:34: 147:65
        StorageDead(_34);                // scope 5 at src/codec/utf_16.rs:147:64: 147:65
        StorageLive(_37);                // scope 5 at src/codec/utf_16.rs:147:68: 147:88
        StorageLive(_38);                // scope 5 at src/codec/utf_16.rs:147:69: 147:78
        StorageLive(_39);                // scope 5 at src/codec/utf_16.rs:147:69: 147:71
        _39 = _20;                       // scope 5 at src/codec/utf_16.rs:147:69: 147:71
        _38 = move _39 as u32 (Misc);    // scope 5 at src/codec/utf_16.rs:147:69: 147:78
        StorageDead(_39);                // scope 5 at src/codec/utf_16.rs:147:77: 147:78
        _37 = Sub(move _38, const 56320_u32); // scope 5 at src/codec/utf_16.rs:147:68: 147:88
        StorageDead(_38);                // scope 5 at src/codec/utf_16.rs:147:87: 147:88
        _32 = Add(move _33, move _37);   // scope 5 at src/codec/utf_16.rs:147:34: 147:88
        StorageDead(_37);                // scope 5 at src/codec/utf_16.rs:147:87: 147:88
        StorageDead(_33);                // scope 5 at src/codec/utf_16.rs:147:87: 147:88
        StorageLive(_40);                // scope 6 at src/codec/utf_16.rs:148:25: 148:65
        StorageLive(_41);                // scope 6 at src/codec/utf_16.rs:148:25: 148:31
        _41 = &mut (*_3);                // scope 6 at src/codec/utf_16.rs:148:25: 148:31
        StorageLive(_42);                // scope 6 at src/codec/utf_16.rs:148:43: 148:64
        StorageLive(_43);                // scope 6 at src/codec/utf_16.rs:148:51: 148:63
        StorageLive(_44);                // scope 6 at src/codec/utf_16.rs:148:51: 148:53
        _44 = _32;                       // scope 6 at src/codec/utf_16.rs:148:51: 148:53
        _43 = Add(move _44, const 65536_u32); // scope 6 at src/codec/utf_16.rs:148:51: 148:63
        StorageDead(_44);                // scope 6 at src/codec/utf_16.rs:148:62: 148:63
        _42 = as_char(move _43) -> [return: bb14, unwind: bb86]; // scope 6 at src/codec/utf_16.rs:148:43: 148:64
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:148:43: 148:50
                                         // + literal: Const { ty: fn(u32) -> char {util::as_char}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_43);                // scope 6 at src/codec/utf_16.rs:148:63: 148:64
        _40 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _41, move _42) -> [return: bb15, unwind: bb86]; // scope 6 at src/codec/utf_16.rs:148:25: 148:65
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:148:32: 148:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_42);                // scope 6 at src/codec/utf_16.rs:148:64: 148:65
        StorageDead(_41);                // scope 6 at src/codec/utf_16.rs:148:64: 148:65
        StorageDead(_40);                // scope 6 at src/codec/utf_16.rs:148:65: 148:66
        StorageLive(_45);                // scope 6 at src/codec/utf_16.rs:149:37: 149:38
        _45 = _10;                       // scope 6 at src/codec/utf_16.rs:149:37: 149:38
        _11 = move _45;                  // scope 6 at src/codec/utf_16.rs:149:25: 149:38
        StorageDead(_45);                // scope 6 at src/codec/utf_16.rs:149:37: 149:38
        StorageDead(_32);                // scope 5 at src/codec/utf_16.rs:150:21: 150:22
        StorageDead(_29);                // scope 4 at src/codec/utf_16.rs:157:13: 157:14
        goto -> bb27;                    // scope 4 at src/codec/utf_16.rs:142:13: 173:14
    }

    bb16: {
        StorageDead(_53);                // scope 5 at src/codec/utf_16.rs:153:82: 153:83
        (_48.0: isize) = move _49;       // scope 5 at src/codec/utf_16.rs:152:49: 154:26
        (_48.1: std::borrow::Cow<str>) = move _52; // scope 5 at src/codec/utf_16.rs:152:49: 154:26
        StorageDead(_52);                // scope 5 at src/codec/utf_16.rs:154:25: 154:26
        StorageDead(_49);                // scope 5 at src/codec/utf_16.rs:154:25: 154:26
        ((_47 as Some).0: encoding_types::CodecError) = move _48; // scope 5 at src/codec/utf_16.rs:152:44: 154:27
        discriminant(_47) = 1;           // scope 5 at src/codec/utf_16.rs:152:44: 154:27
        StorageDead(_48);                // scope 5 at src/codec/utf_16.rs:154:26: 154:27
        (_0.0: usize) = move _46;        // scope 5 at src/codec/utf_16.rs:152:32: 154:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _47; // scope 5 at src/codec/utf_16.rs:152:32: 154:28
        StorageDead(_47);                // scope 5 at src/codec/utf_16.rs:154:27: 154:28
        StorageDead(_46);                // scope 5 at src/codec/utf_16.rs:154:27: 154:28
        StorageDead(_54);                // scope 5 at src/codec/utf_16.rs:154:28: 154:29
        StorageDead(_29);                // scope 4 at src/codec/utf_16.rs:157:13: 157:14
        goto -> bb82;                    // scope 4 at no-location
    }

    bb17: {
        StorageDead(_28);                // scope 4 at src/codec/utf_16.rs:142:16: 142:44
        _57 = Le(const 55296_u16, _20);  // scope 4 at src/codec/utf_16.rs:159:21: 159:36
        switchInt(move _57) -> [false: bb19, otherwise: bb18]; // scope 4 at src/codec/utf_16.rs:159:21: 159:36
    }

    bb18: {
        _58 = Le(_20, const 56319_u16);  // scope 4 at src/codec/utf_16.rs:159:21: 159:36
        switchInt(move _58) -> [false: bb19, otherwise: bb22]; // scope 4 at src/codec/utf_16.rs:159:21: 159:36
    }

    bb19: {
        _55 = Le(const 56320_u16, _20);  // scope 4 at src/codec/utf_16.rs:163:21: 163:36
        switchInt(move _55) -> [false: bb21, otherwise: bb20]; // scope 4 at src/codec/utf_16.rs:163:21: 163:36
    }

    bb20: {
        _56 = Le(_20, const 57343_u16);  // scope 4 at src/codec/utf_16.rs:163:21: 163:36
        switchInt(move _56) -> [false: bb21, otherwise: bb23]; // scope 4 at src/codec/utf_16.rs:163:21: 163:36
    }

    bb21: {
        StorageLive(_68);                // scope 4 at src/codec/utf_16.rs:169:25: 169:62
        StorageLive(_69);                // scope 4 at src/codec/utf_16.rs:169:25: 169:31
        _69 = &mut (*_3);                // scope 4 at src/codec/utf_16.rs:169:25: 169:31
        StorageLive(_70);                // scope 4 at src/codec/utf_16.rs:169:43: 169:61
        StorageLive(_71);                // scope 4 at src/codec/utf_16.rs:169:51: 169:60
        StorageLive(_72);                // scope 4 at src/codec/utf_16.rs:169:51: 169:53
        _72 = _20;                       // scope 4 at src/codec/utf_16.rs:169:51: 169:53
        _71 = move _72 as u32 (Misc);    // scope 4 at src/codec/utf_16.rs:169:51: 169:60
        StorageDead(_72);                // scope 4 at src/codec/utf_16.rs:169:59: 169:60
        _70 = as_char(move _71) -> [return: bb25, unwind: bb86]; // scope 4 at src/codec/utf_16.rs:169:43: 169:61
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:169:43: 169:50
                                         // + literal: Const { ty: fn(u32) -> char {util::as_char}, val: Value(Scalar(<ZST>)) }
    }

    bb22: {
        StorageLive(_59);                // scope 4 at src/codec/utf_16.rs:160:46: 160:48
        _59 = _20;                       // scope 4 at src/codec/utf_16.rs:160:46: 160:48
        ((*_1).1: u16) = move _59;       // scope 4 at src/codec/utf_16.rs:160:25: 160:48
        StorageDead(_59);                // scope 4 at src/codec/utf_16.rs:160:47: 160:48
        goto -> bb27;                    // scope 4 at src/codec/utf_16.rs:159:40: 162:22
    }

    bb23: {
        StorageLive(_60);                // scope 4 at src/codec/utf_16.rs:164:33: 164:42
        _60 = _11;                       // scope 4 at src/codec/utf_16.rs:164:33: 164:42
        StorageLive(_61);                // scope 4 at src/codec/utf_16.rs:164:44: 166:27
        StorageLive(_62);                // scope 4 at src/codec/utf_16.rs:164:49: 166:26
        StorageLive(_63);                // scope 4 at src/codec/utf_16.rs:165:35: 165:45
        StorageLive(_64);                // scope 4 at src/codec/utf_16.rs:165:35: 165:36
        _64 = _10;                       // scope 4 at src/codec/utf_16.rs:165:35: 165:36
        _63 = move _64 as isize (Misc);  // scope 4 at src/codec/utf_16.rs:165:35: 165:45
        StorageDead(_64);                // scope 4 at src/codec/utf_16.rs:165:44: 165:45
        StorageLive(_65);                // scope 4 at src/codec/utf_16.rs:165:54: 165:79
        StorageLive(_66);                // scope 4 at src/codec/utf_16.rs:165:54: 165:72
        StorageLive(_67);                // scope 4 at src/codec/utf_16.rs:165:54: 165:72
        _67 = const "invalid sequence";  // scope 4 at src/codec/utf_16.rs:165:54: 165:72
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:165:54: 165:72
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _66 = _67;                       // scope 4 at src/codec/utf_16.rs:165:54: 165:72
        _65 = <&str as Into<Cow<str>>>::into(move _66) -> [return: bb24, unwind: bb86]; // scope 4 at src/codec/utf_16.rs:165:54: 165:79
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:165:73: 165:77
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_66);                // scope 4 at src/codec/utf_16.rs:165:78: 165:79
        (_62.0: isize) = move _63;       // scope 4 at src/codec/utf_16.rs:164:49: 166:26
        (_62.1: std::borrow::Cow<str>) = move _65; // scope 4 at src/codec/utf_16.rs:164:49: 166:26
        StorageDead(_65);                // scope 4 at src/codec/utf_16.rs:166:25: 166:26
        StorageDead(_63);                // scope 4 at src/codec/utf_16.rs:166:25: 166:26
        ((_61 as Some).0: encoding_types::CodecError) = move _62; // scope 4 at src/codec/utf_16.rs:164:44: 166:27
        discriminant(_61) = 1;           // scope 4 at src/codec/utf_16.rs:164:44: 166:27
        StorageDead(_62);                // scope 4 at src/codec/utf_16.rs:166:26: 166:27
        (_0.0: usize) = move _60;        // scope 4 at src/codec/utf_16.rs:164:32: 166:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _61; // scope 4 at src/codec/utf_16.rs:164:32: 166:28
        StorageDead(_61);                // scope 4 at src/codec/utf_16.rs:166:27: 166:28
        StorageDead(_60);                // scope 4 at src/codec/utf_16.rs:166:27: 166:28
        StorageDead(_67);                // scope 4 at src/codec/utf_16.rs:166:28: 166:29
        goto -> bb82;                    // scope 4 at no-location
    }

    bb25: {
        StorageDead(_71);                // scope 4 at src/codec/utf_16.rs:169:60: 169:61
        _68 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _69, move _70) -> [return: bb26, unwind: bb86]; // scope 4 at src/codec/utf_16.rs:169:25: 169:62
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:169:32: 169:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb26: {
        StorageDead(_70);                // scope 4 at src/codec/utf_16.rs:169:61: 169:62
        StorageDead(_69);                // scope 4 at src/codec/utf_16.rs:169:61: 169:62
        StorageDead(_68);                // scope 4 at src/codec/utf_16.rs:169:62: 169:63
        StorageLive(_73);                // scope 4 at src/codec/utf_16.rs:170:37: 170:38
        _73 = _10;                       // scope 4 at src/codec/utf_16.rs:170:37: 170:38
        _11 = move _73;                  // scope 4 at src/codec/utf_16.rs:170:25: 170:38
        StorageDead(_73);                // scope 4 at src/codec/utf_16.rs:170:37: 170:38
        goto -> bb27;                    // scope 4 at src/codec/utf_16.rs:168:26: 171:22
    }

    bb27: {
        StorageLive(_74);                // scope 4 at src/codec/utf_16.rs:174:16: 174:24
        StorageLive(_75);                // scope 4 at src/codec/utf_16.rs:174:16: 174:17
        _75 = _10;                       // scope 4 at src/codec/utf_16.rs:174:16: 174:17
        StorageLive(_76);                // scope 4 at src/codec/utf_16.rs:174:21: 174:24
        _76 = _12;                       // scope 4 at src/codec/utf_16.rs:174:21: 174:24
        _74 = Ge(move _75, move _76);    // scope 4 at src/codec/utf_16.rs:174:16: 174:24
        StorageDead(_76);                // scope 4 at src/codec/utf_16.rs:174:23: 174:24
        StorageDead(_75);                // scope 4 at src/codec/utf_16.rs:174:23: 174:24
        switchInt(move _74) -> [false: bb29, otherwise: bb28]; // scope 4 at src/codec/utf_16.rs:174:16: 174:24
    }

    bb28: {
        StorageLive(_77);                // scope 4 at src/codec/utf_16.rs:174:35: 174:44
        _77 = _11;                       // scope 4 at src/codec/utf_16.rs:174:35: 174:44
        StorageLive(_78);                // scope 4 at src/codec/utf_16.rs:174:46: 174:50
        discriminant(_78) = 0;           // scope 4 at src/codec/utf_16.rs:174:46: 174:50
        (_0.0: usize) = move _77;        // scope 4 at src/codec/utf_16.rs:174:34: 174:51
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _78; // scope 4 at src/codec/utf_16.rs:174:34: 174:51
        StorageDead(_78);                // scope 4 at src/codec/utf_16.rs:174:50: 174:51
        StorageDead(_77);                // scope 4 at src/codec/utf_16.rs:174:50: 174:51
        StorageDead(_74);                // scope 4 at src/codec/utf_16.rs:174:53: 174:54
        goto -> bb83;                    // scope 4 at no-location
    }

    bb29: {
        StorageDead(_74);                // scope 4 at src/codec/utf_16.rs:174:53: 174:54
        StorageDead(_20);                // scope 3 at src/codec/utf_16.rs:175:9: 175:10
        goto -> bb30;                    // scope 3 at src/codec/utf_16.rs:138:9: 175:10
    }

    bb30: {
        StorageLive(_79);                // scope 3 at src/codec/utf_16.rs:177:12: 177:30
        _79 = ((*_1).1: u16);            // scope 3 at src/codec/utf_16.rs:177:12: 177:30
        switchInt(move _79) -> [u16::MAX: bb44, otherwise: bb31]; // scope 3 at src/codec/utf_16.rs:177:12: 177:40
    }

    bb31: {
        StorageDead(_79);                // scope 3 at src/codec/utf_16.rs:177:12: 177:40
        _10 = Add(_10, const 1_usize);   // scope 3 at src/codec/utf_16.rs:178:13: 178:19
        StorageLive(_80);                // scope 3 at src/codec/utf_16.rs:179:16: 179:24
        StorageLive(_81);                // scope 3 at src/codec/utf_16.rs:179:16: 179:17
        _81 = _10;                       // scope 3 at src/codec/utf_16.rs:179:16: 179:17
        StorageLive(_82);                // scope 3 at src/codec/utf_16.rs:179:21: 179:24
        _82 = _12;                       // scope 3 at src/codec/utf_16.rs:179:21: 179:24
        _80 = Ge(move _81, move _82);    // scope 3 at src/codec/utf_16.rs:179:16: 179:24
        StorageDead(_82);                // scope 3 at src/codec/utf_16.rs:179:23: 179:24
        StorageDead(_81);                // scope 3 at src/codec/utf_16.rs:179:23: 179:24
        switchInt(move _80) -> [false: bb34, otherwise: bb32]; // scope 3 at src/codec/utf_16.rs:179:16: 179:24
    }

    bb32: {
        StorageLive(_83);                // scope 3 at src/codec/utf_16.rs:180:33: 180:43
        StorageLive(_84);                // scope 3 at src/codec/utf_16.rs:180:39: 180:42
        StorageLive(_85);                // scope 3 at src/codec/utf_16.rs:180:39: 180:40
        _85 = _10;                       // scope 3 at src/codec/utf_16.rs:180:39: 180:40
        _84 = Sub(move _85, const 1_usize); // scope 3 at src/codec/utf_16.rs:180:39: 180:42
        StorageDead(_85);                // scope 3 at src/codec/utf_16.rs:180:41: 180:42
        _86 = Len((*_2));                // scope 3 at src/codec/utf_16.rs:180:33: 180:43
        _87 = Lt(_84, _86);              // scope 3 at src/codec/utf_16.rs:180:33: 180:43
        assert(move _87, "index out of bounds: the length is {} but the index is {}", move _86, _84) -> [success: bb33, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:180:33: 180:43
    }

    bb33: {
        _83 = (*_2)[_84];                // scope 3 at src/codec/utf_16.rs:180:33: 180:43
        ((*_1).0: u16) = move _83 as u16 (Misc); // scope 3 at src/codec/utf_16.rs:180:17: 180:50
        StorageDead(_83);                // scope 3 at src/codec/utf_16.rs:180:49: 180:50
        StorageDead(_84);                // scope 3 at src/codec/utf_16.rs:180:50: 180:51
        StorageLive(_88);                // scope 3 at src/codec/utf_16.rs:181:25: 181:34
        _88 = _11;                       // scope 3 at src/codec/utf_16.rs:181:25: 181:34
        StorageLive(_89);                // scope 3 at src/codec/utf_16.rs:181:36: 181:40
        discriminant(_89) = 0;           // scope 3 at src/codec/utf_16.rs:181:36: 181:40
        (_0.0: usize) = move _88;        // scope 3 at src/codec/utf_16.rs:181:24: 181:41
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _89; // scope 3 at src/codec/utf_16.rs:181:24: 181:41
        StorageDead(_89);                // scope 3 at src/codec/utf_16.rs:181:40: 181:41
        StorageDead(_88);                // scope 3 at src/codec/utf_16.rs:181:40: 181:41
        StorageDead(_80);                // scope 3 at src/codec/utf_16.rs:182:13: 182:14
        goto -> bb81;                    // scope 3 at no-location
    }

    bb34: {
        StorageDead(_80);                // scope 3 at src/codec/utf_16.rs:182:13: 182:14
        StorageLive(_90);                // scope 3 at src/codec/utf_16.rs:183:17: 183:22
        _90 = ((*_1).1: u16);            // scope 3 at src/codec/utf_16.rs:183:25: 183:43
        StorageLive(_91);                // scope 7 at src/codec/utf_16.rs:184:17: 184:19
        StorageLive(_92);                // scope 7 at src/codec/utf_16.rs:184:22: 184:38
        _92 = &_4;                       // scope 7 at src/codec/utf_16.rs:184:22: 184:38
        StorageLive(_93);                // scope 7 at src/codec/utf_16.rs:184:22: 184:67
        StorageLive(_94);                // scope 7 at src/codec/utf_16.rs:184:39: 184:56
        StorageLive(_95);                // scope 7 at src/codec/utf_16.rs:184:39: 184:49
        StorageLive(_96);                // scope 7 at src/codec/utf_16.rs:184:45: 184:48
        StorageLive(_97);                // scope 7 at src/codec/utf_16.rs:184:45: 184:46
        _97 = _10;                       // scope 7 at src/codec/utf_16.rs:184:45: 184:46
        _96 = Sub(move _97, const 1_usize); // scope 7 at src/codec/utf_16.rs:184:45: 184:48
        StorageDead(_97);                // scope 7 at src/codec/utf_16.rs:184:47: 184:48
        _98 = Len((*_2));                // scope 7 at src/codec/utf_16.rs:184:39: 184:49
        _99 = Lt(_96, _98);              // scope 7 at src/codec/utf_16.rs:184:39: 184:49
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _96) -> [success: bb35, unwind: bb86]; // scope 7 at src/codec/utf_16.rs:184:39: 184:49
    }

    bb35: {
        _95 = (*_2)[_96];                // scope 7 at src/codec/utf_16.rs:184:39: 184:49
        _94 = move _95 as u16 (Misc);    // scope 7 at src/codec/utf_16.rs:184:39: 184:56
        StorageDead(_95);                // scope 7 at src/codec/utf_16.rs:184:55: 184:56
        StorageLive(_100);               // scope 7 at src/codec/utf_16.rs:184:58: 184:66
        StorageLive(_101);               // scope 7 at src/codec/utf_16.rs:184:64: 184:65
        _101 = _10;                      // scope 7 at src/codec/utf_16.rs:184:64: 184:65
        _102 = Len((*_2));               // scope 7 at src/codec/utf_16.rs:184:58: 184:66
        _103 = Lt(_101, _102);           // scope 7 at src/codec/utf_16.rs:184:58: 184:66
        assert(move _103, "index out of bounds: the length is {} but the index is {}", move _102, _101) -> [success: bb36, unwind: bb86]; // scope 7 at src/codec/utf_16.rs:184:58: 184:66
    }

    bb36: {
        _100 = (*_2)[_101];              // scope 7 at src/codec/utf_16.rs:184:58: 184:66
        (_93.0: u16) = move _94;         // scope 7 at src/codec/utf_16.rs:184:22: 184:67
        (_93.1: u8) = move _100;         // scope 7 at src/codec/utf_16.rs:184:22: 184:67
        _91 = <F as Fn<(u16, u8)>>::call(move _92, move _93) -> [return: bb37, unwind: bb86]; // scope 7 at src/codec/utf_16.rs:184:22: 184:67
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:184:22: 184:38
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (u16, u8)) -> <F as std::ops::FnOnce<(u16, u8)>>::Output {<F as std::ops::Fn<(u16, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb37: {
        StorageDead(_100);               // scope 7 at src/codec/utf_16.rs:184:66: 184:67
        StorageDead(_94);                // scope 7 at src/codec/utf_16.rs:184:66: 184:67
        StorageDead(_93);                // scope 7 at src/codec/utf_16.rs:184:66: 184:67
        StorageDead(_92);                // scope 7 at src/codec/utf_16.rs:184:66: 184:67
        StorageDead(_101);               // scope 7 at src/codec/utf_16.rs:184:67: 184:68
        StorageDead(_96);                // scope 7 at src/codec/utf_16.rs:184:67: 184:68
        _10 = Add(_10, const 1_usize);   // scope 8 at src/codec/utf_16.rs:185:13: 185:19
        _104 = Le(const 56320_u16, _91); // scope 8 at src/codec/utf_16.rs:187:17: 187:32
        switchInt(move _104) -> [false: bb39, otherwise: bb38]; // scope 8 at src/codec/utf_16.rs:187:17: 187:32
    }

    bb38: {
        _105 = Le(_91, const 57343_u16); // scope 8 at src/codec/utf_16.rs:187:17: 187:32
        switchInt(move _105) -> [false: bb39, otherwise: bb40]; // scope 8 at src/codec/utf_16.rs:187:17: 187:32
    }

    bb39: {
        ((*_1).0: u16) = const u16::MAX; // scope 8 at src/codec/utf_16.rs:192:21: 192:43
        ((*_1).1: u16) = const u16::MAX; // scope 8 at src/codec/utf_16.rs:193:21: 193:48
        StorageLive(_119);               // scope 8 at src/codec/utf_16.rs:194:29: 194:38
        _119 = _11;                      // scope 8 at src/codec/utf_16.rs:194:29: 194:38
        StorageLive(_120);               // scope 8 at src/codec/utf_16.rs:194:40: 196:23
        StorageLive(_121);               // scope 8 at src/codec/utf_16.rs:194:45: 196:22
        StorageLive(_122);               // scope 8 at src/codec/utf_16.rs:195:31: 195:45
        StorageLive(_123);               // scope 8 at src/codec/utf_16.rs:195:31: 195:41
        StorageLive(_124);               // scope 8 at src/codec/utf_16.rs:195:31: 195:32
        _124 = _10;                      // scope 8 at src/codec/utf_16.rs:195:31: 195:32
        _123 = move _124 as isize (Misc); // scope 8 at src/codec/utf_16.rs:195:31: 195:41
        StorageDead(_124);               // scope 8 at src/codec/utf_16.rs:195:40: 195:41
        _122 = Sub(move _123, const 2_isize); // scope 8 at src/codec/utf_16.rs:195:31: 195:45
        StorageDead(_123);               // scope 8 at src/codec/utf_16.rs:195:44: 195:45
        StorageLive(_125);               // scope 8 at src/codec/utf_16.rs:195:54: 195:79
        StorageLive(_126);               // scope 8 at src/codec/utf_16.rs:195:54: 195:72
        StorageLive(_127);               // scope 8 at src/codec/utf_16.rs:195:54: 195:72
        _127 = const "invalid sequence"; // scope 8 at src/codec/utf_16.rs:195:54: 195:72
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:195:54: 195:72
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _126 = _127;                     // scope 8 at src/codec/utf_16.rs:195:54: 195:72
        _125 = <&str as Into<Cow<str>>>::into(move _126) -> [return: bb43, unwind: bb86]; // scope 8 at src/codec/utf_16.rs:195:54: 195:79
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:195:73: 195:77
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb40: {
        StorageLive(_106);               // scope 8 at src/codec/utf_16.rs:188:25: 188:27
        StorageLive(_107);               // scope 8 at src/codec/utf_16.rs:188:30: 188:61
        StorageLive(_108);               // scope 8 at src/codec/utf_16.rs:188:31: 188:54
        StorageLive(_109);               // scope 8 at src/codec/utf_16.rs:188:32: 188:44
        StorageLive(_110);               // scope 8 at src/codec/utf_16.rs:188:32: 188:37
        _110 = _90;                      // scope 8 at src/codec/utf_16.rs:188:32: 188:37
        _109 = move _110 as u32 (Misc);  // scope 8 at src/codec/utf_16.rs:188:32: 188:44
        StorageDead(_110);               // scope 8 at src/codec/utf_16.rs:188:43: 188:44
        _108 = Sub(move _109, const 55296_u32); // scope 8 at src/codec/utf_16.rs:188:31: 188:54
        StorageDead(_109);               // scope 8 at src/codec/utf_16.rs:188:53: 188:54
        _107 = Shl(move _108, const 10_i32); // scope 8 at src/codec/utf_16.rs:188:30: 188:61
        StorageDead(_108);               // scope 8 at src/codec/utf_16.rs:188:60: 188:61
        StorageLive(_111);               // scope 8 at src/codec/utf_16.rs:188:64: 188:84
        StorageLive(_112);               // scope 8 at src/codec/utf_16.rs:188:65: 188:74
        StorageLive(_113);               // scope 8 at src/codec/utf_16.rs:188:65: 188:67
        _113 = _91;                      // scope 8 at src/codec/utf_16.rs:188:65: 188:67
        _112 = move _113 as u32 (Misc);  // scope 8 at src/codec/utf_16.rs:188:65: 188:74
        StorageDead(_113);               // scope 8 at src/codec/utf_16.rs:188:73: 188:74
        _111 = Sub(move _112, const 56320_u32); // scope 8 at src/codec/utf_16.rs:188:64: 188:84
        StorageDead(_112);               // scope 8 at src/codec/utf_16.rs:188:83: 188:84
        _106 = Add(move _107, move _111); // scope 8 at src/codec/utf_16.rs:188:30: 188:84
        StorageDead(_111);               // scope 8 at src/codec/utf_16.rs:188:83: 188:84
        StorageDead(_107);               // scope 8 at src/codec/utf_16.rs:188:83: 188:84
        StorageLive(_114);               // scope 9 at src/codec/utf_16.rs:189:21: 189:61
        StorageLive(_115);               // scope 9 at src/codec/utf_16.rs:189:21: 189:27
        _115 = &mut (*_3);               // scope 9 at src/codec/utf_16.rs:189:21: 189:27
        StorageLive(_116);               // scope 9 at src/codec/utf_16.rs:189:39: 189:60
        StorageLive(_117);               // scope 9 at src/codec/utf_16.rs:189:47: 189:59
        StorageLive(_118);               // scope 9 at src/codec/utf_16.rs:189:47: 189:49
        _118 = _106;                     // scope 9 at src/codec/utf_16.rs:189:47: 189:49
        _117 = Add(move _118, const 65536_u32); // scope 9 at src/codec/utf_16.rs:189:47: 189:59
        StorageDead(_118);               // scope 9 at src/codec/utf_16.rs:189:58: 189:59
        _116 = as_char(move _117) -> [return: bb41, unwind: bb86]; // scope 9 at src/codec/utf_16.rs:189:39: 189:60
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:189:39: 189:46
                                         // + literal: Const { ty: fn(u32) -> char {util::as_char}, val: Value(Scalar(<ZST>)) }
    }

    bb41: {
        StorageDead(_117);               // scope 9 at src/codec/utf_16.rs:189:59: 189:60
        _114 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _115, move _116) -> [return: bb42, unwind: bb86]; // scope 9 at src/codec/utf_16.rs:189:21: 189:61
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:189:28: 189:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb42: {
        StorageDead(_116);               // scope 9 at src/codec/utf_16.rs:189:60: 189:61
        StorageDead(_115);               // scope 9 at src/codec/utf_16.rs:189:60: 189:61
        StorageDead(_114);               // scope 9 at src/codec/utf_16.rs:189:61: 189:62
        StorageDead(_106);               // scope 8 at src/codec/utf_16.rs:190:17: 190:18
        StorageDead(_91);                // scope 7 at src/codec/utf_16.rs:199:9: 199:10
        StorageDead(_90);                // scope 3 at src/codec/utf_16.rs:199:9: 199:10
        goto -> bb45;                    // scope 3 at src/codec/utf_16.rs:177:9: 199:10
    }

    bb43: {
        StorageDead(_126);               // scope 8 at src/codec/utf_16.rs:195:78: 195:79
        (_121.0: isize) = move _122;     // scope 8 at src/codec/utf_16.rs:194:45: 196:22
        (_121.1: std::borrow::Cow<str>) = move _125; // scope 8 at src/codec/utf_16.rs:194:45: 196:22
        StorageDead(_125);               // scope 8 at src/codec/utf_16.rs:196:21: 196:22
        StorageDead(_122);               // scope 8 at src/codec/utf_16.rs:196:21: 196:22
        ((_120 as Some).0: encoding_types::CodecError) = move _121; // scope 8 at src/codec/utf_16.rs:194:40: 196:23
        discriminant(_120) = 1;          // scope 8 at src/codec/utf_16.rs:194:40: 196:23
        StorageDead(_121);               // scope 8 at src/codec/utf_16.rs:196:22: 196:23
        (_0.0: usize) = move _119;       // scope 8 at src/codec/utf_16.rs:194:28: 196:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _120; // scope 8 at src/codec/utf_16.rs:194:28: 196:24
        StorageDead(_120);               // scope 8 at src/codec/utf_16.rs:196:23: 196:24
        StorageDead(_119);               // scope 8 at src/codec/utf_16.rs:196:23: 196:24
        StorageDead(_127);               // scope 8 at src/codec/utf_16.rs:196:24: 196:25
        StorageDead(_91);                // scope 7 at src/codec/utf_16.rs:199:9: 199:10
        StorageDead(_90);                // scope 3 at src/codec/utf_16.rs:199:9: 199:10
        goto -> bb81;                    // scope 3 at no-location
    }

    bb44: {
        StorageDead(_79);                // scope 3 at src/codec/utf_16.rs:177:12: 177:40
        goto -> bb45;                    // scope 3 at src/codec/utf_16.rs:177:9: 199:10
    }

    bb45: {
        ((*_1).0: u16) = const u16::MAX; // scope 3 at src/codec/utf_16.rs:201:9: 201:31
        ((*_1).1: u16) = const u16::MAX; // scope 3 at src/codec/utf_16.rs:202:9: 202:36
        StorageLive(_128);               // scope 3 at src/codec/utf_16.rs:203:21: 203:22
        _128 = _10;                      // scope 3 at src/codec/utf_16.rs:203:21: 203:22
        _11 = move _128;                 // scope 3 at src/codec/utf_16.rs:203:9: 203:22
        StorageDead(_128);               // scope 3 at src/codec/utf_16.rs:203:21: 203:22
        goto -> bb46;                    // scope 3 at src/codec/utf_16.rs:204:9: 243:10
    }

    bb46: {
        StorageLive(_129);               // scope 3 at src/codec/utf_16.rs:204:15: 204:22
        StorageLive(_130);               // scope 3 at src/codec/utf_16.rs:204:15: 204:16
        _130 = _10;                      // scope 3 at src/codec/utf_16.rs:204:15: 204:16
        StorageLive(_131);               // scope 3 at src/codec/utf_16.rs:204:19: 204:22
        _131 = _12;                      // scope 3 at src/codec/utf_16.rs:204:19: 204:22
        _129 = Lt(move _130, move _131); // scope 3 at src/codec/utf_16.rs:204:15: 204:22
        StorageDead(_131);               // scope 3 at src/codec/utf_16.rs:204:21: 204:22
        StorageDead(_130);               // scope 3 at src/codec/utf_16.rs:204:21: 204:22
        switchInt(move _129) -> [false: bb78, otherwise: bb47]; // scope 3 at src/codec/utf_16.rs:204:15: 204:22
    }

    bb47: {
        _10 = Add(_10, const 1_usize);   // scope 3 at src/codec/utf_16.rs:205:13: 205:19
        StorageLive(_132);               // scope 3 at src/codec/utf_16.rs:206:16: 206:24
        StorageLive(_133);               // scope 3 at src/codec/utf_16.rs:206:16: 206:17
        _133 = _10;                      // scope 3 at src/codec/utf_16.rs:206:16: 206:17
        StorageLive(_134);               // scope 3 at src/codec/utf_16.rs:206:21: 206:24
        _134 = _12;                      // scope 3 at src/codec/utf_16.rs:206:21: 206:24
        _132 = Ge(move _133, move _134); // scope 3 at src/codec/utf_16.rs:206:16: 206:24
        StorageDead(_134);               // scope 3 at src/codec/utf_16.rs:206:23: 206:24
        StorageDead(_133);               // scope 3 at src/codec/utf_16.rs:206:23: 206:24
        switchInt(move _132) -> [false: bb50, otherwise: bb48]; // scope 3 at src/codec/utf_16.rs:206:16: 206:24
    }

    bb48: {
        StorageLive(_135);               // scope 3 at src/codec/utf_16.rs:207:33: 207:43
        StorageLive(_136);               // scope 3 at src/codec/utf_16.rs:207:39: 207:42
        StorageLive(_137);               // scope 3 at src/codec/utf_16.rs:207:39: 207:40
        _137 = _10;                      // scope 3 at src/codec/utf_16.rs:207:39: 207:40
        _136 = Sub(move _137, const 1_usize); // scope 3 at src/codec/utf_16.rs:207:39: 207:42
        StorageDead(_137);               // scope 3 at src/codec/utf_16.rs:207:41: 207:42
        _138 = Len((*_2));               // scope 3 at src/codec/utf_16.rs:207:33: 207:43
        _139 = Lt(_136, _138);           // scope 3 at src/codec/utf_16.rs:207:33: 207:43
        assert(move _139, "index out of bounds: the length is {} but the index is {}", move _138, _136) -> [success: bb49, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:207:33: 207:43
    }

    bb49: {
        _135 = (*_2)[_136];              // scope 3 at src/codec/utf_16.rs:207:33: 207:43
        ((*_1).0: u16) = move _135 as u16 (Misc); // scope 3 at src/codec/utf_16.rs:207:17: 207:50
        StorageDead(_135);               // scope 3 at src/codec/utf_16.rs:207:49: 207:50
        StorageDead(_136);               // scope 3 at src/codec/utf_16.rs:207:50: 207:51
        StorageDead(_132);               // scope 3 at src/codec/utf_16.rs:209:13: 209:14
        goto -> bb79;                    // scope 3 at no-location
    }

    bb50: {
        StorageDead(_132);               // scope 3 at src/codec/utf_16.rs:209:13: 209:14
        StorageLive(_140);               // scope 3 at src/codec/utf_16.rs:210:17: 210:19
        StorageLive(_141);               // scope 3 at src/codec/utf_16.rs:210:22: 210:38
        _141 = &_4;                      // scope 3 at src/codec/utf_16.rs:210:22: 210:38
        StorageLive(_142);               // scope 3 at src/codec/utf_16.rs:210:22: 210:67
        StorageLive(_143);               // scope 3 at src/codec/utf_16.rs:210:39: 210:56
        StorageLive(_144);               // scope 3 at src/codec/utf_16.rs:210:39: 210:49
        StorageLive(_145);               // scope 3 at src/codec/utf_16.rs:210:45: 210:48
        StorageLive(_146);               // scope 3 at src/codec/utf_16.rs:210:45: 210:46
        _146 = _10;                      // scope 3 at src/codec/utf_16.rs:210:45: 210:46
        _145 = Sub(move _146, const 1_usize); // scope 3 at src/codec/utf_16.rs:210:45: 210:48
        StorageDead(_146);               // scope 3 at src/codec/utf_16.rs:210:47: 210:48
        _147 = Len((*_2));               // scope 3 at src/codec/utf_16.rs:210:39: 210:49
        _148 = Lt(_145, _147);           // scope 3 at src/codec/utf_16.rs:210:39: 210:49
        assert(move _148, "index out of bounds: the length is {} but the index is {}", move _147, _145) -> [success: bb51, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:210:39: 210:49
    }

    bb51: {
        _144 = (*_2)[_145];              // scope 3 at src/codec/utf_16.rs:210:39: 210:49
        _143 = move _144 as u16 (Misc);  // scope 3 at src/codec/utf_16.rs:210:39: 210:56
        StorageDead(_144);               // scope 3 at src/codec/utf_16.rs:210:55: 210:56
        StorageLive(_149);               // scope 3 at src/codec/utf_16.rs:210:58: 210:66
        StorageLive(_150);               // scope 3 at src/codec/utf_16.rs:210:64: 210:65
        _150 = _10;                      // scope 3 at src/codec/utf_16.rs:210:64: 210:65
        _151 = Len((*_2));               // scope 3 at src/codec/utf_16.rs:210:58: 210:66
        _152 = Lt(_150, _151);           // scope 3 at src/codec/utf_16.rs:210:58: 210:66
        assert(move _152, "index out of bounds: the length is {} but the index is {}", move _151, _150) -> [success: bb52, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:210:58: 210:66
    }

    bb52: {
        _149 = (*_2)[_150];              // scope 3 at src/codec/utf_16.rs:210:58: 210:66
        (_142.0: u16) = move _143;       // scope 3 at src/codec/utf_16.rs:210:22: 210:67
        (_142.1: u8) = move _149;        // scope 3 at src/codec/utf_16.rs:210:22: 210:67
        _140 = <F as Fn<(u16, u8)>>::call(move _141, move _142) -> [return: bb53, unwind: bb86]; // scope 3 at src/codec/utf_16.rs:210:22: 210:67
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:210:22: 210:38
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (u16, u8)) -> <F as std::ops::FnOnce<(u16, u8)>>::Output {<F as std::ops::Fn<(u16, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb53: {
        StorageDead(_149);               // scope 3 at src/codec/utf_16.rs:210:66: 210:67
        StorageDead(_143);               // scope 3 at src/codec/utf_16.rs:210:66: 210:67
        StorageDead(_142);               // scope 3 at src/codec/utf_16.rs:210:66: 210:67
        StorageDead(_141);               // scope 3 at src/codec/utf_16.rs:210:66: 210:67
        StorageDead(_150);               // scope 3 at src/codec/utf_16.rs:210:67: 210:68
        StorageDead(_145);               // scope 3 at src/codec/utf_16.rs:210:67: 210:68
        _155 = Le(const 55296_u16, _140); // scope 10 at src/codec/utf_16.rs:212:17: 212:32
        switchInt(move _155) -> [false: bb55, otherwise: bb54]; // scope 10 at src/codec/utf_16.rs:212:17: 212:32
    }

    bb54: {
        _156 = Le(_140, const 56319_u16); // scope 10 at src/codec/utf_16.rs:212:17: 212:32
        switchInt(move _156) -> [false: bb55, otherwise: bb58]; // scope 10 at src/codec/utf_16.rs:212:17: 212:32
    }

    bb55: {
        _153 = Le(const 56320_u16, _140); // scope 10 at src/codec/utf_16.rs:232:17: 232:32
        switchInt(move _153) -> [false: bb57, otherwise: bb56]; // scope 10 at src/codec/utf_16.rs:232:17: 232:32
    }

    bb56: {
        _154 = Le(_140, const 57343_u16); // scope 10 at src/codec/utf_16.rs:232:17: 232:32
        switchInt(move _154) -> [false: bb57, otherwise: bb73]; // scope 10 at src/codec/utf_16.rs:232:17: 232:32
    }

    bb57: {
        StorageLive(_216);               // scope 10 at src/codec/utf_16.rs:238:21: 238:58
        StorageLive(_217);               // scope 10 at src/codec/utf_16.rs:238:21: 238:27
        _217 = &mut (*_3);               // scope 10 at src/codec/utf_16.rs:238:21: 238:27
        StorageLive(_218);               // scope 10 at src/codec/utf_16.rs:238:39: 238:57
        StorageLive(_219);               // scope 10 at src/codec/utf_16.rs:238:47: 238:56
        StorageLive(_220);               // scope 10 at src/codec/utf_16.rs:238:47: 238:49
        _220 = _140;                     // scope 10 at src/codec/utf_16.rs:238:47: 238:49
        _219 = move _220 as u32 (Misc);  // scope 10 at src/codec/utf_16.rs:238:47: 238:56
        StorageDead(_220);               // scope 10 at src/codec/utf_16.rs:238:55: 238:56
        _218 = as_char(move _219) -> [return: bb75, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:238:39: 238:57
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:238:39: 238:46
                                         // + literal: Const { ty: fn(u32) -> char {util::as_char}, val: Value(Scalar(<ZST>)) }
    }

    bb58: {
        _10 = Add(_10, const 2_usize);   // scope 10 at src/codec/utf_16.rs:213:21: 213:27
        StorageLive(_157);               // scope 10 at src/codec/utf_16.rs:214:24: 214:32
        StorageLive(_158);               // scope 10 at src/codec/utf_16.rs:214:24: 214:25
        _158 = _10;                      // scope 10 at src/codec/utf_16.rs:214:24: 214:25
        StorageLive(_159);               // scope 10 at src/codec/utf_16.rs:214:29: 214:32
        _159 = _12;                      // scope 10 at src/codec/utf_16.rs:214:29: 214:32
        _157 = Ge(move _158, move _159); // scope 10 at src/codec/utf_16.rs:214:24: 214:32
        StorageDead(_159);               // scope 10 at src/codec/utf_16.rs:214:31: 214:32
        StorageDead(_158);               // scope 10 at src/codec/utf_16.rs:214:31: 214:32
        switchInt(move _157) -> [false: bb63, otherwise: bb59]; // scope 10 at src/codec/utf_16.rs:214:24: 214:32
    }

    bb59: {
        StorageLive(_160);               // scope 10 at src/codec/utf_16.rs:215:46: 215:48
        _160 = _140;                     // scope 10 at src/codec/utf_16.rs:215:46: 215:48
        ((*_1).1: u16) = move _160;      // scope 10 at src/codec/utf_16.rs:215:25: 215:48
        StorageDead(_160);               // scope 10 at src/codec/utf_16.rs:215:47: 215:48
        StorageLive(_161);               // scope 10 at src/codec/utf_16.rs:216:28: 216:37
        StorageLive(_162);               // scope 10 at src/codec/utf_16.rs:216:28: 216:31
        StorageLive(_163);               // scope 10 at src/codec/utf_16.rs:216:28: 216:29
        _163 = _10;                      // scope 10 at src/codec/utf_16.rs:216:28: 216:29
        _162 = Sub(move _163, const 1_usize); // scope 10 at src/codec/utf_16.rs:216:28: 216:31
        StorageDead(_163);               // scope 10 at src/codec/utf_16.rs:216:30: 216:31
        StorageLive(_164);               // scope 10 at src/codec/utf_16.rs:216:34: 216:37
        _164 = _12;                      // scope 10 at src/codec/utf_16.rs:216:34: 216:37
        _161 = Lt(move _162, move _164); // scope 10 at src/codec/utf_16.rs:216:28: 216:37
        StorageDead(_164);               // scope 10 at src/codec/utf_16.rs:216:36: 216:37
        StorageDead(_162);               // scope 10 at src/codec/utf_16.rs:216:36: 216:37
        switchInt(move _161) -> [false: bb62, otherwise: bb60]; // scope 10 at src/codec/utf_16.rs:216:28: 216:37
    }

    bb60: {
        StorageLive(_165);               // scope 10 at src/codec/utf_16.rs:216:56: 216:66
        StorageLive(_166);               // scope 10 at src/codec/utf_16.rs:216:62: 216:65
        StorageLive(_167);               // scope 10 at src/codec/utf_16.rs:216:62: 216:63
        _167 = _10;                      // scope 10 at src/codec/utf_16.rs:216:62: 216:63
        _166 = Sub(move _167, const 1_usize); // scope 10 at src/codec/utf_16.rs:216:62: 216:65
        StorageDead(_167);               // scope 10 at src/codec/utf_16.rs:216:64: 216:65
        _168 = Len((*_2));               // scope 10 at src/codec/utf_16.rs:216:56: 216:66
        _169 = Lt(_166, _168);           // scope 10 at src/codec/utf_16.rs:216:56: 216:66
        assert(move _169, "index out of bounds: the length is {} but the index is {}", move _168, _166) -> [success: bb61, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:216:56: 216:66
    }

    bb61: {
        _165 = (*_2)[_166];              // scope 10 at src/codec/utf_16.rs:216:56: 216:66
        ((*_1).0: u16) = move _165 as u16 (Misc); // scope 10 at src/codec/utf_16.rs:216:40: 216:73
        StorageDead(_165);               // scope 10 at src/codec/utf_16.rs:216:72: 216:73
        StorageDead(_166);               // scope 10 at src/codec/utf_16.rs:216:73: 216:74
        goto -> bb62;                    // scope 10 at src/codec/utf_16.rs:216:25: 216:76
    }

    bb62: {
        StorageDead(_161);               // scope 10 at src/codec/utf_16.rs:216:75: 216:76
        StorageDead(_157);               // scope 10 at src/codec/utf_16.rs:218:21: 218:22
        StorageDead(_140);               // scope 3 at src/codec/utf_16.rs:243:9: 243:10
        goto -> bb79;                    // scope 3 at no-location
    }

    bb63: {
        StorageDead(_157);               // scope 10 at src/codec/utf_16.rs:218:21: 218:22
        StorageLive(_170);               // scope 10 at src/codec/utf_16.rs:219:25: 219:28
        StorageLive(_171);               // scope 10 at src/codec/utf_16.rs:219:31: 219:47
        _171 = &_4;                      // scope 10 at src/codec/utf_16.rs:219:31: 219:47
        StorageLive(_172);               // scope 10 at src/codec/utf_16.rs:219:31: 219:76
        StorageLive(_173);               // scope 10 at src/codec/utf_16.rs:219:48: 219:65
        StorageLive(_174);               // scope 10 at src/codec/utf_16.rs:219:48: 219:58
        StorageLive(_175);               // scope 10 at src/codec/utf_16.rs:219:54: 219:57
        StorageLive(_176);               // scope 10 at src/codec/utf_16.rs:219:54: 219:55
        _176 = _10;                      // scope 10 at src/codec/utf_16.rs:219:54: 219:55
        _175 = Sub(move _176, const 1_usize); // scope 10 at src/codec/utf_16.rs:219:54: 219:57
        StorageDead(_176);               // scope 10 at src/codec/utf_16.rs:219:56: 219:57
        _177 = Len((*_2));               // scope 10 at src/codec/utf_16.rs:219:48: 219:58
        _178 = Lt(_175, _177);           // scope 10 at src/codec/utf_16.rs:219:48: 219:58
        assert(move _178, "index out of bounds: the length is {} but the index is {}", move _177, _175) -> [success: bb64, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:219:48: 219:58
    }

    bb64: {
        _174 = (*_2)[_175];              // scope 10 at src/codec/utf_16.rs:219:48: 219:58
        _173 = move _174 as u16 (Misc);  // scope 10 at src/codec/utf_16.rs:219:48: 219:65
        StorageDead(_174);               // scope 10 at src/codec/utf_16.rs:219:64: 219:65
        StorageLive(_179);               // scope 10 at src/codec/utf_16.rs:219:67: 219:75
        StorageLive(_180);               // scope 10 at src/codec/utf_16.rs:219:73: 219:74
        _180 = _10;                      // scope 10 at src/codec/utf_16.rs:219:73: 219:74
        _181 = Len((*_2));               // scope 10 at src/codec/utf_16.rs:219:67: 219:75
        _182 = Lt(_180, _181);           // scope 10 at src/codec/utf_16.rs:219:67: 219:75
        assert(move _182, "index out of bounds: the length is {} but the index is {}", move _181, _180) -> [success: bb65, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:219:67: 219:75
    }

    bb65: {
        _179 = (*_2)[_180];              // scope 10 at src/codec/utf_16.rs:219:67: 219:75
        (_172.0: u16) = move _173;       // scope 10 at src/codec/utf_16.rs:219:31: 219:76
        (_172.1: u8) = move _179;        // scope 10 at src/codec/utf_16.rs:219:31: 219:76
        _170 = <F as Fn<(u16, u8)>>::call(move _171, move _172) -> [return: bb66, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:219:31: 219:76
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:219:31: 219:47
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (u16, u8)) -> <F as std::ops::FnOnce<(u16, u8)>>::Output {<F as std::ops::Fn<(u16, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb66: {
        StorageDead(_179);               // scope 10 at src/codec/utf_16.rs:219:75: 219:76
        StorageDead(_173);               // scope 10 at src/codec/utf_16.rs:219:75: 219:76
        StorageDead(_172);               // scope 10 at src/codec/utf_16.rs:219:75: 219:76
        StorageDead(_171);               // scope 10 at src/codec/utf_16.rs:219:75: 219:76
        StorageDead(_180);               // scope 10 at src/codec/utf_16.rs:219:76: 219:77
        StorageDead(_175);               // scope 10 at src/codec/utf_16.rs:219:76: 219:77
        _183 = Le(const 56320_u16, _170); // scope 11 at src/codec/utf_16.rs:221:25: 221:40
        switchInt(move _183) -> [false: bb68, otherwise: bb67]; // scope 11 at src/codec/utf_16.rs:221:25: 221:40
    }

    bb67: {
        _184 = Le(_170, const 57343_u16); // scope 11 at src/codec/utf_16.rs:221:25: 221:40
        switchInt(move _184) -> [false: bb68, otherwise: bb69]; // scope 11 at src/codec/utf_16.rs:221:25: 221:40
    }

    bb68: {
        StorageLive(_198);               // scope 11 at src/codec/utf_16.rs:226:37: 226:46
        _198 = _11;                      // scope 11 at src/codec/utf_16.rs:226:37: 226:46
        StorageLive(_199);               // scope 11 at src/codec/utf_16.rs:226:48: 228:31
        StorageLive(_200);               // scope 11 at src/codec/utf_16.rs:226:53: 228:30
        StorageLive(_201);               // scope 11 at src/codec/utf_16.rs:227:39: 227:53
        StorageLive(_202);               // scope 11 at src/codec/utf_16.rs:227:39: 227:49
        StorageLive(_203);               // scope 11 at src/codec/utf_16.rs:227:39: 227:40
        _203 = _10;                      // scope 11 at src/codec/utf_16.rs:227:39: 227:40
        _202 = move _203 as isize (Misc); // scope 11 at src/codec/utf_16.rs:227:39: 227:49
        StorageDead(_203);               // scope 11 at src/codec/utf_16.rs:227:48: 227:49
        _201 = Sub(move _202, const 1_isize); // scope 11 at src/codec/utf_16.rs:227:39: 227:53
        StorageDead(_202);               // scope 11 at src/codec/utf_16.rs:227:52: 227:53
        StorageLive(_204);               // scope 11 at src/codec/utf_16.rs:227:62: 227:87
        StorageLive(_205);               // scope 11 at src/codec/utf_16.rs:227:62: 227:80
        StorageLive(_206);               // scope 11 at src/codec/utf_16.rs:227:62: 227:80
        _206 = const "invalid sequence"; // scope 11 at src/codec/utf_16.rs:227:62: 227:80
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:227:62: 227:80
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _205 = _206;                     // scope 11 at src/codec/utf_16.rs:227:62: 227:80
        _204 = <&str as Into<Cow<str>>>::into(move _205) -> [return: bb72, unwind: bb86]; // scope 11 at src/codec/utf_16.rs:227:62: 227:87
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:227:81: 227:85
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb69: {
        StorageLive(_185);               // scope 11 at src/codec/utf_16.rs:222:33: 222:35
        StorageLive(_186);               // scope 11 at src/codec/utf_16.rs:222:38: 222:66
        StorageLive(_187);               // scope 11 at src/codec/utf_16.rs:222:39: 222:59
        StorageLive(_188);               // scope 11 at src/codec/utf_16.rs:222:40: 222:49
        StorageLive(_189);               // scope 11 at src/codec/utf_16.rs:222:40: 222:42
        _189 = _140;                     // scope 11 at src/codec/utf_16.rs:222:40: 222:42
        _188 = move _189 as u32 (Misc);  // scope 11 at src/codec/utf_16.rs:222:40: 222:49
        StorageDead(_189);               // scope 11 at src/codec/utf_16.rs:222:48: 222:49
        _187 = Sub(move _188, const 55296_u32); // scope 11 at src/codec/utf_16.rs:222:39: 222:59
        StorageDead(_188);               // scope 11 at src/codec/utf_16.rs:222:58: 222:59
        _186 = Shl(move _187, const 10_i32); // scope 11 at src/codec/utf_16.rs:222:38: 222:66
        StorageDead(_187);               // scope 11 at src/codec/utf_16.rs:222:65: 222:66
        StorageLive(_190);               // scope 11 at src/codec/utf_16.rs:222:69: 222:90
        StorageLive(_191);               // scope 11 at src/codec/utf_16.rs:222:70: 222:80
        StorageLive(_192);               // scope 11 at src/codec/utf_16.rs:222:70: 222:73
        _192 = _170;                     // scope 11 at src/codec/utf_16.rs:222:70: 222:73
        _191 = move _192 as u32 (Misc);  // scope 11 at src/codec/utf_16.rs:222:70: 222:80
        StorageDead(_192);               // scope 11 at src/codec/utf_16.rs:222:79: 222:80
        _190 = Sub(move _191, const 56320_u32); // scope 11 at src/codec/utf_16.rs:222:69: 222:90
        StorageDead(_191);               // scope 11 at src/codec/utf_16.rs:222:89: 222:90
        _185 = Add(move _186, move _190); // scope 11 at src/codec/utf_16.rs:222:38: 222:90
        StorageDead(_190);               // scope 11 at src/codec/utf_16.rs:222:89: 222:90
        StorageDead(_186);               // scope 11 at src/codec/utf_16.rs:222:89: 222:90
        StorageLive(_193);               // scope 12 at src/codec/utf_16.rs:223:29: 223:69
        StorageLive(_194);               // scope 12 at src/codec/utf_16.rs:223:29: 223:35
        _194 = &mut (*_3);               // scope 12 at src/codec/utf_16.rs:223:29: 223:35
        StorageLive(_195);               // scope 12 at src/codec/utf_16.rs:223:47: 223:68
        StorageLive(_196);               // scope 12 at src/codec/utf_16.rs:223:55: 223:67
        StorageLive(_197);               // scope 12 at src/codec/utf_16.rs:223:55: 223:57
        _197 = _185;                     // scope 12 at src/codec/utf_16.rs:223:55: 223:57
        _196 = Add(move _197, const 65536_u32); // scope 12 at src/codec/utf_16.rs:223:55: 223:67
        StorageDead(_197);               // scope 12 at src/codec/utf_16.rs:223:66: 223:67
        _195 = as_char(move _196) -> [return: bb70, unwind: bb86]; // scope 12 at src/codec/utf_16.rs:223:47: 223:68
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:223:47: 223:54
                                         // + literal: Const { ty: fn(u32) -> char {util::as_char}, val: Value(Scalar(<ZST>)) }
    }

    bb70: {
        StorageDead(_196);               // scope 12 at src/codec/utf_16.rs:223:67: 223:68
        _193 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _194, move _195) -> [return: bb71, unwind: bb86]; // scope 12 at src/codec/utf_16.rs:223:29: 223:69
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:223:36: 223:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb71: {
        StorageDead(_195);               // scope 12 at src/codec/utf_16.rs:223:68: 223:69
        StorageDead(_194);               // scope 12 at src/codec/utf_16.rs:223:68: 223:69
        StorageDead(_193);               // scope 12 at src/codec/utf_16.rs:223:69: 223:70
        StorageDead(_185);               // scope 11 at src/codec/utf_16.rs:224:25: 224:26
        StorageDead(_170);               // scope 10 at src/codec/utf_16.rs:231:17: 231:18
        goto -> bb77;                    // scope 10 at src/codec/utf_16.rs:231:17: 231:18
    }

    bb72: {
        StorageDead(_205);               // scope 11 at src/codec/utf_16.rs:227:86: 227:87
        (_200.0: isize) = move _201;     // scope 11 at src/codec/utf_16.rs:226:53: 228:30
        (_200.1: std::borrow::Cow<str>) = move _204; // scope 11 at src/codec/utf_16.rs:226:53: 228:30
        StorageDead(_204);               // scope 11 at src/codec/utf_16.rs:228:29: 228:30
        StorageDead(_201);               // scope 11 at src/codec/utf_16.rs:228:29: 228:30
        ((_199 as Some).0: encoding_types::CodecError) = move _200; // scope 11 at src/codec/utf_16.rs:226:48: 228:31
        discriminant(_199) = 1;          // scope 11 at src/codec/utf_16.rs:226:48: 228:31
        StorageDead(_200);               // scope 11 at src/codec/utf_16.rs:228:30: 228:31
        (_0.0: usize) = move _198;       // scope 11 at src/codec/utf_16.rs:226:36: 228:32
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _199; // scope 11 at src/codec/utf_16.rs:226:36: 228:32
        StorageDead(_199);               // scope 11 at src/codec/utf_16.rs:228:31: 228:32
        StorageDead(_198);               // scope 11 at src/codec/utf_16.rs:228:31: 228:32
        StorageDead(_206);               // scope 11 at src/codec/utf_16.rs:228:32: 228:33
        StorageDead(_170);               // scope 10 at src/codec/utf_16.rs:231:17: 231:18
        goto -> bb80;                    // scope 10 at no-location
    }

    bb73: {
        StorageLive(_207);               // scope 10 at src/codec/utf_16.rs:233:29: 233:38
        _207 = _11;                      // scope 10 at src/codec/utf_16.rs:233:29: 233:38
        StorageLive(_208);               // scope 10 at src/codec/utf_16.rs:233:40: 235:23
        StorageLive(_209);               // scope 10 at src/codec/utf_16.rs:233:45: 235:22
        StorageLive(_210);               // scope 10 at src/codec/utf_16.rs:234:31: 234:45
        StorageLive(_211);               // scope 10 at src/codec/utf_16.rs:234:31: 234:41
        StorageLive(_212);               // scope 10 at src/codec/utf_16.rs:234:31: 234:32
        _212 = _10;                      // scope 10 at src/codec/utf_16.rs:234:31: 234:32
        _211 = move _212 as isize (Misc); // scope 10 at src/codec/utf_16.rs:234:31: 234:41
        StorageDead(_212);               // scope 10 at src/codec/utf_16.rs:234:40: 234:41
        _210 = Add(move _211, const 1_isize); // scope 10 at src/codec/utf_16.rs:234:31: 234:45
        StorageDead(_211);               // scope 10 at src/codec/utf_16.rs:234:44: 234:45
        StorageLive(_213);               // scope 10 at src/codec/utf_16.rs:234:54: 234:79
        StorageLive(_214);               // scope 10 at src/codec/utf_16.rs:234:54: 234:72
        StorageLive(_215);               // scope 10 at src/codec/utf_16.rs:234:54: 234:72
        _215 = const "invalid sequence"; // scope 10 at src/codec/utf_16.rs:234:54: 234:72
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:234:54: 234:72
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _214 = _215;                     // scope 10 at src/codec/utf_16.rs:234:54: 234:72
        _213 = <&str as Into<Cow<str>>>::into(move _214) -> [return: bb74, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:234:54: 234:79
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:234:73: 234:77
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb74: {
        StorageDead(_214);               // scope 10 at src/codec/utf_16.rs:234:78: 234:79
        (_209.0: isize) = move _210;     // scope 10 at src/codec/utf_16.rs:233:45: 235:22
        (_209.1: std::borrow::Cow<str>) = move _213; // scope 10 at src/codec/utf_16.rs:233:45: 235:22
        StorageDead(_213);               // scope 10 at src/codec/utf_16.rs:235:21: 235:22
        StorageDead(_210);               // scope 10 at src/codec/utf_16.rs:235:21: 235:22
        ((_208 as Some).0: encoding_types::CodecError) = move _209; // scope 10 at src/codec/utf_16.rs:233:40: 235:23
        discriminant(_208) = 1;          // scope 10 at src/codec/utf_16.rs:233:40: 235:23
        StorageDead(_209);               // scope 10 at src/codec/utf_16.rs:235:22: 235:23
        (_0.0: usize) = move _207;       // scope 10 at src/codec/utf_16.rs:233:28: 235:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _208; // scope 10 at src/codec/utf_16.rs:233:28: 235:24
        StorageDead(_208);               // scope 10 at src/codec/utf_16.rs:235:23: 235:24
        StorageDead(_207);               // scope 10 at src/codec/utf_16.rs:235:23: 235:24
        StorageDead(_215);               // scope 10 at src/codec/utf_16.rs:235:24: 235:25
        goto -> bb80;                    // scope 10 at no-location
    }

    bb75: {
        StorageDead(_219);               // scope 10 at src/codec/utf_16.rs:238:56: 238:57
        _216 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _217, move _218) -> [return: bb76, unwind: bb86]; // scope 10 at src/codec/utf_16.rs:238:21: 238:58
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:238:28: 238:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb76: {
        StorageDead(_218);               // scope 10 at src/codec/utf_16.rs:238:57: 238:58
        StorageDead(_217);               // scope 10 at src/codec/utf_16.rs:238:57: 238:58
        StorageDead(_216);               // scope 10 at src/codec/utf_16.rs:238:58: 238:59
        goto -> bb77;                    // scope 10 at src/codec/utf_16.rs:237:22: 239:18
    }

    bb77: {
        _10 = Add(_10, const 1_usize);   // scope 10 at src/codec/utf_16.rs:241:13: 241:19
        StorageLive(_221);               // scope 10 at src/codec/utf_16.rs:242:25: 242:26
        _221 = _10;                      // scope 10 at src/codec/utf_16.rs:242:25: 242:26
        _11 = move _221;                 // scope 10 at src/codec/utf_16.rs:242:13: 242:26
        StorageDead(_221);               // scope 10 at src/codec/utf_16.rs:242:25: 242:26
        StorageDead(_140);               // scope 3 at src/codec/utf_16.rs:243:9: 243:10
        StorageDead(_129);               // scope 3 at src/codec/utf_16.rs:243:9: 243:10
        goto -> bb46;                    // scope 3 at src/codec/utf_16.rs:204:9: 243:10
    }

    bb78: {
        goto -> bb79;                    // scope 3 at no-location
    }

    bb79: {
        StorageDead(_129);               // scope 3 at src/codec/utf_16.rs:243:9: 243:10
        StorageLive(_222);               // scope 3 at src/codec/utf_16.rs:244:10: 244:19
        _222 = _11;                      // scope 3 at src/codec/utf_16.rs:244:10: 244:19
        StorageLive(_223);               // scope 3 at src/codec/utf_16.rs:244:21: 244:25
        discriminant(_223) = 0;          // scope 3 at src/codec/utf_16.rs:244:21: 244:25
        (_0.0: usize) = move _222;       // scope 3 at src/codec/utf_16.rs:244:9: 244:26
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _223; // scope 3 at src/codec/utf_16.rs:244:9: 244:26
        StorageDead(_223);               // scope 3 at src/codec/utf_16.rs:244:25: 244:26
        StorageDead(_222);               // scope 3 at src/codec/utf_16.rs:244:25: 244:26
        StorageDead(_12);                // scope 2 at src/codec/utf_16.rs:245:5: 245:6
        StorageDead(_11);                // scope 1 at src/codec/utf_16.rs:245:5: 245:6
        StorageDead(_10);                // scope 0 at src/codec/utf_16.rs:245:5: 245:6
        drop(_4) -> bb85;                // scope 0 at src/codec/utf_16.rs:245:5: 245:6
    }

    bb80: {
        StorageDead(_140);               // scope 3 at src/codec/utf_16.rs:243:9: 243:10
        StorageDead(_129);               // scope 3 at src/codec/utf_16.rs:243:9: 243:10
        goto -> bb84;                    // scope 3 at no-location
    }

    bb81: {
        goto -> bb84;                    // scope 3 at no-location
    }

    bb82: {
        goto -> bb83;                    // scope 4 at no-location
    }

    bb83: {
        StorageDead(_20);                // scope 3 at src/codec/utf_16.rs:175:9: 175:10
        goto -> bb84;                    // scope 3 at no-location
    }

    bb84: {
        StorageDead(_12);                // scope 2 at src/codec/utf_16.rs:245:5: 245:6
        StorageDead(_11);                // scope 1 at src/codec/utf_16.rs:245:5: 245:6
        StorageDead(_10);                // scope 0 at src/codec/utf_16.rs:245:5: 245:6
        drop(_4) -> bb85;                // scope 0 at src/codec/utf_16.rs:245:5: 245:6
    }

    bb85: {
        return;                          // scope 0 at src/codec/utf_16.rs:245:6: 245:6
    }

    bb86 (cleanup): {
        drop(_4) -> bb87;                // scope 0 at src/codec/utf_16.rs:245:5: 245:6
    }

    bb87 (cleanup): {
        resume;                          // scope 0 at src/codec/utf_16.rs:127:5: 245:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:482:1: 533:2>::from_self(_1: &HZEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:483:18: 483:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:483:28: 483:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:483:46: 483:62
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:483:46: 483:62

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:483:46: 483:62
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:483:46: 483:62
        _3 = HZEncoder::new() -> bb1;    // scope 0 at src/codec/simpchinese.rs:483:46: 483:62
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:483:46: 483:60
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::simpchinese::HZEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:483:46: 483:62
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:483:61: 483:62
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:483:46: 483:62
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:483:63: 483:64
        return;                          // scope 0 at src/codec/simpchinese.rs:483:64: 483:64
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:30:1: 32:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/ascii.rs:31:21: 31:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/ascii.rs:31:39: 31:61
    let mut _2: std::boxed::Box<codec::ascii::ASCIIEncoder>; // in scope 0 at src/codec/ascii.rs:31:39: 31:61
    let mut _3: codec::ascii::ASCIIEncoder; // in scope 0 at src/codec/ascii.rs:31:48: 31:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/ascii.rs:31:39: 31:61
        StorageLive(_2);                 // scope 0 at src/codec/ascii.rs:31:39: 31:61
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:31:48: 31:60
        _2 = Box::<ASCIIEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/ascii.rs:31:39: 31:61
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:31:39: 31:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::ascii::ASCIIEncoder) -> std::boxed::Box<codec::ascii::ASCIIEncoder> {std::boxed::Box::<codec::ascii::ASCIIEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:31:39: 31:61
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:31:60: 31:61
        StorageDead(_2);                 // scope 0 at src/codec/ascii.rs:31:60: 31:61
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:31:39: 31:61
        StorageDead(_1);                 // scope 0 at src/codec/ascii.rs:31:62: 31:63
        return;                          // scope 0 at src/codec/ascii.rs:31:63: 31:63
    }
}

fn iso2022jp::transient::ASCII(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

fn codec::whatwg::<impl at src/codec/whatwg.rs:15:1: 20:2>::raw_decoder(_1: &EncoderOnlyUTF8Encoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/whatwg.rs:19:20: 19:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/whatwg.rs:19:30: 19:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/whatwg.rs:19:48: 19:89
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/whatwg.rs:19:48: 19:89
    let mut _4: &codec::error::ErrorEncoding; // in scope 0 at src/codec/whatwg.rs:19:48: 19:75
    let mut _5: &codec::error::ErrorEncoding; // in scope 0 at src/codec/whatwg.rs:19:48: 19:75

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/whatwg.rs:19:48: 19:89
        StorageLive(_3);                 // scope 0 at src/codec/whatwg.rs:19:48: 19:89
        StorageLive(_4);                 // scope 0 at src/codec/whatwg.rs:19:48: 19:75
        _5 = const <EncoderOnlyUTF8Encoding as encoding_types::Encoding>::raw_decoder::promoted[0]; // scope 0 at src/codec/whatwg.rs:19:48: 19:75
                                         // ty::Const
                                         // + ty: &codec::error::ErrorEncoding
                                         // + val: Unevaluated(<EncoderOnlyUTF8Encoding as encoding_types::Encoding>::raw_decoder, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/whatwg.rs:19:48: 19:75
                                         // + literal: Const { ty: &codec::error::ErrorEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:557 ~ encoding[5d2c]::codec::whatwg::{impl#0}::raw_decoder), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _4 = _5;                         // scope 0 at src/codec/whatwg.rs:19:48: 19:75
        _3 = <ErrorEncoding as encoding_types::Encoding>::raw_decoder(move _4) -> bb1; // scope 0 at src/codec/whatwg.rs:19:48: 19:89
                                         // mir::Constant
                                         // + span: src/codec/whatwg.rs:19:76: 19:87
                                         // + literal: Const { ty: for<'r> fn(&'r codec::error::ErrorEncoding) -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {<codec::error::ErrorEncoding as encoding_types::Encoding>::raw_decoder}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/whatwg.rs:19:48: 19:89
        StorageDead(_4);                 // scope 0 at src/codec/whatwg.rs:19:88: 19:89
        StorageDead(_3);                 // scope 0 at src/codec/whatwg.rs:19:88: 19:89
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/whatwg.rs:19:48: 19:89
        StorageDead(_2);                 // scope 0 at src/codec/whatwg.rs:19:90: 19:91
        return;                          // scope 0 at src/codec/whatwg.rs:19:91: 19:91
    }
}

promoted[0] in codec::whatwg::<impl at src/codec/whatwg.rs:15:1: 20:2>::raw_decoder: &ErrorEncoding = {
    let mut _0: &codec::error::ErrorEncoding; // return place in scope 0 at src/codec/whatwg.rs:19:48: 19:75
    let mut _1: codec::error::ErrorEncoding; // in scope 0 at src/codec/whatwg.rs:19:48: 19:75

    bb0: {
        nop;                             // scope 0 at src/codec/whatwg.rs:19:48: 19:75
        _0 = &_1;                        // scope 0 at src/codec/whatwg.rs:19:48: 19:75
        return;                          // scope 0 at src/codec/whatwg.rs:19:48: 19:75
    }
}

const ISO_8859_10: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:50:66: 50:79
    let _5: &str;                        // in scope 0 at src/all.rs:50:66: 50:79
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_10::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_10, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1258 ~ encoding[5d2c]::all::ISO_8859_10), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_10: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:50:66: 50:79
    let mut _4: &str;                    // in scope 0 at src/all.rs:50:66: 50:79
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-10";        // scope 0 at src/all.rs:50:66: 50:79
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:50:66: 50:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:50:66: 50:79
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_10::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_10::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_10::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_10::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-10"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:50:66: 50:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:520:1: 535:2>::raw_feed(_1: &mut Windows31JDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:524:17: 524:26
    debug input => _2;                   // in scope 0 at src/codec/japanese.rs:524:28: 524:33
    debug output => _3;                  // in scope 0 at src/codec/japanese.rs:524:42: 524:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/japanese.rs:524:72: 524:99
    let _4: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:525:14: 525:16
    let _5: usize;                       // in scope 0 at src/codec/japanese.rs:525:18: 525:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:525:29: 525:32
    let mut _7: (codec::japanese::windows31j::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/japanese.rs:525:36: 525:85
    let mut _8: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:525:57: 525:64
    let mut _9: &[u8];                   // in scope 0 at src/codec/japanese.rs:525:66: 525:71
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:525:73: 525:79
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:525:73: 525:79
    let mut _12: &();                    // in scope 0 at src/codec/japanese.rs:525:81: 525:84
    let _13: &();                        // in scope 0 at src/codec/japanese.rs:525:81: 525:84
    let mut _14: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:526:19: 526:21
    let mut _15: usize;                  // in scope 0 at src/codec/japanese.rs:527:10: 527:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:527:21: 527:24
    let mut _17: &();                    // in scope 0 at src/codec/japanese.rs:525:81: 525:84
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/japanese.rs:525:14: 525:16
        debug processed => _5;           // in scope 1 at src/codec/japanese.rs:525:18: 525:27
        debug err => _6;                 // in scope 1 at src/codec/japanese.rs:525:29: 525:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:525:36: 525:85
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:525:57: 525:64
        _8 = ((*_1).0: codec::japanese::windows31j::State); // scope 0 at src/codec/japanese.rs:525:57: 525:64
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:525:66: 525:71
        _9 = _2;                         // scope 0 at src/codec/japanese.rs:525:66: 525:71
        StorageLive(_10);                // scope 0 at src/codec/japanese.rs:525:73: 525:79
        StorageLive(_11);                // scope 0 at src/codec/japanese.rs:525:73: 525:79
        _11 = &mut (*_3);                // scope 0 at src/codec/japanese.rs:525:73: 525:79
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:525:73: 525:79
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:525:78: 525:79
        StorageLive(_12);                // scope 0 at src/codec/japanese.rs:525:81: 525:84
        StorageLive(_13);                // scope 0 at src/codec/japanese.rs:525:81: 525:84
        _17 = const <Windows31JDecoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/japanese.rs:525:81: 525:84
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<Windows31JDecoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:525:81: 525:84
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:423 ~ encoding[5d2c]::codec::japanese::{impl#9}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/japanese.rs:525:81: 525:84
        _12 = _13;                       // scope 0 at src/codec/japanese.rs:525:81: 525:84
        _7 = windows31j::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/japanese.rs:525:36: 525:85
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:525:36: 525:56
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::japanese::windows31j::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::japanese::windows31j::State, usize, std::option::Option<encoding_types::CodecError>) {codec::japanese::windows31j::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/japanese.rs:525:84: 525:85
        StorageDead(_10);                // scope 0 at src/codec/japanese.rs:525:84: 525:85
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:525:84: 525:85
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:525:84: 525:85
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:525:14: 525:16
        _4 = (_7.0: codec::japanese::windows31j::State); // scope 0 at src/codec/japanese.rs:525:14: 525:16
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:525:18: 525:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/japanese.rs:525:18: 525:27
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:525:29: 525:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/japanese.rs:525:29: 525:32
        StorageDead(_13);                // scope 0 at src/codec/japanese.rs:525:85: 525:86
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:525:85: 525:86
        StorageLive(_14);                // scope 1 at src/codec/japanese.rs:526:19: 526:21
        _14 = _4;                        // scope 1 at src/codec/japanese.rs:526:19: 526:21
        ((*_1).0: codec::japanese::windows31j::State) = move _14; // scope 1 at src/codec/japanese.rs:526:9: 526:21
        StorageDead(_14);                // scope 1 at src/codec/japanese.rs:526:20: 526:21
        StorageLive(_15);                // scope 1 at src/codec/japanese.rs:527:10: 527:19
        _15 = _5;                        // scope 1 at src/codec/japanese.rs:527:10: 527:19
        StorageLive(_16);                // scope 1 at src/codec/japanese.rs:527:21: 527:24
        _16 = move _6;                   // scope 1 at src/codec/japanese.rs:527:21: 527:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/japanese.rs:527:9: 527:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/japanese.rs:527:9: 527:25
        StorageDead(_16);                // scope 1 at src/codec/japanese.rs:527:24: 527:25
        StorageDead(_15);                // scope 1 at src/codec/japanese.rs:527:24: 527:25
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:528:5: 528:6
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:528:5: 528:6
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:528:5: 528:6
        return;                          // scope 0 at src/codec/japanese.rs:528:6: 528:6
    }
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:520:1: 535:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/japanese.rs:525:81: 525:84
    let mut _1: ();                      // in scope 0 at src/codec/japanese.rs:525:82: 525:84

    bb0: {
        nop;                             // scope 0 at src/codec/japanese.rs:525:82: 525:84
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:525:81: 525:84
        return;                          // scope 0 at src/codec/japanese.rs:525:81: 525:84
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::reset(_1: &StatefulDecoderHelper<St, Data>) -> St {
    debug self => _1;                    // in scope 0 at src/util.rs:90:18: 90:23
    let mut _0: St;                      // return place in scope 0 at src/util.rs:90:28: 90:30

    bb0: {
        _0 = <St as Default>::default() -> bb1; // scope 0 at src/util.rs:91:9: 91:27
                                         // mir::Constant
                                         // + span: src/util.rs:91:9: 91:25
                                         // + literal: Const { ty: fn() -> St {<St as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        return;                          // scope 0 at src/util.rs:92:6: 92:6
    }
}

fn iso2022jp::internal::map_two_0208_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/japanese.rs:884:40: 884:44
    debug trail => _2;                   // in scope 0 at src/codec/japanese.rs:884:50: 884:55
    let mut _0: u32;                     // return place in scope 0 at src/codec/japanese.rs:884:64: 884:67
    let _3: u16;                         // in scope 0 at src/codec/japanese.rs:887:13: 887:17
    let mut _4: u8;                      // in scope 0 at src/codec/japanese.rs:887:20: 887:24
    let mut _6: u8;                      // in scope 0 at src/codec/japanese.rs:888:21: 888:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/japanese.rs:889:27: 889:40
    let mut _9: u16;                     // in scope 0 at src/codec/japanese.rs:889:28: 889:32
    let mut _10: u16;                    // in scope 0 at src/codec/japanese.rs:889:34: 889:39
    let mut _11: bool;                   // in scope 0 at src/codec/japanese.rs:890:27: 890:38
    let mut _12: bool;                   // in scope 0 at src/codec/japanese.rs:890:27: 890:38
    let mut _13: bool;                   // in scope 0 at src/codec/japanese.rs:890:14: 890:25
    let mut _14: bool;                   // in scope 0 at src/codec/japanese.rs:890:14: 890:25
    let mut _15: u16;                    // in scope 0 at src/codec/japanese.rs:890:43: 890:69
    let mut _16: u16;                    // in scope 0 at src/codec/japanese.rs:890:43: 890:61
    let mut _17: u16;                    // in scope 0 at src/codec/japanese.rs:890:43: 890:56
    let mut _18: u16;                    // in scope 0 at src/codec/japanese.rs:890:44: 890:48
    let mut _19: u16;                    // in scope 0 at src/codec/japanese.rs:890:64: 890:69
    let mut _20: u16;                    // in scope 0 at src/codec/japanese.rs:893:33: 893:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/japanese.rs:887:13: 887:17
        let _5: u16;                     // in scope 1 at src/codec/japanese.rs:888:13: 888:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/japanese.rs:888:13: 888:18
            let _7: u16;                 // in scope 2 at src/codec/japanese.rs:889:13: 889:18
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/japanese.rs:889:13: 889:18
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:887:13: 887:17
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:887:20: 887:24
        _4 = _1;                         // scope 0 at src/codec/japanese.rs:887:20: 887:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/japanese.rs:887:20: 887:31
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:887:30: 887:31
        StorageLive(_5);                 // scope 1 at src/codec/japanese.rs:888:13: 888:18
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:888:21: 888:26
        _6 = _2;                         // scope 1 at src/codec/japanese.rs:888:21: 888:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/japanese.rs:888:21: 888:33
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:888:32: 888:33
        StorageLive(_7);                 // scope 2 at src/codec/japanese.rs:889:13: 889:18
        StorageLive(_8);                 // scope 2 at src/codec/japanese.rs:889:27: 889:40
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:889:28: 889:32
        _9 = _3;                         // scope 2 at src/codec/japanese.rs:889:28: 889:32
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:889:34: 889:39
        _10 = _5;                        // scope 2 at src/codec/japanese.rs:889:34: 889:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/japanese.rs:889:27: 889:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/japanese.rs:889:27: 889:40
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:889:39: 889:40
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:889:39: 889:40
        _13 = Le(const 33_u16, (_8.0: u16)); // scope 2 at src/codec/japanese.rs:890:14: 890:25
        switchInt(move _13) -> [false: bb4, otherwise: bb1]; // scope 2 at src/codec/japanese.rs:890:14: 890:25
    }

    bb1: {
        _14 = Le((_8.0: u16), const 126_u16); // scope 2 at src/codec/japanese.rs:890:14: 890:25
        switchInt(move _14) -> [false: bb4, otherwise: bb2]; // scope 2 at src/codec/japanese.rs:890:14: 890:25
    }

    bb2: {
        _11 = Le(const 33_u16, (_8.1: u16)); // scope 2 at src/codec/japanese.rs:890:27: 890:38
        switchInt(move _11) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/japanese.rs:890:27: 890:38
    }

    bb3: {
        _12 = Le((_8.1: u16), const 126_u16); // scope 2 at src/codec/japanese.rs:890:27: 890:38
        switchInt(move _12) -> [false: bb4, otherwise: bb5]; // scope 2 at src/codec/japanese.rs:890:27: 890:38
    }

    bb4: {
        _7 = const u16::MAX;             // scope 2 at src/codec/japanese.rs:891:18: 891:24
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:891:18: 891:24
    }

    bb5: {
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:890:43: 890:69
        StorageLive(_16);                // scope 2 at src/codec/japanese.rs:890:43: 890:61
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:890:43: 890:56
        StorageLive(_18);                // scope 2 at src/codec/japanese.rs:890:44: 890:48
        _18 = _3;                        // scope 2 at src/codec/japanese.rs:890:44: 890:48
        _17 = Sub(move _18, const 33_u16); // scope 2 at src/codec/japanese.rs:890:43: 890:56
        StorageDead(_18);                // scope 2 at src/codec/japanese.rs:890:55: 890:56
        _16 = Mul(move _17, const 94_u16); // scope 2 at src/codec/japanese.rs:890:43: 890:61
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:890:60: 890:61
        StorageLive(_19);                // scope 2 at src/codec/japanese.rs:890:64: 890:69
        _19 = _5;                        // scope 2 at src/codec/japanese.rs:890:64: 890:69
        _15 = Add(move _16, move _19);   // scope 2 at src/codec/japanese.rs:890:43: 890:69
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:890:68: 890:69
        StorageDead(_16);                // scope 2 at src/codec/japanese.rs:890:68: 890:69
        _7 = Sub(move _15, const 33_u16); // scope 2 at src/codec/japanese.rs:890:43: 890:76
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:890:75: 890:76
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:890:75: 890:76
    }

    bb6: {
        StorageDead(_8);                 // scope 2 at src/codec/japanese.rs:892:10: 892:11
        StorageLive(_20);                // scope 3 at src/codec/japanese.rs:893:33: 893:38
        _20 = _7;                        // scope 3 at src/codec/japanese.rs:893:33: 893:38
        _0 = index_japanese::jis0208::forward(move _20) -> bb7; // scope 3 at src/codec/japanese.rs:893:9: 893:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:893:9: 893:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_japanese::jis0208::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:893:38: 893:39
        StorageDead(_7);                 // scope 2 at src/codec/japanese.rs:894:5: 894:6
        StorageDead(_5);                 // scope 1 at src/codec/japanese.rs:894:5: 894:6
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:894:5: 894:6
        return;                          // scope 0 at src/codec/japanese.rs:894:6: 894:6
    }
}

const WINDOWS_31J: &Windows31JEncoding = {
    let mut _0: &codec::japanese::Windows31JEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const WINDOWS_31J::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::japanese::Windows31JEncoding
                                         // + val: Unevaluated(WINDOWS_31J, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::japanese::Windows31JEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1282 ~ encoding[5d2c]::all::WINDOWS_31J), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in WINDOWS_31J: &Windows31JEncoding = {
    let mut _0: &codec::japanese::Windows31JEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::japanese::Windows31JEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn codec::error::<impl at src/codec/error.rs:24:1: 26:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/error.rs:25:21: 25:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/error.rs:25:39: 25:61
    let mut _2: std::boxed::Box<codec::error::ErrorEncoder>; // in scope 0 at src/codec/error.rs:25:39: 25:61
    let mut _3: codec::error::ErrorEncoder; // in scope 0 at src/codec/error.rs:25:48: 25:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/error.rs:25:39: 25:61
        StorageLive(_2);                 // scope 0 at src/codec/error.rs:25:39: 25:61
        StorageLive(_3);                 // scope 0 at src/codec/error.rs:25:48: 25:60
        _2 = Box::<ErrorEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/error.rs:25:39: 25:61
                                         // mir::Constant
                                         // + span: src/codec/error.rs:25:39: 25:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::error::ErrorEncoder) -> std::boxed::Box<codec::error::ErrorEncoder> {std::boxed::Box::<codec::error::ErrorEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:25:39: 25:61
        StorageDead(_3);                 // scope 0 at src/codec/error.rs:25:60: 25:61
        StorageDead(_2);                 // scope 0 at src/codec/error.rs:25:60: 25:61
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:25:39: 25:61
        StorageDead(_1);                 // scope 0 at src/codec/error.rs:25:62: 25:63
        return;                          // scope 0 at src/codec/error.rs:25:63: 25:63
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:81:10: 81:15>::clone(_1: &UTF8Decoder) -> UTF8Decoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:81:10: 81:15
    let mut _0: codec::utf_8::UTF8Decoder; // return place in scope 0 at src/codec/utf_8.rs:81:10: 81:15
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 3 at src/codec/utf_8.rs:81:10: 81:15
        return;                          // scope 0 at src/codec/utf_8.rs:81:15: 81:15
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:30:1: 35:2>::raw_decoder(_1: &BigFive2003Encoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:34:20: 34:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/tradchinese.rs:34:30: 34:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/tradchinese.rs:34:48: 34:82
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/tradchinese.rs:34:48: 34:82

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:34:48: 34:82
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:34:48: 34:82
        _3 = BigFive2003HKSCS2008Decoder::new() -> bb1; // scope 0 at src/codec/tradchinese.rs:34:48: 34:82
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:34:48: 34:80
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::tradchinese::BigFive2003HKSCS2008Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:34:48: 34:82
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:34:81: 34:82
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:34:48: 34:82
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:34:83: 34:84
        return;                          // scope 0 at src/codec/tradchinese.rs:34:84: 34:84
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:20:1: 25:2>::raw_encoder(_1: &SingleByteEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:23:20: 23:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/singlebyte.rs:23:30: 23:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/singlebyte.rs:23:48: 23:91
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/singlebyte.rs:23:48: 23:91
    let mut _4: fn(u32) -> u8;           // in scope 0 at src/codec/singlebyte.rs:23:71: 23:90

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:23:48: 23:91
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:23:48: 23:91
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:23:71: 23:90
        _4 = ((*_1).3: fn(u32) -> u8);   // scope 0 at src/codec/singlebyte.rs:23:71: 23:90
        _3 = SingleByteEncoder::new(move _4) -> bb1; // scope 0 at src/codec/singlebyte.rs:23:48: 23:91
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:23:48: 23:70
                                         // + literal: Const { ty: fn(fn(u32) -> u8) -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::singlebyte::SingleByteEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:23:48: 23:91
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:23:90: 23:91
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:23:90: 23:91
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:23:48: 23:91
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:23:92: 23:93
        return;                          // scope 0 at src/codec/singlebyte.rs:23:93: 23:93
    }
}

fn japanese::<impl at src/codec/japanese.rs:509:10: 509:15>::clone(_1: &Windows31JDecoder) -> Windows31JDecoder {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:509:10: 509:15
    let mut _0: codec::japanese::Windows31JDecoder; // return place in scope 0 at src/codec/japanese.rs:509:10: 509:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/japanese.rs:509:10: 509:15
        return;                          // scope 0 at src/codec/japanese.rs:509:15: 509:15
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:109:10: 109:15>::clone(_1: &GBEncoder) -> GBEncoder {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:109:10: 109:15
    let mut _0: codec::simpchinese::GBEncoder; // return place in scope 0 at src/codec/simpchinese.rs:109:10: 109:15

    bb0: {
        return;                          // scope 0 at src/codec/simpchinese.rs:109:15: 109:15
    }
}

const ISO_8859_8_I: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:88:70: 88:84
    let _5: &str;                        // in scope 0 at src/all.rs:88:70: 88:84
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_8_I::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8_I, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1289 ~ encoding[5d2c]::all::whatwg::ISO_8859_8_I), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_8_I: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:88:70: 88:84
    let mut _4: &str;                    // in scope 0 at src/all.rs:88:70: 88:84
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-8-i";       // scope 0 at src/all.rs:88:70: 88:84
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:88:70: 88:84
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:88:70: 88:84
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_8::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_8::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_8::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_8::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-8-i"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:88:70: 88:84
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn iso2022jp::State::Lead0212(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as Lead0212).0: ()) = move _1; // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 2;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

// MIR FOR CTFE
fn iso2022jp::State::Lead0212(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as Lead0212).0: ()) = move _1; // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 2;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

fn hz::transient::B1(_1: &mut StatefulDecoderHelper<hz::State, T>) -> hz::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:611:25: 611:28
    let mut _7: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:612:25: 612:28
    let _8: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:613:22: 613:36
    let mut _9: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:613:22: 613:25
    let mut _10: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:613:41: 613:44
    let mut _11: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:614:25: 614:28
    let _12: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:615:19: 615:60
    let mut _13: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:615:19: 615:22
    let mut _14: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:615:65: 615:68
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<hz::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_5) -> [123_u8: bb6, 125_u8: bb8, 126_u8: bb10, 10_u8: bb13, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 3;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb18;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/simpchinese.rs:615:19: 615:60
        StorageLive(_13);                // scope 1 at src/codec/simpchinese.rs:615:19: 615:22
        _13 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:615:19: 615:22
        _12 = StatefulDecoderHelper::<hz::State, T>::backup_and_err(move _13, const 1_usize, const "invalid sequence") -> bb15; // scope 1 at src/codec/simpchinese.rs:615:19: 615:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:615:23: 615:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, usize, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:615:41: 615:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/simpchinese.rs:611:25: 611:28
        _6 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:611:25: 611:28
        _0 = hz::transient::B0::<T>(move _6) -> bb7; // scope 1 at src/codec/simpchinese.rs:611:22: 611:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:611:22: 611:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/simpchinese.rs:611:28: 611:29
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:611:28: 611:29
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/simpchinese.rs:612:25: 612:28
        _7 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:612:25: 612:28
        _0 = hz::transient::A0::<T>(move _7) -> bb9; // scope 1 at src/codec/simpchinese.rs:612:22: 612:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:612:22: 612:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/simpchinese.rs:612:28: 612:29
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:612:28: 612:29
    }

    bb10: {
        StorageLive(_8);                 // scope 1 at src/codec/simpchinese.rs:613:22: 613:36
        StorageLive(_9);                 // scope 1 at src/codec/simpchinese.rs:613:22: 613:25
        _9 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:613:22: 613:25
        _8 = StatefulDecoderHelper::<hz::State, T>::emit(move _9, const 126_u32) -> bb11; // scope 1 at src/codec/simpchinese.rs:613:22: 613:36
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:613:26: 613:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, u32) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_9);                 // scope 1 at src/codec/simpchinese.rs:613:35: 613:36
        StorageDead(_8);                 // scope 1 at src/util.rs:226:72: 226:73
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:613:41: 613:44
        _10 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:613:41: 613:44
        _0 = hz::transient::B0::<T>(move _10) -> bb12; // scope 1 at src/codec/simpchinese.rs:613:38: 613:45
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:613:38: 613:40
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_10);                // scope 1 at src/codec/simpchinese.rs:613:44: 613:45
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:613:44: 613:45
    }

    bb13: {
        StorageLive(_11);                // scope 1 at src/codec/simpchinese.rs:614:25: 614:28
        _11 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:614:25: 614:28
        _0 = hz::transient::A0::<T>(move _11) -> bb14; // scope 1 at src/codec/simpchinese.rs:614:22: 614:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:614:22: 614:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_11);                // scope 1 at src/codec/simpchinese.rs:614:28: 614:29
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:614:28: 614:29
    }

    bb15: {
        StorageDead(_13);                // scope 1 at src/codec/simpchinese.rs:615:59: 615:60
        StorageDead(_12);                // scope 1 at src/util.rs:226:72: 226:73
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:615:65: 615:68
        _14 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:615:65: 615:68
        _0 = hz::transient::B0::<T>(move _14) -> bb16; // scope 1 at src/codec/simpchinese.rs:615:62: 615:69
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:615:62: 615:64
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_14);                // scope 1 at src/codec/simpchinese.rs:615:68: 615:69
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:615:68: 615:69
    }

    bb17: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb18;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb18: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:272:1: 280:2>::raw_feed(_1: &mut UTF16LEDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:274:17: 274:26
    debug input => _2;                   // in scope 0 at src/codec/utf_16.rs:274:28: 274:33
    debug output => _3;                  // in scope 0 at src/codec/utf_16.rs:274:42: 274:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_16.rs:274:72: 274:99
    let mut _4: &mut codec::utf_16::UTF16Decoder; // in scope 0 at src/codec/utf_16.rs:275:9: 275:19
    let mut _5: &[u8];                   // in scope 0 at src/codec/utf_16.rs:275:29: 275:34
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:275:36: 275:42
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:275:36: 275:42
    let mut _8: [closure@src/codec/utf_16.rs:275:44: 275:95]; // in scope 0 at src/codec/utf_16.rs:275:44: 275:95

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:275:9: 275:19
        _4 = &mut ((*_1).0: codec::utf_16::UTF16Decoder); // scope 0 at src/codec/utf_16.rs:275:9: 275:19
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:275:29: 275:34
        _5 = _2;                         // scope 0 at src/codec/utf_16.rs:275:29: 275:34
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:275:36: 275:42
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:275:36: 275:42
        _7 = &mut (*_3);                 // scope 0 at src/codec/utf_16.rs:275:36: 275:42
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:275:36: 275:42
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:275:41: 275:42
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:275:44: 275:95
        _0 = UTF16Decoder::raw_feed::<[closure@src/codec/utf_16.rs:275:44: 275:95]>(move _4, move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/utf_16.rs:275:9: 275:96
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:275:20: 275:28
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut codec::utf_16::UTF16Decoder, &'s [u8], &'t0 mut (dyn encoding_types::StringWriter + 't0), [closure@src/codec/utf_16.rs:275:44: 275:95]) -> (usize, std::option::Option<encoding_types::CodecError>) {codec::utf_16::UTF16Decoder::raw_feed::<[closure@src/codec/utf_16.rs:275:44: 275:95]>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:275:95: 275:96
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:275:95: 275:96
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:275:95: 275:96
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:275:95: 275:96
        return;                          // scope 0 at src/codec/utf_16.rs:276:6: 276:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:541:1: 545:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:542:21: 542:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:543:9: 543:55
    let mut _2: std::boxed::Box<codec::simpchinese::HZDecoder>; // in scope 0 at src/codec/simpchinese.rs:543:9: 543:55
    let mut _3: codec::simpchinese::HZDecoder; // in scope 0 at src/codec/simpchinese.rs:543:18: 543:54
    let mut _4: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:543:34: 543:52

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/simpchinese.rs:543:9: 543:55
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:543:9: 543:55
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:543:18: 543:54
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:543:34: 543:52
        _4 = <hz::State as Default>::default() -> bb1; // scope 0 at src/codec/simpchinese.rs:543:34: 543:52
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:543:34: 543:50
                                         // + literal: Const { ty: fn() -> codec::simpchinese::hz::State {<codec::simpchinese::hz::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::simpchinese::hz::State) = move _4; // scope 0 at src/codec/simpchinese.rs:543:18: 543:54
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:543:53: 543:54
        _2 = Box::<HZDecoder>::new(move _3) -> bb2; // scope 0 at src/codec/simpchinese.rs:543:9: 543:55
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:543:9: 543:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::simpchinese::HZDecoder) -> std::boxed::Box<codec::simpchinese::HZDecoder> {std::boxed::Box::<codec::simpchinese::HZDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:543:9: 543:55
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:543:54: 543:55
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:543:54: 543:55
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:543:9: 543:55
        StorageDead(_1);                 // scope 0 at src/codec/simpchinese.rs:544:5: 544:6
        return;                          // scope 0 at src/codec/simpchinese.rs:544:6: 544:6
    }
}

fn simpchinese::gb18030::State::S3(_1: (), _2: u8, _3: u8, _4: u8) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S3).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).2: u8) = move _3;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).3: u8) = move _4;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 3;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn simpchinese::gb18030::State::S3(_1: (), _2: u8, _3: u8, _4: u8) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S3).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).2: u8) = move _3;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).3: u8) = move _4;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 3;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

const MAC_ROMAN: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:57:75: 57:92
    let mut _4: &str;                    // in scope 0 at src/all.rs:57:80: 57:91
    let _5: &str;                        // in scope 0 at src/all.rs:57:80: 57:91
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const MAC_ROMAN::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_ROMAN, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1265 ~ encoding[5d2c]::all::MAC_ROMAN), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in MAC_ROMAN: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:57:75: 57:92
    let mut _3: &str;                    // in scope 0 at src/all.rs:57:80: 57:91
    let mut _4: &str;                    // in scope 0 at src/all.rs:57:80: 57:91
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "macintosh";          // scope 0 at src/all.rs:57:80: 57:91
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 105, 110, 116, 111, 115, 104], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/all.rs:57:80: 57:91
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 105, 110, 116, 111, 115, 104], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:57:80: 57:91
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:57:75: 57:92
        discriminant(_2) = 1;            // scope 0 at src/all.rs:57:75: 57:92
        _5 = index_singlebyte::macintosh::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::macintosh::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::macintosh::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::macintosh::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "mac-roman"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 45, 114, 111, 109, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/all.rs:57:55: 57:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 45, 114, 111, 109, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:45:1: 76:2>::raw_finish(_1: &mut BigFive2003Encoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:73:19: 73:28
    debug _output => _2;                 // in scope 0 at src/codec/tradchinese.rs:73:30: 73:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/tradchinese.rs:73:59: 73:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/tradchinese.rs:74:9: 74:13
        return;                          // scope 0 at src/codec/tradchinese.rs:75:6: 75:6
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:39:1: 67:2>::raw_feed(_1: &mut SingleByteEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:43:17: 43:26
    debug input => _2;                   // in scope 0 at src/codec/singlebyte.rs:43:28: 43:33
    debug output => _3;                  // in scope 0 at src/codec/singlebyte.rs:43:41: 43:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/singlebyte.rs:43:69: 43:96
    let _4: ();                          // in scope 0 at src/codec/singlebyte.rs:44:9: 44:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/singlebyte.rs:44:9: 44:15
    let mut _6: usize;                   // in scope 0 at src/codec/singlebyte.rs:44:28: 44:39
    let mut _7: &str;                    // in scope 0 at src/codec/singlebyte.rs:44:28: 44:33
    let mut _8: util::StrCharIndexIterator; // in scope 0 at src/codec/singlebyte.rs:46:28: 46:46
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/singlebyte.rs:46:28: 46:46
    let mut _10: &&str;                  // in scope 0 at src/codec/singlebyte.rs:46:28: 46:33
    let mut _11: util::StrCharIndexIterator; // in scope 0 at src/codec/singlebyte.rs:46:28: 46:46
    let mut _13: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/singlebyte.rs:46:28: 46:46
    let mut _14: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/singlebyte.rs:46:28: 46:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/singlebyte.rs:46:28: 46:46
    let mut _16: isize;                  // in scope 0 at src/codec/singlebyte.rs:46:13: 46:24
    let mut _18: ((usize, usize), char); // in scope 0 at src/codec/singlebyte.rs:46:13: 46:24
    let mut _22: bool;                   // in scope 0 at src/codec/singlebyte.rs:47:16: 47:30
    let mut _23: char;                   // in scope 0 at src/codec/singlebyte.rs:47:16: 47:18
    let _24: ();                         // in scope 0 at src/codec/singlebyte.rs:48:17: 48:44
    let mut _25: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/singlebyte.rs:48:17: 48:23
    let mut _26: u8;                     // in scope 0 at src/codec/singlebyte.rs:48:35: 48:43
    let mut _27: char;                   // in scope 0 at src/codec/singlebyte.rs:48:35: 48:37
    let mut _29: fn(u32) -> u8;          // in scope 0 at src/codec/singlebyte.rs:51:29: 51:50
    let mut _30: u32;                    // in scope 0 at src/codec/singlebyte.rs:51:51: 51:60
    let mut _31: char;                   // in scope 0 at src/codec/singlebyte.rs:51:51: 51:53
    let mut _32: u8;                     // in scope 0 at src/codec/singlebyte.rs:52:20: 52:25
    let _33: ();                         // in scope 0 at src/codec/singlebyte.rs:53:21: 53:45
    let mut _34: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/singlebyte.rs:53:21: 53:27
    let mut _35: u8;                     // in scope 0 at src/codec/singlebyte.rs:53:39: 53:44
    let mut _36: usize;                  // in scope 0 at src/codec/singlebyte.rs:55:29: 55:30
    let mut _37: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/singlebyte.rs:55:32: 57:23
    let mut _38: encoding_types::CodecError; // in scope 0 at src/codec/singlebyte.rs:55:37: 57:22
    let mut _39: isize;                  // in scope 0 at src/codec/singlebyte.rs:56:31: 56:41
    let mut _40: usize;                  // in scope 0 at src/codec/singlebyte.rs:56:31: 56:32
    let mut _41: std::borrow::Cow<str>;  // in scope 0 at src/codec/singlebyte.rs:56:50: 56:84
    let mut _42: &str;                   // in scope 0 at src/codec/singlebyte.rs:56:50: 56:77
    let _43: &str;                       // in scope 0 at src/codec/singlebyte.rs:56:50: 56:77
    let mut _44: usize;                  // in scope 0 at src/codec/singlebyte.rs:61:10: 61:21
    let mut _45: &str;                   // in scope 0 at src/codec/singlebyte.rs:61:10: 61:15
    let mut _46: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/singlebyte.rs:61:23: 61:27
    scope 1 {
        debug iter => _11;               // in scope 1 at src/codec/singlebyte.rs:46:28: 46:46
        let mut _12: ((usize, usize), char); // in scope 1 at src/codec/singlebyte.rs:46:28: 46:46
        scope 2 {
            debug __next => _12;         // in scope 2 at src/codec/singlebyte.rs:46:28: 46:46
            let _17: ((usize, usize), char); // in scope 2 at src/codec/singlebyte.rs:46:13: 46:24
            let _19: usize;              // in scope 2 at src/codec/singlebyte.rs:46:15: 46:16
            let _20: usize;              // in scope 2 at src/codec/singlebyte.rs:46:17: 46:18
            let _21: char;               // in scope 2 at src/codec/singlebyte.rs:46:21: 46:23
            scope 3 {
                debug val => _17;        // in scope 3 at src/codec/singlebyte.rs:46:13: 46:24
            }
            scope 4 {
                debug i => _19;          // in scope 4 at src/codec/singlebyte.rs:46:15: 46:16
                debug j => _20;          // in scope 4 at src/codec/singlebyte.rs:46:17: 46:18
                debug ch => _21;         // in scope 4 at src/codec/singlebyte.rs:46:21: 46:23
                let _28: u8;             // in scope 4 at src/codec/singlebyte.rs:51:21: 51:26
                scope 5 {
                    debug index => _28;  // in scope 5 at src/codec/singlebyte.rs:51:21: 51:26
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:44:9: 44:40
        StorageLive(_5);                 // scope 0 at src/codec/singlebyte.rs:44:9: 44:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/singlebyte.rs:44:9: 44:15
        StorageLive(_6);                 // scope 0 at src/codec/singlebyte.rs:44:28: 44:39
        StorageLive(_7);                 // scope 0 at src/codec/singlebyte.rs:44:28: 44:33
        _7 = _2;                         // scope 0 at src/codec/singlebyte.rs:44:28: 44:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/singlebyte.rs:44:28: 44:39
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:44:34: 44:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/singlebyte.rs:44:38: 44:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/singlebyte.rs:44:9: 44:40
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:44:16: 44:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/singlebyte.rs:44:39: 44:40
        StorageDead(_5);                 // scope 0 at src/codec/singlebyte.rs:44:39: 44:40
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:44:40: 44:41
        StorageLive(_8);                 // scope 0 at src/codec/singlebyte.rs:46:28: 46:46
        StorageLive(_9);                 // scope 0 at src/codec/singlebyte.rs:46:28: 46:46
        StorageLive(_10);                // scope 0 at src/codec/singlebyte.rs:46:28: 46:33
        _10 = &_2;                       // scope 0 at src/codec/singlebyte.rs:46:28: 46:33
        _9 = <&str as StrCharIndex>::index_iter(move _10) -> bb3; // scope 0 at src/codec/singlebyte.rs:46:28: 46:46
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:46:34: 46:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_10);                // scope 0 at src/codec/singlebyte.rs:46:45: 46:46
        _8 = <StrCharIndexIterator as IntoIterator>::into_iter(move _9) -> bb4; // scope 0 at src/codec/singlebyte.rs:46:28: 46:46
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:46:28: 46:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_9);                 // scope 0 at src/codec/singlebyte.rs:46:45: 46:46
        StorageLive(_11);                // scope 0 at src/codec/singlebyte.rs:46:28: 46:46
        _11 = move _8;                   // scope 0 at src/codec/singlebyte.rs:46:28: 46:46
        goto -> bb5;                     // scope 1 at src/codec/singlebyte.rs:46:9: 60:10
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/singlebyte.rs:46:28: 46:46
        StorageLive(_13);                // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
        StorageLive(_14);                // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
        StorageLive(_15);                // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
        _15 = &mut _11;                  // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
        _14 = &mut (*_15);               // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
        _13 = <StrCharIndexIterator as Iterator>::next(move _14) -> bb6; // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:46:28: 46:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_14);                // scope 2 at src/codec/singlebyte.rs:46:45: 46:46
        _16 = discriminant(_13);         // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
        switchInt(move _16) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
    }

    bb7: {
        StorageDead(_15);                // scope 2 at src/codec/singlebyte.rs:46:45: 46:46
        StorageDead(_13);                // scope 2 at src/codec/singlebyte.rs:46:45: 46:46
        StorageDead(_12);                // scope 1 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_11);                // scope 0 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_8);                 // scope 0 at src/codec/singlebyte.rs:46:45: 46:46
        StorageLive(_44);                // scope 0 at src/codec/singlebyte.rs:61:10: 61:21
        StorageLive(_45);                // scope 0 at src/codec/singlebyte.rs:61:10: 61:15
        _45 = _2;                        // scope 0 at src/codec/singlebyte.rs:61:10: 61:15
        _44 = core::str::<impl str>::len(move _45) -> bb18; // scope 0 at src/codec/singlebyte.rs:61:10: 61:21
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:61:16: 61:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/singlebyte.rs:46:28: 46:46
    }

    bb9: {
        StorageLive(_17);                // scope 2 at src/codec/singlebyte.rs:46:13: 46:24
        _17 = ((_13 as Some).0: ((usize, usize), char)); // scope 2 at src/codec/singlebyte.rs:46:13: 46:24
        StorageLive(_18);                // scope 3 at src/codec/singlebyte.rs:46:13: 46:24
        _18 = _17;                       // scope 3 at src/codec/singlebyte.rs:46:13: 46:24
        _12 = move _18;                  // scope 3 at src/codec/singlebyte.rs:46:13: 46:24
        StorageDead(_18);                // scope 3 at src/codec/singlebyte.rs:46:23: 46:24
        StorageDead(_17);                // scope 2 at src/codec/singlebyte.rs:46:23: 46:24
        StorageDead(_15);                // scope 2 at src/codec/singlebyte.rs:46:45: 46:46
        StorageDead(_13);                // scope 2 at src/codec/singlebyte.rs:46:45: 46:46
        StorageLive(_19);                // scope 2 at src/codec/singlebyte.rs:46:15: 46:16
        _19 = ((_12.0: (usize, usize)).0: usize); // scope 2 at src/codec/singlebyte.rs:46:15: 46:16
        StorageLive(_20);                // scope 2 at src/codec/singlebyte.rs:46:17: 46:18
        _20 = ((_12.0: (usize, usize)).1: usize); // scope 2 at src/codec/singlebyte.rs:46:17: 46:18
        StorageLive(_21);                // scope 2 at src/codec/singlebyte.rs:46:21: 46:23
        _21 = (_12.1: char);             // scope 2 at src/codec/singlebyte.rs:46:21: 46:23
        StorageLive(_22);                // scope 4 at src/codec/singlebyte.rs:47:16: 47:30
        StorageLive(_23);                // scope 4 at src/codec/singlebyte.rs:47:16: 47:18
        _23 = _21;                       // scope 4 at src/codec/singlebyte.rs:47:16: 47:18
        _22 = Le(move _23, const '\u{7f}'); // scope 4 at src/codec/singlebyte.rs:47:16: 47:30
        StorageDead(_23);                // scope 4 at src/codec/singlebyte.rs:47:29: 47:30
        switchInt(move _22) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/singlebyte.rs:47:16: 47:30
    }

    bb10: {
        StorageLive(_24);                // scope 4 at src/codec/singlebyte.rs:48:17: 48:44
        StorageLive(_25);                // scope 4 at src/codec/singlebyte.rs:48:17: 48:23
        _25 = &mut (*_3);                // scope 4 at src/codec/singlebyte.rs:48:17: 48:23
        StorageLive(_26);                // scope 4 at src/codec/singlebyte.rs:48:35: 48:43
        StorageLive(_27);                // scope 4 at src/codec/singlebyte.rs:48:35: 48:37
        _27 = _21;                       // scope 4 at src/codec/singlebyte.rs:48:35: 48:37
        _26 = move _27 as u8 (Misc);     // scope 4 at src/codec/singlebyte.rs:48:35: 48:43
        StorageDead(_27);                // scope 4 at src/codec/singlebyte.rs:48:42: 48:43
        _24 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _25, move _26) -> bb12; // scope 4 at src/codec/singlebyte.rs:48:17: 48:44
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:48:24: 48:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageLive(_28);                // scope 4 at src/codec/singlebyte.rs:51:21: 51:26
        StorageLive(_29);                // scope 4 at src/codec/singlebyte.rs:51:29: 51:50
        _29 = ((*_1).0: fn(u32) -> u8);  // scope 4 at src/codec/singlebyte.rs:51:29: 51:50
        StorageLive(_30);                // scope 4 at src/codec/singlebyte.rs:51:51: 51:60
        StorageLive(_31);                // scope 4 at src/codec/singlebyte.rs:51:51: 51:53
        _31 = _21;                       // scope 4 at src/codec/singlebyte.rs:51:51: 51:53
        _30 = move _31 as u32 (Misc);    // scope 4 at src/codec/singlebyte.rs:51:51: 51:60
        StorageDead(_31);                // scope 4 at src/codec/singlebyte.rs:51:59: 51:60
        _28 = move _29(move _30) -> bb13; // scope 4 at src/codec/singlebyte.rs:51:29: 51:61
    }

    bb12: {
        StorageDead(_26);                // scope 4 at src/codec/singlebyte.rs:48:43: 48:44
        StorageDead(_25);                // scope 4 at src/codec/singlebyte.rs:48:43: 48:44
        StorageDead(_24);                // scope 4 at src/codec/singlebyte.rs:48:44: 48:45
        StorageDead(_22);                // scope 4 at src/codec/singlebyte.rs:59:13: 59:14
        StorageDead(_21);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_20);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_19);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_12);                // scope 1 at src/codec/singlebyte.rs:60:9: 60:10
        goto -> bb5;                     // scope 1 at no-location
    }

    bb13: {
        StorageDead(_30);                // scope 4 at src/codec/singlebyte.rs:51:60: 51:61
        StorageDead(_29);                // scope 4 at src/codec/singlebyte.rs:51:60: 51:61
        StorageLive(_32);                // scope 5 at src/codec/singlebyte.rs:52:20: 52:25
        _32 = _28;                       // scope 5 at src/codec/singlebyte.rs:52:20: 52:25
        switchInt(move _32) -> [0_u8: bb16, otherwise: bb14]; // scope 5 at src/codec/singlebyte.rs:52:20: 52:30
    }

    bb14: {
        StorageDead(_32);                // scope 5 at src/codec/singlebyte.rs:52:20: 52:30
        StorageLive(_33);                // scope 5 at src/codec/singlebyte.rs:53:21: 53:45
        StorageLive(_34);                // scope 5 at src/codec/singlebyte.rs:53:21: 53:27
        _34 = &mut (*_3);                // scope 5 at src/codec/singlebyte.rs:53:21: 53:27
        StorageLive(_35);                // scope 5 at src/codec/singlebyte.rs:53:39: 53:44
        _35 = _28;                       // scope 5 at src/codec/singlebyte.rs:53:39: 53:44
        _33 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _34, move _35) -> bb15; // scope 5 at src/codec/singlebyte.rs:53:21: 53:45
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:53:28: 53:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_35);                // scope 5 at src/codec/singlebyte.rs:53:44: 53:45
        StorageDead(_34);                // scope 5 at src/codec/singlebyte.rs:53:44: 53:45
        StorageDead(_33);                // scope 5 at src/codec/singlebyte.rs:53:45: 53:46
        StorageDead(_28);                // scope 4 at src/codec/singlebyte.rs:59:13: 59:14
        StorageDead(_22);                // scope 4 at src/codec/singlebyte.rs:59:13: 59:14
        StorageDead(_21);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_20);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_19);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_12);                // scope 1 at src/codec/singlebyte.rs:60:9: 60:10
        goto -> bb5;                     // scope 1 at src/codec/singlebyte.rs:46:9: 60:10
    }

    bb16: {
        StorageDead(_32);                // scope 5 at src/codec/singlebyte.rs:52:20: 52:30
        StorageLive(_36);                // scope 5 at src/codec/singlebyte.rs:55:29: 55:30
        _36 = _19;                       // scope 5 at src/codec/singlebyte.rs:55:29: 55:30
        StorageLive(_37);                // scope 5 at src/codec/singlebyte.rs:55:32: 57:23
        StorageLive(_38);                // scope 5 at src/codec/singlebyte.rs:55:37: 57:22
        StorageLive(_39);                // scope 5 at src/codec/singlebyte.rs:56:31: 56:41
        StorageLive(_40);                // scope 5 at src/codec/singlebyte.rs:56:31: 56:32
        _40 = _20;                       // scope 5 at src/codec/singlebyte.rs:56:31: 56:32
        _39 = move _40 as isize (Misc);  // scope 5 at src/codec/singlebyte.rs:56:31: 56:41
        StorageDead(_40);                // scope 5 at src/codec/singlebyte.rs:56:40: 56:41
        StorageLive(_41);                // scope 5 at src/codec/singlebyte.rs:56:50: 56:84
        StorageLive(_42);                // scope 5 at src/codec/singlebyte.rs:56:50: 56:77
        StorageLive(_43);                // scope 5 at src/codec/singlebyte.rs:56:50: 56:77
        _43 = const "unrepresentable character"; // scope 5 at src/codec/singlebyte.rs:56:50: 56:77
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:56:50: 56:77
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _42 = _43;                       // scope 5 at src/codec/singlebyte.rs:56:50: 56:77
        _41 = <&str as Into<Cow<str>>>::into(move _42) -> bb17; // scope 5 at src/codec/singlebyte.rs:56:50: 56:84
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:56:78: 56:82
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_42);                // scope 5 at src/codec/singlebyte.rs:56:83: 56:84
        (_38.0: isize) = move _39;       // scope 5 at src/codec/singlebyte.rs:55:37: 57:22
        (_38.1: std::borrow::Cow<str>) = move _41; // scope 5 at src/codec/singlebyte.rs:55:37: 57:22
        StorageDead(_41);                // scope 5 at src/codec/singlebyte.rs:57:21: 57:22
        StorageDead(_39);                // scope 5 at src/codec/singlebyte.rs:57:21: 57:22
        ((_37 as Some).0: encoding_types::CodecError) = move _38; // scope 5 at src/codec/singlebyte.rs:55:32: 57:23
        discriminant(_37) = 1;           // scope 5 at src/codec/singlebyte.rs:55:32: 57:23
        StorageDead(_38);                // scope 5 at src/codec/singlebyte.rs:57:22: 57:23
        (_0.0: usize) = move _36;        // scope 5 at src/codec/singlebyte.rs:55:28: 57:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _37; // scope 5 at src/codec/singlebyte.rs:55:28: 57:24
        StorageDead(_37);                // scope 5 at src/codec/singlebyte.rs:57:23: 57:24
        StorageDead(_36);                // scope 5 at src/codec/singlebyte.rs:57:23: 57:24
        StorageDead(_43);                // scope 5 at src/codec/singlebyte.rs:57:24: 57:25
        StorageDead(_28);                // scope 4 at src/codec/singlebyte.rs:59:13: 59:14
        StorageDead(_22);                // scope 4 at src/codec/singlebyte.rs:59:13: 59:14
        StorageDead(_21);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_20);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_19);                // scope 2 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_12);                // scope 1 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_11);                // scope 0 at src/codec/singlebyte.rs:60:9: 60:10
        StorageDead(_8);                 // scope 0 at src/codec/singlebyte.rs:46:45: 46:46
        goto -> bb19;                    // scope 0 at src/codec/singlebyte.rs:62:6: 62:6
    }

    bb18: {
        StorageDead(_45);                // scope 0 at src/codec/singlebyte.rs:61:20: 61:21
        StorageLive(_46);                // scope 0 at src/codec/singlebyte.rs:61:23: 61:27
        discriminant(_46) = 0;           // scope 0 at src/codec/singlebyte.rs:61:23: 61:27
        (_0.0: usize) = move _44;        // scope 0 at src/codec/singlebyte.rs:61:9: 61:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _46; // scope 0 at src/codec/singlebyte.rs:61:9: 61:28
        StorageDead(_46);                // scope 0 at src/codec/singlebyte.rs:61:27: 61:28
        StorageDead(_44);                // scope 0 at src/codec/singlebyte.rs:61:27: 61:28
        goto -> bb19;                    // scope 0 at src/codec/singlebyte.rs:62:6: 62:6
    }

    bb19: {
        return;                          // scope 0 at src/codec/singlebyte.rs:62:6: 62:6
    }
}

fn windows949::<impl at src/util.rs:168:13: 170:14>::default() -> windows949::State {
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn util::<impl at src/util.rs:46:1: 51:2>::index_iter(_1: &&str) -> StrCharIndexIterator {
    debug self => _1;                    // in scope 0 at src/util.rs:48:19: 48:24
    let mut _0: util::StrCharIndexIterator; // return place in scope 0 at src/util.rs:48:29: 48:53
    let mut _2: std::str::Chars;         // in scope 0 at src/util.rs:49:49: 49:61
    let mut _3: &str;                    // in scope 0 at src/util.rs:49:49: 49:53

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:49:49: 49:61
        StorageLive(_3);                 // scope 0 at src/util.rs:49:49: 49:53
        _3 = (*_1);                      // scope 0 at src/util.rs:49:49: 49:53
        _2 = core::str::<impl str>::chars(move _3) -> bb1; // scope 0 at src/util.rs:49:49: 49:61
                                         // mir::Constant
                                         // + span: src/util.rs:49:54: 49:59
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> std::str::Chars<'r> {core::str::<impl str>::chars}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:49:60: 49:61
        (_0.0: usize) = const 0_usize;   // scope 0 at src/util.rs:49:9: 49:63
        (_0.1: std::str::Chars) = move _2; // scope 0 at src/util.rs:49:9: 49:63
        StorageDead(_2);                 // scope 0 at src/util.rs:49:62: 49:63
        return;                          // scope 0 at src/util.rs:50:6: 50:6
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:141:1: 209:2>::raw_finish(_1: &mut UTF8Decoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:197:19: 197:28
    debug _output => _2;                 // in scope 0 at src/codec/utf_8.rs:197:30: 197:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_8.rs:197:61: 197:79
    let _3: u8;                          // in scope 0 at src/codec/utf_8.rs:198:13: 198:18
    let mut _5: u8;                      // in scope 0 at src/codec/utf_8.rs:200:22: 200:35
    let mut _6: bool;                    // in scope 0 at src/codec/utf_8.rs:202:12: 202:33
    let mut _7: u8;                      // in scope 0 at src/codec/utf_8.rs:202:12: 202:17
    let mut _8: u8;                      // in scope 0 at src/codec/utf_8.rs:202:21: 202:33
    let mut _9: encoding_types::CodecError; // in scope 0 at src/codec/utf_8.rs:203:18: 203:77
    let mut _10: std::borrow::Cow<str>;  // in scope 0 at src/codec/utf_8.rs:203:47: 203:75
    let mut _11: &str;                   // in scope 0 at src/codec/utf_8.rs:203:47: 203:68
    let _12: &str;                       // in scope 0 at src/codec/utf_8.rs:203:47: 203:68
    let mut _13: bool;                   // in scope 0 at src/codec/utf_8.rs:205:13: 205:36
    let mut _14: bool;                   // in scope 0 at src/codec/utf_8.rs:205:21: 205:34
    let mut _15: usize;                  // in scope 0 at src/codec/utf_8.rs:205:21: 205:29
    scope 1 {
        debug state => _3;               // in scope 1 at src/codec/utf_8.rs:198:13: 198:18
        let _4: usize;                   // in scope 1 at src/codec/utf_8.rs:199:13: 199:21
        scope 2 {
            debug queuelen => _4;        // in scope 2 at src/codec/utf_8.rs:199:13: 199:21
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:198:13: 198:18
        _3 = ((*_1).2: u8);              // scope 0 at src/codec/utf_8.rs:198:21: 198:31
        StorageLive(_4);                 // scope 1 at src/codec/utf_8.rs:199:13: 199:21
        _4 = ((*_1).0: usize);           // scope 1 at src/codec/utf_8.rs:199:24: 199:37
        StorageLive(_5);                 // scope 2 at src/codec/utf_8.rs:200:22: 200:35
        _5 = const 0_u8;                 // scope 2 at src/codec/utf_8.rs:200:22: 200:35
        ((*_1).2: u8) = move _5;         // scope 2 at src/codec/utf_8.rs:200:9: 200:35
        StorageDead(_5);                 // scope 2 at src/codec/utf_8.rs:200:34: 200:35
        ((*_1).0: usize) = const 0_usize; // scope 2 at src/codec/utf_8.rs:201:9: 201:26
        StorageLive(_6);                 // scope 2 at src/codec/utf_8.rs:202:12: 202:33
        StorageLive(_7);                 // scope 2 at src/codec/utf_8.rs:202:12: 202:17
        _7 = _3;                         // scope 2 at src/codec/utf_8.rs:202:12: 202:17
        StorageLive(_8);                 // scope 2 at src/codec/utf_8.rs:202:21: 202:33
        _8 = const 0_u8;                 // scope 2 at src/codec/utf_8.rs:202:21: 202:33
        _6 = Ne(move _7, move _8);       // scope 2 at src/codec/utf_8.rs:202:12: 202:33
        StorageDead(_8);                 // scope 2 at src/codec/utf_8.rs:202:32: 202:33
        StorageDead(_7);                 // scope 2 at src/codec/utf_8.rs:202:32: 202:33
        switchInt(move _6) -> [false: bb3, otherwise: bb1]; // scope 2 at src/codec/utf_8.rs:202:12: 202:33
    }

    bb1: {
        StorageLive(_9);                 // scope 2 at src/codec/utf_8.rs:203:18: 203:77
        StorageLive(_10);                // scope 2 at src/codec/utf_8.rs:203:47: 203:75
        StorageLive(_11);                // scope 2 at src/codec/utf_8.rs:203:47: 203:68
        StorageLive(_12);                // scope 2 at src/codec/utf_8.rs:203:47: 203:68
        _12 = const "incomplete sequence"; // scope 2 at src/codec/utf_8.rs:203:47: 203:68
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:203:47: 203:68
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
        _11 = _12;                       // scope 2 at src/codec/utf_8.rs:203:47: 203:68
        _10 = <&str as Into<Cow<str>>>::into(move _11) -> bb2; // scope 2 at src/codec/utf_8.rs:203:47: 203:75
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:203:69: 203:73
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_11);                // scope 2 at src/codec/utf_8.rs:203:74: 203:75
        (_9.0: isize) = const 0_isize;   // scope 2 at src/codec/utf_8.rs:203:18: 203:77
        (_9.1: std::borrow::Cow<str>) = move _10; // scope 2 at src/codec/utf_8.rs:203:18: 203:77
        StorageDead(_10);                // scope 2 at src/codec/utf_8.rs:203:76: 203:77
        ((_0 as Some).0: encoding_types::CodecError) = move _9; // scope 2 at src/codec/utf_8.rs:203:13: 203:78
        discriminant(_0) = 1;            // scope 2 at src/codec/utf_8.rs:203:13: 203:78
        StorageDead(_9);                 // scope 2 at src/codec/utf_8.rs:203:77: 203:78
        StorageDead(_12);                // scope 2 at src/codec/utf_8.rs:204:9: 204:10
        goto -> bb6;                     // scope 2 at src/codec/utf_8.rs:202:9: 207:10
    }

    bb3: {
        StorageLive(_13);                // scope 2 at src/codec/utf_8.rs:205:13: 205:36
        StorageLive(_14);                // scope 2 at src/codec/utf_8.rs:205:21: 205:34
        StorageLive(_15);                // scope 2 at src/codec/utf_8.rs:205:21: 205:29
        _15 = _4;                        // scope 2 at src/codec/utf_8.rs:205:21: 205:29
        _14 = Eq(move _15, const 0_usize); // scope 2 at src/codec/utf_8.rs:205:21: 205:34
        StorageDead(_15);                // scope 2 at src/codec/utf_8.rs:205:33: 205:34
        _13 = Not(move _14);             // scope 2 at src/codec/utf_8.rs:205:13: 205:36
        StorageDead(_14);                // scope 2 at src/codec/utf_8.rs:205:35: 205:36
        switchInt(move _13) -> [false: bb5, otherwise: bb4]; // scope 2 at src/codec/utf_8.rs:205:13: 205:36
    }

    bb4: {
        core::panicking::panic(const "assertion failed: queuelen == 0"); // scope 2 at src/codec/utf_8.rs:205:13: 205:36
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:205:13: 205:36
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 113, 117, 101, 117, 101, 108, 101, 110, 32, 61, 61, 32, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 113, 117, 101, 117, 101, 108, 101, 110, 32, 61, 61, 32, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }
    }

    bb5: {
        StorageDead(_13);                // scope 2 at src/codec/utf_8.rs:205:35: 205:36
        discriminant(_0) = 0;            // scope 2 at src/codec/utf_8.rs:206:13: 206:17
        goto -> bb6;                     // scope 2 at src/codec/utf_8.rs:202:9: 207:10
    }

    bb6: {
        StorageDead(_6);                 // scope 2 at src/codec/utf_8.rs:207:9: 207:10
        StorageDead(_4);                 // scope 1 at src/codec/utf_8.rs:208:5: 208:6
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:208:5: 208:6
        return;                          // scope 0 at src/codec/utf_8.rs:208:6: 208:6
    }
}

fn iso2022jp::transient::EscapeFinal(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:973:31: 973:34
    let mut _7: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:974:19: 974:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_5) -> [68_u8: bb6, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 7;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb10;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:974:19: 974:22
        _7 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:974:19: 974:22
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::backup_and_err(move _7, const 3_usize, const "invalid sequence") -> bb8; // scope 1 at src/codec/japanese.rs:974:19: 974:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:974:23: 974:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, usize, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:974:41: 974:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:973:31: 973:34
        _6 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:973:31: 973:34
        _0 = iso2022jp::transient::Lead0212::<T>(move _6) -> bb7; // scope 1 at src/codec/japanese.rs:973:22: 973:35
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:973:22: 973:30
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Lead0212::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:973:34: 973:35
        goto -> bb9;                     // scope 1 at src/codec/japanese.rs:973:34: 973:35
    }

    bb8: {
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:974:59: 974:60
        goto -> bb9;                     // scope 1 at src/codec/japanese.rs:974:59: 974:60
    }

    bb9: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb10;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb10: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn simpchinese::gb18030::<impl at src/util.rs:157:22: 157:31>::eq(_1: &simpchinese::gb18030::State, _2: &simpchinese::gb18030::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::simpchinese::gb18030::State, &codec::simpchinese::gb18030::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _24: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _26: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _27: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _28: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _29: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _36: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _37: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _38: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _39: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _40: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _41: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _42: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _43: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _44: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _45: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _54: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _55: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _56: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _57: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _58: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _59: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _60: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _61: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _62: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _63: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _64: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _65: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _66: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _67: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _22: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _23: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _30: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _31: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _32: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _33: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _34: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _35: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _46: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _47: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _48: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _49: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _50: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _51: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _52: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _53: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _20;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _21;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _22;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _23;  // in scope 3 at src/util.rs:164:32: 164:35
            }
            scope 4 {
                debug __self_0 => _30;   // in scope 4 at src/util.rs:164:25: 164:27
                debug __self_1 => _31;   // in scope 4 at src/util.rs:164:32: 164:35
                debug __self_2 => _32;   // in scope 4 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _33;  // in scope 4 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _34;  // in scope 4 at src/util.rs:164:32: 164:35
                debug __arg_1_2 => _35;  // in scope 4 at src/util.rs:164:32: 164:35
            }
            scope 5 {
                debug __self_0 => _46;   // in scope 5 at src/util.rs:164:25: 164:27
                debug __self_1 => _47;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __self_2 => _48;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __self_3 => _49;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _50;  // in scope 5 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _51;  // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_2 => _52;  // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_3 => _53;  // in scope 5 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb31, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::simpchinese::gb18030::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::simpchinese::gb18030::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _19 = discriminant((*(_13.0: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb6, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb19, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 2 at src/util.rs:164:25: 164:27
        _22 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 2 at src/util.rs:164:32: 164:35
        _23 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_25);                // scope 3 at src/util.rs:164:25: 164:27
        _25 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_26);                // scope 3 at src/util.rs:164:25: 164:27
        _26 = _22;                       // scope 3 at src/util.rs:164:25: 164:27
        _24 = <() as PartialEq>::eq(move _25, move _26) -> bb10; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        _0 = const false;                // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb9;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb8: {
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_28);                // scope 3 at src/util.rs:164:32: 164:35
        _28 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_29);                // scope 3 at src/util.rs:164:32: 164:35
        _29 = (*_23);                    // scope 3 at src/util.rs:164:32: 164:35
        _27 = Eq(move _28, move _29);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_29);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_28);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _27;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb9;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_24);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_23);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_22);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb10: {
        StorageDead(_26);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_25);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _24) -> [false: bb7, otherwise: bb8]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb11: {
        StorageLive(_30);                // scope 2 at src/util.rs:164:25: 164:27
        _30 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_31);                // scope 2 at src/util.rs:164:32: 164:35
        _31 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_32);                // scope 2 at src/util.rs:164:32: 164:35
        _32 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S2).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_33);                // scope 2 at src/util.rs:164:25: 164:27
        _33 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_34);                // scope 2 at src/util.rs:164:32: 164:35
        _34 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_35);                // scope 2 at src/util.rs:164:32: 164:35
        _35 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S2).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_36);                // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_37);                // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_38);                // scope 4 at src/util.rs:164:25: 164:27
        _38 = _30;                       // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_39);                // scope 4 at src/util.rs:164:25: 164:27
        _39 = _33;                       // scope 4 at src/util.rs:164:25: 164:27
        _37 = <() as PartialEq>::eq(move _38, move _39) -> bb18; // scope 4 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        _0 = const false;                // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb13: {
        StorageLive(_43);                // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_44);                // scope 4 at src/util.rs:164:32: 164:35
        _44 = (*_32);                    // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_45);                // scope 4 at src/util.rs:164:32: 164:35
        _45 = (*_35);                    // scope 4 at src/util.rs:164:32: 164:35
        _43 = Eq(move _44, move _45);    // scope 4 at src/util.rs:164:32: 164:35
        StorageDead(_45);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_44);                // scope 4 at src/util.rs:164:34: 164:35
        _0 = move _43;                   // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb14: {
        StorageDead(_43);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_36);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_35);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_34);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_33);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_32);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_31);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb15: {
        _36 = const false;               // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb17;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb16: {
        StorageLive(_40);                // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_41);                // scope 4 at src/util.rs:164:32: 164:35
        _41 = (*_31);                    // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_42);                // scope 4 at src/util.rs:164:32: 164:35
        _42 = (*_34);                    // scope 4 at src/util.rs:164:32: 164:35
        _40 = Eq(move _41, move _42);    // scope 4 at src/util.rs:164:32: 164:35
        StorageDead(_42);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_41);                // scope 4 at src/util.rs:164:34: 164:35
        _36 = move _40;                  // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb17;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb17: {
        StorageDead(_40);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_37);                // scope 4 at src/util.rs:164:34: 164:35
        switchInt(move _36) -> [false: bb12, otherwise: bb13]; // scope 4 at src/util.rs:164:32: 164:35
    }

    bb18: {
        StorageDead(_39);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_38);                // scope 4 at src/util.rs:164:26: 164:27
        switchInt(move _37) -> [false: bb15, otherwise: bb16]; // scope 4 at src/util.rs:164:32: 164:35
    }

    bb19: {
        StorageLive(_46);                // scope 2 at src/util.rs:164:25: 164:27
        _46 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_47);                // scope 2 at src/util.rs:164:32: 164:35
        _47 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_48);                // scope 2 at src/util.rs:164:32: 164:35
        _48 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_49);                // scope 2 at src/util.rs:164:32: 164:35
        _49 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).3: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_50);                // scope 2 at src/util.rs:164:25: 164:27
        _50 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_51);                // scope 2 at src/util.rs:164:32: 164:35
        _51 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_52);                // scope 2 at src/util.rs:164:32: 164:35
        _52 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_53);                // scope 2 at src/util.rs:164:32: 164:35
        _53 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).3: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_54);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_55);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_56);                // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_57);                // scope 5 at src/util.rs:164:25: 164:27
        _57 = _46;                       // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_58);                // scope 5 at src/util.rs:164:25: 164:27
        _58 = _50;                       // scope 5 at src/util.rs:164:25: 164:27
        _56 = <() as PartialEq>::eq(move _57, move _58) -> bb29; // scope 5 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        _0 = const false;                // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb22;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb21: {
        StorageLive(_65);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_66);                // scope 5 at src/util.rs:164:32: 164:35
        _66 = (*_49);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_67);                // scope 5 at src/util.rs:164:32: 164:35
        _67 = (*_53);                    // scope 5 at src/util.rs:164:32: 164:35
        _65 = Eq(move _66, move _67);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_67);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_66);                // scope 5 at src/util.rs:164:34: 164:35
        _0 = move _65;                   // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb22;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb22: {
        StorageDead(_65);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_54);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_53);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_52);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_51);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_50);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_49);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_48);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_47);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_46);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb23: {
        _54 = const false;               // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb25;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb24: {
        StorageLive(_62);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_63);                // scope 5 at src/util.rs:164:32: 164:35
        _63 = (*_48);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_64);                // scope 5 at src/util.rs:164:32: 164:35
        _64 = (*_52);                    // scope 5 at src/util.rs:164:32: 164:35
        _62 = Eq(move _63, move _64);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_64);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_63);                // scope 5 at src/util.rs:164:34: 164:35
        _54 = move _62;                  // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb25;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb25: {
        StorageDead(_62);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_55);                // scope 5 at src/util.rs:164:34: 164:35
        switchInt(move _54) -> [false: bb20, otherwise: bb21]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb26: {
        _55 = const false;               // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb28;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb27: {
        StorageLive(_59);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_60);                // scope 5 at src/util.rs:164:32: 164:35
        _60 = (*_47);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_61);                // scope 5 at src/util.rs:164:32: 164:35
        _61 = (*_51);                    // scope 5 at src/util.rs:164:32: 164:35
        _59 = Eq(move _60, move _61);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_61);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_60);                // scope 5 at src/util.rs:164:34: 164:35
        _55 = move _59;                  // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb28;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb28: {
        StorageDead(_59);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_56);                // scope 5 at src/util.rs:164:34: 164:35
        switchInt(move _55) -> [false: bb23, otherwise: bb24]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb29: {
        StorageDead(_58);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_57);                // scope 5 at src/util.rs:164:26: 164:27
        switchInt(move _56) -> [false: bb26, otherwise: bb27]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb30: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb32;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb31: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb32;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb32: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:294:1: 302:2>::raw_feed(_1: &mut UTF16BEDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:296:17: 296:26
    debug input => _2;                   // in scope 0 at src/codec/utf_16.rs:296:28: 296:33
    debug output => _3;                  // in scope 0 at src/codec/utf_16.rs:296:42: 296:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_16.rs:296:72: 296:99
    let mut _4: &mut codec::utf_16::UTF16Decoder; // in scope 0 at src/codec/utf_16.rs:297:9: 297:19
    let mut _5: &[u8];                   // in scope 0 at src/codec/utf_16.rs:297:29: 297:34
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:297:36: 297:42
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:297:36: 297:42
    let mut _8: [closure@src/codec/utf_16.rs:297:44: 297:93]; // in scope 0 at src/codec/utf_16.rs:297:44: 297:93

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:297:9: 297:19
        _4 = &mut ((*_1).0: codec::utf_16::UTF16Decoder); // scope 0 at src/codec/utf_16.rs:297:9: 297:19
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:297:29: 297:34
        _5 = _2;                         // scope 0 at src/codec/utf_16.rs:297:29: 297:34
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:297:36: 297:42
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:297:36: 297:42
        _7 = &mut (*_3);                 // scope 0 at src/codec/utf_16.rs:297:36: 297:42
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:297:36: 297:42
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:297:41: 297:42
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:297:44: 297:93
        _0 = UTF16Decoder::raw_feed::<[closure@src/codec/utf_16.rs:297:44: 297:93]>(move _4, move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/utf_16.rs:297:9: 297:94
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:297:20: 297:28
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut codec::utf_16::UTF16Decoder, &'s [u8], &'t0 mut (dyn encoding_types::StringWriter + 't0), [closure@src/codec/utf_16.rs:297:44: 297:93]) -> (usize, std::option::Option<encoding_types::CodecError>) {codec::utf_16::UTF16Decoder::raw_feed::<[closure@src/codec/utf_16.rs:297:44: 297:93]>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:297:93: 297:94
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:297:93: 297:94
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:297:93: 297:94
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:297:93: 297:94
        return;                          // scope 0 at src/codec/utf_16.rs:298:6: 298:6
    }
}

fn eucjp::<impl at src/util.rs:157:22: 157:31>::ne(_1: &eucjp::State, _2: &eucjp::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::japanese::eucjp::State, &codec::japanese::eucjp::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _20: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _27: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _28: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _33: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _34: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _35: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _36: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _37: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _38: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _43: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _44: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _45: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _46: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _47: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _48: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _21: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _22: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _25: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _26: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _29: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _30: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _31: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _32: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _39: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _40: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _41: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _42: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _21;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _22;  // in scope 3 at src/util.rs:164:25: 164:27
            }
            scope 4 {
                debug __self_0 => _25;   // in scope 4 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _26;  // in scope 4 at src/util.rs:164:25: 164:27
            }
            scope 5 {
                debug __self_0 => _29;   // in scope 5 at src/util.rs:164:25: 164:27
                debug __self_1 => _30;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _31;  // in scope 5 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _32;  // in scope 5 at src/util.rs:164:32: 164:35
            }
            scope 6 {
                debug __self_0 => _39;   // in scope 6 at src/util.rs:164:25: 164:27
                debug __self_1 => _40;   // in scope 6 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _41;  // in scope 6 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _42;  // in scope 6 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb22, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::japanese::eucjp::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::japanese::eucjp::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _20 = discriminant((*(_13.0: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _20) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, 4_isize: bb6, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb7, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb9, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        _19 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [4_isize: bb16, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb7: {
        StorageLive(_21);                // scope 2 at src/util.rs:164:25: 164:27
        _21 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_22);                // scope 2 at src/util.rs:164:25: 164:27
        _22 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _21;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _22;                       // scope 3 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_22);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb9: {
        StorageLive(_25);                // scope 2 at src/util.rs:164:25: 164:27
        _25 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_26);                // scope 2 at src/util.rs:164:25: 164:27
        _26 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_27);                // scope 4 at src/util.rs:164:25: 164:27
        _27 = _25;                       // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_28);                // scope 4 at src/util.rs:164:25: 164:27
        _28 = _26;                       // scope 4 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _27, move _28) -> bb10; // scope 4 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_28);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_27);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_26);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_25);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb11: {
        StorageLive(_29);                // scope 2 at src/util.rs:164:25: 164:27
        _29 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_30);                // scope 2 at src/util.rs:164:32: 164:35
        _30 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_31);                // scope 2 at src/util.rs:164:25: 164:27
        _31 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_32);                // scope 2 at src/util.rs:164:32: 164:35
        _32 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_33);                // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_34);                // scope 5 at src/util.rs:164:25: 164:27
        _34 = _29;                       // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_35);                // scope 5 at src/util.rs:164:25: 164:27
        _35 = _31;                       // scope 5 at src/util.rs:164:25: 164:27
        _33 = <() as PartialEq>::ne(move _34, move _35) -> bb15; // scope 5 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        _0 = const true;                 // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb13: {
        StorageLive(_36);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_37);                // scope 5 at src/util.rs:164:32: 164:35
        _37 = (*_30);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_38);                // scope 5 at src/util.rs:164:32: 164:35
        _38 = (*_32);                    // scope 5 at src/util.rs:164:32: 164:35
        _36 = Ne(move _37, move _38);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_38);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_37);                // scope 5 at src/util.rs:164:34: 164:35
        _0 = move _36;                   // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb14: {
        StorageDead(_36);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_33);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_32);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_31);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_29);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb15: {
        StorageDead(_35);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_34);                // scope 5 at src/util.rs:164:26: 164:27
        switchInt(move _33) -> [false: bb13, otherwise: bb12]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb16: {
        StorageLive(_39);                // scope 2 at src/util.rs:164:25: 164:27
        _39 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S4).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_40);                // scope 2 at src/util.rs:164:32: 164:35
        _40 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S4).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_41);                // scope 2 at src/util.rs:164:25: 164:27
        _41 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S4).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_42);                // scope 2 at src/util.rs:164:32: 164:35
        _42 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S4).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_43);                // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_44);                // scope 6 at src/util.rs:164:25: 164:27
        _44 = _39;                       // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_45);                // scope 6 at src/util.rs:164:25: 164:27
        _45 = _41;                       // scope 6 at src/util.rs:164:25: 164:27
        _43 = <() as PartialEq>::ne(move _44, move _45) -> bb20; // scope 6 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        _0 = const true;                 // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb19;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb18: {
        StorageLive(_46);                // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_47);                // scope 6 at src/util.rs:164:32: 164:35
        _47 = (*_40);                    // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_48);                // scope 6 at src/util.rs:164:32: 164:35
        _48 = (*_42);                    // scope 6 at src/util.rs:164:32: 164:35
        _46 = Ne(move _47, move _48);    // scope 6 at src/util.rs:164:32: 164:35
        StorageDead(_48);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_47);                // scope 6 at src/util.rs:164:34: 164:35
        _0 = move _46;                   // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb19;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb19: {
        StorageDead(_46);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_43);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_42);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_41);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_40);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_39);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb20: {
        StorageDead(_45);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_44);                // scope 6 at src/util.rs:164:26: 164:27
        switchInt(move _43) -> [false: bb18, otherwise: bb17]; // scope 6 at src/util.rs:164:32: 164:35
    }

    bb21: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb23;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb22: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb23;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb23: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:69:1: 97:2>::raw_feed::{closure#0}(_1: &mut [closure@src/codec/ascii.rs:80:37: 80:53], _2: &u8) -> bool {
    let mut _0: bool;                    // return place in scope 0 at src/codec/ascii.rs:80:43: 80:43
    let _3: u8;                          // in scope 0 at src/codec/ascii.rs:80:39: 80:41
    let mut _4: u8;                      // in scope 0 at src/codec/ascii.rs:80:43: 80:45
    scope 1 {
        debug ch => _3;                  // in scope 1 at src/codec/ascii.rs:80:39: 80:41
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:80:39: 80:41
        _3 = (*_2);                      // scope 0 at src/codec/ascii.rs:80:39: 80:41
        StorageLive(_4);                 // scope 1 at src/codec/ascii.rs:80:43: 80:45
        _4 = _3;                         // scope 1 at src/codec/ascii.rs:80:43: 80:45
        _0 = Ge(move _4, const 128_u8);  // scope 1 at src/codec/ascii.rs:80:43: 80:53
        StorageDead(_4);                 // scope 1 at src/codec/ascii.rs:80:52: 80:53
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:80:52: 80:53
        return;                          // scope 0 at src/codec/ascii.rs:80:53: 80:53
    }
}

fn windows31j::<impl at src/util.rs:157:22: 157:31>::eq(_1: &windows31j::State, _2: &windows31j::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::japanese::windows31j::State, &codec::japanese::windows31j::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _26: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _27: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _18: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _19: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _18;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _19;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _20;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _21;  // in scope 3 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb10, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::japanese::windows31j::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::japanese::windows31j::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _17 = discriminant((*(_13.0: &codec::japanese::windows31j::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [1_isize: bb3, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::japanese::windows31j::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb4, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        StorageLive(_18);                // scope 2 at src/util.rs:164:25: 164:27
        _18 = &(((*(_13.0: &codec::japanese::windows31j::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_19);                // scope 2 at src/util.rs:164:32: 164:35
        _19 = &(((*(_13.0: &codec::japanese::windows31j::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.1: &codec::japanese::windows31j::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.1: &codec::japanese::windows31j::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _18;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        _22 = <() as PartialEq>::eq(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        _0 = const false;                // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb6: {
        StorageLive(_25);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_26);                // scope 3 at src/util.rs:164:32: 164:35
        _26 = (*_19);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        _27 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        _25 = Eq(move _26, move _27);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_26);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _25;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb7: {
        StorageDead(_25);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_22);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_19);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_18);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:30: 157:31
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _22) -> [false: bb5, otherwise: bb6]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn simpchinese::gb18030::raw_feed(_1: simpchinese::gb18030::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (simpchinese::gb18030::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::simpchinese::gb18030::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _18: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _19: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _20: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _23: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _24: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _25: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _26: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _30: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _31: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _32: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _33: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _34: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _35: (std::option::Option<encoding_types::CodecError>, codec::simpchinese::gb18030::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _36: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _37: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _38: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _39: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _40: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _41: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _42: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _43: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _44: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _45: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _47: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _48: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _49: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _50: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _51: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _52: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _53: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _54: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _56: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _57: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _58: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _59: (std::option::Option<encoding_types::CodecError>, codec::simpchinese::gb18030::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _60: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _61: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _62: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _63: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _64: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _65: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _66: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _67: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _68: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _69: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _71: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _72: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _73: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _74: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _75: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _76: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _77: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::simpchinese::gb18030::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _17: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _21: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _22: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _27: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _28: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _29: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _46: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _55: codec::simpchinese::gb18030::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 7 {
                    debug err => _46;    // in scope 7 at src/util.rs:252:27: 252:30
                }
                scope 8 {
                    debug st_ => _55;    // in scope 8 at src/util.rs:256:25: 256:28
                    let _70: encoding_types::CodecError; // in scope 8 at src/util.rs:267:31: 267:34
                    scope 9 {
                        debug err => _70; // in scope 9 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug first => _17;      // in scope 4 at src/util.rs:245:36: 245:40
            }
            scope 5 {
                debug first => _21;      // in scope 5 at src/util.rs:245:36: 245:40
                debug second => _22;     // in scope 5 at src/util.rs:245:36: 245:40
            }
            scope 6 {
                debug first => _27;      // in scope 6 at src/util.rs:245:36: 245:40
                debug second => _28;     // in scope 6 at src/util.rs:245:36: 245:40
                debug third => _29;      // in scope 6 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T> {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb6, 2_isize: bb8, 3_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_27);                // scope 2 at src/util.rs:245:36: 245:40
        _27 = ((_1 as S3).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_28);                // scope 2 at src/util.rs:245:36: 245:40
        _28 = ((_1 as S3).2: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_29);                // scope 2 at src/util.rs:245:36: 245:40
        _29 = ((_1 as S3).3: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_30);                // scope 6 at src/util.rs:245:62: 245:70
        StorageLive(_31);                // scope 6 at src/util.rs:245:62: 245:70
        _31 = &mut _9;                   // scope 6 at src/util.rs:245:62: 245:70
        _30 = &mut (*_31);               // scope 6 at src/util.rs:245:62: 245:70
        StorageLive(_32);                // scope 6 at src/util.rs:245:75: 245:79
        _32 = _27;                       // scope 6 at src/util.rs:245:75: 245:79
        StorageLive(_33);                // scope 6 at src/util.rs:245:75: 245:79
        _33 = _28;                       // scope 6 at src/util.rs:245:75: 245:79
        StorageLive(_34);                // scope 6 at src/util.rs:245:75: 245:79
        _34 = _29;                       // scope 6 at src/util.rs:245:75: 245:79
        _15 = simpchinese::gb18030::transient::S3::<T>(move _30, move _32, move _33, move _34) -> [return: bb10, unwind: bb37]; // scope 6 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>, u8, u8, u8) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::transient::S3::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb11;                    // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageLive(_17);                // scope 2 at src/util.rs:245:36: 245:40
        _17 = ((_1 as S1).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_18);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_19);                // scope 4 at src/util.rs:245:62: 245:70
        _19 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _18 = &mut (*_19);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_20);                // scope 4 at src/util.rs:245:75: 245:79
        _20 = _17;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = simpchinese::gb18030::transient::S1::<T>(move _18, move _20) -> [return: bb7, unwind: bb37]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>, u8) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_19);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_18);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_17);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb11;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb8: {
        StorageLive(_21);                // scope 2 at src/util.rs:245:36: 245:40
        _21 = ((_1 as S2).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_22);                // scope 2 at src/util.rs:245:36: 245:40
        _22 = ((_1 as S2).2: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_23);                // scope 5 at src/util.rs:245:62: 245:70
        StorageLive(_24);                // scope 5 at src/util.rs:245:62: 245:70
        _24 = &mut _9;                   // scope 5 at src/util.rs:245:62: 245:70
        _23 = &mut (*_24);               // scope 5 at src/util.rs:245:62: 245:70
        StorageLive(_25);                // scope 5 at src/util.rs:245:75: 245:79
        _25 = _21;                       // scope 5 at src/util.rs:245:75: 245:79
        StorageLive(_26);                // scope 5 at src/util.rs:245:75: 245:79
        _26 = _22;                       // scope 5 at src/util.rs:245:75: 245:79
        _15 = simpchinese::gb18030::transient::S2::<T>(move _23, move _25, move _26) -> [return: bb9, unwind: bb37]; // scope 5 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>, u8, u8) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::transient::S2::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_26);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_25);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_24);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_23);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_22);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_21);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb11;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb10: {
        StorageDead(_34);                // scope 6 at src/util.rs:245:81: 245:82
        StorageDead(_33);                // scope 6 at src/util.rs:245:81: 245:82
        StorageDead(_32);                // scope 6 at src/util.rs:245:81: 245:82
        StorageDead(_31);                // scope 6 at src/util.rs:245:81: 245:82
        StorageDead(_30);                // scope 6 at src/util.rs:245:81: 245:82
        StorageDead(_29);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_28);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_27);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb11;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb11: {
        StorageLive(_35);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_36);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_37);                // scope 3 at src/util.rs:248:24: 248:31
        _37 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _36 = Option::<encoding_types::CodecError>::take(move _37) -> [return: bb12, unwind: bb37]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_37);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_38);                // scope 3 at src/util.rs:248:40: 248:43
        _38 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_35.0: std::option::Option<encoding_types::CodecError>) = move _36; // scope 3 at src/util.rs:248:23: 248:44
        (_35.1: codec::simpchinese::gb18030::State) = move _38; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_38);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_36);                // scope 3 at src/util.rs:248:43: 248:44
        _40 = discriminant((_35.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _40) -> [0_isize: bb13, 1_isize: bb14, otherwise: bb15]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb13: {
        _39 = discriminant((_35.1: codec::simpchinese::gb18030::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _39) -> [0_isize: bb16, otherwise: bb17]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb14: {
        StorageLive(_46);                // scope 3 at src/util.rs:252:27: 252:30
        _46 = move (((_35.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_47);                // scope 7 at src/util.rs:252:49: 252:52
        _47 = _15;                       // scope 7 at src/util.rs:252:49: 252:52
        StorageLive(_48);                // scope 7 at src/util.rs:252:54: 252:63
        _48 = _14;                       // scope 7 at src/util.rs:252:54: 252:63
        StorageLive(_49);                // scope 7 at src/util.rs:252:65: 252:74
        StorageLive(_50);                // scope 7 at src/util.rs:252:70: 252:73
        _50 = move _46;                  // scope 7 at src/util.rs:252:70: 252:73
        ((_49 as Some).0: encoding_types::CodecError) = move _50; // scope 7 at src/util.rs:252:65: 252:74
        discriminant(_49) = 1;           // scope 7 at src/util.rs:252:65: 252:74
        StorageDead(_50);                // scope 7 at src/util.rs:252:73: 252:74
        (_0.0: codec::simpchinese::gb18030::State) = move _47; // scope 7 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _48;        // scope 7 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _49; // scope 7 at src/util.rs:252:48: 252:75
        StorageDead(_49);                // scope 7 at src/util.rs:252:74: 252:75
        StorageDead(_48);                // scope 7 at src/util.rs:252:74: 252:75
        StorageDead(_47);                // scope 7 at src/util.rs:252:74: 252:75
        StorageDead(_46);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb33;                    // scope 3 at no-location
    }

    bb15: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb16: {
        StorageLive(_41);                // scope 3 at src/util.rs:249:70: 249:73
        _41 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _41;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_41);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_42);                // scope 3 at src/util.rs:249:87: 249:94
        _42 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _42;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_42);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_35);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb18;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb17: {
        StorageLive(_43);                // scope 3 at src/util.rs:251:44: 251:47
        _43 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_44);                // scope 3 at src/util.rs:251:49: 251:58
        _44 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_45);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_45) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::simpchinese::gb18030::State) = move _43; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _44;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _45; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_45);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_44);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_43);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb33;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb18: {
        StorageLive(_51);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_52);                // scope 3 at src/util.rs:255:23: 255:30
        _52 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_53);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_54);                // scope 3 at src/util.rs:255:33: 255:40
        _54 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _53 = core::slice::<impl [u8]>::len(move _54) -> [return: bb19, unwind: bb37]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_54);                // scope 3 at src/util.rs:255:45: 255:46
        _51 = Lt(move _52, move _53);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_53);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_52);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _51) -> [false: bb30, otherwise: bb20]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb20: {
        StorageLive(_55);                // scope 3 at src/util.rs:256:25: 256:28
        _56 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _56) -> [0_isize: bb22, otherwise: bb21]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb21: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb37; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb22: {
        StorageLive(_57);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_58);                // scope 3 at src/util.rs:257:49: 257:57
        _58 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _57 = &mut (*_58);               // scope 3 at src/util.rs:257:49: 257:57
        _55 = simpchinese::gb18030::start::S0::<T>(move _57) -> [return: bb23, unwind: bb37]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::start::S0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb23: {
        StorageDead(_58);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_57);                // scope 3 at src/util.rs:257:57: 257:58
        StorageLive(_59);                // scope 8 at src/util.rs:263:27: 263:48
        StorageLive(_60);                // scope 8 at src/util.rs:263:28: 263:42
        StorageLive(_61);                // scope 8 at src/util.rs:263:28: 263:35
        _61 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 8 at src/util.rs:263:28: 263:35
        _60 = Option::<encoding_types::CodecError>::take(move _61) -> [return: bb24, unwind: bb37]; // scope 8 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_61);                // scope 8 at src/util.rs:263:41: 263:42
        StorageLive(_62);                // scope 8 at src/util.rs:263:44: 263:47
        _62 = _55;                       // scope 8 at src/util.rs:263:44: 263:47
        (_59.0: std::option::Option<encoding_types::CodecError>) = move _60; // scope 8 at src/util.rs:263:27: 263:48
        (_59.1: codec::simpchinese::gb18030::State) = move _62; // scope 8 at src/util.rs:263:27: 263:48
        StorageDead(_62);                // scope 8 at src/util.rs:263:47: 263:48
        StorageDead(_60);                // scope 8 at src/util.rs:263:47: 263:48
        _64 = discriminant((_59.0: std::option::Option<encoding_types::CodecError>)); // scope 8 at src/util.rs:263:27: 263:48
        switchInt(move _64) -> [0_isize: bb25, 1_isize: bb26, otherwise: bb27]; // scope 8 at src/util.rs:263:21: 263:48
    }

    bb25: {
        _63 = discriminant((_59.1: codec::simpchinese::gb18030::State)); // scope 8 at src/util.rs:263:27: 263:48
        switchInt(move _63) -> [0_isize: bb28, otherwise: bb29]; // scope 8 at src/util.rs:263:21: 263:48
    }

    bb26: {
        StorageLive(_70);                // scope 8 at src/util.rs:267:31: 267:34
        _70 = move (((_59.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 8 at src/util.rs:267:31: 267:34
        StorageLive(_71);                // scope 9 at src/util.rs:267:53: 267:56
        _71 = _55;                       // scope 9 at src/util.rs:267:53: 267:56
        StorageLive(_72);                // scope 9 at src/util.rs:267:58: 267:67
        _72 = _14;                       // scope 9 at src/util.rs:267:58: 267:67
        StorageLive(_73);                // scope 9 at src/util.rs:267:69: 267:78
        StorageLive(_74);                // scope 9 at src/util.rs:267:74: 267:77
        _74 = move _70;                  // scope 9 at src/util.rs:267:74: 267:77
        ((_73 as Some).0: encoding_types::CodecError) = move _74; // scope 9 at src/util.rs:267:69: 267:78
        discriminant(_73) = 1;           // scope 9 at src/util.rs:267:69: 267:78
        StorageDead(_74);                // scope 9 at src/util.rs:267:77: 267:78
        (_0.0: codec::simpchinese::gb18030::State) = move _71; // scope 9 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _72;        // scope 9 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _73; // scope 9 at src/util.rs:267:52: 267:79
        StorageDead(_73);                // scope 9 at src/util.rs:267:78: 267:79
        StorageDead(_72);                // scope 9 at src/util.rs:267:78: 267:79
        StorageDead(_71);                // scope 9 at src/util.rs:267:78: 267:79
        StorageDead(_70);                // scope 8 at src/util.rs:267:81: 267:82
        goto -> bb32;                    // scope 8 at no-location
    }

    bb27: {
        unreachable;                     // scope 8 at src/util.rs:263:27: 263:48
    }

    bb28: {
        StorageLive(_65);                // scope 8 at src/util.rs:264:74: 264:77
        _65 = _55;                       // scope 8 at src/util.rs:264:74: 264:77
        _1 = move _65;                   // scope 8 at src/util.rs:264:69: 264:77
        StorageDead(_65);                // scope 8 at src/util.rs:264:76: 264:77
        StorageLive(_66);                // scope 8 at src/util.rs:264:91: 264:98
        _66 = (_9.1: usize);             // scope 8 at src/util.rs:264:91: 264:98
        _14 = move _66;                  // scope 8 at src/util.rs:264:79: 264:98
        StorageDead(_66);                // scope 8 at src/util.rs:264:97: 264:98
        StorageDead(_55);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_59);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_51);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb18;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb29: {
        StorageLive(_67);                // scope 8 at src/util.rs:266:48: 266:51
        _67 = _55;                       // scope 8 at src/util.rs:266:48: 266:51
        StorageLive(_68);                // scope 8 at src/util.rs:266:53: 266:62
        _68 = _14;                       // scope 8 at src/util.rs:266:53: 266:62
        StorageLive(_69);                // scope 8 at src/util.rs:266:64: 266:68
        discriminant(_69) = 0;           // scope 8 at src/util.rs:266:64: 266:68
        (_0.0: codec::simpchinese::gb18030::State) = move _67; // scope 8 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _68;        // scope 8 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _69; // scope 8 at src/util.rs:266:47: 266:69
        StorageDead(_69);                // scope 8 at src/util.rs:266:68: 266:69
        StorageDead(_68);                // scope 8 at src/util.rs:266:68: 266:69
        StorageDead(_67);                // scope 8 at src/util.rs:266:68: 266:69
        goto -> bb32;                    // scope 8 at src/util.rs:266:40: 266:69
    }

    bb30: {
        StorageDead(_51);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_75);                // scope 3 at src/util.rs:271:18: 271:20
        _75 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_76);                // scope 3 at src/util.rs:271:22: 271:31
        _76 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_77);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_77) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::simpchinese::gb18030::State) = move _75; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _76;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _77; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_77);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_76);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_75);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb31;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb31: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb36;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb32: {
        StorageDead(_55);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_59);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_51);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb34;                    // scope 3 at no-location
    }

    bb33: {
        StorageDead(_35);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb34;                    // scope 3 at no-location
    }

    bb34: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb35;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb35: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb36;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb36: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb37 (cleanup): {
        drop(_9) -> bb38;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb38 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

const WINDOWS_1255: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:64:68: 64:82
    let _5: &str;                        // in scope 0 at src/all.rs:64:68: 64:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1255::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1255, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1272 ~ encoding[5d2c]::all::WINDOWS_1255), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1255: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:64:68: 64:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:64:68: 64:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1255";       // scope 0 at src/all.rs:64:68: 64:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:64:68: 64:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:64:68: 64:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1255::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1255::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1255::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1255::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1255"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:64:68: 64:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:27:10: 27:15>::clone(_1: &ASCIIEncoder) -> ASCIIEncoder {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:27:10: 27:15
    let mut _0: codec::ascii::ASCIIEncoder; // return place in scope 0 at src/codec/ascii.rs:27:10: 27:15

    bb0: {
        return;                          // scope 0 at src/codec/ascii.rs:27:15: 27:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:85:1: 94:2>::raw_finish(_1: &mut UTF16LEEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:93:19: 93:28
    debug _output => _2;                 // in scope 0 at src/codec/utf_16.rs:93:30: 93:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_16.rs:93:59: 93:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/utf_16.rs:93:80: 93:84
        return;                          // scope 0 at src/codec/utf_16.rs:93:86: 93:86
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:165:1: 180:2>::raw_feed(_1: &mut GB18030Decoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:169:17: 169:26
    debug input => _2;                   // in scope 0 at src/codec/simpchinese.rs:169:28: 169:33
    debug output => _3;                  // in scope 0 at src/codec/simpchinese.rs:169:42: 169:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/simpchinese.rs:169:72: 169:99
    let _4: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:170:14: 170:16
    let _5: usize;                       // in scope 0 at src/codec/simpchinese.rs:170:18: 170:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:170:29: 170:32
    let mut _7: (codec::simpchinese::gb18030::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/simpchinese.rs:170:36: 170:82
    let mut _8: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:170:54: 170:61
    let mut _9: &[u8];                   // in scope 0 at src/codec/simpchinese.rs:170:63: 170:68
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:170:70: 170:76
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:170:70: 170:76
    let mut _12: &();                    // in scope 0 at src/codec/simpchinese.rs:170:78: 170:81
    let _13: &();                        // in scope 0 at src/codec/simpchinese.rs:170:78: 170:81
    let mut _14: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:171:19: 171:21
    let mut _15: usize;                  // in scope 0 at src/codec/simpchinese.rs:172:10: 172:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:172:21: 172:24
    let mut _17: &();                    // in scope 0 at src/codec/simpchinese.rs:170:78: 170:81
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/simpchinese.rs:170:14: 170:16
        debug processed => _5;           // in scope 1 at src/codec/simpchinese.rs:170:18: 170:27
        debug err => _6;                 // in scope 1 at src/codec/simpchinese.rs:170:29: 170:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:170:36: 170:82
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:170:54: 170:61
        _8 = ((*_1).0: codec::simpchinese::gb18030::State); // scope 0 at src/codec/simpchinese.rs:170:54: 170:61
        StorageLive(_9);                 // scope 0 at src/codec/simpchinese.rs:170:63: 170:68
        _9 = _2;                         // scope 0 at src/codec/simpchinese.rs:170:63: 170:68
        StorageLive(_10);                // scope 0 at src/codec/simpchinese.rs:170:70: 170:76
        StorageLive(_11);                // scope 0 at src/codec/simpchinese.rs:170:70: 170:76
        _11 = &mut (*_3);                // scope 0 at src/codec/simpchinese.rs:170:70: 170:76
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:170:70: 170:76
        StorageDead(_11);                // scope 0 at src/codec/simpchinese.rs:170:75: 170:76
        StorageLive(_12);                // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
        StorageLive(_13);                // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
        _17 = const <GB18030Decoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<GB18030Decoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:170:78: 170:81
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:492 ~ encoding[5d2c]::codec::simpchinese::{impl#8}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
        _12 = _13;                       // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
        _7 = simpchinese::gb18030::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/simpchinese.rs:170:36: 170:82
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:170:36: 170:53
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::simpchinese::gb18030::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::simpchinese::gb18030::State, usize, std::option::Option<encoding_types::CodecError>) {codec::simpchinese::gb18030::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/simpchinese.rs:170:81: 170:82
        StorageDead(_10);                // scope 0 at src/codec/simpchinese.rs:170:81: 170:82
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:170:81: 170:82
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:170:81: 170:82
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:170:14: 170:16
        _4 = (_7.0: codec::simpchinese::gb18030::State); // scope 0 at src/codec/simpchinese.rs:170:14: 170:16
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:170:18: 170:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/simpchinese.rs:170:18: 170:27
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:170:29: 170:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/simpchinese.rs:170:29: 170:32
        StorageDead(_13);                // scope 0 at src/codec/simpchinese.rs:170:82: 170:83
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:170:82: 170:83
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:171:19: 171:21
        _14 = _4;                        // scope 1 at src/codec/simpchinese.rs:171:19: 171:21
        ((*_1).0: codec::simpchinese::gb18030::State) = move _14; // scope 1 at src/codec/simpchinese.rs:171:9: 171:21
        StorageDead(_14);                // scope 1 at src/codec/simpchinese.rs:171:20: 171:21
        StorageLive(_15);                // scope 1 at src/codec/simpchinese.rs:172:10: 172:19
        _15 = _5;                        // scope 1 at src/codec/simpchinese.rs:172:10: 172:19
        StorageLive(_16);                // scope 1 at src/codec/simpchinese.rs:172:21: 172:24
        _16 = move _6;                   // scope 1 at src/codec/simpchinese.rs:172:21: 172:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/simpchinese.rs:172:9: 172:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/simpchinese.rs:172:9: 172:25
        StorageDead(_16);                // scope 1 at src/codec/simpchinese.rs:172:24: 172:25
        StorageDead(_15);                // scope 1 at src/codec/simpchinese.rs:172:24: 172:25
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:173:5: 173:6
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:173:5: 173:6
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:173:5: 173:6
        return;                          // scope 0 at src/codec/simpchinese.rs:173:6: 173:6
    }
}

promoted[0] in simpchinese::<impl at src/codec/simpchinese.rs:165:1: 180:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/simpchinese.rs:170:78: 170:81
    let mut _1: ();                      // in scope 0 at src/codec/simpchinese.rs:170:79: 170:81

    bb0: {
        nop;                             // scope 0 at src/codec/simpchinese.rs:170:79: 170:81
        _0 = &_1;                        // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
        return;                          // scope 0 at src/codec/simpchinese.rs:170:78: 170:81
    }
}

fn eucjp::raw_feed(_1: eucjp::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (eucjp::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::japanese::eucjp::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _18: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _19: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _20: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _22: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _23: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _24: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _26: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _27: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _28: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _29: (std::option::Option<encoding_types::CodecError>, codec::japanese::eucjp::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _30: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _31: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _32: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _33: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _34: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _35: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _36: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _37: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _38: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _39: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _41: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _42: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _43: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _44: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _45: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _46: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _47: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _48: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _50: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _51: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _52: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _53: (std::option::Option<encoding_types::CodecError>, codec::japanese::eucjp::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _54: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _55: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _56: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _57: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _58: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _59: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _60: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _61: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _62: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _63: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _65: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _66: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _67: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _68: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _69: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _70: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _71: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::japanese::eucjp::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _21: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _25: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _40: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _49: codec::japanese::eucjp::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 6 {
                    debug err => _40;    // in scope 6 at src/util.rs:252:27: 252:30
                }
                scope 7 {
                    debug st_ => _49;    // in scope 7 at src/util.rs:256:25: 256:28
                    let _64: encoding_types::CodecError; // in scope 7 at src/util.rs:267:31: 267:34
                    scope 8 {
                        debug err => _64; // in scope 8 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug lead => _21;       // in scope 4 at src/util.rs:245:36: 245:40
            }
            scope 5 {
                debug lead => _25;       // in scope 5 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<eucjp::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::japanese::eucjp::State, T> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb6, 2_isize: bb8, 3_isize: bb10, 4_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_25);                // scope 2 at src/util.rs:245:36: 245:40
        _25 = ((_1 as S4).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_26);                // scope 5 at src/util.rs:245:62: 245:70
        StorageLive(_27);                // scope 5 at src/util.rs:245:62: 245:70
        _27 = &mut _9;                   // scope 5 at src/util.rs:245:62: 245:70
        _26 = &mut (*_27);               // scope 5 at src/util.rs:245:62: 245:70
        StorageLive(_28);                // scope 5 at src/util.rs:245:75: 245:79
        _28 = _25;                       // scope 5 at src/util.rs:245:75: 245:79
        _15 = eucjp::transient::S4::<T>(move _26, move _28) -> [return: bb12, unwind: bb39]; // scope 5 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>, u8) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S4::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb13;                    // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageLive(_17);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_18);                // scope 2 at src/util.rs:245:62: 245:70
        _18 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _17 = &mut (*_18);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = eucjp::transient::S1::<T>(move _17) -> [return: bb7, unwind: bb39]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_18);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_17);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb8: {
        StorageLive(_19);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_20);                // scope 2 at src/util.rs:245:62: 245:70
        _20 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _19 = &mut (*_20);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = eucjp::transient::S2::<T>(move _19) -> [return: bb9, unwind: bb39]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S2::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_20);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_19);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb10: {
        StorageLive(_21);                // scope 2 at src/util.rs:245:36: 245:40
        _21 = ((_1 as S3).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_22);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_23);                // scope 4 at src/util.rs:245:62: 245:70
        _23 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _22 = &mut (*_23);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_24);                // scope 4 at src/util.rs:245:75: 245:79
        _24 = _21;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = eucjp::transient::S3::<T>(move _22, move _24) -> [return: bb11, unwind: bb39]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>, u8) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S3::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_24);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_23);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_22);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_21);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb12: {
        StorageDead(_28);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_27);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_26);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_25);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb13: {
        StorageLive(_29);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_30);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_31);                // scope 3 at src/util.rs:248:24: 248:31
        _31 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _30 = Option::<encoding_types::CodecError>::take(move _31) -> [return: bb14, unwind: bb39]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_31);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_32);                // scope 3 at src/util.rs:248:40: 248:43
        _32 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_29.0: std::option::Option<encoding_types::CodecError>) = move _30; // scope 3 at src/util.rs:248:23: 248:44
        (_29.1: codec::japanese::eucjp::State) = move _32; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_32);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_30);                // scope 3 at src/util.rs:248:43: 248:44
        _34 = discriminant((_29.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _34) -> [0_isize: bb15, 1_isize: bb16, otherwise: bb17]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb15: {
        _33 = discriminant((_29.1: codec::japanese::eucjp::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _33) -> [0_isize: bb18, otherwise: bb19]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb16: {
        StorageLive(_40);                // scope 3 at src/util.rs:252:27: 252:30
        _40 = move (((_29.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_41);                // scope 6 at src/util.rs:252:49: 252:52
        _41 = _15;                       // scope 6 at src/util.rs:252:49: 252:52
        StorageLive(_42);                // scope 6 at src/util.rs:252:54: 252:63
        _42 = _14;                       // scope 6 at src/util.rs:252:54: 252:63
        StorageLive(_43);                // scope 6 at src/util.rs:252:65: 252:74
        StorageLive(_44);                // scope 6 at src/util.rs:252:70: 252:73
        _44 = move _40;                  // scope 6 at src/util.rs:252:70: 252:73
        ((_43 as Some).0: encoding_types::CodecError) = move _44; // scope 6 at src/util.rs:252:65: 252:74
        discriminant(_43) = 1;           // scope 6 at src/util.rs:252:65: 252:74
        StorageDead(_44);                // scope 6 at src/util.rs:252:73: 252:74
        (_0.0: codec::japanese::eucjp::State) = move _41; // scope 6 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _42;        // scope 6 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _43; // scope 6 at src/util.rs:252:48: 252:75
        StorageDead(_43);                // scope 6 at src/util.rs:252:74: 252:75
        StorageDead(_42);                // scope 6 at src/util.rs:252:74: 252:75
        StorageDead(_41);                // scope 6 at src/util.rs:252:74: 252:75
        StorageDead(_40);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb35;                    // scope 3 at no-location
    }

    bb17: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb18: {
        StorageLive(_35);                // scope 3 at src/util.rs:249:70: 249:73
        _35 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _35;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_35);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_36);                // scope 3 at src/util.rs:249:87: 249:94
        _36 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _36;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_36);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_29);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb20;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb19: {
        StorageLive(_37);                // scope 3 at src/util.rs:251:44: 251:47
        _37 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_38);                // scope 3 at src/util.rs:251:49: 251:58
        _38 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_39);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_39) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::japanese::eucjp::State) = move _37; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _38;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _39; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_39);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_38);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_37);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb35;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb20: {
        StorageLive(_45);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_46);                // scope 3 at src/util.rs:255:23: 255:30
        _46 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_47);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_48);                // scope 3 at src/util.rs:255:33: 255:40
        _48 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _47 = core::slice::<impl [u8]>::len(move _48) -> [return: bb21, unwind: bb39]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb21: {
        StorageDead(_48);                // scope 3 at src/util.rs:255:45: 255:46
        _45 = Lt(move _46, move _47);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_47);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_46);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _45) -> [false: bb32, otherwise: bb22]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb22: {
        StorageLive(_49);                // scope 3 at src/util.rs:256:25: 256:28
        _50 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _50) -> [0_isize: bb24, otherwise: bb23]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb23: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb39; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb24: {
        StorageLive(_51);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_52);                // scope 3 at src/util.rs:257:49: 257:57
        _52 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _51 = &mut (*_52);               // scope 3 at src/util.rs:257:49: 257:57
        _49 = eucjp::start::S0::<T>(move _51) -> [return: bb25, unwind: bb39]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>) -> codec::japanese::eucjp::State {codec::japanese::eucjp::start::S0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb25: {
        StorageDead(_52);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_51);                // scope 3 at src/util.rs:257:57: 257:58
        StorageLive(_53);                // scope 7 at src/util.rs:263:27: 263:48
        StorageLive(_54);                // scope 7 at src/util.rs:263:28: 263:42
        StorageLive(_55);                // scope 7 at src/util.rs:263:28: 263:35
        _55 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 7 at src/util.rs:263:28: 263:35
        _54 = Option::<encoding_types::CodecError>::take(move _55) -> [return: bb26, unwind: bb39]; // scope 7 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb26: {
        StorageDead(_55);                // scope 7 at src/util.rs:263:41: 263:42
        StorageLive(_56);                // scope 7 at src/util.rs:263:44: 263:47
        _56 = _49;                       // scope 7 at src/util.rs:263:44: 263:47
        (_53.0: std::option::Option<encoding_types::CodecError>) = move _54; // scope 7 at src/util.rs:263:27: 263:48
        (_53.1: codec::japanese::eucjp::State) = move _56; // scope 7 at src/util.rs:263:27: 263:48
        StorageDead(_56);                // scope 7 at src/util.rs:263:47: 263:48
        StorageDead(_54);                // scope 7 at src/util.rs:263:47: 263:48
        _58 = discriminant((_53.0: std::option::Option<encoding_types::CodecError>)); // scope 7 at src/util.rs:263:27: 263:48
        switchInt(move _58) -> [0_isize: bb27, 1_isize: bb28, otherwise: bb29]; // scope 7 at src/util.rs:263:21: 263:48
    }

    bb27: {
        _57 = discriminant((_53.1: codec::japanese::eucjp::State)); // scope 7 at src/util.rs:263:27: 263:48
        switchInt(move _57) -> [0_isize: bb30, otherwise: bb31]; // scope 7 at src/util.rs:263:21: 263:48
    }

    bb28: {
        StorageLive(_64);                // scope 7 at src/util.rs:267:31: 267:34
        _64 = move (((_53.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 7 at src/util.rs:267:31: 267:34
        StorageLive(_65);                // scope 8 at src/util.rs:267:53: 267:56
        _65 = _49;                       // scope 8 at src/util.rs:267:53: 267:56
        StorageLive(_66);                // scope 8 at src/util.rs:267:58: 267:67
        _66 = _14;                       // scope 8 at src/util.rs:267:58: 267:67
        StorageLive(_67);                // scope 8 at src/util.rs:267:69: 267:78
        StorageLive(_68);                // scope 8 at src/util.rs:267:74: 267:77
        _68 = move _64;                  // scope 8 at src/util.rs:267:74: 267:77
        ((_67 as Some).0: encoding_types::CodecError) = move _68; // scope 8 at src/util.rs:267:69: 267:78
        discriminant(_67) = 1;           // scope 8 at src/util.rs:267:69: 267:78
        StorageDead(_68);                // scope 8 at src/util.rs:267:77: 267:78
        (_0.0: codec::japanese::eucjp::State) = move _65; // scope 8 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _66;        // scope 8 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _67; // scope 8 at src/util.rs:267:52: 267:79
        StorageDead(_67);                // scope 8 at src/util.rs:267:78: 267:79
        StorageDead(_66);                // scope 8 at src/util.rs:267:78: 267:79
        StorageDead(_65);                // scope 8 at src/util.rs:267:78: 267:79
        StorageDead(_64);                // scope 7 at src/util.rs:267:81: 267:82
        goto -> bb34;                    // scope 7 at no-location
    }

    bb29: {
        unreachable;                     // scope 7 at src/util.rs:263:27: 263:48
    }

    bb30: {
        StorageLive(_59);                // scope 7 at src/util.rs:264:74: 264:77
        _59 = _49;                       // scope 7 at src/util.rs:264:74: 264:77
        _1 = move _59;                   // scope 7 at src/util.rs:264:69: 264:77
        StorageDead(_59);                // scope 7 at src/util.rs:264:76: 264:77
        StorageLive(_60);                // scope 7 at src/util.rs:264:91: 264:98
        _60 = (_9.1: usize);             // scope 7 at src/util.rs:264:91: 264:98
        _14 = move _60;                  // scope 7 at src/util.rs:264:79: 264:98
        StorageDead(_60);                // scope 7 at src/util.rs:264:97: 264:98
        StorageDead(_49);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_53);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb20;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb31: {
        StorageLive(_61);                // scope 7 at src/util.rs:266:48: 266:51
        _61 = _49;                       // scope 7 at src/util.rs:266:48: 266:51
        StorageLive(_62);                // scope 7 at src/util.rs:266:53: 266:62
        _62 = _14;                       // scope 7 at src/util.rs:266:53: 266:62
        StorageLive(_63);                // scope 7 at src/util.rs:266:64: 266:68
        discriminant(_63) = 0;           // scope 7 at src/util.rs:266:64: 266:68
        (_0.0: codec::japanese::eucjp::State) = move _61; // scope 7 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _62;        // scope 7 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _63; // scope 7 at src/util.rs:266:47: 266:69
        StorageDead(_63);                // scope 7 at src/util.rs:266:68: 266:69
        StorageDead(_62);                // scope 7 at src/util.rs:266:68: 266:69
        StorageDead(_61);                // scope 7 at src/util.rs:266:68: 266:69
        goto -> bb34;                    // scope 7 at src/util.rs:266:40: 266:69
    }

    bb32: {
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_69);                // scope 3 at src/util.rs:271:18: 271:20
        _69 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_70);                // scope 3 at src/util.rs:271:22: 271:31
        _70 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_71);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_71) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::japanese::eucjp::State) = move _69; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _70;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _71; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_71);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_70);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_69);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb33;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb33: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb38;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb34: {
        StorageDead(_49);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_53);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb36;                    // scope 3 at no-location
    }

    bb35: {
        StorageDead(_29);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb36;                    // scope 3 at no-location
    }

    bb36: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb37;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb37: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb38;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb38: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb39 (cleanup): {
        drop(_9) -> bb40;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb40 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:90:1: 105:2>::raw_finish(_1: &mut BigFive2003HKSCS2008Decoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:100:19: 100:28
    debug output => _2;                  // in scope 0 at src/codec/tradchinese.rs:100:30: 100:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/tradchinese.rs:101:18: 101:21
    let _3: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:101:14: 101:16
    let mut _4: (codec::tradchinese::bigfive2003::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/tradchinese.rs:101:25: 101:70
    let mut _5: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:101:49: 101:56
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/tradchinese.rs:101:58: 101:64
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/tradchinese.rs:101:58: 101:64
    let mut _8: &();                     // in scope 0 at src/codec/tradchinese.rs:101:66: 101:69
    let _9: &();                         // in scope 0 at src/codec/tradchinese.rs:101:66: 101:69
    let mut _10: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:102:19: 102:21
    let mut _11: &();                    // in scope 0 at src/codec/tradchinese.rs:101:66: 101:69
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/tradchinese.rs:101:14: 101:16
        debug err => _0;                 // in scope 1 at src/codec/tradchinese.rs:101:18: 101:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/tradchinese.rs:101:25: 101:70
        StorageLive(_5);                 // scope 0 at src/codec/tradchinese.rs:101:49: 101:56
        _5 = ((*_1).0: codec::tradchinese::bigfive2003::State); // scope 0 at src/codec/tradchinese.rs:101:49: 101:56
        StorageLive(_6);                 // scope 0 at src/codec/tradchinese.rs:101:58: 101:64
        StorageLive(_7);                 // scope 0 at src/codec/tradchinese.rs:101:58: 101:64
        _7 = &mut (*_2);                 // scope 0 at src/codec/tradchinese.rs:101:58: 101:64
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:101:58: 101:64
        StorageDead(_7);                 // scope 0 at src/codec/tradchinese.rs:101:63: 101:64
        StorageLive(_8);                 // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
        StorageLive(_9);                 // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
        _11 = const <BigFive2003HKSCS2008Decoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<BigFive2003HKSCS2008Decoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:101:66: 101:69
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:547 ~ encoding[5d2c]::codec::tradchinese::{impl#4}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
        _8 = _9;                         // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
        _4 = bigfive2003::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/tradchinese.rs:101:25: 101:70
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:101:25: 101:48
                                         // + literal: Const { ty: for<'r, 's> fn(codec::tradchinese::bigfive2003::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::tradchinese::bigfive2003::State, std::option::Option<encoding_types::CodecError>) {codec::tradchinese::bigfive2003::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/tradchinese.rs:101:69: 101:70
        StorageDead(_6);                 // scope 0 at src/codec/tradchinese.rs:101:69: 101:70
        StorageDead(_5);                 // scope 0 at src/codec/tradchinese.rs:101:69: 101:70
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:101:14: 101:16
        _3 = (_4.0: codec::tradchinese::bigfive2003::State); // scope 0 at src/codec/tradchinese.rs:101:14: 101:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/tradchinese.rs:101:18: 101:21
        StorageDead(_9);                 // scope 0 at src/codec/tradchinese.rs:101:70: 101:71
        StorageDead(_4);                 // scope 0 at src/codec/tradchinese.rs:101:70: 101:71
        StorageLive(_10);                // scope 1 at src/codec/tradchinese.rs:102:19: 102:21
        _10 = _3;                        // scope 1 at src/codec/tradchinese.rs:102:19: 102:21
        ((*_1).0: codec::tradchinese::bigfive2003::State) = move _10; // scope 1 at src/codec/tradchinese.rs:102:9: 102:21
        StorageDead(_10);                // scope 1 at src/codec/tradchinese.rs:102:20: 102:21
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:104:5: 104:6
        return;                          // scope 0 at src/codec/tradchinese.rs:104:6: 104:6
    }
}

promoted[0] in tradchinese::<impl at src/codec/tradchinese.rs:90:1: 105:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/tradchinese.rs:101:66: 101:69
    let mut _1: ();                      // in scope 0 at src/codec/tradchinese.rs:101:67: 101:69

    bb0: {
        nop;                             // scope 0 at src/codec/tradchinese.rs:101:67: 101:69
        _0 = &_1;                        // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
        return;                          // scope 0 at src/codec/tradchinese.rs:101:66: 101:69
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:81:1: 111:2>::raw_feed(_1: &mut SingleByteDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:85:17: 85:26
    debug input => _2;                   // in scope 0 at src/codec/singlebyte.rs:85:28: 85:33
    debug output => _3;                  // in scope 0 at src/codec/singlebyte.rs:85:42: 85:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/singlebyte.rs:85:72: 85:99
    let _4: ();                          // in scope 0 at src/codec/singlebyte.rs:86:9: 86:40
    let mut _5: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/singlebyte.rs:86:9: 86:15
    let mut _6: usize;                   // in scope 0 at src/codec/singlebyte.rs:86:28: 86:39
    let mut _7: &[u8];                   // in scope 0 at src/codec/singlebyte.rs:86:28: 86:33
    let mut _8: usize;                   // in scope 0 at src/codec/singlebyte.rs:88:13: 88:18
    let mut _10: &[u8];                  // in scope 0 at src/codec/singlebyte.rs:89:19: 89:24
    let mut _11: bool;                   // in scope 0 at src/codec/singlebyte.rs:90:15: 90:22
    let mut _12: usize;                  // in scope 0 at src/codec/singlebyte.rs:90:15: 90:16
    let mut _13: usize;                  // in scope 0 at src/codec/singlebyte.rs:90:19: 90:22
    let mut _14: bool;                   // in scope 0 at src/codec/singlebyte.rs:91:16: 91:32
    let mut _15: u8;                     // in scope 0 at src/codec/singlebyte.rs:91:16: 91:24
    let _16: usize;                      // in scope 0 at src/codec/singlebyte.rs:91:22: 91:23
    let mut _17: usize;                  // in scope 0 at src/codec/singlebyte.rs:91:16: 91:24
    let mut _18: bool;                   // in scope 0 at src/codec/singlebyte.rs:91:16: 91:24
    let _19: ();                         // in scope 0 at src/codec/singlebyte.rs:92:17: 92:52
    let mut _20: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/singlebyte.rs:92:17: 92:23
    let mut _21: char;                   // in scope 0 at src/codec/singlebyte.rs:92:35: 92:51
    let mut _22: u8;                     // in scope 0 at src/codec/singlebyte.rs:92:35: 92:43
    let _23: usize;                      // in scope 0 at src/codec/singlebyte.rs:92:41: 92:42
    let mut _24: usize;                  // in scope 0 at src/codec/singlebyte.rs:92:35: 92:43
    let mut _25: bool;                   // in scope 0 at src/codec/singlebyte.rs:92:35: 92:43
    let mut _27: fn(u8) -> u16;          // in scope 0 at src/codec/singlebyte.rs:94:26: 94:46
    let mut _28: u8;                     // in scope 0 at src/codec/singlebyte.rs:94:47: 94:55
    let _29: usize;                      // in scope 0 at src/codec/singlebyte.rs:94:53: 94:54
    let mut _30: usize;                  // in scope 0 at src/codec/singlebyte.rs:94:47: 94:55
    let mut _31: bool;                   // in scope 0 at src/codec/singlebyte.rs:94:47: 94:55
    let mut _32: u16;                    // in scope 0 at src/codec/singlebyte.rs:95:20: 95:22
    let _33: ();                         // in scope 0 at src/codec/singlebyte.rs:96:21: 96:58
    let mut _34: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/singlebyte.rs:96:21: 96:27
    let mut _35: char;                   // in scope 0 at src/codec/singlebyte.rs:96:39: 96:57
    let mut _36: u32;                    // in scope 0 at src/codec/singlebyte.rs:96:47: 96:56
    let mut _37: u16;                    // in scope 0 at src/codec/singlebyte.rs:96:47: 96:49
    let mut _38: usize;                  // in scope 0 at src/codec/singlebyte.rs:98:29: 98:30
    let mut _39: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/singlebyte.rs:98:32: 100:23
    let mut _40: encoding_types::CodecError; // in scope 0 at src/codec/singlebyte.rs:98:37: 100:22
    let mut _41: isize;                  // in scope 0 at src/codec/singlebyte.rs:99:31: 99:45
    let mut _42: isize;                  // in scope 0 at src/codec/singlebyte.rs:99:31: 99:41
    let mut _43: usize;                  // in scope 0 at src/codec/singlebyte.rs:99:31: 99:32
    let mut _44: std::borrow::Cow<str>;  // in scope 0 at src/codec/singlebyte.rs:99:54: 99:79
    let mut _45: &str;                   // in scope 0 at src/codec/singlebyte.rs:99:54: 99:72
    let _46: &str;                       // in scope 0 at src/codec/singlebyte.rs:99:54: 99:72
    let mut _47: usize;                  // in scope 0 at src/codec/singlebyte.rs:105:10: 105:11
    let mut _48: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/singlebyte.rs:105:13: 105:17
    scope 1 {
        debug i => _8;                   // in scope 1 at src/codec/singlebyte.rs:88:13: 88:18
        let _9: usize;                   // in scope 1 at src/codec/singlebyte.rs:89:13: 89:16
        scope 2 {
            debug len => _9;             // in scope 2 at src/codec/singlebyte.rs:89:13: 89:16
            let _26: u16;                // in scope 2 at src/codec/singlebyte.rs:94:21: 94:23
            scope 3 {
                debug ch => _26;         // in scope 3 at src/codec/singlebyte.rs:94:21: 94:23
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:86:9: 86:40
        StorageLive(_5);                 // scope 0 at src/codec/singlebyte.rs:86:9: 86:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/singlebyte.rs:86:9: 86:15
        StorageLive(_6);                 // scope 0 at src/codec/singlebyte.rs:86:28: 86:39
        StorageLive(_7);                 // scope 0 at src/codec/singlebyte.rs:86:28: 86:33
        _7 = _2;                         // scope 0 at src/codec/singlebyte.rs:86:28: 86:33
        _6 = Len((*_7));                 // scope 0 at src/codec/singlebyte.rs:86:28: 86:39
        StorageDead(_7);                 // scope 0 at src/codec/singlebyte.rs:86:38: 86:39
        _4 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _5, move _6) -> bb1; // scope 0 at src/codec/singlebyte.rs:86:9: 86:40
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:86:16: 86:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 0 at src/codec/singlebyte.rs:86:39: 86:40
        StorageDead(_5);                 // scope 0 at src/codec/singlebyte.rs:86:39: 86:40
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:86:40: 86:41
        StorageLive(_8);                 // scope 0 at src/codec/singlebyte.rs:88:13: 88:18
        _8 = const 0_usize;              // scope 0 at src/codec/singlebyte.rs:88:21: 88:22
        StorageLive(_9);                 // scope 1 at src/codec/singlebyte.rs:89:13: 89:16
        StorageLive(_10);                // scope 1 at src/codec/singlebyte.rs:89:19: 89:24
        _10 = _2;                        // scope 1 at src/codec/singlebyte.rs:89:19: 89:24
        _9 = Len((*_10));                // scope 1 at src/codec/singlebyte.rs:89:19: 89:30
        StorageDead(_10);                // scope 1 at src/codec/singlebyte.rs:89:29: 89:30
        goto -> bb2;                     // scope 2 at src/codec/singlebyte.rs:90:9: 104:10
    }

    bb2: {
        StorageLive(_11);                // scope 2 at src/codec/singlebyte.rs:90:15: 90:22
        StorageLive(_12);                // scope 2 at src/codec/singlebyte.rs:90:15: 90:16
        _12 = _8;                        // scope 2 at src/codec/singlebyte.rs:90:15: 90:16
        StorageLive(_13);                // scope 2 at src/codec/singlebyte.rs:90:19: 90:22
        _13 = _9;                        // scope 2 at src/codec/singlebyte.rs:90:19: 90:22
        _11 = Lt(move _12, move _13);    // scope 2 at src/codec/singlebyte.rs:90:15: 90:22
        StorageDead(_13);                // scope 2 at src/codec/singlebyte.rs:90:21: 90:22
        StorageDead(_12);                // scope 2 at src/codec/singlebyte.rs:90:21: 90:22
        switchInt(move _11) -> [false: bb17, otherwise: bb3]; // scope 2 at src/codec/singlebyte.rs:90:15: 90:22
    }

    bb3: {
        StorageLive(_14);                // scope 2 at src/codec/singlebyte.rs:91:16: 91:32
        StorageLive(_15);                // scope 2 at src/codec/singlebyte.rs:91:16: 91:24
        StorageLive(_16);                // scope 2 at src/codec/singlebyte.rs:91:22: 91:23
        _16 = _8;                        // scope 2 at src/codec/singlebyte.rs:91:22: 91:23
        _17 = Len((*_2));                // scope 2 at src/codec/singlebyte.rs:91:16: 91:24
        _18 = Lt(_16, _17);              // scope 2 at src/codec/singlebyte.rs:91:16: 91:24
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> bb4; // scope 2 at src/codec/singlebyte.rs:91:16: 91:24
    }

    bb4: {
        _15 = (*_2)[_16];                // scope 2 at src/codec/singlebyte.rs:91:16: 91:24
        _14 = Le(move _15, const 127_u8); // scope 2 at src/codec/singlebyte.rs:91:16: 91:32
        StorageDead(_16);                // scope 2 at src/codec/singlebyte.rs:91:31: 91:32
        StorageDead(_15);                // scope 2 at src/codec/singlebyte.rs:91:31: 91:32
        switchInt(move _14) -> [false: bb8, otherwise: bb5]; // scope 2 at src/codec/singlebyte.rs:91:16: 91:32
    }

    bb5: {
        StorageLive(_19);                // scope 2 at src/codec/singlebyte.rs:92:17: 92:52
        StorageLive(_20);                // scope 2 at src/codec/singlebyte.rs:92:17: 92:23
        _20 = &mut (*_3);                // scope 2 at src/codec/singlebyte.rs:92:17: 92:23
        StorageLive(_21);                // scope 2 at src/codec/singlebyte.rs:92:35: 92:51
        StorageLive(_22);                // scope 2 at src/codec/singlebyte.rs:92:35: 92:43
        StorageLive(_23);                // scope 2 at src/codec/singlebyte.rs:92:41: 92:42
        _23 = _8;                        // scope 2 at src/codec/singlebyte.rs:92:41: 92:42
        _24 = Len((*_2));                // scope 2 at src/codec/singlebyte.rs:92:35: 92:43
        _25 = Lt(_23, _24);              // scope 2 at src/codec/singlebyte.rs:92:35: 92:43
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb6; // scope 2 at src/codec/singlebyte.rs:92:35: 92:43
    }

    bb6: {
        _22 = (*_2)[_23];                // scope 2 at src/codec/singlebyte.rs:92:35: 92:43
        _21 = move _22 as char (Misc);   // scope 2 at src/codec/singlebyte.rs:92:35: 92:51
        StorageDead(_22);                // scope 2 at src/codec/singlebyte.rs:92:50: 92:51
        _19 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _20, move _21) -> bb7; // scope 2 at src/codec/singlebyte.rs:92:17: 92:52
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:92:24: 92:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_21);                // scope 2 at src/codec/singlebyte.rs:92:51: 92:52
        StorageDead(_20);                // scope 2 at src/codec/singlebyte.rs:92:51: 92:52
        StorageDead(_23);                // scope 2 at src/codec/singlebyte.rs:92:52: 92:53
        StorageDead(_19);                // scope 2 at src/codec/singlebyte.rs:92:52: 92:53
        goto -> bb16;                    // scope 2 at src/codec/singlebyte.rs:91:13: 102:14
    }

    bb8: {
        StorageLive(_26);                // scope 2 at src/codec/singlebyte.rs:94:21: 94:23
        StorageLive(_27);                // scope 2 at src/codec/singlebyte.rs:94:26: 94:46
        _27 = ((*_1).0: fn(u8) -> u16);  // scope 2 at src/codec/singlebyte.rs:94:26: 94:46
        StorageLive(_28);                // scope 2 at src/codec/singlebyte.rs:94:47: 94:55
        StorageLive(_29);                // scope 2 at src/codec/singlebyte.rs:94:53: 94:54
        _29 = _8;                        // scope 2 at src/codec/singlebyte.rs:94:53: 94:54
        _30 = Len((*_2));                // scope 2 at src/codec/singlebyte.rs:94:47: 94:55
        _31 = Lt(_29, _30);              // scope 2 at src/codec/singlebyte.rs:94:47: 94:55
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb9; // scope 2 at src/codec/singlebyte.rs:94:47: 94:55
    }

    bb9: {
        _28 = (*_2)[_29];                // scope 2 at src/codec/singlebyte.rs:94:47: 94:55
        _26 = move _27(move _28) -> bb10; // scope 2 at src/codec/singlebyte.rs:94:26: 94:56
    }

    bb10: {
        StorageDead(_28);                // scope 2 at src/codec/singlebyte.rs:94:55: 94:56
        StorageDead(_27);                // scope 2 at src/codec/singlebyte.rs:94:55: 94:56
        StorageDead(_29);                // scope 2 at src/codec/singlebyte.rs:94:56: 94:57
        StorageLive(_32);                // scope 3 at src/codec/singlebyte.rs:95:20: 95:22
        _32 = _26;                       // scope 3 at src/codec/singlebyte.rs:95:20: 95:22
        switchInt(move _32) -> [u16::MAX: bb14, otherwise: bb11]; // scope 3 at src/codec/singlebyte.rs:95:20: 95:32
    }

    bb11: {
        StorageDead(_32);                // scope 3 at src/codec/singlebyte.rs:95:20: 95:32
        StorageLive(_33);                // scope 3 at src/codec/singlebyte.rs:96:21: 96:58
        StorageLive(_34);                // scope 3 at src/codec/singlebyte.rs:96:21: 96:27
        _34 = &mut (*_3);                // scope 3 at src/codec/singlebyte.rs:96:21: 96:27
        StorageLive(_35);                // scope 3 at src/codec/singlebyte.rs:96:39: 96:57
        StorageLive(_36);                // scope 3 at src/codec/singlebyte.rs:96:47: 96:56
        StorageLive(_37);                // scope 3 at src/codec/singlebyte.rs:96:47: 96:49
        _37 = _26;                       // scope 3 at src/codec/singlebyte.rs:96:47: 96:49
        _36 = move _37 as u32 (Misc);    // scope 3 at src/codec/singlebyte.rs:96:47: 96:56
        StorageDead(_37);                // scope 3 at src/codec/singlebyte.rs:96:55: 96:56
        _35 = as_char(move _36) -> bb12; // scope 3 at src/codec/singlebyte.rs:96:39: 96:57
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:96:39: 96:46
                                         // + literal: Const { ty: fn(u32) -> char {util::as_char}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_36);                // scope 3 at src/codec/singlebyte.rs:96:56: 96:57
        _33 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _34, move _35) -> bb13; // scope 3 at src/codec/singlebyte.rs:96:21: 96:58
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:96:28: 96:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_35);                // scope 3 at src/codec/singlebyte.rs:96:57: 96:58
        StorageDead(_34);                // scope 3 at src/codec/singlebyte.rs:96:57: 96:58
        StorageDead(_33);                // scope 3 at src/codec/singlebyte.rs:96:58: 96:59
        StorageDead(_26);                // scope 2 at src/codec/singlebyte.rs:102:13: 102:14
        goto -> bb16;                    // scope 2 at src/codec/singlebyte.rs:91:13: 102:14
    }

    bb14: {
        StorageDead(_32);                // scope 3 at src/codec/singlebyte.rs:95:20: 95:32
        StorageLive(_38);                // scope 3 at src/codec/singlebyte.rs:98:29: 98:30
        _38 = _8;                        // scope 3 at src/codec/singlebyte.rs:98:29: 98:30
        StorageLive(_39);                // scope 3 at src/codec/singlebyte.rs:98:32: 100:23
        StorageLive(_40);                // scope 3 at src/codec/singlebyte.rs:98:37: 100:22
        StorageLive(_41);                // scope 3 at src/codec/singlebyte.rs:99:31: 99:45
        StorageLive(_42);                // scope 3 at src/codec/singlebyte.rs:99:31: 99:41
        StorageLive(_43);                // scope 3 at src/codec/singlebyte.rs:99:31: 99:32
        _43 = _8;                        // scope 3 at src/codec/singlebyte.rs:99:31: 99:32
        _42 = move _43 as isize (Misc);  // scope 3 at src/codec/singlebyte.rs:99:31: 99:41
        StorageDead(_43);                // scope 3 at src/codec/singlebyte.rs:99:40: 99:41
        _41 = Add(move _42, const 1_isize); // scope 3 at src/codec/singlebyte.rs:99:31: 99:45
        StorageDead(_42);                // scope 3 at src/codec/singlebyte.rs:99:44: 99:45
        StorageLive(_44);                // scope 3 at src/codec/singlebyte.rs:99:54: 99:79
        StorageLive(_45);                // scope 3 at src/codec/singlebyte.rs:99:54: 99:72
        StorageLive(_46);                // scope 3 at src/codec/singlebyte.rs:99:54: 99:72
        _46 = const "invalid sequence";  // scope 3 at src/codec/singlebyte.rs:99:54: 99:72
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:99:54: 99:72
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _45 = _46;                       // scope 3 at src/codec/singlebyte.rs:99:54: 99:72
        _44 = <&str as Into<Cow<str>>>::into(move _45) -> bb15; // scope 3 at src/codec/singlebyte.rs:99:54: 99:79
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:99:73: 99:77
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_45);                // scope 3 at src/codec/singlebyte.rs:99:78: 99:79
        (_40.0: isize) = move _41;       // scope 3 at src/codec/singlebyte.rs:98:37: 100:22
        (_40.1: std::borrow::Cow<str>) = move _44; // scope 3 at src/codec/singlebyte.rs:98:37: 100:22
        StorageDead(_44);                // scope 3 at src/codec/singlebyte.rs:100:21: 100:22
        StorageDead(_41);                // scope 3 at src/codec/singlebyte.rs:100:21: 100:22
        ((_39 as Some).0: encoding_types::CodecError) = move _40; // scope 3 at src/codec/singlebyte.rs:98:32: 100:23
        discriminant(_39) = 1;           // scope 3 at src/codec/singlebyte.rs:98:32: 100:23
        StorageDead(_40);                // scope 3 at src/codec/singlebyte.rs:100:22: 100:23
        (_0.0: usize) = move _38;        // scope 3 at src/codec/singlebyte.rs:98:28: 100:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _39; // scope 3 at src/codec/singlebyte.rs:98:28: 100:24
        StorageDead(_39);                // scope 3 at src/codec/singlebyte.rs:100:23: 100:24
        StorageDead(_38);                // scope 3 at src/codec/singlebyte.rs:100:23: 100:24
        StorageDead(_46);                // scope 3 at src/codec/singlebyte.rs:100:24: 100:25
        StorageDead(_26);                // scope 2 at src/codec/singlebyte.rs:102:13: 102:14
        StorageDead(_14);                // scope 2 at src/codec/singlebyte.rs:102:13: 102:14
        StorageDead(_11);                // scope 2 at src/codec/singlebyte.rs:104:9: 104:10
        StorageDead(_9);                 // scope 1 at src/codec/singlebyte.rs:106:5: 106:6
        StorageDead(_8);                 // scope 0 at src/codec/singlebyte.rs:106:5: 106:6
        goto -> bb18;                    // scope 0 at src/codec/singlebyte.rs:106:6: 106:6
    }

    bb16: {
        StorageDead(_14);                // scope 2 at src/codec/singlebyte.rs:102:13: 102:14
        _8 = Add(_8, const 1_usize);     // scope 2 at src/codec/singlebyte.rs:103:13: 103:19
        StorageDead(_11);                // scope 2 at src/codec/singlebyte.rs:104:9: 104:10
        goto -> bb2;                     // scope 2 at src/codec/singlebyte.rs:90:9: 104:10
    }

    bb17: {
        StorageDead(_11);                // scope 2 at src/codec/singlebyte.rs:104:9: 104:10
        StorageLive(_47);                // scope 2 at src/codec/singlebyte.rs:105:10: 105:11
        _47 = _8;                        // scope 2 at src/codec/singlebyte.rs:105:10: 105:11
        StorageLive(_48);                // scope 2 at src/codec/singlebyte.rs:105:13: 105:17
        discriminant(_48) = 0;           // scope 2 at src/codec/singlebyte.rs:105:13: 105:17
        (_0.0: usize) = move _47;        // scope 2 at src/codec/singlebyte.rs:105:9: 105:18
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _48; // scope 2 at src/codec/singlebyte.rs:105:9: 105:18
        StorageDead(_48);                // scope 2 at src/codec/singlebyte.rs:105:17: 105:18
        StorageDead(_47);                // scope 2 at src/codec/singlebyte.rs:105:17: 105:18
        StorageDead(_9);                 // scope 1 at src/codec/singlebyte.rs:106:5: 106:6
        StorageDead(_8);                 // scope 0 at src/codec/singlebyte.rs:106:5: 106:6
        goto -> bb18;                    // scope 0 at src/codec/singlebyte.rs:106:6: 106:6
    }

    bb18: {
        return;                          // scope 0 at src/codec/singlebyte.rs:106:6: 106:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:853:10: 853:15>::clone(_1: &ISO2022JPDecoder) -> ISO2022JPDecoder {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:853:10: 853:15
    let mut _0: codec::japanese::ISO2022JPDecoder; // return place in scope 0 at src/codec/japanese.rs:853:10: 853:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/japanese.rs:853:10: 853:15
        return;                          // scope 0 at src/codec/japanese.rs:853:15: 853:15
    }
}

const all::ASCII: &ASCIIEncoding = {
    let mut _0: &codec::ascii::ASCIIEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const all::ASCII::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::ascii::ASCIIEncoding
                                         // + val: Unevaluated(all::ASCII, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::ascii::ASCIIEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1248 ~ encoding[5d2c]::all::ASCII), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in all::ASCII: &ASCIIEncoding = {
    let mut _0: &codec::ascii::ASCIIEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::ascii::ASCIIEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn japanese::<impl at src/codec/japanese.rs:449:10: 449:15>::clone(_1: &Windows31JEncoding) -> Windows31JEncoding {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:449:10: 449:15
    let mut _0: codec::japanese::Windows31JEncoding; // return place in scope 0 at src/codec/japanese.rs:449:10: 449:15

    bb0: {
        return;                          // scope 0 at src/codec/japanese.rs:449:15: 449:15
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:81:10: 81:15>::clone(_1: &GBKEncoding) -> GBKEncoding {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:81:10: 81:15
    let mut _0: codec::simpchinese::GBKEncoding; // return place in scope 0 at src/codec/simpchinese.rs:81:10: 81:15

    bb0: {
        return;                          // scope 0 at src/codec/simpchinese.rs:81:15: 81:15
    }
}

fn bigfive2003::raw_feed(_1: bigfive2003::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (bigfive2003::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::tradchinese::bigfive2003::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _18: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _19: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _20: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _21: (std::option::Option<encoding_types::CodecError>, codec::tradchinese::bigfive2003::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _22: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _23: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _24: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _25: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _26: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _27: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _28: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _29: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _30: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _31: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _33: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _34: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _35: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _36: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _37: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _38: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _39: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _40: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _42: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _43: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _44: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _45: (std::option::Option<encoding_types::CodecError>, codec::tradchinese::bigfive2003::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _46: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _47: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _48: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _49: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _50: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _51: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _52: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _53: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _54: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _55: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _57: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _58: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _59: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _60: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _61: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _62: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _63: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::tradchinese::bigfive2003::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _17: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _32: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _41: codec::tradchinese::bigfive2003::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 5 {
                    debug err => _32;    // in scope 5 at src/util.rs:252:27: 252:30
                }
                scope 6 {
                    debug st_ => _41;    // in scope 6 at src/util.rs:256:25: 256:28
                    let _56: encoding_types::CodecError; // in scope 6 at src/util.rs:267:31: 267:34
                    scope 7 {
                        debug err => _56; // in scope 7 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug lead => _17;       // in scope 4 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<bigfive2003::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T> {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_17);                // scope 2 at src/util.rs:245:36: 245:40
        _17 = ((_1 as S1).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_18);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_19);                // scope 4 at src/util.rs:245:62: 245:70
        _19 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _18 = &mut (*_19);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_20);                // scope 4 at src/util.rs:245:75: 245:79
        _20 = _17;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = bigfive2003::transient::S1::<T>(move _18, move _20) -> [return: bb6, unwind: bb33]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::tradchinese::bigfive2003::State, T>, u8) -> codec::tradchinese::bigfive2003::State {codec::tradchinese::bigfive2003::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb7;                     // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageDead(_20);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_19);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_18);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_17);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb7;                     // scope 2 at src/util.rs:245:81: 245:82
    }

    bb7: {
        StorageLive(_21);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_22);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_23);                // scope 3 at src/util.rs:248:24: 248:31
        _23 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _22 = Option::<encoding_types::CodecError>::take(move _23) -> [return: bb8, unwind: bb33]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_23);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_24);                // scope 3 at src/util.rs:248:40: 248:43
        _24 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_21.0: std::option::Option<encoding_types::CodecError>) = move _22; // scope 3 at src/util.rs:248:23: 248:44
        (_21.1: codec::tradchinese::bigfive2003::State) = move _24; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_24);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_22);                // scope 3 at src/util.rs:248:43: 248:44
        _26 = discriminant((_21.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _26) -> [0_isize: bb9, 1_isize: bb10, otherwise: bb11]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb9: {
        _25 = discriminant((_21.1: codec::tradchinese::bigfive2003::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _25) -> [0_isize: bb12, otherwise: bb13]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb10: {
        StorageLive(_32);                // scope 3 at src/util.rs:252:27: 252:30
        _32 = move (((_21.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_33);                // scope 5 at src/util.rs:252:49: 252:52
        _33 = _15;                       // scope 5 at src/util.rs:252:49: 252:52
        StorageLive(_34);                // scope 5 at src/util.rs:252:54: 252:63
        _34 = _14;                       // scope 5 at src/util.rs:252:54: 252:63
        StorageLive(_35);                // scope 5 at src/util.rs:252:65: 252:74
        StorageLive(_36);                // scope 5 at src/util.rs:252:70: 252:73
        _36 = move _32;                  // scope 5 at src/util.rs:252:70: 252:73
        ((_35 as Some).0: encoding_types::CodecError) = move _36; // scope 5 at src/util.rs:252:65: 252:74
        discriminant(_35) = 1;           // scope 5 at src/util.rs:252:65: 252:74
        StorageDead(_36);                // scope 5 at src/util.rs:252:73: 252:74
        (_0.0: codec::tradchinese::bigfive2003::State) = move _33; // scope 5 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _34;        // scope 5 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _35; // scope 5 at src/util.rs:252:48: 252:75
        StorageDead(_35);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_34);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_33);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_32);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb29;                    // scope 3 at no-location
    }

    bb11: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb12: {
        StorageLive(_27);                // scope 3 at src/util.rs:249:70: 249:73
        _27 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _27;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_27);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_28);                // scope 3 at src/util.rs:249:87: 249:94
        _28 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _28;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_28);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_21);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb14;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb13: {
        StorageLive(_29);                // scope 3 at src/util.rs:251:44: 251:47
        _29 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_30);                // scope 3 at src/util.rs:251:49: 251:58
        _30 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_31);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_31) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::tradchinese::bigfive2003::State) = move _29; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _30;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _31; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_31);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_30);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_29);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb29;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb14: {
        StorageLive(_37);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_38);                // scope 3 at src/util.rs:255:23: 255:30
        _38 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_39);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_40);                // scope 3 at src/util.rs:255:33: 255:40
        _40 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _39 = core::slice::<impl [u8]>::len(move _40) -> [return: bb15, unwind: bb33]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_40);                // scope 3 at src/util.rs:255:45: 255:46
        _37 = Lt(move _38, move _39);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_39);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_38);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _37) -> [false: bb26, otherwise: bb16]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb16: {
        StorageLive(_41);                // scope 3 at src/util.rs:256:25: 256:28
        _42 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _42) -> [0_isize: bb18, otherwise: bb17]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb17: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb33; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb18: {
        StorageLive(_43);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_44);                // scope 3 at src/util.rs:257:49: 257:57
        _44 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _43 = &mut (*_44);               // scope 3 at src/util.rs:257:49: 257:57
        _41 = bigfive2003::start::S0::<T>(move _43) -> [return: bb19, unwind: bb33]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::tradchinese::bigfive2003::State, T>) -> codec::tradchinese::bigfive2003::State {codec::tradchinese::bigfive2003::start::S0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_44);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_43);                // scope 3 at src/util.rs:257:57: 257:58
        StorageLive(_45);                // scope 6 at src/util.rs:263:27: 263:48
        StorageLive(_46);                // scope 6 at src/util.rs:263:28: 263:42
        StorageLive(_47);                // scope 6 at src/util.rs:263:28: 263:35
        _47 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 6 at src/util.rs:263:28: 263:35
        _46 = Option::<encoding_types::CodecError>::take(move _47) -> [return: bb20, unwind: bb33]; // scope 6 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_47);                // scope 6 at src/util.rs:263:41: 263:42
        StorageLive(_48);                // scope 6 at src/util.rs:263:44: 263:47
        _48 = _41;                       // scope 6 at src/util.rs:263:44: 263:47
        (_45.0: std::option::Option<encoding_types::CodecError>) = move _46; // scope 6 at src/util.rs:263:27: 263:48
        (_45.1: codec::tradchinese::bigfive2003::State) = move _48; // scope 6 at src/util.rs:263:27: 263:48
        StorageDead(_48);                // scope 6 at src/util.rs:263:47: 263:48
        StorageDead(_46);                // scope 6 at src/util.rs:263:47: 263:48
        _50 = discriminant((_45.0: std::option::Option<encoding_types::CodecError>)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _50) -> [0_isize: bb21, 1_isize: bb22, otherwise: bb23]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb21: {
        _49 = discriminant((_45.1: codec::tradchinese::bigfive2003::State)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _49) -> [0_isize: bb24, otherwise: bb25]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb22: {
        StorageLive(_56);                // scope 6 at src/util.rs:267:31: 267:34
        _56 = move (((_45.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 6 at src/util.rs:267:31: 267:34
        StorageLive(_57);                // scope 7 at src/util.rs:267:53: 267:56
        _57 = _41;                       // scope 7 at src/util.rs:267:53: 267:56
        StorageLive(_58);                // scope 7 at src/util.rs:267:58: 267:67
        _58 = _14;                       // scope 7 at src/util.rs:267:58: 267:67
        StorageLive(_59);                // scope 7 at src/util.rs:267:69: 267:78
        StorageLive(_60);                // scope 7 at src/util.rs:267:74: 267:77
        _60 = move _56;                  // scope 7 at src/util.rs:267:74: 267:77
        ((_59 as Some).0: encoding_types::CodecError) = move _60; // scope 7 at src/util.rs:267:69: 267:78
        discriminant(_59) = 1;           // scope 7 at src/util.rs:267:69: 267:78
        StorageDead(_60);                // scope 7 at src/util.rs:267:77: 267:78
        (_0.0: codec::tradchinese::bigfive2003::State) = move _57; // scope 7 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _58;        // scope 7 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _59; // scope 7 at src/util.rs:267:52: 267:79
        StorageDead(_59);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_58);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_57);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_56);                // scope 6 at src/util.rs:267:81: 267:82
        goto -> bb28;                    // scope 6 at no-location
    }

    bb23: {
        unreachable;                     // scope 6 at src/util.rs:263:27: 263:48
    }

    bb24: {
        StorageLive(_51);                // scope 6 at src/util.rs:264:74: 264:77
        _51 = _41;                       // scope 6 at src/util.rs:264:74: 264:77
        _1 = move _51;                   // scope 6 at src/util.rs:264:69: 264:77
        StorageDead(_51);                // scope 6 at src/util.rs:264:76: 264:77
        StorageLive(_52);                // scope 6 at src/util.rs:264:91: 264:98
        _52 = (_9.1: usize);             // scope 6 at src/util.rs:264:91: 264:98
        _14 = move _52;                  // scope 6 at src/util.rs:264:79: 264:98
        StorageDead(_52);                // scope 6 at src/util.rs:264:97: 264:98
        StorageDead(_41);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb14;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb25: {
        StorageLive(_53);                // scope 6 at src/util.rs:266:48: 266:51
        _53 = _41;                       // scope 6 at src/util.rs:266:48: 266:51
        StorageLive(_54);                // scope 6 at src/util.rs:266:53: 266:62
        _54 = _14;                       // scope 6 at src/util.rs:266:53: 266:62
        StorageLive(_55);                // scope 6 at src/util.rs:266:64: 266:68
        discriminant(_55) = 0;           // scope 6 at src/util.rs:266:64: 266:68
        (_0.0: codec::tradchinese::bigfive2003::State) = move _53; // scope 6 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _54;        // scope 6 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _55; // scope 6 at src/util.rs:266:47: 266:69
        StorageDead(_55);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_54);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_53);                // scope 6 at src/util.rs:266:68: 266:69
        goto -> bb28;                    // scope 6 at src/util.rs:266:40: 266:69
    }

    bb26: {
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_61);                // scope 3 at src/util.rs:271:18: 271:20
        _61 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_62);                // scope 3 at src/util.rs:271:22: 271:31
        _62 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_63);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_63) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::tradchinese::bigfive2003::State) = move _61; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _62;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _63; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_63);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_62);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_61);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb27;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb27: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb32;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb28: {
        StorageDead(_41);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb30;                    // scope 3 at no-location
    }

    bb29: {
        StorageDead(_21);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb30;                    // scope 3 at no-location
    }

    bb30: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb31;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb31: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb32;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb32: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb33 (cleanup): {
        drop(_9) -> bb34;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb34 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:32:1: 37:2>::whatwg_name(_1: &EUCJPEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:34:20: 34:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/japanese.rs:34:30: 34:50
    let mut _2: &str;                    // in scope 0 at src/codec/japanese.rs:34:58: 34:66
    let _3: &str;                        // in scope 0 at src/codec/japanese.rs:34:58: 34:66

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:34:58: 34:66
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:34:58: 34:66
        _3 = const "euc-jp";             // scope 0 at src/codec/japanese.rs:34:58: 34:66
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:34:58: 34:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        _2 = _3;                         // scope 0 at src/codec/japanese.rs:34:58: 34:66
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/japanese.rs:34:53: 34:67
        discriminant(_0) = 1;            // scope 0 at src/codec/japanese.rs:34:53: 34:67
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:34:66: 34:67
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:34:68: 34:69
        return;                          // scope 0 at src/codec/japanese.rs:34:69: 34:69
    }
}

utf_8::<impl at src/codec/utf_8.rs:88:1: 92:2>::new::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at src/codec/utf_8.rs:90:56: 90:57

    bb0: {
        _0 = const 4_usize;              // scope 0 at src/codec/utf_8.rs:90:56: 90:57
        return;                          // scope 0 at src/codec/utf_8.rs:90:56: 90:57
    }
}

fn japanese::<impl at src/codec/japanese.rs:864:1: 879:2>::is_ascii_compatible(_1: &ISO2022JPDecoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:866:28: 866:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:866:38: 866:42

    bb0: {
        _0 = const false;                // scope 0 at src/codec/japanese.rs:866:45: 866:50
        return;                          // scope 0 at src/codec/japanese.rs:866:52: 866:52
    }
}

const UTF_16BE: &UTF16BEEncoding = {
    let mut _0: &codec::utf_16::UTF16BEEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const UTF_16BE::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16BEEncoding
                                         // + val: Unevaluated(UTF_16BE, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::utf_16::UTF16BEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1279 ~ encoding[5d2c]::all::UTF_16BE), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in UTF_16BE: &UTF16BEEncoding = {
    let mut _0: &codec::utf_16::UTF16BEEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::utf_16::UTF16BEEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:104:1: 113:2>::raw_finish(_1: &mut UTF16BEEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:112:19: 112:28
    debug _output => _2;                 // in scope 0 at src/codec/utf_16.rs:112:30: 112:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_16.rs:112:59: 112:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/utf_16.rs:112:80: 112:84
        return;                          // scope 0 at src/codec/utf_16.rs:112:86: 112:86
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:20:1: 24:2>::raw_encoder(_1: &ASCIIEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:22:20: 22:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/ascii.rs:22:30: 22:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/ascii.rs:22:48: 22:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/ascii.rs:22:48: 22:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/ascii.rs:22:48: 22:67
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:22:48: 22:67
        _3 = ASCIIEncoder::new() -> bb1; // scope 0 at src/codec/ascii.rs:22:48: 22:67
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:22:48: 22:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::ascii::ASCIIEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:22:48: 22:67
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:22:66: 22:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:22:48: 22:67
        StorageDead(_2);                 // scope 0 at src/codec/ascii.rs:22:68: 22:69
        return;                          // scope 0 at src/codec/ascii.rs:22:69: 22:69
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:78:10: 78:15>::clone(_1: &UTF16LEEncoder) -> UTF16LEEncoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:78:10: 78:15
    let mut _0: codec::utf_16::UTF16LEEncoder; // return place in scope 0 at src/codec/utf_16.rs:78:10: 78:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_16.rs:78:15: 78:15
    }
}

fn codec::whatwg::<impl at src/codec/whatwg.rs:15:1: 20:2>::name(_1: &EncoderOnlyUTF8Encoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/whatwg.rs:16:13: 16:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/whatwg.rs:16:23: 16:35

    bb0: {
        _0 = const "encoder-only-utf-8"; // scope 0 at src/codec/whatwg.rs:16:38: 16:58
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 110, 99, 111, 100, 101, 114, 45, 111, 110, 108, 121, 45, 117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [262143], len: Size { raw: 18 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 18 })
                                         // mir::Constant
                                         // + span: src/codec/whatwg.rs:16:38: 16:58
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 110, 99, 111, 100, 101, 114, 45, 111, 110, 108, 121, 45, 117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [262143], len: Size { raw: 18 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 18 }) }
        return;                          // scope 0 at src/codec/whatwg.rs:16:60: 16:60
    }
}

fn windows31j::transient::S0(_1: &mut StatefulDecoderHelper<windows31j::State, T>) -> windows31j::State {
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

const ISO_8859_6: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:47:64: 47:76
    let _5: &str;                        // in scope 0 at src/all.rs:47:64: 47:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_6::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_6, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1255 ~ encoding[5d2c]::all::ISO_8859_6), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_6: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:47:64: 47:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:47:64: 47:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-6";         // scope 0 at src/all.rs:47:64: 47:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:47:64: 47:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:47:64: 47:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_6::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_6::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_6::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_6::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-6"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:47:64: 47:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:22:1: 27:2>::whatwg_name(_1: &UTF16LEEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:24:20: 24:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/utf_16.rs:24:30: 24:50
    let mut _2: &str;                    // in scope 0 at src/codec/utf_16.rs:24:58: 24:68
    let _3: &str;                        // in scope 0 at src/codec/utf_16.rs:24:58: 24:68

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:24:58: 24:68
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:24:58: 24:68
        _3 = const "utf-16le";           // scope 0 at src/codec/utf_16.rs:24:58: 24:68
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 108, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:24:58: 24:68
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 108, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
        _2 = _3;                         // scope 0 at src/codec/utf_16.rs:24:58: 24:68
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/utf_16.rs:24:53: 24:69
        discriminant(_0) = 1;            // scope 0 at src/codec/utf_16.rs:24:53: 24:69
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:24:68: 24:69
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:24:70: 24:71
        return;                          // scope 0 at src/codec/utf_16.rs:24:71: 24:71
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:84:1: 89:2>::whatwg_name(_1: &GBKEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:86:20: 86:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/simpchinese.rs:86:30: 86:50
    let mut _2: &str;                    // in scope 0 at src/codec/simpchinese.rs:86:58: 86:63
    let _3: &str;                        // in scope 0 at src/codec/simpchinese.rs:86:58: 86:63

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:86:58: 86:63
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:86:58: 86:63
        _3 = const "gbk";                // scope 0 at src/codec/simpchinese.rs:86:58: 86:63
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:86:58: 86:63
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 }) }
        _2 = _3;                         // scope 0 at src/codec/simpchinese.rs:86:58: 86:63
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/simpchinese.rs:86:53: 86:64
        discriminant(_0) = 1;            // scope 0 at src/codec/simpchinese.rs:86:53: 86:64
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:86:63: 86:64
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:86:65: 86:66
        return;                          // scope 0 at src/codec/simpchinese.rs:86:66: 86:66
    }
}

fn codec::error::<impl at src/codec/error.rs:14:1: 18:2>::raw_encoder(_1: &ErrorEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:16:20: 16:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/error.rs:16:30: 16:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/error.rs:16:48: 16:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/error.rs:16:48: 16:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/error.rs:16:48: 16:67
        StorageLive(_3);                 // scope 0 at src/codec/error.rs:16:48: 16:67
        _3 = ErrorEncoder::new() -> bb1; // scope 0 at src/codec/error.rs:16:48: 16:67
                                         // mir::Constant
                                         // + span: src/codec/error.rs:16:48: 16:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::error::ErrorEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:16:48: 16:67
        StorageDead(_3);                 // scope 0 at src/codec/error.rs:16:66: 16:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:16:48: 16:67
        StorageDead(_2);                 // scope 0 at src/codec/error.rs:16:68: 16:69
        return;                          // scope 0 at src/codec/error.rs:16:69: 16:69
    }
}

UTF8Decoder::queue::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at src/codec/utf_8.rs:84:17: 84:18

    bb0: {
        _0 = const 4_usize;              // scope 0 at src/codec/utf_8.rs:84:17: 84:18
        return;                          // scope 0 at src/codec/utf_8.rs:84:17: 84:18
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:30:1: 35:2>::name(_1: &BigFive2003Encoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:31:13: 31:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/tradchinese.rs:31:23: 31:35

    bb0: {
        _0 = const "big5-2003";          // scope 0 at src/codec/tradchinese.rs:31:38: 31:49
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53, 45, 50, 48, 48, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:31:38: 31:49
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53, 45, 50, 48, 48, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
        return;                          // scope 0 at src/codec/tradchinese.rs:31:51: 31:51
    }
}

fn korean::<impl at src/codec/korean.rs:35:10: 35:15>::clone(_1: &Windows949Encoder) -> Windows949Encoder {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:35:10: 35:15
    let mut _0: codec::korean::Windows949Encoder; // return place in scope 0 at src/codec/korean.rs:35:10: 35:15

    bb0: {
        return;                          // scope 0 at src/codec/korean.rs:35:15: 35:15
    }
}

fn japanese::<impl at src/codec/japanese.rs:47:1: 84:2>::is_ascii_compatible(_1: &EUCJPEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:49:28: 49:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:49:38: 49:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/japanese.rs:49:45: 49:49
        return;                          // scope 0 at src/codec/japanese.rs:49:51: 49:51
    }
}

fn iso2022jp::State::Lead0208(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as Lead0208).0: ()) = move _1; // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 1;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

// MIR FOR CTFE
fn iso2022jp::State::Lead0208(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as Lead0208).0: ()) = move _1; // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 1;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

static REJECT_STATE: u8 = {
    let mut _0: u8;                      // return place in scope 0 at src/codec/utf_8.rs:133:22: 133:24

    bb0: {
        _0 = const 98_u8;                // scope 0 at src/codec/utf_8.rs:133:27: 133:29
        return;                          // scope 0 at src/codec/utf_8.rs:133:1: 133:30
    }
}

fn iso2022jp::transient::Lead0212(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:216:80: 216:92

    bb0: {
        discriminant(_0) = 2;            // scope 0 at src/util.rs:217:25: 217:54
        return;                          // scope 0 at src/util.rs:218:22: 218:22
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:12:16: 12:21>::clone(_1: &SingleByteEncoding) -> SingleByteEncoding {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:12:16: 12:21
    let mut _0: codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/codec/singlebyte.rs:12:16: 12:21
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 4 at src/codec/singlebyte.rs:12:16: 12:21
        return;                          // scope 0 at src/codec/singlebyte.rs:12:21: 12:21
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:266:1: 270:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_16.rs:267:21: 267:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:268:9: 268:64
    let mut _2: std::boxed::Box<codec::utf_16::UTF16LEDecoder>; // in scope 0 at src/codec/utf_16.rs:268:9: 268:64
    let mut _3: codec::utf_16::UTF16LEDecoder; // in scope 0 at src/codec/utf_16.rs:268:18: 268:63
    let mut _4: codec::utf_16::UTF16Decoder; // in scope 0 at src/codec/utf_16.rs:268:42: 268:61

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/utf_16.rs:268:9: 268:64
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:268:9: 268:64
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:268:18: 268:63
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:268:42: 268:61
        _4 = UTF16Decoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:268:42: 268:61
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:268:42: 268:59
                                         // + literal: Const { ty: fn() -> codec::utf_16::UTF16Decoder {codec::utf_16::UTF16Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::utf_16::UTF16Decoder) = move _4; // scope 0 at src/codec/utf_16.rs:268:18: 268:63
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:268:62: 268:63
        _2 = Box::<UTF16LEDecoder>::new(move _3) -> bb2; // scope 0 at src/codec/utf_16.rs:268:9: 268:64
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:268:9: 268:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::utf_16::UTF16LEDecoder) -> std::boxed::Box<codec::utf_16::UTF16LEDecoder> {std::boxed::Box::<codec::utf_16::UTF16LEDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:268:9: 268:64
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:268:63: 268:64
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:268:63: 268:64
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:268:9: 268:64
        StorageDead(_1);                 // scope 0 at src/codec/utf_16.rs:269:5: 269:6
        return;                          // scope 0 at src/codec/utf_16.rs:269:6: 269:6
    }
}

fn iso2022jp::<impl at src/util.rs:157:22: 157:31>::ne(_1: &iso2022jp::State, _2: &iso2022jp::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::japanese::iso2022jp::State, &codec::japanese::iso2022jp::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _20: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _21: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _23: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _24: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _25: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _28: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _29: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _32: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _33: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _36: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _37: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _40: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _41: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _44: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _45: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _48: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _49: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _52: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _53: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _58: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _59: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _60: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _61: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _62: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _63: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _68: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _69: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _70: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _71: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _72: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _73: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _26: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _27: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _30: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _31: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _34: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _35: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _38: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _39: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _42: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _43: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _46: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _47: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _50: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _51: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _54: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _55: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _56: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _57: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _64: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _65: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _66: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _67: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _26;   // in scope 3 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _27;  // in scope 3 at src/util.rs:161:27: 161:29
            }
            scope 4 {
                debug __self_0 => _30;   // in scope 4 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _31;  // in scope 4 at src/util.rs:161:27: 161:29
            }
            scope 5 {
                debug __self_0 => _34;   // in scope 5 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _35;  // in scope 5 at src/util.rs:161:27: 161:29
            }
            scope 6 {
                debug __self_0 => _38;   // in scope 6 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _39;  // in scope 6 at src/util.rs:164:25: 164:27
            }
            scope 7 {
                debug __self_0 => _42;   // in scope 7 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _43;  // in scope 7 at src/util.rs:164:25: 164:27
            }
            scope 8 {
                debug __self_0 => _46;   // in scope 8 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _47;  // in scope 8 at src/util.rs:164:25: 164:27
            }
            scope 9 {
                debug __self_0 => _50;   // in scope 9 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _51;  // in scope 9 at src/util.rs:164:25: 164:27
            }
            scope 10 {
                debug __self_0 => _54;   // in scope 10 at src/util.rs:164:25: 164:27
                debug __self_1 => _55;   // in scope 10 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _56;  // in scope 10 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _57;  // in scope 10 at src/util.rs:164:32: 164:35
            }
            scope 11 {
                debug __self_0 => _64;   // in scope 11 at src/util.rs:164:25: 164:27
                debug __self_1 => _65;   // in scope 11 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _66;  // in scope 11 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _67;  // in scope 11 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb37, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::japanese::iso2022jp::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::japanese::iso2022jp::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _25 = discriminant((*(_13.0: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _25) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, 4_isize: bb6, 5_isize: bb7, 6_isize: bb8, 7_isize: bb9, 8_isize: bb10, 9_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb12, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb14, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb16, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        _19 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [4_isize: bb18, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb7: {
        _20 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _20) -> [5_isize: bb20, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb8: {
        _21 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _21) -> [6_isize: bb22, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb9: {
        _22 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _22) -> [7_isize: bb24, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _23 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _23) -> [8_isize: bb26, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        _24 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _24) -> [9_isize: bb31, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb12: {
        StorageLive(_26);                // scope 2 at src/util.rs:161:27: 161:29
        _26 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Lead0208).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_27);                // scope 2 at src/util.rs:161:27: 161:29
        _27 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Lead0208).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_28);                // scope 3 at src/util.rs:161:27: 161:29
        _28 = _26;                       // scope 3 at src/util.rs:161:27: 161:29
        StorageLive(_29);                // scope 3 at src/util.rs:161:27: 161:29
        _29 = _27;                       // scope 3 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::ne(move _28, move _29) -> bb13; // scope 3 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_29);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_28);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_27);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_26);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb14: {
        StorageLive(_30);                // scope 2 at src/util.rs:161:27: 161:29
        _30 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Lead0212).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_31);                // scope 2 at src/util.rs:161:27: 161:29
        _31 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Lead0212).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_32);                // scope 4 at src/util.rs:161:27: 161:29
        _32 = _30;                       // scope 4 at src/util.rs:161:27: 161:29
        StorageLive(_33);                // scope 4 at src/util.rs:161:27: 161:29
        _33 = _31;                       // scope 4 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::ne(move _32, move _33) -> bb15; // scope 4 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_33);                // scope 4 at src/util.rs:161:28: 161:29
        StorageDead(_32);                // scope 4 at src/util.rs:161:28: 161:29
        StorageDead(_31);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb16: {
        StorageLive(_34);                // scope 2 at src/util.rs:161:27: 161:29
        _34 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Katakana).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_35);                // scope 2 at src/util.rs:161:27: 161:29
        _35 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Katakana).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_36);                // scope 5 at src/util.rs:161:27: 161:29
        _36 = _34;                       // scope 5 at src/util.rs:161:27: 161:29
        StorageLive(_37);                // scope 5 at src/util.rs:161:27: 161:29
        _37 = _35;                       // scope 5 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::ne(move _36, move _37) -> bb17; // scope 5 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_37);                // scope 5 at src/util.rs:161:28: 161:29
        StorageDead(_36);                // scope 5 at src/util.rs:161:28: 161:29
        StorageDead(_35);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_34);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb18: {
        StorageLive(_38);                // scope 2 at src/util.rs:164:25: 164:27
        _38 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeStart).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_39);                // scope 2 at src/util.rs:164:25: 164:27
        _39 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeStart).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_40);                // scope 6 at src/util.rs:164:25: 164:27
        _40 = _38;                       // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_41);                // scope 6 at src/util.rs:164:25: 164:27
        _41 = _39;                       // scope 6 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _40, move _41) -> bb19; // scope 6 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_41);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_40);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_39);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_38);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb20: {
        StorageLive(_42);                // scope 2 at src/util.rs:164:25: 164:27
        _42 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeMiddle24).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_43);                // scope 2 at src/util.rs:164:25: 164:27
        _43 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeMiddle24).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_44);                // scope 7 at src/util.rs:164:25: 164:27
        _44 = _42;                       // scope 7 at src/util.rs:164:25: 164:27
        StorageLive(_45);                // scope 7 at src/util.rs:164:25: 164:27
        _45 = _43;                       // scope 7 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _44, move _45) -> bb21; // scope 7 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb21: {
        StorageDead(_45);                // scope 7 at src/util.rs:164:26: 164:27
        StorageDead(_44);                // scope 7 at src/util.rs:164:26: 164:27
        StorageDead(_43);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_42);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb22: {
        StorageLive(_46);                // scope 2 at src/util.rs:164:25: 164:27
        _46 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeMiddle28).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_47);                // scope 2 at src/util.rs:164:25: 164:27
        _47 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeMiddle28).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_48);                // scope 8 at src/util.rs:164:25: 164:27
        _48 = _46;                       // scope 8 at src/util.rs:164:25: 164:27
        StorageLive(_49);                // scope 8 at src/util.rs:164:25: 164:27
        _49 = _47;                       // scope 8 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _48, move _49) -> bb23; // scope 8 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb23: {
        StorageDead(_49);                // scope 8 at src/util.rs:164:26: 164:27
        StorageDead(_48);                // scope 8 at src/util.rs:164:26: 164:27
        StorageDead(_47);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_46);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb24: {
        StorageLive(_50);                // scope 2 at src/util.rs:164:25: 164:27
        _50 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeFinal).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_51);                // scope 2 at src/util.rs:164:25: 164:27
        _51 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeFinal).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_52);                // scope 9 at src/util.rs:164:25: 164:27
        _52 = _50;                       // scope 9 at src/util.rs:164:25: 164:27
        StorageLive(_53);                // scope 9 at src/util.rs:164:25: 164:27
        _53 = _51;                       // scope 9 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _52, move _53) -> bb25; // scope 9 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb25: {
        StorageDead(_53);                // scope 9 at src/util.rs:164:26: 164:27
        StorageDead(_52);                // scope 9 at src/util.rs:164:26: 164:27
        StorageDead(_51);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_50);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb26: {
        StorageLive(_54);                // scope 2 at src/util.rs:164:25: 164:27
        _54 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0208).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_55);                // scope 2 at src/util.rs:164:32: 164:35
        _55 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0208).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_56);                // scope 2 at src/util.rs:164:25: 164:27
        _56 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0208).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_57);                // scope 2 at src/util.rs:164:32: 164:35
        _57 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0208).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_58);                // scope 10 at src/util.rs:164:25: 164:27
        StorageLive(_59);                // scope 10 at src/util.rs:164:25: 164:27
        _59 = _54;                       // scope 10 at src/util.rs:164:25: 164:27
        StorageLive(_60);                // scope 10 at src/util.rs:164:25: 164:27
        _60 = _56;                       // scope 10 at src/util.rs:164:25: 164:27
        _58 = <() as PartialEq>::ne(move _59, move _60) -> bb30; // scope 10 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb27: {
        _0 = const true;                 // scope 10 at src/util.rs:164:32: 164:35
        goto -> bb29;                    // scope 10 at src/util.rs:164:32: 164:35
    }

    bb28: {
        StorageLive(_61);                // scope 10 at src/util.rs:164:32: 164:35
        StorageLive(_62);                // scope 10 at src/util.rs:164:32: 164:35
        _62 = (*_55);                    // scope 10 at src/util.rs:164:32: 164:35
        StorageLive(_63);                // scope 10 at src/util.rs:164:32: 164:35
        _63 = (*_57);                    // scope 10 at src/util.rs:164:32: 164:35
        _61 = Ne(move _62, move _63);    // scope 10 at src/util.rs:164:32: 164:35
        StorageDead(_63);                // scope 10 at src/util.rs:164:34: 164:35
        StorageDead(_62);                // scope 10 at src/util.rs:164:34: 164:35
        _0 = move _61;                   // scope 10 at src/util.rs:164:32: 164:35
        goto -> bb29;                    // scope 10 at src/util.rs:164:32: 164:35
    }

    bb29: {
        StorageDead(_61);                // scope 10 at src/util.rs:164:34: 164:35
        StorageDead(_58);                // scope 10 at src/util.rs:164:34: 164:35
        StorageDead(_57);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_56);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_55);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_54);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb30: {
        StorageDead(_60);                // scope 10 at src/util.rs:164:26: 164:27
        StorageDead(_59);                // scope 10 at src/util.rs:164:26: 164:27
        switchInt(move _58) -> [false: bb28, otherwise: bb27]; // scope 10 at src/util.rs:164:32: 164:35
    }

    bb31: {
        StorageLive(_64);                // scope 2 at src/util.rs:164:25: 164:27
        _64 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0212).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_65);                // scope 2 at src/util.rs:164:32: 164:35
        _65 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0212).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_66);                // scope 2 at src/util.rs:164:25: 164:27
        _66 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0212).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_67);                // scope 2 at src/util.rs:164:32: 164:35
        _67 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0212).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_68);                // scope 11 at src/util.rs:164:25: 164:27
        StorageLive(_69);                // scope 11 at src/util.rs:164:25: 164:27
        _69 = _64;                       // scope 11 at src/util.rs:164:25: 164:27
        StorageLive(_70);                // scope 11 at src/util.rs:164:25: 164:27
        _70 = _66;                       // scope 11 at src/util.rs:164:25: 164:27
        _68 = <() as PartialEq>::ne(move _69, move _70) -> bb35; // scope 11 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb32: {
        _0 = const true;                 // scope 11 at src/util.rs:164:32: 164:35
        goto -> bb34;                    // scope 11 at src/util.rs:164:32: 164:35
    }

    bb33: {
        StorageLive(_71);                // scope 11 at src/util.rs:164:32: 164:35
        StorageLive(_72);                // scope 11 at src/util.rs:164:32: 164:35
        _72 = (*_65);                    // scope 11 at src/util.rs:164:32: 164:35
        StorageLive(_73);                // scope 11 at src/util.rs:164:32: 164:35
        _73 = (*_67);                    // scope 11 at src/util.rs:164:32: 164:35
        _71 = Ne(move _72, move _73);    // scope 11 at src/util.rs:164:32: 164:35
        StorageDead(_73);                // scope 11 at src/util.rs:164:34: 164:35
        StorageDead(_72);                // scope 11 at src/util.rs:164:34: 164:35
        _0 = move _71;                   // scope 11 at src/util.rs:164:32: 164:35
        goto -> bb34;                    // scope 11 at src/util.rs:164:32: 164:35
    }

    bb34: {
        StorageDead(_71);                // scope 11 at src/util.rs:164:34: 164:35
        StorageDead(_68);                // scope 11 at src/util.rs:164:34: 164:35
        StorageDead(_67);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_66);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_65);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_64);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb35: {
        StorageDead(_70);                // scope 11 at src/util.rs:164:26: 164:27
        StorageDead(_69);                // scope 11 at src/util.rs:164:26: 164:27
        switchInt(move _68) -> [false: bb33, otherwise: bb32]; // scope 11 at src/util.rs:164:32: 164:35
    }

    bb36: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb38;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb37: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb38;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb38: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:34:1: 59:2>::raw_feed(_1: &mut ASCIIEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:38:17: 38:26
    debug input => _2;                   // in scope 0 at src/codec/ascii.rs:38:28: 38:33
    debug output => _3;                  // in scope 0 at src/codec/ascii.rs:38:41: 38:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/ascii.rs:38:69: 38:96
    let _4: ();                          // in scope 0 at src/codec/ascii.rs:39:9: 39:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/ascii.rs:39:9: 39:15
    let mut _6: usize;                   // in scope 0 at src/codec/ascii.rs:39:28: 39:39
    let mut _7: &str;                    // in scope 0 at src/codec/ascii.rs:39:28: 39:33
    let mut _8: std::option::Option<usize>; // in scope 0 at src/codec/ascii.rs:41:15: 41:65
    let mut _9: &mut std::slice::Iter<u8>; // in scope 0 at src/codec/ascii.rs:41:15: 41:38
    let mut _10: std::slice::Iter<u8>;   // in scope 0 at src/codec/ascii.rs:41:15: 41:38
    let mut _11: &[u8];                  // in scope 0 at src/codec/ascii.rs:41:15: 41:31
    let _12: &[u8];                      // in scope 0 at src/codec/ascii.rs:41:15: 41:31
    let mut _13: &str;                   // in scope 0 at src/codec/ascii.rs:41:15: 41:20
    let mut _14: [closure@src/codec/ascii.rs:41:48: 41:64]; // in scope 0 at src/codec/ascii.rs:41:48: 41:64
    let mut _15: isize;                  // in scope 0 at src/codec/ascii.rs:42:13: 42:30
    let _16: usize;                      // in scope 0 at src/codec/ascii.rs:42:18: 42:29
    let _17: ();                         // in scope 0 at src/codec/ascii.rs:43:17: 43:69
    let mut _18: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/ascii.rs:43:17: 43:23
    let mut _19: &[u8];                  // in scope 0 at src/codec/ascii.rs:43:36: 43:68
    let _20: &[u8];                      // in scope 0 at src/codec/ascii.rs:43:36: 43:68
    let _21: &[u8];                      // in scope 0 at src/codec/ascii.rs:43:37: 43:68
    let mut _22: &[u8];                  // in scope 0 at src/codec/ascii.rs:43:37: 43:53
    let _23: &[u8];                      // in scope 0 at src/codec/ascii.rs:43:37: 43:53
    let mut _24: &str;                   // in scope 0 at src/codec/ascii.rs:43:37: 43:42
    let mut _25: std::ops::RangeTo<usize>; // in scope 0 at src/codec/ascii.rs:43:54: 43:67
    let mut _26: usize;                  // in scope 0 at src/codec/ascii.rs:43:56: 43:67
    let mut _28: char;                   // in scope 0 at src/codec/ascii.rs:44:27: 44:71
    let mut _29: std::option::Option<char>; // in scope 0 at src/codec/ascii.rs:44:27: 44:62
    let mut _30: &mut std::str::Chars;   // in scope 0 at src/codec/ascii.rs:44:27: 44:55
    let mut _31: std::str::Chars;        // in scope 0 at src/codec/ascii.rs:44:27: 44:55
    let mut _32: &str;                   // in scope 0 at src/codec/ascii.rs:44:27: 44:47
    let _33: &str;                       // in scope 0 at src/codec/ascii.rs:44:27: 44:47
    let mut _34: &str;                   // in scope 0 at src/codec/ascii.rs:44:27: 44:32
    let mut _35: std::ops::RangeFrom<usize>; // in scope 0 at src/codec/ascii.rs:44:33: 44:46
    let mut _36: usize;                  // in scope 0 at src/codec/ascii.rs:44:33: 44:44
    let mut _37: usize;                  // in scope 0 at src/codec/ascii.rs:45:18: 45:29
    let mut _38: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/ascii.rs:45:31: 47:19
    let mut _39: encoding_types::CodecError; // in scope 0 at src/codec/ascii.rs:45:36: 47:18
    let mut _40: isize;                  // in scope 0 at src/codec/ascii.rs:46:27: 46:55
    let mut _41: usize;                  // in scope 0 at src/codec/ascii.rs:46:27: 46:46
    let mut _42: usize;                  // in scope 0 at src/codec/ascii.rs:46:28: 46:39
    let mut _43: usize;                  // in scope 0 at src/codec/ascii.rs:46:42: 46:45
    let mut _44: std::borrow::Cow<str>;  // in scope 0 at src/codec/ascii.rs:46:64: 46:98
    let mut _45: &str;                   // in scope 0 at src/codec/ascii.rs:46:64: 46:91
    let _46: &str;                       // in scope 0 at src/codec/ascii.rs:46:64: 46:91
    let _47: ();                         // in scope 0 at src/codec/ascii.rs:50:17: 50:53
    let mut _48: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/ascii.rs:50:17: 50:23
    let mut _49: &[u8];                  // in scope 0 at src/codec/ascii.rs:50:36: 50:52
    let _50: &[u8];                      // in scope 0 at src/codec/ascii.rs:50:36: 50:52
    let mut _51: &str;                   // in scope 0 at src/codec/ascii.rs:50:36: 50:41
    let mut _52: usize;                  // in scope 0 at src/codec/ascii.rs:51:18: 51:29
    let mut _53: &str;                   // in scope 0 at src/codec/ascii.rs:51:18: 51:23
    let mut _54: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/ascii.rs:51:31: 51:35
    scope 1 {
        debug first_error => _16;        // in scope 1 at src/codec/ascii.rs:42:18: 42:29
        let _27: usize;                  // in scope 1 at src/codec/ascii.rs:44:21: 44:24
        scope 2 {
            debug len => _27;            // in scope 2 at src/codec/ascii.rs:44:21: 44:24
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/ascii.rs:39:9: 39:40
        StorageLive(_5);                 // scope 0 at src/codec/ascii.rs:39:9: 39:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/ascii.rs:39:9: 39:15
        StorageLive(_6);                 // scope 0 at src/codec/ascii.rs:39:28: 39:39
        StorageLive(_7);                 // scope 0 at src/codec/ascii.rs:39:28: 39:33
        _7 = _2;                         // scope 0 at src/codec/ascii.rs:39:28: 39:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/ascii.rs:39:28: 39:39
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:39:34: 39:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/ascii.rs:39:38: 39:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/ascii.rs:39:9: 39:40
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:39:16: 39:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/ascii.rs:39:39: 39:40
        StorageDead(_5);                 // scope 0 at src/codec/ascii.rs:39:39: 39:40
        StorageDead(_4);                 // scope 0 at src/codec/ascii.rs:39:40: 39:41
        StorageLive(_8);                 // scope 0 at src/codec/ascii.rs:41:15: 41:65
        StorageLive(_9);                 // scope 0 at src/codec/ascii.rs:41:15: 41:38
        StorageLive(_10);                // scope 0 at src/codec/ascii.rs:41:15: 41:38
        StorageLive(_11);                // scope 0 at src/codec/ascii.rs:41:15: 41:31
        StorageLive(_12);                // scope 0 at src/codec/ascii.rs:41:15: 41:31
        StorageLive(_13);                // scope 0 at src/codec/ascii.rs:41:15: 41:20
        _13 = _2;                        // scope 0 at src/codec/ascii.rs:41:15: 41:20
        _12 = core::str::<impl str>::as_bytes(move _13) -> bb3; // scope 0 at src/codec/ascii.rs:41:15: 41:31
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:41:21: 41:29
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> &'r [u8] {core::str::<impl str>::as_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        _11 = _12;                       // scope 0 at src/codec/ascii.rs:41:15: 41:31
        StorageDead(_13);                // scope 0 at src/codec/ascii.rs:41:30: 41:31
        _10 = core::slice::<impl [u8]>::iter(move _11) -> bb4; // scope 0 at src/codec/ascii.rs:41:15: 41:38
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:41:32: 41:36
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> std::slice::Iter<'r, u8> {core::slice::<impl [u8]>::iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        _9 = &mut _10;                   // scope 0 at src/codec/ascii.rs:41:15: 41:38
        StorageDead(_11);                // scope 0 at src/codec/ascii.rs:41:37: 41:38
        StorageLive(_14);                // scope 0 at src/codec/ascii.rs:41:48: 41:64
        _8 = <std::slice::Iter<u8> as Iterator>::position::<[closure@src/codec/ascii.rs:41:48: 41:64]>(move _9, move _14) -> bb5; // scope 0 at src/codec/ascii.rs:41:15: 41:65
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:41:39: 41:47
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::slice::Iter<u8>, [closure@src/codec/ascii.rs:41:48: 41:64]) -> std::option::Option<usize> {<std::slice::Iter<u8> as std::iter::Iterator>::position::<[closure@src/codec/ascii.rs:41:48: 41:64]>}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        StorageDead(_14);                // scope 0 at src/codec/ascii.rs:41:64: 41:65
        StorageDead(_9);                 // scope 0 at src/codec/ascii.rs:41:64: 41:65
        _15 = discriminant(_8);          // scope 0 at src/codec/ascii.rs:41:15: 41:65
        switchInt(move _15) -> [0_isize: bb6, 1_isize: bb8, otherwise: bb7]; // scope 0 at src/codec/ascii.rs:41:9: 41:65
    }

    bb6: {
        StorageLive(_47);                // scope 0 at src/codec/ascii.rs:50:17: 50:53
        StorageLive(_48);                // scope 0 at src/codec/ascii.rs:50:17: 50:23
        _48 = &mut (*_3);                // scope 0 at src/codec/ascii.rs:50:17: 50:23
        StorageLive(_49);                // scope 0 at src/codec/ascii.rs:50:36: 50:52
        StorageLive(_50);                // scope 0 at src/codec/ascii.rs:50:36: 50:52
        StorageLive(_51);                // scope 0 at src/codec/ascii.rs:50:36: 50:41
        _51 = _2;                        // scope 0 at src/codec/ascii.rs:50:36: 50:41
        _50 = core::str::<impl str>::as_bytes(move _51) -> bb18; // scope 0 at src/codec/ascii.rs:50:36: 50:52
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:50:42: 50:50
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> &'r [u8] {core::str::<impl str>::as_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        unreachable;                     // scope 0 at src/codec/ascii.rs:41:15: 41:65
    }

    bb8: {
        StorageLive(_16);                // scope 0 at src/codec/ascii.rs:42:18: 42:29
        _16 = ((_8 as Some).0: usize);   // scope 0 at src/codec/ascii.rs:42:18: 42:29
        StorageLive(_17);                // scope 1 at src/codec/ascii.rs:43:17: 43:69
        StorageLive(_18);                // scope 1 at src/codec/ascii.rs:43:17: 43:23
        _18 = &mut (*_3);                // scope 1 at src/codec/ascii.rs:43:17: 43:23
        StorageLive(_19);                // scope 1 at src/codec/ascii.rs:43:36: 43:68
        StorageLive(_20);                // scope 1 at src/codec/ascii.rs:43:36: 43:68
        StorageLive(_21);                // scope 1 at src/codec/ascii.rs:43:37: 43:68
        StorageLive(_22);                // scope 1 at src/codec/ascii.rs:43:37: 43:53
        StorageLive(_23);                // scope 1 at src/codec/ascii.rs:43:37: 43:53
        StorageLive(_24);                // scope 1 at src/codec/ascii.rs:43:37: 43:42
        _24 = _2;                        // scope 1 at src/codec/ascii.rs:43:37: 43:42
        _23 = core::str::<impl str>::as_bytes(move _24) -> bb9; // scope 1 at src/codec/ascii.rs:43:37: 43:53
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:43:43: 43:51
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> &'r [u8] {core::str::<impl str>::as_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        _22 = _23;                       // scope 1 at src/codec/ascii.rs:43:37: 43:53
        StorageDead(_24);                // scope 1 at src/codec/ascii.rs:43:52: 43:53
        StorageLive(_25);                // scope 1 at src/codec/ascii.rs:43:54: 43:67
        StorageLive(_26);                // scope 1 at src/codec/ascii.rs:43:56: 43:67
        _26 = _16;                       // scope 1 at src/codec/ascii.rs:43:56: 43:67
        (_25.0: usize) = move _26;       // scope 1 at src/codec/ascii.rs:43:54: 43:67
        StorageDead(_26);                // scope 1 at src/codec/ascii.rs:43:66: 43:67
        _21 = <[u8] as Index<RangeTo<usize>>>::index(move _22, move _25) -> bb10; // scope 1 at src/codec/ascii.rs:43:37: 43:68
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:43:37: 43:68
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::RangeTo<usize>) -> &'r <[u8] as std::ops::Index<std::ops::RangeTo<usize>>>::Output {<[u8] as std::ops::Index<std::ops::RangeTo<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_25);                // scope 1 at src/codec/ascii.rs:43:67: 43:68
        StorageDead(_22);                // scope 1 at src/codec/ascii.rs:43:67: 43:68
        _20 = _21;                       // scope 1 at src/codec/ascii.rs:43:36: 43:68
        _19 = _20;                       // scope 1 at src/codec/ascii.rs:43:36: 43:68
        _17 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _18, move _19) -> bb11; // scope 1 at src/codec/ascii.rs:43:17: 43:69
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:43:24: 43:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_19);                // scope 1 at src/codec/ascii.rs:43:68: 43:69
        StorageDead(_18);                // scope 1 at src/codec/ascii.rs:43:68: 43:69
        StorageDead(_23);                // scope 1 at src/codec/ascii.rs:43:69: 43:70
        StorageDead(_21);                // scope 1 at src/codec/ascii.rs:43:69: 43:70
        StorageDead(_20);                // scope 1 at src/codec/ascii.rs:43:69: 43:70
        StorageDead(_17);                // scope 1 at src/codec/ascii.rs:43:69: 43:70
        StorageLive(_27);                // scope 1 at src/codec/ascii.rs:44:21: 44:24
        StorageLive(_28);                // scope 1 at src/codec/ascii.rs:44:27: 44:71
        StorageLive(_29);                // scope 1 at src/codec/ascii.rs:44:27: 44:62
        StorageLive(_30);                // scope 1 at src/codec/ascii.rs:44:27: 44:55
        StorageLive(_31);                // scope 1 at src/codec/ascii.rs:44:27: 44:55
        StorageLive(_32);                // scope 1 at src/codec/ascii.rs:44:27: 44:47
        StorageLive(_33);                // scope 1 at src/codec/ascii.rs:44:27: 44:47
        StorageLive(_34);                // scope 1 at src/codec/ascii.rs:44:27: 44:32
        _34 = _2;                        // scope 1 at src/codec/ascii.rs:44:27: 44:32
        StorageLive(_35);                // scope 1 at src/codec/ascii.rs:44:33: 44:46
        StorageLive(_36);                // scope 1 at src/codec/ascii.rs:44:33: 44:44
        _36 = _16;                       // scope 1 at src/codec/ascii.rs:44:33: 44:44
        (_35.0: usize) = move _36;       // scope 1 at src/codec/ascii.rs:44:33: 44:46
        StorageDead(_36);                // scope 1 at src/codec/ascii.rs:44:45: 44:46
        _33 = <str as Index<RangeFrom<usize>>>::index(move _34, move _35) -> bb12; // scope 1 at src/codec/ascii.rs:44:27: 44:47
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:44:27: 44:47
                                         // + literal: Const { ty: for<'r> fn(&'r str, std::ops::RangeFrom<usize>) -> &'r <str as std::ops::Index<std::ops::RangeFrom<usize>>>::Output {<str as std::ops::Index<std::ops::RangeFrom<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        _32 = _33;                       // scope 1 at src/codec/ascii.rs:44:27: 44:47
        StorageDead(_35);                // scope 1 at src/codec/ascii.rs:44:46: 44:47
        StorageDead(_34);                // scope 1 at src/codec/ascii.rs:44:46: 44:47
        _31 = core::str::<impl str>::chars(move _32) -> bb13; // scope 1 at src/codec/ascii.rs:44:27: 44:55
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:44:48: 44:53
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> std::str::Chars<'r> {core::str::<impl str>::chars}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        _30 = &mut _31;                  // scope 1 at src/codec/ascii.rs:44:27: 44:55
        StorageDead(_32);                // scope 1 at src/codec/ascii.rs:44:54: 44:55
        _29 = <Chars as Iterator>::next(move _30) -> bb14; // scope 1 at src/codec/ascii.rs:44:27: 44:62
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:44:56: 44:60
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::str::Chars) -> std::option::Option<<std::str::Chars as std::iter::Iterator>::Item> {<std::str::Chars as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_30);                // scope 1 at src/codec/ascii.rs:44:61: 44:62
        _28 = Option::<char>::unwrap(move _29) -> bb15; // scope 1 at src/codec/ascii.rs:44:27: 44:71
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:44:63: 44:69
                                         // + literal: Const { ty: fn(std::option::Option<char>) -> char {std::option::Option::<char>::unwrap}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_29);                // scope 1 at src/codec/ascii.rs:44:70: 44:71
        _27 = char::methods::<impl char>::len_utf8(move _28) -> bb16; // scope 1 at src/codec/ascii.rs:44:27: 44:82
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:44:72: 44:80
                                         // + literal: Const { ty: fn(char) -> usize {std::char::methods::<impl char>::len_utf8}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_28);                // scope 1 at src/codec/ascii.rs:44:81: 44:82
        StorageDead(_33);                // scope 1 at src/codec/ascii.rs:44:82: 44:83
        StorageDead(_31);                // scope 1 at src/codec/ascii.rs:44:82: 44:83
        StorageLive(_37);                // scope 2 at src/codec/ascii.rs:45:18: 45:29
        _37 = _16;                       // scope 2 at src/codec/ascii.rs:45:18: 45:29
        StorageLive(_38);                // scope 2 at src/codec/ascii.rs:45:31: 47:19
        StorageLive(_39);                // scope 2 at src/codec/ascii.rs:45:36: 47:18
        StorageLive(_40);                // scope 2 at src/codec/ascii.rs:46:27: 46:55
        StorageLive(_41);                // scope 2 at src/codec/ascii.rs:46:27: 46:46
        StorageLive(_42);                // scope 2 at src/codec/ascii.rs:46:28: 46:39
        _42 = _16;                       // scope 2 at src/codec/ascii.rs:46:28: 46:39
        StorageLive(_43);                // scope 2 at src/codec/ascii.rs:46:42: 46:45
        _43 = _27;                       // scope 2 at src/codec/ascii.rs:46:42: 46:45
        _41 = Add(move _42, move _43);   // scope 2 at src/codec/ascii.rs:46:27: 46:46
        StorageDead(_43);                // scope 2 at src/codec/ascii.rs:46:45: 46:46
        StorageDead(_42);                // scope 2 at src/codec/ascii.rs:46:45: 46:46
        _40 = move _41 as isize (Misc);  // scope 2 at src/codec/ascii.rs:46:27: 46:55
        StorageDead(_41);                // scope 2 at src/codec/ascii.rs:46:54: 46:55
        StorageLive(_44);                // scope 2 at src/codec/ascii.rs:46:64: 46:98
        StorageLive(_45);                // scope 2 at src/codec/ascii.rs:46:64: 46:91
        StorageLive(_46);                // scope 2 at src/codec/ascii.rs:46:64: 46:91
        _46 = const "unrepresentable character"; // scope 2 at src/codec/ascii.rs:46:64: 46:91
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:46:64: 46:91
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _45 = _46;                       // scope 2 at src/codec/ascii.rs:46:64: 46:91
        _44 = <&str as Into<Cow<str>>>::into(move _45) -> bb17; // scope 2 at src/codec/ascii.rs:46:64: 46:98
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:46:92: 46:96
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_45);                // scope 2 at src/codec/ascii.rs:46:97: 46:98
        (_39.0: isize) = move _40;       // scope 2 at src/codec/ascii.rs:45:36: 47:18
        (_39.1: std::borrow::Cow<str>) = move _44; // scope 2 at src/codec/ascii.rs:45:36: 47:18
        StorageDead(_44);                // scope 2 at src/codec/ascii.rs:47:17: 47:18
        StorageDead(_40);                // scope 2 at src/codec/ascii.rs:47:17: 47:18
        ((_38 as Some).0: encoding_types::CodecError) = move _39; // scope 2 at src/codec/ascii.rs:45:31: 47:19
        discriminant(_38) = 1;           // scope 2 at src/codec/ascii.rs:45:31: 47:19
        StorageDead(_39);                // scope 2 at src/codec/ascii.rs:47:18: 47:19
        (_0.0: usize) = move _37;        // scope 2 at src/codec/ascii.rs:45:17: 47:20
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _38; // scope 2 at src/codec/ascii.rs:45:17: 47:20
        StorageDead(_38);                // scope 2 at src/codec/ascii.rs:47:19: 47:20
        StorageDead(_37);                // scope 2 at src/codec/ascii.rs:47:19: 47:20
        StorageDead(_27);                // scope 1 at src/codec/ascii.rs:48:13: 48:14
        StorageDead(_46);                // scope 1 at src/codec/ascii.rs:48:13: 48:14
        StorageDead(_16);                // scope 0 at src/codec/ascii.rs:48:13: 48:14
        goto -> bb21;                    // scope 0 at src/codec/ascii.rs:48:13: 48:14
    }

    bb18: {
        _49 = _50;                       // scope 0 at src/codec/ascii.rs:50:36: 50:52
        StorageDead(_51);                // scope 0 at src/codec/ascii.rs:50:51: 50:52
        _47 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _48, move _49) -> bb19; // scope 0 at src/codec/ascii.rs:50:17: 50:53
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:50:24: 50:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_49);                // scope 0 at src/codec/ascii.rs:50:52: 50:53
        StorageDead(_48);                // scope 0 at src/codec/ascii.rs:50:52: 50:53
        StorageDead(_50);                // scope 0 at src/codec/ascii.rs:50:53: 50:54
        StorageDead(_47);                // scope 0 at src/codec/ascii.rs:50:53: 50:54
        StorageLive(_52);                // scope 0 at src/codec/ascii.rs:51:18: 51:29
        StorageLive(_53);                // scope 0 at src/codec/ascii.rs:51:18: 51:23
        _53 = _2;                        // scope 0 at src/codec/ascii.rs:51:18: 51:23
        _52 = core::str::<impl str>::len(move _53) -> bb20; // scope 0 at src/codec/ascii.rs:51:18: 51:29
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:51:24: 51:27
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_53);                // scope 0 at src/codec/ascii.rs:51:28: 51:29
        StorageLive(_54);                // scope 0 at src/codec/ascii.rs:51:31: 51:35
        discriminant(_54) = 0;           // scope 0 at src/codec/ascii.rs:51:31: 51:35
        (_0.0: usize) = move _52;        // scope 0 at src/codec/ascii.rs:51:17: 51:36
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _54; // scope 0 at src/codec/ascii.rs:51:17: 51:36
        StorageDead(_54);                // scope 0 at src/codec/ascii.rs:51:35: 51:36
        StorageDead(_52);                // scope 0 at src/codec/ascii.rs:51:35: 51:36
        goto -> bb21;                    // scope 0 at src/codec/ascii.rs:51:35: 51:36
    }

    bb21: {
        StorageDead(_12);                // scope 0 at src/codec/ascii.rs:54:5: 54:6
        StorageDead(_10);                // scope 0 at src/codec/ascii.rs:54:5: 54:6
        StorageDead(_8);                 // scope 0 at src/codec/ascii.rs:54:5: 54:6
        return;                          // scope 0 at src/codec/ascii.rs:54:6: 54:6
    }
}

const HZ: &HZEncoding = {
    let mut _0: &codec::simpchinese::HZEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const HZ::promoted[0];      // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::simpchinese::HZEncoding
                                         // + val: Unevaluated(HZ, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::simpchinese::HZEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1286 ~ encoding[5d2c]::all::HZ), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in HZ: &HZEncoding = {
    let mut _0: &codec::simpchinese::HZEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::simpchinese::HZEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn eucjp::State::S3(_1: (), _2: u8) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S3).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 3;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn eucjp::State::S3(_1: (), _2: u8) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S3).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S3).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 3;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

const ISO_8859_16: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:54:66: 54:79
    let _5: &str;                        // in scope 0 at src/all.rs:54:66: 54:79
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_16::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_16, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1262 ~ encoding[5d2c]::all::ISO_8859_16), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_16: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:54:66: 54:79
    let mut _4: &str;                    // in scope 0 at src/all.rs:54:66: 54:79
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-16";        // scope 0 at src/all.rs:54:66: 54:79
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:54:66: 54:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:54:66: 54:79
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_16::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_16::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_16::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_16::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-16"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:54:66: 54:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:774:1: 779:2>::whatwg_name(_1: &ISO2022JPEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:776:20: 776:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/japanese.rs:776:30: 776:50
    let mut _2: &str;                    // in scope 0 at src/codec/japanese.rs:776:58: 776:71
    let _3: &str;                        // in scope 0 at src/codec/japanese.rs:776:58: 776:71

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:776:58: 776:71
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:776:58: 776:71
        _3 = const "iso-2022-jp";        // scope 0 at src/codec/japanese.rs:776:58: 776:71
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:776:58: 776:71
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _2 = _3;                         // scope 0 at src/codec/japanese.rs:776:58: 776:71
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/japanese.rs:776:53: 776:72
        discriminant(_0) = 1;            // scope 0 at src/codec/japanese.rs:776:53: 776:72
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:776:71: 776:72
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:776:73: 776:74
        return;                          // scope 0 at src/codec/japanese.rs:776:74: 776:74
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::backup_and_err(_1: &mut StatefulDecoderHelper<St, Data>, _2: usize, _3: &str) -> St {
    debug self => _1;                    // in scope 0 at src/util.rs:125:27: 125:36
    debug backup => _2;                  // in scope 0 at src/util.rs:125:38: 125:44
    debug msg => _3;                     // in scope 0 at src/util.rs:125:53: 125:56
    let mut _0: St;                      // return place in scope 0 at src/util.rs:125:75: 125:77
    let _4: isize;                       // in scope 0 at src/util.rs:126:13: 126:17
    let mut _5: isize;                   // in scope 0 at src/util.rs:126:20: 126:37
    let mut _6: usize;                   // in scope 0 at src/util.rs:126:20: 126:28
    let mut _7: isize;                   // in scope 0 at src/util.rs:126:40: 126:55
    let mut _8: usize;                   // in scope 0 at src/util.rs:126:40: 126:46
    let mut _9: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:127:20: 127:77
    let mut _10: encoding_types::CodecError; // in scope 0 at src/util.rs:127:25: 127:76
    let mut _11: isize;                  // in scope 0 at src/util.rs:127:51: 127:55
    let mut _12: std::borrow::Cow<str>;  // in scope 0 at src/util.rs:127:64: 127:74
    let mut _13: &str;                   // in scope 0 at src/util.rs:127:64: 127:67
    scope 1 {
        debug upto => _4;                // in scope 1 at src/util.rs:126:13: 126:17
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:126:13: 126:17
        StorageLive(_5);                 // scope 0 at src/util.rs:126:20: 126:37
        StorageLive(_6);                 // scope 0 at src/util.rs:126:20: 126:28
        _6 = ((*_1).1: usize);           // scope 0 at src/util.rs:126:20: 126:28
        _5 = move _6 as isize (Misc);    // scope 0 at src/util.rs:126:20: 126:37
        StorageDead(_6);                 // scope 0 at src/util.rs:126:36: 126:37
        StorageLive(_7);                 // scope 0 at src/util.rs:126:40: 126:55
        StorageLive(_8);                 // scope 0 at src/util.rs:126:40: 126:46
        _8 = _2;                         // scope 0 at src/util.rs:126:40: 126:46
        _7 = move _8 as isize (Misc);    // scope 0 at src/util.rs:126:40: 126:55
        StorageDead(_8);                 // scope 0 at src/util.rs:126:54: 126:55
        _4 = Sub(move _5, move _7);      // scope 0 at src/util.rs:126:20: 126:55
        StorageDead(_7);                 // scope 0 at src/util.rs:126:54: 126:55
        StorageDead(_5);                 // scope 0 at src/util.rs:126:54: 126:55
        StorageLive(_9);                 // scope 1 at src/util.rs:127:20: 127:77
        StorageLive(_10);                // scope 1 at src/util.rs:127:25: 127:76
        StorageLive(_11);                // scope 1 at src/util.rs:127:51: 127:55
        _11 = _4;                        // scope 1 at src/util.rs:127:51: 127:55
        StorageLive(_12);                // scope 1 at src/util.rs:127:64: 127:74
        StorageLive(_13);                // scope 1 at src/util.rs:127:64: 127:67
        _13 = _3;                        // scope 1 at src/util.rs:127:64: 127:67
        _12 = <&str as Into<Cow<str>>>::into(move _13) -> bb1; // scope 1 at src/util.rs:127:64: 127:74
                                         // mir::Constant
                                         // + span: src/util.rs:127:68: 127:72
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_13);                // scope 1 at src/util.rs:127:73: 127:74
        (_10.0: isize) = move _11;       // scope 1 at src/util.rs:127:25: 127:76
        (_10.1: std::borrow::Cow<str>) = move _12; // scope 1 at src/util.rs:127:25: 127:76
        StorageDead(_12);                // scope 1 at src/util.rs:127:75: 127:76
        StorageDead(_11);                // scope 1 at src/util.rs:127:75: 127:76
        ((_9 as Some).0: encoding_types::CodecError) = move _10; // scope 1 at src/util.rs:127:20: 127:77
        discriminant(_9) = 1;            // scope 1 at src/util.rs:127:20: 127:77
        StorageDead(_10);                // scope 1 at src/util.rs:127:76: 127:77
        drop(((*_1).3: std::option::Option<encoding_types::CodecError>)) -> [return: bb4, unwind: bb3]; // scope 1 at src/util.rs:127:9: 127:17
    }

    bb2: {
        StorageDead(_4);                 // scope 0 at src/util.rs:129:5: 129:6
        return;                          // scope 0 at src/util.rs:129:6: 129:6
    }

    bb3 (cleanup): {
        ((*_1).3: std::option::Option<encoding_types::CodecError>) = move _9; // scope 1 at src/util.rs:127:9: 127:17
        resume;                          // scope 0 at src/util.rs:125:5: 129:6
    }

    bb4: {
        ((*_1).3: std::option::Option<encoding_types::CodecError>) = move _9; // scope 1 at src/util.rs:127:9: 127:17
        StorageDead(_9);                 // scope 1 at src/util.rs:127:76: 127:77
        _0 = <St as Default>::default() -> bb2; // scope 1 at src/util.rs:128:9: 128:27
                                         // mir::Constant
                                         // + span: src/util.rs:128:9: 128:25
                                         // + literal: Const { ty: fn() -> St {<St as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:40:1: 45:2>::raw_decoder(_1: &UTF16BEEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:44:20: 44:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_16.rs:44:30: 44:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:44:48: 44:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:44:48: 44:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:44:48: 44:69
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:44:48: 44:69
        _3 = UTF16BEDecoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:44:48: 44:69
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:44:48: 44:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::utf_16::UTF16BEDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:44:48: 44:69
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:44:68: 44:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:44:48: 44:69
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:44:70: 44:71
        return;                          // scope 0 at src/codec/utf_16.rs:44:71: 44:71
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:99:1: 106:2>::is_ascii_compatible(_1: &GBKEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:101:28: 101:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/simpchinese.rs:101:38: 101:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/simpchinese.rs:101:45: 101:49
        return;                          // scope 0 at src/codec/simpchinese.rs:101:51: 101:51
    }
}

fn codec::error::<impl at src/codec/error.rs:28:1: 43:2>::raw_finish(_1: &mut ErrorEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:40:19: 40:28
    debug _output => _2;                 // in scope 0 at src/codec/error.rs:40:30: 40:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/error.rs:40:59: 40:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/error.rs:41:9: 41:13
        return;                          // scope 0 at src/codec/error.rs:42:6: 42:6
    }
}

fn korean::<impl at src/codec/korean.rs:27:1: 32:2>::raw_decoder(_1: &Windows949Encoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:31:20: 31:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/korean.rs:31:30: 31:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/korean.rs:31:48: 31:72
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/korean.rs:31:48: 31:72

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:31:48: 31:72
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:31:48: 31:72
        _3 = Windows949Decoder::new() -> bb1; // scope 0 at src/codec/korean.rs:31:48: 31:72
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:31:48: 31:70
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::korean::Windows949Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:31:48: 31:72
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:31:71: 31:72
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:31:48: 31:72
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:31:73: 31:74
        return;                          // scope 0 at src/codec/korean.rs:31:74: 31:74
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:45:1: 76:2>::from_self(_1: &BigFive2003Encoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:46:18: 46:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/tradchinese.rs:46:28: 46:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/tradchinese.rs:46:46: 46:71
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/tradchinese.rs:46:46: 46:71

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:46:46: 46:71
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:46:46: 46:71
        _3 = BigFive2003Encoder::new() -> bb1; // scope 0 at src/codec/tradchinese.rs:46:46: 46:71
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:46:46: 46:69
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::tradchinese::BigFive2003Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:46:46: 46:71
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:46:70: 46:71
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:46:46: 46:71
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:46:72: 46:73
        return;                          // scope 0 at src/codec/tradchinese.rs:46:73: 46:73
    }
}

fn codec::error::<impl at src/codec/error.rs:46:10: 46:15>::clone(_1: &ErrorDecoder) -> ErrorDecoder {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:46:10: 46:15
    let mut _0: codec::error::ErrorDecoder; // return place in scope 0 at src/codec/error.rs:46:10: 46:15

    bb0: {
        return;                          // scope 0 at src/codec/error.rs:46:15: 46:15
    }
}

fn japanese::<impl at src/codec/japanese.rs:98:1: 113:2>::is_ascii_compatible(_1: &EUCJP0212Decoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:100:28: 100:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:100:38: 100:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/japanese.rs:100:45: 100:49
        return;                          // scope 0 at src/codec/japanese.rs:100:51: 100:51
    }
}

fn decode(_1: &[u8], _2: DecoderTrap, _3: &dyn encoding_types::Encoding + Send + Sync) -> (Result<String, Cow<str>>, &dyn encoding_types::Encoding + Send + Sync) {
    debug input => _1;                   // in scope 0 at src/lib.rs:268:15: 268:20
    debug trap => _2;                    // in scope 0 at src/lib.rs:268:29: 268:33
    debug fallback_encoding => _3;       // in scope 0 at src/lib.rs:268:48: 268:65
    let mut _0: (std::result::Result<std::string::String, std::borrow::Cow<str>>, &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync); // return place in scope 0 at src/lib.rs:269:15: 269:63
    let mut _4: bool;                    // in scope 0 at src/lib.rs:271:8: 271:46
    let mut _5: &[u8];                   // in scope 0 at src/lib.rs:271:8: 271:13
    let mut _6: &[u8];                   // in scope 0 at src/lib.rs:271:26: 271:45
    let mut _7: &[u8; 3];                // in scope 0 at src/lib.rs:271:26: 271:45
    let _8: &[u8; 3];                    // in scope 0 at src/lib.rs:271:26: 271:45
    let mut _9: std::result::Result<std::string::String, std::borrow::Cow<str>>; // in scope 0 at src/lib.rs:272:10: 272:41
    let mut _10: &codec::utf_8::UTF8Encoding; // in scope 0 at src/lib.rs:272:10: 272:15
    let _11: &codec::utf_8::UTF8Encoding; // in scope 0 at src/lib.rs:272:10: 272:15
    let mut _12: &[u8];                  // in scope 0 at src/lib.rs:272:23: 272:34
    let _13: &[u8];                      // in scope 0 at src/lib.rs:272:23: 272:34
    let _14: &[u8];                      // in scope 0 at src/lib.rs:272:24: 272:34
    let mut _15: &[u8];                  // in scope 0 at src/lib.rs:272:24: 272:29
    let mut _16: std::ops::RangeFrom<usize>; // in scope 0 at src/lib.rs:272:30: 272:33
    let mut _17: encoding_types::DecoderTrap; // in scope 0 at src/lib.rs:272:36: 272:40
    let mut _18: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:272:43: 272:63
    let mut _19: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:272:43: 272:63
    let _20: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:272:43: 272:63
    let mut _21: &codec::utf_8::UTF8Encoding; // in scope 0 at src/lib.rs:272:43: 272:48
    let _22: &codec::utf_8::UTF8Encoding; // in scope 0 at src/lib.rs:272:43: 272:48
    let mut _23: bool;                   // in scope 0 at src/lib.rs:273:15: 273:47
    let mut _24: &[u8];                  // in scope 0 at src/lib.rs:273:15: 273:20
    let mut _25: &[u8];                  // in scope 0 at src/lib.rs:273:33: 273:46
    let mut _26: &[u8; 2];               // in scope 0 at src/lib.rs:273:33: 273:46
    let _27: &[u8; 2];                   // in scope 0 at src/lib.rs:273:33: 273:46
    let mut _28: std::result::Result<std::string::String, std::borrow::Cow<str>>; // in scope 0 at src/lib.rs:274:10: 274:44
    let mut _29: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/lib.rs:274:10: 274:18
    let _30: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/lib.rs:274:10: 274:18
    let mut _31: &[u8];                  // in scope 0 at src/lib.rs:274:26: 274:37
    let _32: &[u8];                      // in scope 0 at src/lib.rs:274:26: 274:37
    let _33: &[u8];                      // in scope 0 at src/lib.rs:274:27: 274:37
    let mut _34: &[u8];                  // in scope 0 at src/lib.rs:274:27: 274:32
    let mut _35: std::ops::RangeFrom<usize>; // in scope 0 at src/lib.rs:274:33: 274:36
    let mut _36: encoding_types::DecoderTrap; // in scope 0 at src/lib.rs:274:39: 274:43
    let mut _37: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:274:46: 274:69
    let mut _38: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:274:46: 274:69
    let _39: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:274:46: 274:69
    let mut _40: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/lib.rs:274:46: 274:54
    let _41: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/lib.rs:274:46: 274:54
    let mut _42: bool;                   // in scope 0 at src/lib.rs:275:15: 275:47
    let mut _43: &[u8];                  // in scope 0 at src/lib.rs:275:15: 275:20
    let mut _44: &[u8];                  // in scope 0 at src/lib.rs:275:33: 275:46
    let mut _45: &[u8; 2];               // in scope 0 at src/lib.rs:275:33: 275:46
    let _46: &[u8; 2];                   // in scope 0 at src/lib.rs:275:33: 275:46
    let mut _47: std::result::Result<std::string::String, std::borrow::Cow<str>>; // in scope 0 at src/lib.rs:276:10: 276:44
    let mut _48: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/lib.rs:276:10: 276:18
    let _49: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/lib.rs:276:10: 276:18
    let mut _50: &[u8];                  // in scope 0 at src/lib.rs:276:26: 276:37
    let _51: &[u8];                      // in scope 0 at src/lib.rs:276:26: 276:37
    let _52: &[u8];                      // in scope 0 at src/lib.rs:276:27: 276:37
    let mut _53: &[u8];                  // in scope 0 at src/lib.rs:276:27: 276:32
    let mut _54: std::ops::RangeFrom<usize>; // in scope 0 at src/lib.rs:276:33: 276:36
    let mut _55: encoding_types::DecoderTrap; // in scope 0 at src/lib.rs:276:39: 276:43
    let mut _56: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:276:46: 276:69
    let mut _57: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:276:46: 276:69
    let _58: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:276:46: 276:69
    let mut _59: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/lib.rs:276:46: 276:54
    let _60: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/lib.rs:276:46: 276:54
    let mut _61: std::result::Result<std::string::String, std::borrow::Cow<str>>; // in scope 0 at src/lib.rs:278:10: 278:47
    let mut _62: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:278:10: 278:27
    let mut _63: &[u8];                  // in scope 0 at src/lib.rs:278:35: 278:40
    let mut _64: encoding_types::DecoderTrap; // in scope 0 at src/lib.rs:278:42: 278:46
    let mut _65: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:278:49: 278:66
    let mut _66: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/lib.rs:278:49: 278:66
    let mut _67: &[u8; 2];               // in scope 0 at src/lib.rs:275:33: 275:46
    let mut _68: &[u8; 2];               // in scope 0 at src/lib.rs:273:33: 273:46
    let mut _69: &[u8; 3];               // in scope 0 at src/lib.rs:271:26: 271:45

    bb0: {
        StorageLive(_4);                 // scope 0 at src/lib.rs:271:8: 271:46
        StorageLive(_5);                 // scope 0 at src/lib.rs:271:8: 271:13
        _5 = _1;                         // scope 0 at src/lib.rs:271:8: 271:13
        StorageLive(_6);                 // scope 0 at src/lib.rs:271:26: 271:45
        StorageLive(_7);                 // scope 0 at src/lib.rs:271:26: 271:45
        StorageLive(_8);                 // scope 0 at src/lib.rs:271:26: 271:45
        _69 = const decode::promoted[2]; // scope 0 at src/lib.rs:271:26: 271:45
                                         // ty::Const
                                         // + ty: &[u8; 3]
                                         // + val: Unevaluated(decode, [], Some(promoted[2]))
                                         // mir::Constant
                                         // + span: src/lib.rs:271:26: 271:45
                                         // + literal: Const { ty: &[u8; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:592 ~ encoding[5d2c]::decode), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[2]) }) }
        _8 = _69;                        // scope 0 at src/lib.rs:271:26: 271:45
        _7 = _8;                         // scope 0 at src/lib.rs:271:26: 271:45
        _6 = move _7 as &[u8] (Pointer(Unsize)); // scope 0 at src/lib.rs:271:26: 271:45
        StorageDead(_7);                 // scope 0 at src/lib.rs:271:44: 271:45
        _4 = core::slice::<impl [u8]>::starts_with(move _5, move _6) -> bb1; // scope 0 at src/lib.rs:271:8: 271:46
                                         // mir::Constant
                                         // + span: src/lib.rs:271:14: 271:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r [u8], &'s [u8]) -> bool {core::slice::<impl [u8]>::starts_with}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/lib.rs:271:45: 271:46
        StorageDead(_6);                 // scope 0 at src/lib.rs:271:45: 271:46
        StorageDead(_5);                 // scope 0 at src/lib.rs:271:45: 271:46
        switchInt(move _4) -> [false: bb5, otherwise: bb2]; // scope 0 at src/lib.rs:271:8: 271:46
    }

    bb2: {
        StorageLive(_9);                 // scope 0 at src/lib.rs:272:10: 272:41
        StorageLive(_10);                // scope 0 at src/lib.rs:272:10: 272:15
        StorageLive(_11);                // scope 0 at src/lib.rs:272:10: 272:15
        _11 = const UTF_8;               // scope 0 at src/lib.rs:272:10: 272:15
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(UTF_8, [], None)
                                         // mir::Constant
                                         // + span: src/lib.rs:272:10: 272:15
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1277 ~ encoding[5d2c]::all::UTF_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _10 = _11;                       // scope 0 at src/lib.rs:272:10: 272:15
        StorageLive(_12);                // scope 0 at src/lib.rs:272:23: 272:34
        StorageLive(_13);                // scope 0 at src/lib.rs:272:23: 272:34
        StorageLive(_14);                // scope 0 at src/lib.rs:272:24: 272:34
        StorageLive(_15);                // scope 0 at src/lib.rs:272:24: 272:29
        _15 = _1;                        // scope 0 at src/lib.rs:272:24: 272:29
        StorageLive(_16);                // scope 0 at src/lib.rs:272:30: 272:33
        (_16.0: usize) = const 3_usize;  // scope 0 at src/lib.rs:272:30: 272:33
        _14 = <[u8] as Index<RangeFrom<usize>>>::index(move _15, move _16) -> bb3; // scope 0 at src/lib.rs:272:24: 272:34
                                         // mir::Constant
                                         // + span: src/lib.rs:272:24: 272:34
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::RangeFrom<usize>) -> &'r <[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::Output {<[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_16);                // scope 0 at src/lib.rs:272:33: 272:34
        StorageDead(_15);                // scope 0 at src/lib.rs:272:33: 272:34
        _13 = _14;                       // scope 0 at src/lib.rs:272:23: 272:34
        _12 = _13;                       // scope 0 at src/lib.rs:272:23: 272:34
        StorageLive(_17);                // scope 0 at src/lib.rs:272:36: 272:40
        _17 = _2;                        // scope 0 at src/lib.rs:272:36: 272:40
        _9 = <UTF8Encoding as encoding_types::Encoding>::decode(move _10, move _12, move _17) -> bb4; // scope 0 at src/lib.rs:272:10: 272:41
                                         // mir::Constant
                                         // + span: src/lib.rs:272:16: 272:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::utf_8::UTF8Encoding, &'s [u8], encoding_types::DecoderTrap) -> std::result::Result<std::string::String, std::borrow::Cow<'static, str>> {<codec::utf_8::UTF8Encoding as encoding_types::Encoding>::decode}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_17);                // scope 0 at src/lib.rs:272:40: 272:41
        StorageDead(_12);                // scope 0 at src/lib.rs:272:40: 272:41
        StorageDead(_10);                // scope 0 at src/lib.rs:272:40: 272:41
        StorageLive(_18);                // scope 0 at src/lib.rs:272:43: 272:63
        StorageLive(_19);                // scope 0 at src/lib.rs:272:43: 272:63
        StorageLive(_20);                // scope 0 at src/lib.rs:272:43: 272:63
        StorageLive(_21);                // scope 0 at src/lib.rs:272:43: 272:48
        StorageLive(_22);                // scope 0 at src/lib.rs:272:43: 272:48
        _22 = const UTF_8;               // scope 0 at src/lib.rs:272:43: 272:48
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(UTF_8, [], None)
                                         // mir::Constant
                                         // + span: src/lib.rs:272:43: 272:48
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1277 ~ encoding[5d2c]::all::UTF_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _21 = _22;                       // scope 0 at src/lib.rs:272:43: 272:48
        _20 = move _21 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:272:43: 272:48
        StorageDead(_21);                // scope 0 at src/lib.rs:272:47: 272:48
        _19 = _20;                       // scope 0 at src/lib.rs:272:43: 272:63
        _18 = move _19 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:272:43: 272:63
        StorageDead(_19);                // scope 0 at src/lib.rs:272:62: 272:63
        (_0.0: std::result::Result<std::string::String, std::borrow::Cow<str>>) = move _9; // scope 0 at src/lib.rs:272:9: 272:64
        (_0.1: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _18; // scope 0 at src/lib.rs:272:9: 272:64
        StorageDead(_18);                // scope 0 at src/lib.rs:272:63: 272:64
        StorageDead(_9);                 // scope 0 at src/lib.rs:272:63: 272:64
        StorageDead(_22);                // scope 0 at src/lib.rs:273:5: 273:6
        StorageDead(_20);                // scope 0 at src/lib.rs:273:5: 273:6
        StorageDead(_14);                // scope 0 at src/lib.rs:273:5: 273:6
        StorageDead(_13);                // scope 0 at src/lib.rs:273:5: 273:6
        StorageDead(_11);                // scope 0 at src/lib.rs:273:5: 273:6
        goto -> bb19;                    // scope 0 at src/lib.rs:271:5: 279:6
    }

    bb5: {
        StorageLive(_23);                // scope 0 at src/lib.rs:273:15: 273:47
        StorageLive(_24);                // scope 0 at src/lib.rs:273:15: 273:20
        _24 = _1;                        // scope 0 at src/lib.rs:273:15: 273:20
        StorageLive(_25);                // scope 0 at src/lib.rs:273:33: 273:46
        StorageLive(_26);                // scope 0 at src/lib.rs:273:33: 273:46
        StorageLive(_27);                // scope 0 at src/lib.rs:273:33: 273:46
        _68 = const decode::promoted[1]; // scope 0 at src/lib.rs:273:33: 273:46
                                         // ty::Const
                                         // + ty: &[u8; 2]
                                         // + val: Unevaluated(decode, [], Some(promoted[1]))
                                         // mir::Constant
                                         // + span: src/lib.rs:273:33: 273:46
                                         // + literal: Const { ty: &[u8; 2], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:592 ~ encoding[5d2c]::decode), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[1]) }) }
        _27 = _68;                       // scope 0 at src/lib.rs:273:33: 273:46
        _26 = _27;                       // scope 0 at src/lib.rs:273:33: 273:46
        _25 = move _26 as &[u8] (Pointer(Unsize)); // scope 0 at src/lib.rs:273:33: 273:46
        StorageDead(_26);                // scope 0 at src/lib.rs:273:45: 273:46
        _23 = core::slice::<impl [u8]>::starts_with(move _24, move _25) -> bb6; // scope 0 at src/lib.rs:273:15: 273:47
                                         // mir::Constant
                                         // + span: src/lib.rs:273:21: 273:32
                                         // + literal: Const { ty: for<'r, 's> fn(&'r [u8], &'s [u8]) -> bool {core::slice::<impl [u8]>::starts_with}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_27);                // scope 0 at src/lib.rs:273:46: 273:47
        StorageDead(_25);                // scope 0 at src/lib.rs:273:46: 273:47
        StorageDead(_24);                // scope 0 at src/lib.rs:273:46: 273:47
        switchInt(move _23) -> [false: bb10, otherwise: bb7]; // scope 0 at src/lib.rs:273:15: 273:47
    }

    bb7: {
        StorageLive(_28);                // scope 0 at src/lib.rs:274:10: 274:44
        StorageLive(_29);                // scope 0 at src/lib.rs:274:10: 274:18
        StorageLive(_30);                // scope 0 at src/lib.rs:274:10: 274:18
        _30 = const UTF_16BE;            // scope 0 at src/lib.rs:274:10: 274:18
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16BEEncoding
                                         // + val: Unevaluated(UTF_16BE, [], None)
                                         // mir::Constant
                                         // + span: src/lib.rs:274:10: 274:18
                                         // + literal: Const { ty: &codec::utf_16::UTF16BEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1279 ~ encoding[5d2c]::all::UTF_16BE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _29 = _30;                       // scope 0 at src/lib.rs:274:10: 274:18
        StorageLive(_31);                // scope 0 at src/lib.rs:274:26: 274:37
        StorageLive(_32);                // scope 0 at src/lib.rs:274:26: 274:37
        StorageLive(_33);                // scope 0 at src/lib.rs:274:27: 274:37
        StorageLive(_34);                // scope 0 at src/lib.rs:274:27: 274:32
        _34 = _1;                        // scope 0 at src/lib.rs:274:27: 274:32
        StorageLive(_35);                // scope 0 at src/lib.rs:274:33: 274:36
        (_35.0: usize) = const 2_usize;  // scope 0 at src/lib.rs:274:33: 274:36
        _33 = <[u8] as Index<RangeFrom<usize>>>::index(move _34, move _35) -> bb8; // scope 0 at src/lib.rs:274:27: 274:37
                                         // mir::Constant
                                         // + span: src/lib.rs:274:27: 274:37
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::RangeFrom<usize>) -> &'r <[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::Output {<[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_35);                // scope 0 at src/lib.rs:274:36: 274:37
        StorageDead(_34);                // scope 0 at src/lib.rs:274:36: 274:37
        _32 = _33;                       // scope 0 at src/lib.rs:274:26: 274:37
        _31 = _32;                       // scope 0 at src/lib.rs:274:26: 274:37
        StorageLive(_36);                // scope 0 at src/lib.rs:274:39: 274:43
        _36 = _2;                        // scope 0 at src/lib.rs:274:39: 274:43
        _28 = <UTF16BEEncoding as encoding_types::Encoding>::decode(move _29, move _31, move _36) -> bb9; // scope 0 at src/lib.rs:274:10: 274:44
                                         // mir::Constant
                                         // + span: src/lib.rs:274:19: 274:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::utf_16::UTF16BEEncoding, &'s [u8], encoding_types::DecoderTrap) -> std::result::Result<std::string::String, std::borrow::Cow<'static, str>> {<codec::utf_16::UTF16BEEncoding as encoding_types::Encoding>::decode}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_36);                // scope 0 at src/lib.rs:274:43: 274:44
        StorageDead(_31);                // scope 0 at src/lib.rs:274:43: 274:44
        StorageDead(_29);                // scope 0 at src/lib.rs:274:43: 274:44
        StorageLive(_37);                // scope 0 at src/lib.rs:274:46: 274:69
        StorageLive(_38);                // scope 0 at src/lib.rs:274:46: 274:69
        StorageLive(_39);                // scope 0 at src/lib.rs:274:46: 274:69
        StorageLive(_40);                // scope 0 at src/lib.rs:274:46: 274:54
        StorageLive(_41);                // scope 0 at src/lib.rs:274:46: 274:54
        _41 = const UTF_16BE;            // scope 0 at src/lib.rs:274:46: 274:54
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16BEEncoding
                                         // + val: Unevaluated(UTF_16BE, [], None)
                                         // mir::Constant
                                         // + span: src/lib.rs:274:46: 274:54
                                         // + literal: Const { ty: &codec::utf_16::UTF16BEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1279 ~ encoding[5d2c]::all::UTF_16BE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _40 = _41;                       // scope 0 at src/lib.rs:274:46: 274:54
        _39 = move _40 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:274:46: 274:54
        StorageDead(_40);                // scope 0 at src/lib.rs:274:53: 274:54
        _38 = _39;                       // scope 0 at src/lib.rs:274:46: 274:69
        _37 = move _38 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:274:46: 274:69
        StorageDead(_38);                // scope 0 at src/lib.rs:274:68: 274:69
        (_0.0: std::result::Result<std::string::String, std::borrow::Cow<str>>) = move _28; // scope 0 at src/lib.rs:274:9: 274:70
        (_0.1: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _37; // scope 0 at src/lib.rs:274:9: 274:70
        StorageDead(_37);                // scope 0 at src/lib.rs:274:69: 274:70
        StorageDead(_28);                // scope 0 at src/lib.rs:274:69: 274:70
        StorageDead(_41);                // scope 0 at src/lib.rs:275:5: 275:6
        StorageDead(_39);                // scope 0 at src/lib.rs:275:5: 275:6
        StorageDead(_33);                // scope 0 at src/lib.rs:275:5: 275:6
        StorageDead(_32);                // scope 0 at src/lib.rs:275:5: 275:6
        StorageDead(_30);                // scope 0 at src/lib.rs:275:5: 275:6
        goto -> bb18;                    // scope 0 at src/lib.rs:273:12: 279:6
    }

    bb10: {
        StorageLive(_42);                // scope 0 at src/lib.rs:275:15: 275:47
        StorageLive(_43);                // scope 0 at src/lib.rs:275:15: 275:20
        _43 = _1;                        // scope 0 at src/lib.rs:275:15: 275:20
        StorageLive(_44);                // scope 0 at src/lib.rs:275:33: 275:46
        StorageLive(_45);                // scope 0 at src/lib.rs:275:33: 275:46
        StorageLive(_46);                // scope 0 at src/lib.rs:275:33: 275:46
        _67 = const decode::promoted[0]; // scope 0 at src/lib.rs:275:33: 275:46
                                         // ty::Const
                                         // + ty: &[u8; 2]
                                         // + val: Unevaluated(decode, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/lib.rs:275:33: 275:46
                                         // + literal: Const { ty: &[u8; 2], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:592 ~ encoding[5d2c]::decode), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _46 = _67;                       // scope 0 at src/lib.rs:275:33: 275:46
        _45 = _46;                       // scope 0 at src/lib.rs:275:33: 275:46
        _44 = move _45 as &[u8] (Pointer(Unsize)); // scope 0 at src/lib.rs:275:33: 275:46
        StorageDead(_45);                // scope 0 at src/lib.rs:275:45: 275:46
        _42 = core::slice::<impl [u8]>::starts_with(move _43, move _44) -> bb11; // scope 0 at src/lib.rs:275:15: 275:47
                                         // mir::Constant
                                         // + span: src/lib.rs:275:21: 275:32
                                         // + literal: Const { ty: for<'r, 's> fn(&'r [u8], &'s [u8]) -> bool {core::slice::<impl [u8]>::starts_with}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_46);                // scope 0 at src/lib.rs:275:46: 275:47
        StorageDead(_44);                // scope 0 at src/lib.rs:275:46: 275:47
        StorageDead(_43);                // scope 0 at src/lib.rs:275:46: 275:47
        switchInt(move _42) -> [false: bb15, otherwise: bb12]; // scope 0 at src/lib.rs:275:15: 275:47
    }

    bb12: {
        StorageLive(_47);                // scope 0 at src/lib.rs:276:10: 276:44
        StorageLive(_48);                // scope 0 at src/lib.rs:276:10: 276:18
        StorageLive(_49);                // scope 0 at src/lib.rs:276:10: 276:18
        _49 = const UTF_16LE;            // scope 0 at src/lib.rs:276:10: 276:18
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16LEEncoding
                                         // + val: Unevaluated(UTF_16LE, [], None)
                                         // mir::Constant
                                         // + span: src/lib.rs:276:10: 276:18
                                         // + literal: Const { ty: &codec::utf_16::UTF16LEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1278 ~ encoding[5d2c]::all::UTF_16LE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _48 = _49;                       // scope 0 at src/lib.rs:276:10: 276:18
        StorageLive(_50);                // scope 0 at src/lib.rs:276:26: 276:37
        StorageLive(_51);                // scope 0 at src/lib.rs:276:26: 276:37
        StorageLive(_52);                // scope 0 at src/lib.rs:276:27: 276:37
        StorageLive(_53);                // scope 0 at src/lib.rs:276:27: 276:32
        _53 = _1;                        // scope 0 at src/lib.rs:276:27: 276:32
        StorageLive(_54);                // scope 0 at src/lib.rs:276:33: 276:36
        (_54.0: usize) = const 2_usize;  // scope 0 at src/lib.rs:276:33: 276:36
        _52 = <[u8] as Index<RangeFrom<usize>>>::index(move _53, move _54) -> bb13; // scope 0 at src/lib.rs:276:27: 276:37
                                         // mir::Constant
                                         // + span: src/lib.rs:276:27: 276:37
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::RangeFrom<usize>) -> &'r <[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::Output {<[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_54);                // scope 0 at src/lib.rs:276:36: 276:37
        StorageDead(_53);                // scope 0 at src/lib.rs:276:36: 276:37
        _51 = _52;                       // scope 0 at src/lib.rs:276:26: 276:37
        _50 = _51;                       // scope 0 at src/lib.rs:276:26: 276:37
        StorageLive(_55);                // scope 0 at src/lib.rs:276:39: 276:43
        _55 = _2;                        // scope 0 at src/lib.rs:276:39: 276:43
        _47 = <UTF16LEEncoding as encoding_types::Encoding>::decode(move _48, move _50, move _55) -> bb14; // scope 0 at src/lib.rs:276:10: 276:44
                                         // mir::Constant
                                         // + span: src/lib.rs:276:19: 276:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::utf_16::UTF16LEEncoding, &'s [u8], encoding_types::DecoderTrap) -> std::result::Result<std::string::String, std::borrow::Cow<'static, str>> {<codec::utf_16::UTF16LEEncoding as encoding_types::Encoding>::decode}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_55);                // scope 0 at src/lib.rs:276:43: 276:44
        StorageDead(_50);                // scope 0 at src/lib.rs:276:43: 276:44
        StorageDead(_48);                // scope 0 at src/lib.rs:276:43: 276:44
        StorageLive(_56);                // scope 0 at src/lib.rs:276:46: 276:69
        StorageLive(_57);                // scope 0 at src/lib.rs:276:46: 276:69
        StorageLive(_58);                // scope 0 at src/lib.rs:276:46: 276:69
        StorageLive(_59);                // scope 0 at src/lib.rs:276:46: 276:54
        StorageLive(_60);                // scope 0 at src/lib.rs:276:46: 276:54
        _60 = const UTF_16LE;            // scope 0 at src/lib.rs:276:46: 276:54
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16LEEncoding
                                         // + val: Unevaluated(UTF_16LE, [], None)
                                         // mir::Constant
                                         // + span: src/lib.rs:276:46: 276:54
                                         // + literal: Const { ty: &codec::utf_16::UTF16LEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1278 ~ encoding[5d2c]::all::UTF_16LE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _59 = _60;                       // scope 0 at src/lib.rs:276:46: 276:54
        _58 = move _59 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:276:46: 276:54
        StorageDead(_59);                // scope 0 at src/lib.rs:276:53: 276:54
        _57 = _58;                       // scope 0 at src/lib.rs:276:46: 276:69
        _56 = move _57 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:276:46: 276:69
        StorageDead(_57);                // scope 0 at src/lib.rs:276:68: 276:69
        (_0.0: std::result::Result<std::string::String, std::borrow::Cow<str>>) = move _47; // scope 0 at src/lib.rs:276:9: 276:70
        (_0.1: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _56; // scope 0 at src/lib.rs:276:9: 276:70
        StorageDead(_56);                // scope 0 at src/lib.rs:276:69: 276:70
        StorageDead(_47);                // scope 0 at src/lib.rs:276:69: 276:70
        StorageDead(_60);                // scope 0 at src/lib.rs:277:5: 277:6
        StorageDead(_58);                // scope 0 at src/lib.rs:277:5: 277:6
        StorageDead(_52);                // scope 0 at src/lib.rs:277:5: 277:6
        StorageDead(_51);                // scope 0 at src/lib.rs:277:5: 277:6
        StorageDead(_49);                // scope 0 at src/lib.rs:277:5: 277:6
        goto -> bb17;                    // scope 0 at src/lib.rs:275:12: 279:6
    }

    bb15: {
        StorageLive(_61);                // scope 0 at src/lib.rs:278:10: 278:47
        StorageLive(_62);                // scope 0 at src/lib.rs:278:10: 278:27
        _62 = _3;                        // scope 0 at src/lib.rs:278:10: 278:27
        StorageLive(_63);                // scope 0 at src/lib.rs:278:35: 278:40
        _63 = _1;                        // scope 0 at src/lib.rs:278:35: 278:40
        StorageLive(_64);                // scope 0 at src/lib.rs:278:42: 278:46
        _64 = _2;                        // scope 0 at src/lib.rs:278:42: 278:46
        _61 = <dyn encoding_types::Encoding + Send + Sync as encoding_types::Encoding>::decode(move _62, move _63, move _64) -> bb16; // scope 0 at src/lib.rs:278:10: 278:47
                                         // mir::Constant
                                         // + span: src/lib.rs:278:28: 278:34
                                         // + literal: Const { ty: for<'r, 's> fn(&'r dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync, &'s [u8], encoding_types::DecoderTrap) -> std::result::Result<std::string::String, std::borrow::Cow<'static, str>> {<dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync as encoding_types::Encoding>::decode}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_64);                // scope 0 at src/lib.rs:278:46: 278:47
        StorageDead(_63);                // scope 0 at src/lib.rs:278:46: 278:47
        StorageDead(_62);                // scope 0 at src/lib.rs:278:46: 278:47
        StorageLive(_65);                // scope 0 at src/lib.rs:278:49: 278:66
        StorageLive(_66);                // scope 0 at src/lib.rs:278:49: 278:66
        _66 = _3;                        // scope 0 at src/lib.rs:278:49: 278:66
        _65 = move _66 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/lib.rs:278:49: 278:66
        StorageDead(_66);                // scope 0 at src/lib.rs:278:65: 278:66
        (_0.0: std::result::Result<std::string::String, std::borrow::Cow<str>>) = move _61; // scope 0 at src/lib.rs:278:9: 278:67
        (_0.1: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _65; // scope 0 at src/lib.rs:278:9: 278:67
        StorageDead(_65);                // scope 0 at src/lib.rs:278:66: 278:67
        StorageDead(_61);                // scope 0 at src/lib.rs:278:66: 278:67
        goto -> bb17;                    // scope 0 at src/lib.rs:275:12: 279:6
    }

    bb17: {
        StorageDead(_42);                // scope 0 at src/lib.rs:279:5: 279:6
        goto -> bb18;                    // scope 0 at src/lib.rs:273:12: 279:6
    }

    bb18: {
        StorageDead(_23);                // scope 0 at src/lib.rs:279:5: 279:6
        goto -> bb19;                    // scope 0 at src/lib.rs:271:5: 279:6
    }

    bb19: {
        StorageDead(_4);                 // scope 0 at src/lib.rs:279:5: 279:6
        return;                          // scope 0 at src/lib.rs:280:2: 280:2
    }
}

promoted[0] in decode: &[u8; 2] = {
    let mut _0: &[u8; 2];                // return place in scope 0 at src/lib.rs:275:33: 275:46
    let mut _1: [u8; 2];                 // in scope 0 at src/lib.rs:275:34: 275:46

    bb0: {
        _1 = [const u8::MAX, const 254_u8]; // scope 0 at src/lib.rs:275:34: 275:46
        _0 = &_1;                        // scope 0 at src/lib.rs:275:33: 275:46
        return;                          // scope 0 at src/lib.rs:275:33: 275:46
    }
}

promoted[1] in decode: &[u8; 2] = {
    let mut _0: &[u8; 2];                // return place in scope 0 at src/lib.rs:273:33: 273:46
    let mut _1: [u8; 2];                 // in scope 0 at src/lib.rs:273:34: 273:46

    bb0: {
        _1 = [const 254_u8, const u8::MAX]; // scope 0 at src/lib.rs:273:34: 273:46
        _0 = &_1;                        // scope 0 at src/lib.rs:273:33: 273:46
        return;                          // scope 0 at src/lib.rs:273:33: 273:46
    }
}

promoted[2] in decode: &[u8; 3] = {
    let mut _0: &[u8; 3];                // return place in scope 0 at src/lib.rs:271:26: 271:45
    let mut _1: [u8; 3];                 // in scope 0 at src/lib.rs:271:27: 271:45

    bb0: {
        _1 = [const 239_u8, const 187_u8, const 191_u8]; // scope 0 at src/lib.rs:271:27: 271:45
        _0 = &_1;                        // scope 0 at src/lib.rs:271:26: 271:45
        return;                          // scope 0 at src/lib.rs:271:26: 271:45
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:141:1: 209:2>::raw_feed(_1: &mut UTF8Decoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:145:17: 145:26
    debug input => _2;                   // in scope 0 at src/codec/utf_8.rs:145:28: 145:33
    debug output => _3;                  // in scope 0 at src/codec/utf_8.rs:145:42: 145:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_8.rs:145:72: 145:99
    let _4: ();                          // in scope 0 at src/codec/utf_8.rs:146:9: 146:40
    let mut _5: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:146:9: 146:15
    let mut _6: usize;                   // in scope 0 at src/codec/utf_8.rs:146:28: 146:39
    let mut _7: &[u8];                   // in scope 0 at src/codec/utf_8.rs:146:28: 146:33
    let mut _8: u8;                      // in scope 0 at src/codec/utf_8.rs:152:13: 152:22
    let mut _11: bool;                   // in scope 0 at src/codec/utf_8.rs:157:12: 157:34
    let mut _12: u8;                     // in scope 0 at src/codec/utf_8.rs:157:12: 157:17
    let mut _13: u8;                     // in scope 0 at src/codec/utf_8.rs:157:21: 157:34
    let mut _15: std::option::Option<usize>; // in scope 0 at src/codec/utf_8.rs:158:29: 158:68
    let mut _16: &mut std::slice::Iter<u8>; // in scope 0 at src/codec/utf_8.rs:158:29: 158:41
    let mut _17: std::slice::Iter<u8>;   // in scope 0 at src/codec/utf_8.rs:158:29: 158:41
    let mut _18: &[u8];                  // in scope 0 at src/codec/utf_8.rs:158:29: 158:34
    let mut _19: [closure@src/codec/utf_8.rs:158:51: 158:67]; // in scope 0 at src/codec/utf_8.rs:158:51: 158:67
    let mut _20: usize;                  // in scope 0 at src/codec/utf_8.rs:158:79: 158:90
    let mut _21: &[u8];                  // in scope 0 at src/codec/utf_8.rs:158:79: 158:84
    let mut _22: usize;                  // in scope 0 at src/codec/utf_8.rs:159:23: 159:32
    let mut _23: usize;                  // in scope 0 at src/codec/utf_8.rs:160:26: 160:35
    let mut _24: std::iter::Enumerate<std::slice::Iter<u8>>; // in scope 0 at src/codec/utf_8.rs:163:25: 163:59
    let mut _25: std::iter::Enumerate<std::slice::Iter<u8>>; // in scope 0 at src/codec/utf_8.rs:163:25: 163:59
    let mut _26: std::slice::Iter<u8>;   // in scope 0 at src/codec/utf_8.rs:163:25: 163:47
    let mut _27: &[u8];                  // in scope 0 at src/codec/utf_8.rs:163:25: 163:40
    let _28: &[u8];                      // in scope 0 at src/codec/utf_8.rs:163:25: 163:40
    let mut _29: &[u8];                  // in scope 0 at src/codec/utf_8.rs:163:25: 163:30
    let mut _30: std::ops::RangeFrom<usize>; // in scope 0 at src/codec/utf_8.rs:163:31: 163:39
    let mut _31: usize;                  // in scope 0 at src/codec/utf_8.rs:163:31: 163:37
    let mut _34: std::option::Option<(usize, &u8)>; // in scope 0 at src/codec/utf_8.rs:163:25: 163:59
    let mut _35: &mut std::iter::Enumerate<std::slice::Iter<u8>>; // in scope 0 at src/codec/utf_8.rs:163:25: 163:59
    let mut _36: &mut std::iter::Enumerate<std::slice::Iter<u8>>; // in scope 0 at src/codec/utf_8.rs:163:25: 163:59
    let mut _37: isize;                  // in scope 0 at src/codec/utf_8.rs:163:13: 163:21
    let mut _39: (usize, &u8);           // in scope 0 at src/codec/utf_8.rs:163:13: 163:21
    let mut _42: u8;                     // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _43: &[u8; 110];             // in scope 0 at src/codec/utf_8.rs:138:5: 138:22
    let _44: usize;                      // in scope 0 at src/codec/utf_8.rs:138:23: 138:70
    let mut _45: u8;                     // in scope 0 at src/codec/utf_8.rs:138:23: 138:61
    let mut _46: u8;                     // in scope 0 at src/codec/utf_8.rs:164:33: 164:38
    let mut _47: u8;                     // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _48: &[u8; 256];             // in scope 0 at src/codec/utf_8.rs:138:33: 138:46
    let _49: usize;                      // in scope 0 at src/codec/utf_8.rs:138:47: 138:59
    let mut _50: u8;                     // in scope 0 at src/codec/utf_8.rs:164:40: 164:42
    let mut _51: usize;                  // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _52: bool;                   // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _53: usize;                  // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _54: bool;                   // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _55: bool;                   // in scope 0 at src/codec/utf_8.rs:165:16: 165:37
    let mut _56: u8;                     // in scope 0 at src/codec/utf_8.rs:165:16: 165:21
    let mut _57: u8;                     // in scope 0 at src/codec/utf_8.rs:165:25: 165:37
    let mut _58: usize;                  // in scope 0 at src/codec/utf_8.rs:166:29: 166:39
    let mut _59: usize;                  // in scope 0 at src/codec/utf_8.rs:166:29: 166:30
    let mut _60: usize;                  // in scope 0 at src/codec/utf_8.rs:166:33: 166:39
    let mut _61: bool;                   // in scope 0 at src/codec/utf_8.rs:136:48: 136:82
    let mut _62: u8;                     // in scope 0 at src/codec/utf_8.rs:167:40: 167:45
    let mut _63: u8;                     // in scope 0 at src/codec/utf_8.rs:136:58: 136:82
    let mut _65: bool;                   // in scope 0 at src/codec/utf_8.rs:168:31: 168:52
    let mut _66: u8;                     // in scope 0 at src/codec/utf_8.rs:168:31: 168:36
    let mut _67: u8;                     // in scope 0 at src/codec/utf_8.rs:168:40: 168:52
    let mut _68: usize;                  // in scope 0 at src/codec/utf_8.rs:168:54: 168:64
    let mut _69: usize;                  // in scope 0 at src/codec/utf_8.rs:168:54: 168:55
    let mut _70: usize;                  // in scope 0 at src/codec/utf_8.rs:168:58: 168:64
    let mut _71: usize;                  // in scope 0 at src/codec/utf_8.rs:168:76: 168:77
    let mut _72: usize;                  // in scope 0 at src/codec/utf_8.rs:168:80: 168:86
    let mut _73: u8;                     // in scope 0 at src/codec/utf_8.rs:169:30: 169:43
    let mut _74: bool;                   // in scope 0 at src/codec/utf_8.rs:170:20: 170:54
    let mut _75: bool;                   // in scope 0 at src/codec/utf_8.rs:170:20: 170:33
    let mut _76: usize;                  // in scope 0 at src/codec/utf_8.rs:170:20: 170:29
    let mut _77: bool;                   // in scope 0 at src/codec/utf_8.rs:170:37: 170:54
    let mut _78: usize;                  // in scope 0 at src/codec/utf_8.rs:170:37: 170:50
    let _79: ();                         // in scope 0 at src/codec/utf_8.rs:171:21: 171:71
    let mut _80: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:171:33: 171:39
    let mut _81: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:171:33: 171:39
    let mut _82: &[u8];                  // in scope 0 at src/codec/utf_8.rs:171:41: 171:70
    let _83: &[u8];                      // in scope 0 at src/codec/utf_8.rs:171:41: 171:70
    let _84: &[u8];                      // in scope 0 at src/codec/utf_8.rs:171:42: 171:70
    let mut _85: &[u8; 4];               // in scope 0 at src/codec/utf_8.rs:171:42: 171:52
    let mut _86: std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:171:53: 171:69
    let mut _87: usize;                  // in scope 0 at src/codec/utf_8.rs:171:56: 171:69
    let _88: ();                         // in scope 0 at src/codec/utf_8.rs:174:17: 174:58
    let mut _89: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:174:29: 174:35
    let mut _90: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:174:29: 174:35
    let mut _91: &[u8];                  // in scope 0 at src/codec/utf_8.rs:174:37: 174:57
    let _92: &[u8];                      // in scope 0 at src/codec/utf_8.rs:174:37: 174:57
    let _93: &[u8];                      // in scope 0 at src/codec/utf_8.rs:174:38: 174:57
    let mut _94: &[u8];                  // in scope 0 at src/codec/utf_8.rs:174:38: 174:43
    let mut _95: std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:174:44: 174:56
    let mut _96: usize;                  // in scope 0 at src/codec/utf_8.rs:174:47: 174:56
    let mut _97: usize;                  // in scope 0 at src/codec/utf_8.rs:175:25: 175:34
    let mut _98: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_8.rs:175:36: 177:19
    let mut _99: encoding_types::CodecError; // in scope 0 at src/codec/utf_8.rs:175:41: 177:18
    let mut _100: isize;                 // in scope 0 at src/codec/utf_8.rs:176:27: 176:40
    let mut _101: usize;                 // in scope 0 at src/codec/utf_8.rs:176:27: 176:31
    let mut _102: std::borrow::Cow<str>; // in scope 0 at src/codec/utf_8.rs:176:49: 176:74
    let mut _103: &str;                  // in scope 0 at src/codec/utf_8.rs:176:49: 176:67
    let _104: &str;                      // in scope 0 at src/codec/utf_8.rs:176:49: 176:67
    let mut _105: u8;                    // in scope 0 at src/codec/utf_8.rs:181:22: 181:27
    let mut _106: bool;                  // in scope 0 at src/codec/utf_8.rs:182:12: 182:46
    let mut _107: bool;                  // in scope 0 at src/codec/utf_8.rs:182:12: 182:25
    let mut _108: usize;                 // in scope 0 at src/codec/utf_8.rs:182:12: 182:21
    let mut _109: bool;                  // in scope 0 at src/codec/utf_8.rs:182:29: 182:46
    let mut _110: usize;                 // in scope 0 at src/codec/utf_8.rs:182:29: 182:42
    let _111: ();                        // in scope 0 at src/codec/utf_8.rs:183:13: 183:63
    let mut _112: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:183:25: 183:31
    let mut _113: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:183:25: 183:31
    let mut _114: &[u8];                 // in scope 0 at src/codec/utf_8.rs:183:33: 183:62
    let _115: &[u8];                     // in scope 0 at src/codec/utf_8.rs:183:33: 183:62
    let _116: &[u8];                     // in scope 0 at src/codec/utf_8.rs:183:34: 183:62
    let mut _117: &[u8; 4];              // in scope 0 at src/codec/utf_8.rs:183:34: 183:44
    let mut _118: std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:183:45: 183:61
    let mut _119: usize;                 // in scope 0 at src/codec/utf_8.rs:183:48: 183:61
    let _120: ();                        // in scope 0 at src/codec/utf_8.rs:186:9: 186:50
    let mut _121: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:186:21: 186:27
    let mut _122: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:186:21: 186:27
    let mut _123: &[u8];                 // in scope 0 at src/codec/utf_8.rs:186:29: 186:49
    let _124: &[u8];                     // in scope 0 at src/codec/utf_8.rs:186:29: 186:49
    let _125: &[u8];                     // in scope 0 at src/codec/utf_8.rs:186:30: 186:49
    let mut _126: &[u8];                 // in scope 0 at src/codec/utf_8.rs:186:30: 186:35
    let mut _127: std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:186:36: 186:48
    let mut _128: usize;                 // in scope 0 at src/codec/utf_8.rs:186:39: 186:48
    let mut _129: bool;                  // in scope 0 at src/codec/utf_8.rs:187:12: 187:35
    let mut _130: usize;                 // in scope 0 at src/codec/utf_8.rs:187:12: 187:21
    let mut _131: usize;                 // in scope 0 at src/codec/utf_8.rs:187:24: 187:35
    let mut _132: &[u8];                 // in scope 0 at src/codec/utf_8.rs:187:24: 187:29
    let mut _134: usize;                 // in scope 0 at src/codec/utf_8.rs:188:32: 188:43
    let mut _135: &[u8];                 // in scope 0 at src/codec/utf_8.rs:188:32: 188:37
    let mut _136: usize;                 // in scope 0 at src/codec/utf_8.rs:188:46: 188:55
    let mut _137: std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:189:22: 189:37
    let mut _138: std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:189:22: 189:37
    let mut _139: usize;                 // in scope 0 at src/codec/utf_8.rs:189:25: 189:37
    let mut _142: std::option::Option<usize>; // in scope 0 at src/codec/utf_8.rs:189:22: 189:37
    let mut _143: &mut std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:189:22: 189:37
    let mut _144: &mut std::ops::Range<usize>; // in scope 0 at src/codec/utf_8.rs:189:22: 189:37
    let mut _145: isize;                 // in scope 0 at src/codec/utf_8.rs:189:17: 189:18
    let mut _147: usize;                 // in scope 0 at src/codec/utf_8.rs:189:17: 189:18
    let mut _149: u8;                    // in scope 0 at src/codec/utf_8.rs:190:49: 190:69
    let _150: usize;                     // in scope 0 at src/codec/utf_8.rs:190:55: 190:68
    let mut _151: usize;                 // in scope 0 at src/codec/utf_8.rs:190:55: 190:64
    let mut _152: usize;                 // in scope 0 at src/codec/utf_8.rs:190:67: 190:68
    let mut _153: usize;                 // in scope 0 at src/codec/utf_8.rs:190:49: 190:69
    let mut _154: bool;                  // in scope 0 at src/codec/utf_8.rs:190:49: 190:69
    let _155: usize;                     // in scope 0 at src/codec/utf_8.rs:190:28: 190:45
    let mut _156: usize;                 // in scope 0 at src/codec/utf_8.rs:190:28: 190:41
    let mut _157: usize;                 // in scope 0 at src/codec/utf_8.rs:190:44: 190:45
    let mut _158: usize;                 // in scope 0 at src/codec/utf_8.rs:190:17: 190:46
    let mut _159: bool;                  // in scope 0 at src/codec/utf_8.rs:190:17: 190:46
    let mut _160: usize;                 // in scope 0 at src/codec/utf_8.rs:192:30: 192:42
    let mut _161: usize;                 // in scope 0 at src/codec/utf_8.rs:194:10: 194:19
    let mut _162: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_8.rs:194:21: 194:25
    scope 1 {
        debug state => _8;               // in scope 1 at src/codec/utf_8.rs:152:13: 152:22
        let mut _9: usize;               // in scope 1 at src/codec/utf_8.rs:153:13: 153:26
        scope 2 {
            debug processed => _9;       // in scope 2 at src/codec/utf_8.rs:153:13: 153:26
            let mut _10: usize;          // in scope 2 at src/codec/utf_8.rs:154:13: 154:23
            scope 3 {
                debug offset => _10;     // in scope 3 at src/codec/utf_8.rs:154:13: 154:23
                let _14: usize;          // in scope 3 at src/codec/utf_8.rs:158:17: 158:26
                let mut _32: std::iter::Enumerate<std::slice::Iter<u8>>; // in scope 3 at src/codec/utf_8.rs:163:25: 163:59
                let _133: usize;         // in scope 3 at src/codec/utf_8.rs:188:17: 188:29
                scope 4 {
                    debug first_msb => _14; // in scope 4 at src/codec/utf_8.rs:158:17: 158:26
                }
                scope 5 {
                    debug iter => _32;   // in scope 5 at src/codec/utf_8.rs:163:25: 163:59
                    let mut _33: (usize, &u8); // in scope 5 at src/codec/utf_8.rs:163:25: 163:59
                    scope 6 {
                        debug __next => _33; // in scope 6 at src/codec/utf_8.rs:163:25: 163:59
                        let _38: (usize, &u8); // in scope 6 at src/codec/utf_8.rs:163:13: 163:21
                        let _40: usize;  // in scope 6 at src/codec/utf_8.rs:163:14: 163:15
                        let _41: u8;     // in scope 6 at src/codec/utf_8.rs:163:18: 163:20
                        scope 7 {
                            debug val => _38; // in scope 7 at src/codec/utf_8.rs:163:13: 163:21
                        }
                        scope 8 {
                            debug i => _40; // in scope 8 at src/codec/utf_8.rs:163:14: 163:15
                            debug ch => _41; // in scope 8 at src/codec/utf_8.rs:163:18: 163:20
                            let _64: usize; // in scope 8 at src/codec/utf_8.rs:168:21: 168:25
                            scope 9 {
                                debug upto => _64; // in scope 9 at src/codec/utf_8.rs:168:21: 168:25
                            }
                        }
                    }
                }
                scope 10 {
                    debug morequeuelen => _133; // in scope 10 at src/codec/utf_8.rs:188:17: 188:29
                    let mut _140: std::ops::Range<usize>; // in scope 10 at src/codec/utf_8.rs:189:22: 189:37
                    scope 11 {
                        debug iter => _140; // in scope 11 at src/codec/utf_8.rs:189:22: 189:37
                        let mut _141: usize; // in scope 11 at src/codec/utf_8.rs:189:22: 189:37
                        scope 12 {
                            debug __next => _141; // in scope 12 at src/codec/utf_8.rs:189:22: 189:37
                            let _146: usize; // in scope 12 at src/codec/utf_8.rs:189:17: 189:18
                            let _148: usize; // in scope 12 at src/codec/utf_8.rs:189:17: 189:18
                            scope 13 {
                                debug val => _146; // in scope 13 at src/codec/utf_8.rs:189:17: 189:18
                            }
                            scope 14 {
                                debug i => _148; // in scope 14 at src/codec/utf_8.rs:189:17: 189:18
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_8.rs:146:9: 146:40
        StorageLive(_5);                 // scope 0 at src/codec/utf_8.rs:146:9: 146:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/utf_8.rs:146:9: 146:15
        StorageLive(_6);                 // scope 0 at src/codec/utf_8.rs:146:28: 146:39
        StorageLive(_7);                 // scope 0 at src/codec/utf_8.rs:146:28: 146:33
        _7 = _2;                         // scope 0 at src/codec/utf_8.rs:146:28: 146:33
        _6 = Len((*_7));                 // scope 0 at src/codec/utf_8.rs:146:28: 146:39
        StorageDead(_7);                 // scope 0 at src/codec/utf_8.rs:146:38: 146:39
        _4 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _5, move _6) -> bb1; // scope 0 at src/codec/utf_8.rs:146:9: 146:40
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:146:16: 146:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 0 at src/codec/utf_8.rs:146:39: 146:40
        StorageDead(_5);                 // scope 0 at src/codec/utf_8.rs:146:39: 146:40
        StorageDead(_4);                 // scope 0 at src/codec/utf_8.rs:146:40: 146:41
        StorageLive(_8);                 // scope 0 at src/codec/utf_8.rs:152:13: 152:22
        _8 = ((*_1).2: u8);              // scope 0 at src/codec/utf_8.rs:152:25: 152:35
        StorageLive(_9);                 // scope 1 at src/codec/utf_8.rs:153:13: 153:26
        _9 = const 0_usize;              // scope 1 at src/codec/utf_8.rs:153:29: 153:30
        StorageLive(_10);                // scope 2 at src/codec/utf_8.rs:154:13: 154:23
        _10 = const 0_usize;             // scope 2 at src/codec/utf_8.rs:154:26: 154:27
        StorageLive(_11);                // scope 3 at src/codec/utf_8.rs:157:12: 157:34
        StorageLive(_12);                // scope 3 at src/codec/utf_8.rs:157:12: 157:17
        _12 = _8;                        // scope 3 at src/codec/utf_8.rs:157:12: 157:17
        StorageLive(_13);                // scope 3 at src/codec/utf_8.rs:157:21: 157:34
        _13 = const 0_u8;                // scope 3 at src/codec/utf_8.rs:157:21: 157:34
        _11 = Eq(move _12, move _13);    // scope 3 at src/codec/utf_8.rs:157:12: 157:34
        StorageDead(_13);                // scope 3 at src/codec/utf_8.rs:157:33: 157:34
        StorageDead(_12);                // scope 3 at src/codec/utf_8.rs:157:33: 157:34
        switchInt(move _11) -> [false: bb6, otherwise: bb2]; // scope 3 at src/codec/utf_8.rs:157:12: 157:34
    }

    bb2: {
        StorageLive(_14);                // scope 3 at src/codec/utf_8.rs:158:17: 158:26
        StorageLive(_15);                // scope 3 at src/codec/utf_8.rs:158:29: 158:68
        StorageLive(_16);                // scope 3 at src/codec/utf_8.rs:158:29: 158:41
        StorageLive(_17);                // scope 3 at src/codec/utf_8.rs:158:29: 158:41
        StorageLive(_18);                // scope 3 at src/codec/utf_8.rs:158:29: 158:34
        _18 = _2;                        // scope 3 at src/codec/utf_8.rs:158:29: 158:34
        _17 = core::slice::<impl [u8]>::iter(move _18) -> bb3; // scope 3 at src/codec/utf_8.rs:158:29: 158:41
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:158:35: 158:39
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> std::slice::Iter<'r, u8> {core::slice::<impl [u8]>::iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        _16 = &mut _17;                  // scope 3 at src/codec/utf_8.rs:158:29: 158:41
        StorageDead(_18);                // scope 3 at src/codec/utf_8.rs:158:40: 158:41
        StorageLive(_19);                // scope 3 at src/codec/utf_8.rs:158:51: 158:67
        _15 = <std::slice::Iter<u8> as Iterator>::position::<[closure@src/codec/utf_8.rs:158:51: 158:67]>(move _16, move _19) -> bb4; // scope 3 at src/codec/utf_8.rs:158:29: 158:68
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:158:42: 158:50
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::slice::Iter<u8>, [closure@src/codec/utf_8.rs:158:51: 158:67]) -> std::option::Option<usize> {<std::slice::Iter<u8> as std::iter::Iterator>::position::<[closure@src/codec/utf_8.rs:158:51: 158:67]>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_19);                // scope 3 at src/codec/utf_8.rs:158:67: 158:68
        StorageDead(_16);                // scope 3 at src/codec/utf_8.rs:158:67: 158:68
        StorageLive(_20);                // scope 3 at src/codec/utf_8.rs:158:79: 158:90
        StorageLive(_21);                // scope 3 at src/codec/utf_8.rs:158:79: 158:84
        _21 = _2;                        // scope 3 at src/codec/utf_8.rs:158:79: 158:84
        _20 = Len((*_21));               // scope 3 at src/codec/utf_8.rs:158:79: 158:90
        StorageDead(_21);                // scope 3 at src/codec/utf_8.rs:158:89: 158:90
        _14 = Option::<usize>::unwrap_or(move _15, move _20) -> bb5; // scope 3 at src/codec/utf_8.rs:158:29: 158:91
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:158:69: 158:78
                                         // + literal: Const { ty: fn(std::option::Option<usize>, usize) -> usize {std::option::Option::<usize>::unwrap_or}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        StorageDead(_20);                // scope 3 at src/codec/utf_8.rs:158:90: 158:91
        StorageDead(_15);                // scope 3 at src/codec/utf_8.rs:158:90: 158:91
        StorageDead(_17);                // scope 3 at src/codec/utf_8.rs:158:91: 158:92
        StorageLive(_22);                // scope 4 at src/codec/utf_8.rs:159:23: 159:32
        _22 = _14;                       // scope 4 at src/codec/utf_8.rs:159:23: 159:32
        _10 = Add(_10, move _22);        // scope 4 at src/codec/utf_8.rs:159:13: 159:32
        StorageDead(_22);                // scope 4 at src/codec/utf_8.rs:159:31: 159:32
        StorageLive(_23);                // scope 4 at src/codec/utf_8.rs:160:26: 160:35
        _23 = _14;                       // scope 4 at src/codec/utf_8.rs:160:26: 160:35
        _9 = Add(_9, move _23);          // scope 4 at src/codec/utf_8.rs:160:13: 160:35
        StorageDead(_23);                // scope 4 at src/codec/utf_8.rs:160:34: 160:35
        StorageDead(_14);                // scope 3 at src/codec/utf_8.rs:161:9: 161:10
        goto -> bb6;                     // scope 3 at src/codec/utf_8.rs:157:9: 161:10
    }

    bb6: {
        StorageDead(_11);                // scope 3 at src/codec/utf_8.rs:161:9: 161:10
        StorageLive(_24);                // scope 3 at src/codec/utf_8.rs:163:25: 163:59
        StorageLive(_25);                // scope 3 at src/codec/utf_8.rs:163:25: 163:59
        StorageLive(_26);                // scope 3 at src/codec/utf_8.rs:163:25: 163:47
        StorageLive(_27);                // scope 3 at src/codec/utf_8.rs:163:25: 163:40
        StorageLive(_28);                // scope 3 at src/codec/utf_8.rs:163:25: 163:40
        StorageLive(_29);                // scope 3 at src/codec/utf_8.rs:163:25: 163:30
        _29 = _2;                        // scope 3 at src/codec/utf_8.rs:163:25: 163:30
        StorageLive(_30);                // scope 3 at src/codec/utf_8.rs:163:31: 163:39
        StorageLive(_31);                // scope 3 at src/codec/utf_8.rs:163:31: 163:37
        _31 = _10;                       // scope 3 at src/codec/utf_8.rs:163:31: 163:37
        (_30.0: usize) = move _31;       // scope 3 at src/codec/utf_8.rs:163:31: 163:39
        StorageDead(_31);                // scope 3 at src/codec/utf_8.rs:163:38: 163:39
        _28 = <[u8] as Index<RangeFrom<usize>>>::index(move _29, move _30) -> bb7; // scope 3 at src/codec/utf_8.rs:163:25: 163:40
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:163:25: 163:40
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::RangeFrom<usize>) -> &'r <[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::Output {<[u8] as std::ops::Index<std::ops::RangeFrom<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        _27 = _28;                       // scope 3 at src/codec/utf_8.rs:163:25: 163:40
        StorageDead(_30);                // scope 3 at src/codec/utf_8.rs:163:39: 163:40
        StorageDead(_29);                // scope 3 at src/codec/utf_8.rs:163:39: 163:40
        _26 = core::slice::<impl [u8]>::iter(move _27) -> bb8; // scope 3 at src/codec/utf_8.rs:163:25: 163:47
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:163:41: 163:45
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> std::slice::Iter<'r, u8> {core::slice::<impl [u8]>::iter}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_27);                // scope 3 at src/codec/utf_8.rs:163:46: 163:47
        _25 = <std::slice::Iter<u8> as Iterator>::enumerate(move _26) -> bb9; // scope 3 at src/codec/utf_8.rs:163:25: 163:59
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:163:48: 163:57
                                         // + literal: Const { ty: fn(std::slice::Iter<u8>) -> std::iter::Enumerate<std::slice::Iter<u8>> {<std::slice::Iter<u8> as std::iter::Iterator>::enumerate}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_26);                // scope 3 at src/codec/utf_8.rs:163:58: 163:59
        _24 = <Enumerate<std::slice::Iter<u8>> as IntoIterator>::into_iter(move _25) -> bb10; // scope 3 at src/codec/utf_8.rs:163:25: 163:59
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:163:25: 163:59
                                         // + literal: Const { ty: fn(std::iter::Enumerate<std::slice::Iter<u8>>) -> <std::iter::Enumerate<std::slice::Iter<u8>> as std::iter::IntoIterator>::IntoIter {<std::iter::Enumerate<std::slice::Iter<u8>> as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_25);                // scope 3 at src/codec/utf_8.rs:163:58: 163:59
        StorageLive(_32);                // scope 3 at src/codec/utf_8.rs:163:25: 163:59
        _32 = move _24;                  // scope 3 at src/codec/utf_8.rs:163:25: 163:59
        goto -> bb11;                    // scope 5 at src/codec/utf_8.rs:163:9: 179:10
    }

    bb11: {
        StorageLive(_33);                // scope 5 at src/codec/utf_8.rs:163:25: 163:59
        StorageLive(_34);                // scope 6 at src/codec/utf_8.rs:163:25: 163:59
        StorageLive(_35);                // scope 6 at src/codec/utf_8.rs:163:25: 163:59
        StorageLive(_36);                // scope 6 at src/codec/utf_8.rs:163:25: 163:59
        _36 = &mut _32;                  // scope 6 at src/codec/utf_8.rs:163:25: 163:59
        _35 = &mut (*_36);               // scope 6 at src/codec/utf_8.rs:163:25: 163:59
        _34 = <Enumerate<std::slice::Iter<u8>> as Iterator>::next(move _35) -> bb12; // scope 6 at src/codec/utf_8.rs:163:25: 163:59
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:163:25: 163:59
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::iter::Enumerate<std::slice::Iter<u8>>) -> std::option::Option<<std::iter::Enumerate<std::slice::Iter<u8>> as std::iter::Iterator>::Item> {<std::iter::Enumerate<std::slice::Iter<u8>> as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_35);                // scope 6 at src/codec/utf_8.rs:163:58: 163:59
        _37 = discriminant(_34);         // scope 6 at src/codec/utf_8.rs:163:25: 163:59
        switchInt(move _37) -> [0_isize: bb13, 1_isize: bb15, otherwise: bb14]; // scope 6 at src/codec/utf_8.rs:163:25: 163:59
    }

    bb13: {
        StorageDead(_36);                // scope 6 at src/codec/utf_8.rs:163:58: 163:59
        StorageDead(_34);                // scope 6 at src/codec/utf_8.rs:163:58: 163:59
        StorageDead(_33);                // scope 5 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_32);                // scope 3 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_28);                // scope 3 at src/codec/utf_8.rs:163:58: 163:59
        StorageDead(_24);                // scope 3 at src/codec/utf_8.rs:163:58: 163:59
        StorageLive(_105);               // scope 3 at src/codec/utf_8.rs:181:22: 181:27
        _105 = _8;                       // scope 3 at src/codec/utf_8.rs:181:22: 181:27
        ((*_1).2: u8) = move _105;       // scope 3 at src/codec/utf_8.rs:181:9: 181:27
        StorageDead(_105);               // scope 3 at src/codec/utf_8.rs:181:26: 181:27
        StorageLive(_106);               // scope 3 at src/codec/utf_8.rs:182:12: 182:46
        StorageLive(_107);               // scope 3 at src/codec/utf_8.rs:182:12: 182:25
        StorageLive(_108);               // scope 3 at src/codec/utf_8.rs:182:12: 182:21
        _108 = _9;                       // scope 3 at src/codec/utf_8.rs:182:12: 182:21
        _107 = Gt(move _108, const 0_usize); // scope 3 at src/codec/utf_8.rs:182:12: 182:25
        StorageDead(_108);               // scope 3 at src/codec/utf_8.rs:182:24: 182:25
        switchInt(move _107) -> [false: bb36, otherwise: bb37]; // scope 3 at src/codec/utf_8.rs:182:12: 182:46
    }

    bb14: {
        unreachable;                     // scope 6 at src/codec/utf_8.rs:163:25: 163:59
    }

    bb15: {
        StorageLive(_38);                // scope 6 at src/codec/utf_8.rs:163:13: 163:21
        _38 = ((_34 as Some).0: (usize, &u8)); // scope 6 at src/codec/utf_8.rs:163:13: 163:21
        StorageLive(_39);                // scope 7 at src/codec/utf_8.rs:163:13: 163:21
        _39 = _38;                       // scope 7 at src/codec/utf_8.rs:163:13: 163:21
        _33 = move _39;                  // scope 7 at src/codec/utf_8.rs:163:13: 163:21
        StorageDead(_39);                // scope 7 at src/codec/utf_8.rs:163:20: 163:21
        StorageDead(_38);                // scope 6 at src/codec/utf_8.rs:163:20: 163:21
        StorageDead(_36);                // scope 6 at src/codec/utf_8.rs:163:58: 163:59
        StorageDead(_34);                // scope 6 at src/codec/utf_8.rs:163:58: 163:59
        StorageLive(_41);                // scope 6 at src/codec/utf_8.rs:163:18: 163:20
        _41 = (*(_33.1: &u8));           // scope 6 at src/codec/utf_8.rs:163:18: 163:20
        StorageLive(_40);                // scope 6 at src/codec/utf_8.rs:163:14: 163:15
        _40 = (_33.0: usize);            // scope 6 at src/codec/utf_8.rs:163:14: 163:15
        StorageLive(_42);                // scope 8 at src/codec/utf_8.rs:138:5: 138:71
        StorageLive(_43);                // scope 8 at src/codec/utf_8.rs:138:5: 138:22
        _43 = const <static(DefId(0:258 ~ encoding[5d2c]::codec::utf_8::STATE_TRANSITIONS))>; // scope 8 at src/codec/utf_8.rs:138:5: 138:22
                                         // ty::Const
                                         // + ty: &[u8; 110]
                                         // + val: Value(Scalar(alloc2))
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:138:5: 138:22
                                         // + literal: Const { ty: &[u8; 110], val: Value(Scalar(alloc2)) }
        StorageLive(_44);                // scope 8 at src/codec/utf_8.rs:138:23: 138:70
        StorageLive(_45);                // scope 8 at src/codec/utf_8.rs:138:23: 138:61
        StorageLive(_46);                // scope 8 at src/codec/utf_8.rs:164:33: 164:38
        _46 = _8;                        // scope 8 at src/codec/utf_8.rs:164:33: 164:38
        StorageLive(_47);                // scope 8 at src/codec/utf_8.rs:138:33: 138:60
        StorageLive(_48);                // scope 8 at src/codec/utf_8.rs:138:33: 138:46
        _48 = const <static(DefId(0:256 ~ encoding[5d2c]::codec::utf_8::CHAR_CATEGORY))>; // scope 8 at src/codec/utf_8.rs:138:33: 138:46
                                         // ty::Const
                                         // + ty: &[u8; 256]
                                         // + val: Value(Scalar(alloc3))
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:138:33: 138:46
                                         // + literal: Const { ty: &[u8; 256], val: Value(Scalar(alloc3)) }
        StorageLive(_49);                // scope 8 at src/codec/utf_8.rs:138:47: 138:59
        StorageLive(_50);                // scope 8 at src/codec/utf_8.rs:164:40: 164:42
        _50 = _41;                       // scope 8 at src/codec/utf_8.rs:164:40: 164:42
        _49 = move _50 as usize (Misc);  // scope 8 at src/codec/utf_8.rs:138:47: 138:59
        StorageDead(_50);                // scope 8 at src/codec/utf_8.rs:138:58: 138:59
        _51 = const 256_usize;           // scope 8 at src/codec/utf_8.rs:138:33: 138:60
        _52 = Lt(_49, _51);              // scope 8 at src/codec/utf_8.rs:138:33: 138:60
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _49) -> bb16; // scope 8 at src/codec/utf_8.rs:138:33: 138:60
    }

    bb16: {
        _47 = (*_48)[_49];               // scope 8 at src/codec/utf_8.rs:138:33: 138:60
        _45 = Add(move _46, move _47);   // scope 8 at src/codec/utf_8.rs:138:23: 138:61
        StorageDead(_47);                // scope 8 at src/codec/utf_8.rs:138:60: 138:61
        StorageDead(_46);                // scope 8 at src/codec/utf_8.rs:138:60: 138:61
        _44 = move _45 as usize (Misc);  // scope 8 at src/codec/utf_8.rs:138:23: 138:70
        StorageDead(_45);                // scope 8 at src/codec/utf_8.rs:138:69: 138:70
        _53 = const 110_usize;           // scope 8 at src/codec/utf_8.rs:138:5: 138:71
        _54 = Lt(_44, _53);              // scope 8 at src/codec/utf_8.rs:138:5: 138:71
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _44) -> bb17; // scope 8 at src/codec/utf_8.rs:138:5: 138:71
    }

    bb17: {
        _42 = (*_43)[_44];               // scope 8 at src/codec/utf_8.rs:138:5: 138:71
        _8 = move _42;                   // scope 8 at src/codec/utf_8.rs:164:13: 164:43
        StorageDead(_42);                // scope 8 at src/codec/utf_8.rs:164:42: 164:43
        StorageDead(_49);                // scope 8 at src/codec/utf_8.rs:164:43: 164:44
        StorageDead(_48);                // scope 8 at src/codec/utf_8.rs:164:43: 164:44
        StorageDead(_44);                // scope 8 at src/codec/utf_8.rs:164:43: 164:44
        StorageDead(_43);                // scope 8 at src/codec/utf_8.rs:164:43: 164:44
        StorageLive(_55);                // scope 8 at src/codec/utf_8.rs:165:16: 165:37
        StorageLive(_56);                // scope 8 at src/codec/utf_8.rs:165:16: 165:21
        _56 = _8;                        // scope 8 at src/codec/utf_8.rs:165:16: 165:21
        StorageLive(_57);                // scope 8 at src/codec/utf_8.rs:165:25: 165:37
        _57 = const 0_u8;                // scope 8 at src/codec/utf_8.rs:165:25: 165:37
        _55 = Eq(move _56, move _57);    // scope 8 at src/codec/utf_8.rs:165:16: 165:37
        StorageDead(_57);                // scope 8 at src/codec/utf_8.rs:165:36: 165:37
        StorageDead(_56);                // scope 8 at src/codec/utf_8.rs:165:36: 165:37
        switchInt(move _55) -> [false: bb19, otherwise: bb18]; // scope 8 at src/codec/utf_8.rs:165:16: 165:37
    }

    bb18: {
        StorageLive(_58);                // scope 8 at src/codec/utf_8.rs:166:29: 166:39
        StorageLive(_59);                // scope 8 at src/codec/utf_8.rs:166:29: 166:30
        _59 = _40;                       // scope 8 at src/codec/utf_8.rs:166:29: 166:30
        StorageLive(_60);                // scope 8 at src/codec/utf_8.rs:166:33: 166:39
        _60 = _10;                       // scope 8 at src/codec/utf_8.rs:166:33: 166:39
        _58 = Add(move _59, move _60);   // scope 8 at src/codec/utf_8.rs:166:29: 166:39
        StorageDead(_60);                // scope 8 at src/codec/utf_8.rs:166:38: 166:39
        StorageDead(_59);                // scope 8 at src/codec/utf_8.rs:166:38: 166:39
        _9 = Add(move _58, const 1_usize); // scope 8 at src/codec/utf_8.rs:166:17: 166:43
        StorageDead(_58);                // scope 8 at src/codec/utf_8.rs:166:42: 166:43
        goto -> bb35;                    // scope 8 at src/codec/utf_8.rs:165:13: 178:14
    }

    bb19: {
        StorageLive(_61);                // scope 8 at src/codec/utf_8.rs:136:48: 136:82
        StorageLive(_62);                // scope 8 at src/codec/utf_8.rs:167:40: 167:45
        _62 = _8;                        // scope 8 at src/codec/utf_8.rs:167:40: 167:45
        StorageLive(_63);                // scope 8 at src/codec/utf_8.rs:136:58: 136:82
        _63 = const 86_u8;               // scope 8 at src/codec/utf_8.rs:136:58: 136:82
        _61 = Ge(move _62, move _63);    // scope 8 at src/codec/utf_8.rs:136:48: 136:82
        StorageDead(_63);                // scope 8 at src/codec/utf_8.rs:136:81: 136:82
        StorageDead(_62);                // scope 8 at src/codec/utf_8.rs:136:81: 136:82
        switchInt(move _61) -> [false: bb34, otherwise: bb20]; // scope 8 at src/codec/utf_8.rs:136:48: 136:82
    }

    bb20: {
        StorageLive(_64);                // scope 8 at src/codec/utf_8.rs:168:21: 168:25
        StorageLive(_65);                // scope 8 at src/codec/utf_8.rs:168:31: 168:52
        StorageLive(_66);                // scope 8 at src/codec/utf_8.rs:168:31: 168:36
        _66 = _8;                        // scope 8 at src/codec/utf_8.rs:168:31: 168:36
        StorageLive(_67);                // scope 8 at src/codec/utf_8.rs:168:40: 168:52
        _67 = const 98_u8;               // scope 8 at src/codec/utf_8.rs:168:40: 168:52
        _65 = Eq(move _66, move _67);    // scope 8 at src/codec/utf_8.rs:168:31: 168:52
        StorageDead(_67);                // scope 8 at src/codec/utf_8.rs:168:51: 168:52
        StorageDead(_66);                // scope 8 at src/codec/utf_8.rs:168:51: 168:52
        switchInt(move _65) -> [false: bb22, otherwise: bb21]; // scope 8 at src/codec/utf_8.rs:168:31: 168:52
    }

    bb21: {
        StorageLive(_68);                // scope 8 at src/codec/utf_8.rs:168:54: 168:64
        StorageLive(_69);                // scope 8 at src/codec/utf_8.rs:168:54: 168:55
        _69 = _40;                       // scope 8 at src/codec/utf_8.rs:168:54: 168:55
        StorageLive(_70);                // scope 8 at src/codec/utf_8.rs:168:58: 168:64
        _70 = _10;                       // scope 8 at src/codec/utf_8.rs:168:58: 168:64
        _68 = Add(move _69, move _70);   // scope 8 at src/codec/utf_8.rs:168:54: 168:64
        StorageDead(_70);                // scope 8 at src/codec/utf_8.rs:168:63: 168:64
        StorageDead(_69);                // scope 8 at src/codec/utf_8.rs:168:63: 168:64
        _64 = Add(move _68, const 1_usize); // scope 8 at src/codec/utf_8.rs:168:54: 168:68
        StorageDead(_68);                // scope 8 at src/codec/utf_8.rs:168:67: 168:68
        goto -> bb23;                    // scope 8 at src/codec/utf_8.rs:168:28: 168:87
    }

    bb22: {
        StorageLive(_71);                // scope 8 at src/codec/utf_8.rs:168:76: 168:77
        _71 = _40;                       // scope 8 at src/codec/utf_8.rs:168:76: 168:77
        StorageLive(_72);                // scope 8 at src/codec/utf_8.rs:168:80: 168:86
        _72 = _10;                       // scope 8 at src/codec/utf_8.rs:168:80: 168:86
        _64 = Add(move _71, move _72);   // scope 8 at src/codec/utf_8.rs:168:76: 168:86
        StorageDead(_72);                // scope 8 at src/codec/utf_8.rs:168:85: 168:86
        StorageDead(_71);                // scope 8 at src/codec/utf_8.rs:168:85: 168:86
        goto -> bb23;                    // scope 8 at src/codec/utf_8.rs:168:28: 168:87
    }

    bb23: {
        StorageDead(_65);                // scope 8 at src/codec/utf_8.rs:168:86: 168:87
        StorageLive(_73);                // scope 9 at src/codec/utf_8.rs:169:30: 169:43
        _73 = const 0_u8;                // scope 9 at src/codec/utf_8.rs:169:30: 169:43
        ((*_1).2: u8) = move _73;        // scope 9 at src/codec/utf_8.rs:169:17: 169:43
        StorageDead(_73);                // scope 9 at src/codec/utf_8.rs:169:42: 169:43
        StorageLive(_74);                // scope 9 at src/codec/utf_8.rs:170:20: 170:54
        StorageLive(_75);                // scope 9 at src/codec/utf_8.rs:170:20: 170:33
        StorageLive(_76);                // scope 9 at src/codec/utf_8.rs:170:20: 170:29
        _76 = _9;                        // scope 9 at src/codec/utf_8.rs:170:20: 170:29
        _75 = Gt(move _76, const 0_usize); // scope 9 at src/codec/utf_8.rs:170:20: 170:33
        StorageDead(_76);                // scope 9 at src/codec/utf_8.rs:170:32: 170:33
        switchInt(move _75) -> [false: bb24, otherwise: bb25]; // scope 9 at src/codec/utf_8.rs:170:20: 170:54
    }

    bb24: {
        _74 = const false;               // scope 9 at src/codec/utf_8.rs:170:20: 170:54
        goto -> bb26;                    // scope 9 at src/codec/utf_8.rs:170:20: 170:54
    }

    bb25: {
        StorageLive(_77);                // scope 9 at src/codec/utf_8.rs:170:37: 170:54
        StorageLive(_78);                // scope 9 at src/codec/utf_8.rs:170:37: 170:50
        _78 = ((*_1).0: usize);          // scope 9 at src/codec/utf_8.rs:170:37: 170:50
        _77 = Gt(move _78, const 0_usize); // scope 9 at src/codec/utf_8.rs:170:37: 170:54
        StorageDead(_78);                // scope 9 at src/codec/utf_8.rs:170:53: 170:54
        _74 = move _77;                  // scope 9 at src/codec/utf_8.rs:170:20: 170:54
        goto -> bb26;                    // scope 9 at src/codec/utf_8.rs:170:20: 170:54
    }

    bb26: {
        StorageDead(_77);                // scope 9 at src/codec/utf_8.rs:170:53: 170:54
        StorageDead(_75);                // scope 9 at src/codec/utf_8.rs:170:53: 170:54
        switchInt(move _74) -> [false: bb30, otherwise: bb27]; // scope 9 at src/codec/utf_8.rs:170:20: 170:54
    }

    bb27: {
        StorageLive(_79);                // scope 9 at src/codec/utf_8.rs:171:21: 171:71
        StorageLive(_80);                // scope 9 at src/codec/utf_8.rs:171:33: 171:39
        StorageLive(_81);                // scope 9 at src/codec/utf_8.rs:171:33: 171:39
        _81 = &mut (*_3);                // scope 9 at src/codec/utf_8.rs:171:33: 171:39
        _80 = move _81 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 9 at src/codec/utf_8.rs:171:33: 171:39
        StorageDead(_81);                // scope 9 at src/codec/utf_8.rs:171:38: 171:39
        StorageLive(_82);                // scope 9 at src/codec/utf_8.rs:171:41: 171:70
        StorageLive(_83);                // scope 9 at src/codec/utf_8.rs:171:41: 171:70
        StorageLive(_84);                // scope 9 at src/codec/utf_8.rs:171:42: 171:70
        StorageLive(_85);                // scope 9 at src/codec/utf_8.rs:171:42: 171:52
        _85 = &((*_1).1: [u8; 4]);       // scope 9 at src/codec/utf_8.rs:171:42: 171:52
        StorageLive(_86);                // scope 9 at src/codec/utf_8.rs:171:53: 171:69
        StorageLive(_87);                // scope 9 at src/codec/utf_8.rs:171:56: 171:69
        _87 = ((*_1).0: usize);          // scope 9 at src/codec/utf_8.rs:171:56: 171:69
        (_86.0: usize) = const 0_usize;  // scope 9 at src/codec/utf_8.rs:171:53: 171:69
        (_86.1: usize) = move _87;       // scope 9 at src/codec/utf_8.rs:171:53: 171:69
        StorageDead(_87);                // scope 9 at src/codec/utf_8.rs:171:68: 171:69
        _84 = <[u8; 4] as Index<std::ops::Range<usize>>>::index(move _85, move _86) -> bb28; // scope 9 at src/codec/utf_8.rs:171:42: 171:70
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:171:42: 171:70
                                         // + literal: Const { ty: for<'r> fn(&'r [u8; 4], std::ops::Range<usize>) -> &'r <[u8; 4] as std::ops::Index<std::ops::Range<usize>>>::Output {<[u8; 4] as std::ops::Index<std::ops::Range<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb28: {
        StorageDead(_86);                // scope 9 at src/codec/utf_8.rs:171:69: 171:70
        StorageDead(_85);                // scope 9 at src/codec/utf_8.rs:171:69: 171:70
        _83 = _84;                       // scope 9 at src/codec/utf_8.rs:171:41: 171:70
        _82 = _83;                       // scope 9 at src/codec/utf_8.rs:171:41: 171:70
        _79 = <UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes(move _80, move _82) -> bb29; // scope 9 at src/codec/utf_8.rs:171:21: 171:71
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:171:21: 171:32
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut (dyn encoding_types::StringWriter + 'r), &'s [u8]) {<codec::utf_8::UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb29: {
        StorageDead(_82);                // scope 9 at src/codec/utf_8.rs:171:70: 171:71
        StorageDead(_80);                // scope 9 at src/codec/utf_8.rs:171:70: 171:71
        StorageDead(_84);                // scope 9 at src/codec/utf_8.rs:171:71: 171:72
        StorageDead(_83);                // scope 9 at src/codec/utf_8.rs:171:71: 171:72
        StorageDead(_79);                // scope 9 at src/codec/utf_8.rs:171:71: 171:72
        goto -> bb30;                    // scope 9 at src/codec/utf_8.rs:170:17: 172:18
    }

    bb30: {
        StorageDead(_74);                // scope 9 at src/codec/utf_8.rs:172:17: 172:18
        ((*_1).0: usize) = const 0_usize; // scope 9 at src/codec/utf_8.rs:173:17: 173:34
        StorageLive(_88);                // scope 9 at src/codec/utf_8.rs:174:17: 174:58
        StorageLive(_89);                // scope 9 at src/codec/utf_8.rs:174:29: 174:35
        StorageLive(_90);                // scope 9 at src/codec/utf_8.rs:174:29: 174:35
        _90 = &mut (*_3);                // scope 9 at src/codec/utf_8.rs:174:29: 174:35
        _89 = move _90 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 9 at src/codec/utf_8.rs:174:29: 174:35
        StorageDead(_90);                // scope 9 at src/codec/utf_8.rs:174:34: 174:35
        StorageLive(_91);                // scope 9 at src/codec/utf_8.rs:174:37: 174:57
        StorageLive(_92);                // scope 9 at src/codec/utf_8.rs:174:37: 174:57
        StorageLive(_93);                // scope 9 at src/codec/utf_8.rs:174:38: 174:57
        StorageLive(_94);                // scope 9 at src/codec/utf_8.rs:174:38: 174:43
        _94 = _2;                        // scope 9 at src/codec/utf_8.rs:174:38: 174:43
        StorageLive(_95);                // scope 9 at src/codec/utf_8.rs:174:44: 174:56
        StorageLive(_96);                // scope 9 at src/codec/utf_8.rs:174:47: 174:56
        _96 = _9;                        // scope 9 at src/codec/utf_8.rs:174:47: 174:56
        (_95.0: usize) = const 0_usize;  // scope 9 at src/codec/utf_8.rs:174:44: 174:56
        (_95.1: usize) = move _96;       // scope 9 at src/codec/utf_8.rs:174:44: 174:56
        StorageDead(_96);                // scope 9 at src/codec/utf_8.rs:174:55: 174:56
        _93 = <[u8] as Index<std::ops::Range<usize>>>::index(move _94, move _95) -> bb31; // scope 9 at src/codec/utf_8.rs:174:38: 174:57
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:174:38: 174:57
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::Range<usize>) -> &'r <[u8] as std::ops::Index<std::ops::Range<usize>>>::Output {<[u8] as std::ops::Index<std::ops::Range<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb31: {
        StorageDead(_95);                // scope 9 at src/codec/utf_8.rs:174:56: 174:57
        StorageDead(_94);                // scope 9 at src/codec/utf_8.rs:174:56: 174:57
        _92 = _93;                       // scope 9 at src/codec/utf_8.rs:174:37: 174:57
        _91 = _92;                       // scope 9 at src/codec/utf_8.rs:174:37: 174:57
        _88 = <UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes(move _89, move _91) -> bb32; // scope 9 at src/codec/utf_8.rs:174:17: 174:58
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:174:17: 174:28
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut (dyn encoding_types::StringWriter + 'r), &'s [u8]) {<codec::utf_8::UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb32: {
        StorageDead(_91);                // scope 9 at src/codec/utf_8.rs:174:57: 174:58
        StorageDead(_89);                // scope 9 at src/codec/utf_8.rs:174:57: 174:58
        StorageDead(_93);                // scope 9 at src/codec/utf_8.rs:174:58: 174:59
        StorageDead(_92);                // scope 9 at src/codec/utf_8.rs:174:58: 174:59
        StorageDead(_88);                // scope 9 at src/codec/utf_8.rs:174:58: 174:59
        StorageLive(_97);                // scope 9 at src/codec/utf_8.rs:175:25: 175:34
        _97 = _9;                        // scope 9 at src/codec/utf_8.rs:175:25: 175:34
        StorageLive(_98);                // scope 9 at src/codec/utf_8.rs:175:36: 177:19
        StorageLive(_99);                // scope 9 at src/codec/utf_8.rs:175:41: 177:18
        StorageLive(_100);               // scope 9 at src/codec/utf_8.rs:176:27: 176:40
        StorageLive(_101);               // scope 9 at src/codec/utf_8.rs:176:27: 176:31
        _101 = _64;                      // scope 9 at src/codec/utf_8.rs:176:27: 176:31
        _100 = move _101 as isize (Misc); // scope 9 at src/codec/utf_8.rs:176:27: 176:40
        StorageDead(_101);               // scope 9 at src/codec/utf_8.rs:176:39: 176:40
        StorageLive(_102);               // scope 9 at src/codec/utf_8.rs:176:49: 176:74
        StorageLive(_103);               // scope 9 at src/codec/utf_8.rs:176:49: 176:67
        StorageLive(_104);               // scope 9 at src/codec/utf_8.rs:176:49: 176:67
        _104 = const "invalid sequence"; // scope 9 at src/codec/utf_8.rs:176:49: 176:67
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:176:49: 176:67
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _103 = _104;                     // scope 9 at src/codec/utf_8.rs:176:49: 176:67
        _102 = <&str as Into<Cow<str>>>::into(move _103) -> bb33; // scope 9 at src/codec/utf_8.rs:176:49: 176:74
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:176:68: 176:72
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb33: {
        StorageDead(_103);               // scope 9 at src/codec/utf_8.rs:176:73: 176:74
        (_99.0: isize) = move _100;      // scope 9 at src/codec/utf_8.rs:175:41: 177:18
        (_99.1: std::borrow::Cow<str>) = move _102; // scope 9 at src/codec/utf_8.rs:175:41: 177:18
        StorageDead(_102);               // scope 9 at src/codec/utf_8.rs:177:17: 177:18
        StorageDead(_100);               // scope 9 at src/codec/utf_8.rs:177:17: 177:18
        ((_98 as Some).0: encoding_types::CodecError) = move _99; // scope 9 at src/codec/utf_8.rs:175:36: 177:19
        discriminant(_98) = 1;           // scope 9 at src/codec/utf_8.rs:175:36: 177:19
        StorageDead(_99);                // scope 9 at src/codec/utf_8.rs:177:18: 177:19
        (_0.0: usize) = move _97;        // scope 9 at src/codec/utf_8.rs:175:24: 177:20
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _98; // scope 9 at src/codec/utf_8.rs:175:24: 177:20
        StorageDead(_98);                // scope 9 at src/codec/utf_8.rs:177:19: 177:20
        StorageDead(_97);                // scope 9 at src/codec/utf_8.rs:177:19: 177:20
        StorageDead(_104);               // scope 9 at src/codec/utf_8.rs:177:20: 177:21
        StorageDead(_64);                // scope 8 at src/codec/utf_8.rs:178:13: 178:14
        StorageDead(_61);                // scope 8 at src/codec/utf_8.rs:178:13: 178:14
        StorageDead(_55);                // scope 8 at src/codec/utf_8.rs:178:13: 178:14
        StorageDead(_40);                // scope 6 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_41);                // scope 6 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_33);                // scope 5 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_32);                // scope 3 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_28);                // scope 3 at src/codec/utf_8.rs:163:58: 163:59
        StorageDead(_24);                // scope 3 at src/codec/utf_8.rs:163:58: 163:59
        StorageDead(_10);                // scope 2 at src/codec/utf_8.rs:195:5: 195:6
        StorageDead(_9);                 // scope 1 at src/codec/utf_8.rs:195:5: 195:6
        StorageDead(_8);                 // scope 0 at src/codec/utf_8.rs:195:5: 195:6
        goto -> bb55;                    // scope 0 at src/codec/utf_8.rs:195:6: 195:6
    }

    bb34: {
        StorageDead(_61);                // scope 8 at src/codec/utf_8.rs:178:13: 178:14
        goto -> bb35;                    // scope 8 at src/codec/utf_8.rs:165:13: 178:14
    }

    bb35: {
        StorageDead(_55);                // scope 8 at src/codec/utf_8.rs:178:13: 178:14
        StorageDead(_40);                // scope 6 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_41);                // scope 6 at src/codec/utf_8.rs:179:9: 179:10
        StorageDead(_33);                // scope 5 at src/codec/utf_8.rs:179:9: 179:10
        goto -> bb11;                    // scope 5 at src/codec/utf_8.rs:163:9: 179:10
    }

    bb36: {
        _106 = const false;              // scope 3 at src/codec/utf_8.rs:182:12: 182:46
        goto -> bb38;                    // scope 3 at src/codec/utf_8.rs:182:12: 182:46
    }

    bb37: {
        StorageLive(_109);               // scope 3 at src/codec/utf_8.rs:182:29: 182:46
        StorageLive(_110);               // scope 3 at src/codec/utf_8.rs:182:29: 182:42
        _110 = ((*_1).0: usize);         // scope 3 at src/codec/utf_8.rs:182:29: 182:42
        _109 = Gt(move _110, const 0_usize); // scope 3 at src/codec/utf_8.rs:182:29: 182:46
        StorageDead(_110);               // scope 3 at src/codec/utf_8.rs:182:45: 182:46
        _106 = move _109;                // scope 3 at src/codec/utf_8.rs:182:12: 182:46
        goto -> bb38;                    // scope 3 at src/codec/utf_8.rs:182:12: 182:46
    }

    bb38: {
        StorageDead(_109);               // scope 3 at src/codec/utf_8.rs:182:45: 182:46
        StorageDead(_107);               // scope 3 at src/codec/utf_8.rs:182:45: 182:46
        switchInt(move _106) -> [false: bb42, otherwise: bb39]; // scope 3 at src/codec/utf_8.rs:182:12: 182:46
    }

    bb39: {
        StorageLive(_111);               // scope 3 at src/codec/utf_8.rs:183:13: 183:63
        StorageLive(_112);               // scope 3 at src/codec/utf_8.rs:183:25: 183:31
        StorageLive(_113);               // scope 3 at src/codec/utf_8.rs:183:25: 183:31
        _113 = &mut (*_3);               // scope 3 at src/codec/utf_8.rs:183:25: 183:31
        _112 = move _113 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 3 at src/codec/utf_8.rs:183:25: 183:31
        StorageDead(_113);               // scope 3 at src/codec/utf_8.rs:183:30: 183:31
        StorageLive(_114);               // scope 3 at src/codec/utf_8.rs:183:33: 183:62
        StorageLive(_115);               // scope 3 at src/codec/utf_8.rs:183:33: 183:62
        StorageLive(_116);               // scope 3 at src/codec/utf_8.rs:183:34: 183:62
        StorageLive(_117);               // scope 3 at src/codec/utf_8.rs:183:34: 183:44
        _117 = &((*_1).1: [u8; 4]);      // scope 3 at src/codec/utf_8.rs:183:34: 183:44
        StorageLive(_118);               // scope 3 at src/codec/utf_8.rs:183:45: 183:61
        StorageLive(_119);               // scope 3 at src/codec/utf_8.rs:183:48: 183:61
        _119 = ((*_1).0: usize);         // scope 3 at src/codec/utf_8.rs:183:48: 183:61
        (_118.0: usize) = const 0_usize; // scope 3 at src/codec/utf_8.rs:183:45: 183:61
        (_118.1: usize) = move _119;     // scope 3 at src/codec/utf_8.rs:183:45: 183:61
        StorageDead(_119);               // scope 3 at src/codec/utf_8.rs:183:60: 183:61
        _116 = <[u8; 4] as Index<std::ops::Range<usize>>>::index(move _117, move _118) -> bb40; // scope 3 at src/codec/utf_8.rs:183:34: 183:62
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:183:34: 183:62
                                         // + literal: Const { ty: for<'r> fn(&'r [u8; 4], std::ops::Range<usize>) -> &'r <[u8; 4] as std::ops::Index<std::ops::Range<usize>>>::Output {<[u8; 4] as std::ops::Index<std::ops::Range<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb40: {
        StorageDead(_118);               // scope 3 at src/codec/utf_8.rs:183:61: 183:62
        StorageDead(_117);               // scope 3 at src/codec/utf_8.rs:183:61: 183:62
        _115 = _116;                     // scope 3 at src/codec/utf_8.rs:183:33: 183:62
        _114 = _115;                     // scope 3 at src/codec/utf_8.rs:183:33: 183:62
        _111 = <UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes(move _112, move _114) -> bb41; // scope 3 at src/codec/utf_8.rs:183:13: 183:63
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:183:13: 183:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut (dyn encoding_types::StringWriter + 'r), &'s [u8]) {<codec::utf_8::UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb41: {
        StorageDead(_114);               // scope 3 at src/codec/utf_8.rs:183:62: 183:63
        StorageDead(_112);               // scope 3 at src/codec/utf_8.rs:183:62: 183:63
        StorageDead(_116);               // scope 3 at src/codec/utf_8.rs:183:63: 183:64
        StorageDead(_115);               // scope 3 at src/codec/utf_8.rs:183:63: 183:64
        StorageDead(_111);               // scope 3 at src/codec/utf_8.rs:183:63: 183:64
        ((*_1).0: usize) = const 0_usize; // scope 3 at src/codec/utf_8.rs:184:13: 184:30
        goto -> bb42;                    // scope 3 at src/codec/utf_8.rs:182:9: 185:10
    }

    bb42: {
        StorageDead(_106);               // scope 3 at src/codec/utf_8.rs:185:9: 185:10
        StorageLive(_120);               // scope 3 at src/codec/utf_8.rs:186:9: 186:50
        StorageLive(_121);               // scope 3 at src/codec/utf_8.rs:186:21: 186:27
        StorageLive(_122);               // scope 3 at src/codec/utf_8.rs:186:21: 186:27
        _122 = &mut (*_3);               // scope 3 at src/codec/utf_8.rs:186:21: 186:27
        _121 = move _122 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 3 at src/codec/utf_8.rs:186:21: 186:27
        StorageDead(_122);               // scope 3 at src/codec/utf_8.rs:186:26: 186:27
        StorageLive(_123);               // scope 3 at src/codec/utf_8.rs:186:29: 186:49
        StorageLive(_124);               // scope 3 at src/codec/utf_8.rs:186:29: 186:49
        StorageLive(_125);               // scope 3 at src/codec/utf_8.rs:186:30: 186:49
        StorageLive(_126);               // scope 3 at src/codec/utf_8.rs:186:30: 186:35
        _126 = _2;                       // scope 3 at src/codec/utf_8.rs:186:30: 186:35
        StorageLive(_127);               // scope 3 at src/codec/utf_8.rs:186:36: 186:48
        StorageLive(_128);               // scope 3 at src/codec/utf_8.rs:186:39: 186:48
        _128 = _9;                       // scope 3 at src/codec/utf_8.rs:186:39: 186:48
        (_127.0: usize) = const 0_usize; // scope 3 at src/codec/utf_8.rs:186:36: 186:48
        (_127.1: usize) = move _128;     // scope 3 at src/codec/utf_8.rs:186:36: 186:48
        StorageDead(_128);               // scope 3 at src/codec/utf_8.rs:186:47: 186:48
        _125 = <[u8] as Index<std::ops::Range<usize>>>::index(move _126, move _127) -> bb43; // scope 3 at src/codec/utf_8.rs:186:30: 186:49
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:186:30: 186:49
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::Range<usize>) -> &'r <[u8] as std::ops::Index<std::ops::Range<usize>>>::Output {<[u8] as std::ops::Index<std::ops::Range<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb43: {
        StorageDead(_127);               // scope 3 at src/codec/utf_8.rs:186:48: 186:49
        StorageDead(_126);               // scope 3 at src/codec/utf_8.rs:186:48: 186:49
        _124 = _125;                     // scope 3 at src/codec/utf_8.rs:186:29: 186:49
        _123 = _124;                     // scope 3 at src/codec/utf_8.rs:186:29: 186:49
        _120 = <UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes(move _121, move _123) -> bb44; // scope 3 at src/codec/utf_8.rs:186:9: 186:50
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:186:9: 186:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut (dyn encoding_types::StringWriter + 'r), &'s [u8]) {<codec::utf_8::UTF8Decoder as encoding_types::RawDecoder>::raw_feed::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb44: {
        StorageDead(_123);               // scope 3 at src/codec/utf_8.rs:186:49: 186:50
        StorageDead(_121);               // scope 3 at src/codec/utf_8.rs:186:49: 186:50
        StorageDead(_125);               // scope 3 at src/codec/utf_8.rs:186:50: 186:51
        StorageDead(_124);               // scope 3 at src/codec/utf_8.rs:186:50: 186:51
        StorageDead(_120);               // scope 3 at src/codec/utf_8.rs:186:50: 186:51
        StorageLive(_129);               // scope 3 at src/codec/utf_8.rs:187:12: 187:35
        StorageLive(_130);               // scope 3 at src/codec/utf_8.rs:187:12: 187:21
        _130 = _9;                       // scope 3 at src/codec/utf_8.rs:187:12: 187:21
        StorageLive(_131);               // scope 3 at src/codec/utf_8.rs:187:24: 187:35
        StorageLive(_132);               // scope 3 at src/codec/utf_8.rs:187:24: 187:29
        _132 = _2;                       // scope 3 at src/codec/utf_8.rs:187:24: 187:29
        _131 = Len((*_132));             // scope 3 at src/codec/utf_8.rs:187:24: 187:35
        StorageDead(_132);               // scope 3 at src/codec/utf_8.rs:187:34: 187:35
        _129 = Lt(move _130, move _131); // scope 3 at src/codec/utf_8.rs:187:12: 187:35
        StorageDead(_131);               // scope 3 at src/codec/utf_8.rs:187:34: 187:35
        StorageDead(_130);               // scope 3 at src/codec/utf_8.rs:187:34: 187:35
        switchInt(move _129) -> [false: bb54, otherwise: bb45]; // scope 3 at src/codec/utf_8.rs:187:12: 187:35
    }

    bb45: {
        StorageLive(_133);               // scope 3 at src/codec/utf_8.rs:188:17: 188:29
        StorageLive(_134);               // scope 3 at src/codec/utf_8.rs:188:32: 188:43
        StorageLive(_135);               // scope 3 at src/codec/utf_8.rs:188:32: 188:37
        _135 = _2;                       // scope 3 at src/codec/utf_8.rs:188:32: 188:37
        _134 = Len((*_135));             // scope 3 at src/codec/utf_8.rs:188:32: 188:43
        StorageDead(_135);               // scope 3 at src/codec/utf_8.rs:188:42: 188:43
        StorageLive(_136);               // scope 3 at src/codec/utf_8.rs:188:46: 188:55
        _136 = _9;                       // scope 3 at src/codec/utf_8.rs:188:46: 188:55
        _133 = Sub(move _134, move _136); // scope 3 at src/codec/utf_8.rs:188:32: 188:55
        StorageDead(_136);               // scope 3 at src/codec/utf_8.rs:188:54: 188:55
        StorageDead(_134);               // scope 3 at src/codec/utf_8.rs:188:54: 188:55
        StorageLive(_137);               // scope 10 at src/codec/utf_8.rs:189:22: 189:37
        StorageLive(_138);               // scope 10 at src/codec/utf_8.rs:189:22: 189:37
        StorageLive(_139);               // scope 10 at src/codec/utf_8.rs:189:25: 189:37
        _139 = _133;                     // scope 10 at src/codec/utf_8.rs:189:25: 189:37
        (_138.0: usize) = const 0_usize; // scope 10 at src/codec/utf_8.rs:189:22: 189:37
        (_138.1: usize) = move _139;     // scope 10 at src/codec/utf_8.rs:189:22: 189:37
        StorageDead(_139);               // scope 10 at src/codec/utf_8.rs:189:36: 189:37
        _137 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _138) -> bb46; // scope 10 at src/codec/utf_8.rs:189:22: 189:37
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:189:22: 189:37
                                         // + literal: Const { ty: fn(std::ops::Range<usize>) -> <std::ops::Range<usize> as std::iter::IntoIterator>::IntoIter {<std::ops::Range<usize> as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb46: {
        StorageDead(_138);               // scope 10 at src/codec/utf_8.rs:189:36: 189:37
        StorageLive(_140);               // scope 10 at src/codec/utf_8.rs:189:22: 189:37
        _140 = move _137;                // scope 10 at src/codec/utf_8.rs:189:22: 189:37
        goto -> bb47;                    // scope 11 at src/codec/utf_8.rs:189:13: 191:14
    }

    bb47: {
        StorageLive(_141);               // scope 11 at src/codec/utf_8.rs:189:22: 189:37
        StorageLive(_142);               // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        StorageLive(_143);               // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        StorageLive(_144);               // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        _144 = &mut _140;                // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        _143 = &mut (*_144);             // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        _142 = <std::ops::Range<usize> as Iterator>::next(move _143) -> bb48; // scope 12 at src/codec/utf_8.rs:189:22: 189:37
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:189:22: 189:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::ops::Range<usize>) -> std::option::Option<<std::ops::Range<usize> as std::iter::Iterator>::Item> {<std::ops::Range<usize> as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb48: {
        StorageDead(_143);               // scope 12 at src/codec/utf_8.rs:189:36: 189:37
        _145 = discriminant(_142);       // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        switchInt(move _145) -> [0_isize: bb49, 1_isize: bb51, otherwise: bb50]; // scope 12 at src/codec/utf_8.rs:189:22: 189:37
    }

    bb49: {
        StorageDead(_144);               // scope 12 at src/codec/utf_8.rs:189:36: 189:37
        StorageDead(_142);               // scope 12 at src/codec/utf_8.rs:189:36: 189:37
        StorageDead(_141);               // scope 11 at src/codec/utf_8.rs:191:13: 191:14
        StorageDead(_140);               // scope 10 at src/codec/utf_8.rs:191:13: 191:14
        StorageDead(_137);               // scope 10 at src/codec/utf_8.rs:189:36: 189:37
        StorageLive(_160);               // scope 10 at src/codec/utf_8.rs:192:30: 192:42
        _160 = _133;                     // scope 10 at src/codec/utf_8.rs:192:30: 192:42
        ((*_1).0: usize) = Add(((*_1).0: usize), move _160); // scope 10 at src/codec/utf_8.rs:192:13: 192:42
        StorageDead(_160);               // scope 10 at src/codec/utf_8.rs:192:41: 192:42
        StorageDead(_133);               // scope 3 at src/codec/utf_8.rs:193:9: 193:10
        goto -> bb54;                    // scope 3 at src/codec/utf_8.rs:187:9: 193:10
    }

    bb50: {
        unreachable;                     // scope 12 at src/codec/utf_8.rs:189:22: 189:37
    }

    bb51: {
        StorageLive(_146);               // scope 12 at src/codec/utf_8.rs:189:17: 189:18
        _146 = ((_142 as Some).0: usize); // scope 12 at src/codec/utf_8.rs:189:17: 189:18
        StorageLive(_147);               // scope 13 at src/codec/utf_8.rs:189:17: 189:18
        _147 = _146;                     // scope 13 at src/codec/utf_8.rs:189:17: 189:18
        _141 = move _147;                // scope 13 at src/codec/utf_8.rs:189:17: 189:18
        StorageDead(_147);               // scope 13 at src/codec/utf_8.rs:189:17: 189:18
        StorageDead(_146);               // scope 12 at src/codec/utf_8.rs:189:17: 189:18
        StorageDead(_144);               // scope 12 at src/codec/utf_8.rs:189:36: 189:37
        StorageDead(_142);               // scope 12 at src/codec/utf_8.rs:189:36: 189:37
        StorageLive(_148);               // scope 12 at src/codec/utf_8.rs:189:17: 189:18
        _148 = _141;                     // scope 12 at src/codec/utf_8.rs:189:22: 189:37
        StorageLive(_149);               // scope 14 at src/codec/utf_8.rs:190:49: 190:69
        StorageLive(_150);               // scope 14 at src/codec/utf_8.rs:190:55: 190:68
        StorageLive(_151);               // scope 14 at src/codec/utf_8.rs:190:55: 190:64
        _151 = _9;                       // scope 14 at src/codec/utf_8.rs:190:55: 190:64
        StorageLive(_152);               // scope 14 at src/codec/utf_8.rs:190:67: 190:68
        _152 = _148;                     // scope 14 at src/codec/utf_8.rs:190:67: 190:68
        _150 = Add(move _151, move _152); // scope 14 at src/codec/utf_8.rs:190:55: 190:68
        StorageDead(_152);               // scope 14 at src/codec/utf_8.rs:190:67: 190:68
        StorageDead(_151);               // scope 14 at src/codec/utf_8.rs:190:67: 190:68
        _153 = Len((*_2));               // scope 14 at src/codec/utf_8.rs:190:49: 190:69
        _154 = Lt(_150, _153);           // scope 14 at src/codec/utf_8.rs:190:49: 190:69
        assert(move _154, "index out of bounds: the length is {} but the index is {}", move _153, _150) -> bb52; // scope 14 at src/codec/utf_8.rs:190:49: 190:69
    }

    bb52: {
        _149 = (*_2)[_150];              // scope 14 at src/codec/utf_8.rs:190:49: 190:69
        StorageLive(_155);               // scope 14 at src/codec/utf_8.rs:190:28: 190:45
        StorageLive(_156);               // scope 14 at src/codec/utf_8.rs:190:28: 190:41
        _156 = ((*_1).0: usize);         // scope 14 at src/codec/utf_8.rs:190:28: 190:41
        StorageLive(_157);               // scope 14 at src/codec/utf_8.rs:190:44: 190:45
        _157 = _148;                     // scope 14 at src/codec/utf_8.rs:190:44: 190:45
        _155 = Add(move _156, move _157); // scope 14 at src/codec/utf_8.rs:190:28: 190:45
        StorageDead(_157);               // scope 14 at src/codec/utf_8.rs:190:44: 190:45
        StorageDead(_156);               // scope 14 at src/codec/utf_8.rs:190:44: 190:45
        _158 = const 4_usize;            // scope 14 at src/codec/utf_8.rs:190:17: 190:46
        _159 = Lt(_155, _158);           // scope 14 at src/codec/utf_8.rs:190:17: 190:46
        assert(move _159, "index out of bounds: the length is {} but the index is {}", move _158, _155) -> bb53; // scope 14 at src/codec/utf_8.rs:190:17: 190:46
    }

    bb53: {
        ((*_1).1: [u8; 4])[_155] = move _149; // scope 14 at src/codec/utf_8.rs:190:17: 190:69
        StorageDead(_149);               // scope 14 at src/codec/utf_8.rs:190:68: 190:69
        StorageDead(_155);               // scope 14 at src/codec/utf_8.rs:190:69: 190:70
        StorageDead(_150);               // scope 14 at src/codec/utf_8.rs:190:69: 190:70
        StorageDead(_148);               // scope 12 at src/codec/utf_8.rs:191:13: 191:14
        StorageDead(_141);               // scope 11 at src/codec/utf_8.rs:191:13: 191:14
        goto -> bb47;                    // scope 11 at src/codec/utf_8.rs:189:13: 191:14
    }

    bb54: {
        StorageDead(_129);               // scope 3 at src/codec/utf_8.rs:193:9: 193:10
        StorageLive(_161);               // scope 3 at src/codec/utf_8.rs:194:10: 194:19
        _161 = _9;                       // scope 3 at src/codec/utf_8.rs:194:10: 194:19
        StorageLive(_162);               // scope 3 at src/codec/utf_8.rs:194:21: 194:25
        discriminant(_162) = 0;          // scope 3 at src/codec/utf_8.rs:194:21: 194:25
        (_0.0: usize) = move _161;       // scope 3 at src/codec/utf_8.rs:194:9: 194:26
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _162; // scope 3 at src/codec/utf_8.rs:194:9: 194:26
        StorageDead(_162);               // scope 3 at src/codec/utf_8.rs:194:25: 194:26
        StorageDead(_161);               // scope 3 at src/codec/utf_8.rs:194:25: 194:26
        StorageDead(_10);                // scope 2 at src/codec/utf_8.rs:195:5: 195:6
        StorageDead(_9);                 // scope 1 at src/codec/utf_8.rs:195:5: 195:6
        StorageDead(_8);                 // scope 0 at src/codec/utf_8.rs:195:5: 195:6
        goto -> bb55;                    // scope 0 at src/codec/utf_8.rs:195:6: 195:6
    }

    bb55: {
        return;                          // scope 0 at src/codec/utf_8.rs:195:6: 195:6
    }
}

alloc3 (static: CHAR_CATEGORY, size: 256, align: 1) {
    0x000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x080  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................
    0x090  09 09 09 09 09 09 09 09 09 09 09 09 09 09 09 09  ................
    0x0a0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................
    0x0b0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................
    0x0c0  08 08 02 02 02 02 02 02 02 02 02 02 02 02 02 02  ................
    0x0d0  02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02  ................
    0x0e0  0a 03 03 03 03 03 03 03 03 03 03 03 03 04 03 03  ................
    0x0f0  0b 06 06 06 05 08 08 08 08 08 08 08 08 08 08 08  ................
}

alloc2 (static: STATE_TRANSITIONS, size: 110, align: 1) {
    0x00  00 62 0c 18 30 54 48 62 62 62 24 3c 56 00 56 56  .b..0THbbb$<V.VV
    0x10  56 56 56 00 56 00 56 56 56 0c 56 56 56 56 56 0c  VVV.V.VVV.VVVVV.
    0x20  56 0c 56 56 56 56 56 56 56 56 56 0c 56 56 56 56  V.VVVVVVVVV.VVVV
    0x30  56 0c 56 56 56 56 56 56 56 0c 56 56 56 56 56 56  V.VVVVVVV.VVVVVV
    0x40  56 56 56 18 56 18 56 56 56 18 56 56 56 56 56 18  VVV.V.VVV.VVVVV.
    0x50  56 18 56 56 56 18 56 56 56 56 56 56 56 56 56 56  V.VVV.VVVVVVVVVV
    0x60  56 56 62 62 62 62 62 62 62 62 62 62 62 62        VVbbbbbbbbbbbb
}

fn eucjp::transient::S0(_1: &mut StatefulDecoderHelper<eucjp::State, T>) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

fn japanese::<impl at src/codec/japanese.rs:781:20: 781:25>::clone(_1: &ISO2022JPState) -> ISO2022JPState {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:781:20: 781:25
    let mut _0: codec::japanese::ISO2022JPState; // return place in scope 0 at src/codec/japanese.rs:781:20: 781:25

    bb0: {
        _0 = (*_1);                      // scope 0 at src/codec/japanese.rs:781:20: 781:25
        return;                          // scope 0 at src/codec/japanese.rs:781:25: 781:25
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:288:1: 292:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_16.rs:289:21: 289:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:290:9: 290:64
    let mut _2: std::boxed::Box<codec::utf_16::UTF16BEDecoder>; // in scope 0 at src/codec/utf_16.rs:290:9: 290:64
    let mut _3: codec::utf_16::UTF16BEDecoder; // in scope 0 at src/codec/utf_16.rs:290:18: 290:63
    let mut _4: codec::utf_16::UTF16Decoder; // in scope 0 at src/codec/utf_16.rs:290:42: 290:61

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/utf_16.rs:290:9: 290:64
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:290:9: 290:64
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:290:18: 290:63
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:290:42: 290:61
        _4 = UTF16Decoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:290:42: 290:61
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:290:42: 290:59
                                         // + literal: Const { ty: fn() -> codec::utf_16::UTF16Decoder {codec::utf_16::UTF16Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::utf_16::UTF16Decoder) = move _4; // scope 0 at src/codec/utf_16.rs:290:18: 290:63
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:290:62: 290:63
        _2 = Box::<UTF16BEDecoder>::new(move _3) -> bb2; // scope 0 at src/codec/utf_16.rs:290:9: 290:64
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:290:9: 290:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::utf_16::UTF16BEDecoder) -> std::boxed::Box<codec::utf_16::UTF16BEDecoder> {std::boxed::Box::<codec::utf_16::UTF16BEDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:290:9: 290:64
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:290:63: 290:64
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:290:63: 290:64
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:290:9: 290:64
        StorageDead(_1);                 // scope 0 at src/codec/utf_16.rs:291:5: 291:6
        return;                          // scope 0 at src/codec/utf_16.rs:291:6: 291:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:547:1: 562:2>::raw_feed(_1: &mut HZDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:551:17: 551:26
    debug input => _2;                   // in scope 0 at src/codec/simpchinese.rs:551:28: 551:33
    debug output => _3;                  // in scope 0 at src/codec/simpchinese.rs:551:42: 551:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/simpchinese.rs:551:72: 551:99
    let _4: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:552:14: 552:16
    let _5: usize;                       // in scope 0 at src/codec/simpchinese.rs:552:18: 552:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:552:29: 552:32
    let mut _7: (codec::simpchinese::hz::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/simpchinese.rs:552:36: 552:77
    let mut _8: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:552:49: 552:56
    let mut _9: &[u8];                   // in scope 0 at src/codec/simpchinese.rs:552:58: 552:63
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:552:65: 552:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:552:65: 552:71
    let mut _12: &();                    // in scope 0 at src/codec/simpchinese.rs:552:73: 552:76
    let _13: &();                        // in scope 0 at src/codec/simpchinese.rs:552:73: 552:76
    let mut _14: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:553:19: 553:21
    let mut _15: usize;                  // in scope 0 at src/codec/simpchinese.rs:554:10: 554:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:554:21: 554:24
    let mut _17: &();                    // in scope 0 at src/codec/simpchinese.rs:552:73: 552:76
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/simpchinese.rs:552:14: 552:16
        debug processed => _5;           // in scope 1 at src/codec/simpchinese.rs:552:18: 552:27
        debug err => _6;                 // in scope 1 at src/codec/simpchinese.rs:552:29: 552:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:552:36: 552:77
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:552:49: 552:56
        _8 = ((*_1).0: codec::simpchinese::hz::State); // scope 0 at src/codec/simpchinese.rs:552:49: 552:56
        StorageLive(_9);                 // scope 0 at src/codec/simpchinese.rs:552:58: 552:63
        _9 = _2;                         // scope 0 at src/codec/simpchinese.rs:552:58: 552:63
        StorageLive(_10);                // scope 0 at src/codec/simpchinese.rs:552:65: 552:71
        StorageLive(_11);                // scope 0 at src/codec/simpchinese.rs:552:65: 552:71
        _11 = &mut (*_3);                // scope 0 at src/codec/simpchinese.rs:552:65: 552:71
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:552:65: 552:71
        StorageDead(_11);                // scope 0 at src/codec/simpchinese.rs:552:70: 552:71
        StorageLive(_12);                // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
        StorageLive(_13);                // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
        _17 = const <HZDecoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<HZDecoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:552:73: 552:76
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:513 ~ encoding[5d2c]::codec::simpchinese::{impl#13}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
        _12 = _13;                       // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
        _7 = hz::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/simpchinese.rs:552:36: 552:77
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:552:36: 552:48
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::simpchinese::hz::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::simpchinese::hz::State, usize, std::option::Option<encoding_types::CodecError>) {codec::simpchinese::hz::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/simpchinese.rs:552:76: 552:77
        StorageDead(_10);                // scope 0 at src/codec/simpchinese.rs:552:76: 552:77
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:552:76: 552:77
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:552:76: 552:77
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:552:14: 552:16
        _4 = (_7.0: codec::simpchinese::hz::State); // scope 0 at src/codec/simpchinese.rs:552:14: 552:16
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:552:18: 552:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/simpchinese.rs:552:18: 552:27
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:552:29: 552:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/simpchinese.rs:552:29: 552:32
        StorageDead(_13);                // scope 0 at src/codec/simpchinese.rs:552:77: 552:78
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:552:77: 552:78
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:553:19: 553:21
        _14 = _4;                        // scope 1 at src/codec/simpchinese.rs:553:19: 553:21
        ((*_1).0: codec::simpchinese::hz::State) = move _14; // scope 1 at src/codec/simpchinese.rs:553:9: 553:21
        StorageDead(_14);                // scope 1 at src/codec/simpchinese.rs:553:20: 553:21
        StorageLive(_15);                // scope 1 at src/codec/simpchinese.rs:554:10: 554:19
        _15 = _5;                        // scope 1 at src/codec/simpchinese.rs:554:10: 554:19
        StorageLive(_16);                // scope 1 at src/codec/simpchinese.rs:554:21: 554:24
        _16 = move _6;                   // scope 1 at src/codec/simpchinese.rs:554:21: 554:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/simpchinese.rs:554:9: 554:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/simpchinese.rs:554:9: 554:25
        StorageDead(_16);                // scope 1 at src/codec/simpchinese.rs:554:24: 554:25
        StorageDead(_15);                // scope 1 at src/codec/simpchinese.rs:554:24: 554:25
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:555:5: 555:6
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:555:5: 555:6
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:555:5: 555:6
        return;                          // scope 0 at src/codec/simpchinese.rs:555:6: 555:6
    }
}

promoted[0] in simpchinese::<impl at src/codec/simpchinese.rs:547:1: 562:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/simpchinese.rs:552:73: 552:76
    let mut _1: ();                      // in scope 0 at src/codec/simpchinese.rs:552:74: 552:76

    bb0: {
        nop;                             // scope 0 at src/codec/simpchinese.rs:552:74: 552:76
        _0 = &_1;                        // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
        return;                          // scope 0 at src/codec/simpchinese.rs:552:73: 552:76
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:69:1: 97:2>::is_ascii_compatible(_1: &ASCIIDecoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:71:28: 71:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/ascii.rs:71:38: 71:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/ascii.rs:71:45: 71:49
        return;                          // scope 0 at src/codec/ascii.rs:71:51: 71:51
    }
}

fn iso2022jp::internal::map_two_0212_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/japanese.rs:896:40: 896:44
    debug trail => _2;                   // in scope 0 at src/codec/japanese.rs:896:50: 896:55
    let mut _0: u32;                     // return place in scope 0 at src/codec/japanese.rs:896:64: 896:67
    let _3: u16;                         // in scope 0 at src/codec/japanese.rs:899:13: 899:17
    let mut _4: u8;                      // in scope 0 at src/codec/japanese.rs:899:20: 899:24
    let mut _6: u8;                      // in scope 0 at src/codec/japanese.rs:900:21: 900:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/japanese.rs:901:27: 901:40
    let mut _9: u16;                     // in scope 0 at src/codec/japanese.rs:901:28: 901:32
    let mut _10: u16;                    // in scope 0 at src/codec/japanese.rs:901:34: 901:39
    let mut _11: bool;                   // in scope 0 at src/codec/japanese.rs:902:27: 902:38
    let mut _12: bool;                   // in scope 0 at src/codec/japanese.rs:902:27: 902:38
    let mut _13: bool;                   // in scope 0 at src/codec/japanese.rs:902:14: 902:25
    let mut _14: bool;                   // in scope 0 at src/codec/japanese.rs:902:14: 902:25
    let mut _15: u16;                    // in scope 0 at src/codec/japanese.rs:902:43: 902:69
    let mut _16: u16;                    // in scope 0 at src/codec/japanese.rs:902:43: 902:61
    let mut _17: u16;                    // in scope 0 at src/codec/japanese.rs:902:43: 902:56
    let mut _18: u16;                    // in scope 0 at src/codec/japanese.rs:902:44: 902:48
    let mut _19: u16;                    // in scope 0 at src/codec/japanese.rs:902:64: 902:69
    let mut _20: u16;                    // in scope 0 at src/codec/japanese.rs:905:33: 905:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/japanese.rs:899:13: 899:17
        let _5: u16;                     // in scope 1 at src/codec/japanese.rs:900:13: 900:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/japanese.rs:900:13: 900:18
            let _7: u16;                 // in scope 2 at src/codec/japanese.rs:901:13: 901:18
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/japanese.rs:901:13: 901:18
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:899:13: 899:17
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:899:20: 899:24
        _4 = _1;                         // scope 0 at src/codec/japanese.rs:899:20: 899:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/japanese.rs:899:20: 899:31
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:899:30: 899:31
        StorageLive(_5);                 // scope 1 at src/codec/japanese.rs:900:13: 900:18
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:900:21: 900:26
        _6 = _2;                         // scope 1 at src/codec/japanese.rs:900:21: 900:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/japanese.rs:900:21: 900:33
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:900:32: 900:33
        StorageLive(_7);                 // scope 2 at src/codec/japanese.rs:901:13: 901:18
        StorageLive(_8);                 // scope 2 at src/codec/japanese.rs:901:27: 901:40
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:901:28: 901:32
        _9 = _3;                         // scope 2 at src/codec/japanese.rs:901:28: 901:32
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:901:34: 901:39
        _10 = _5;                        // scope 2 at src/codec/japanese.rs:901:34: 901:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/japanese.rs:901:27: 901:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/japanese.rs:901:27: 901:40
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:901:39: 901:40
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:901:39: 901:40
        _13 = Le(const 33_u16, (_8.0: u16)); // scope 2 at src/codec/japanese.rs:902:14: 902:25
        switchInt(move _13) -> [false: bb4, otherwise: bb1]; // scope 2 at src/codec/japanese.rs:902:14: 902:25
    }

    bb1: {
        _14 = Le((_8.0: u16), const 126_u16); // scope 2 at src/codec/japanese.rs:902:14: 902:25
        switchInt(move _14) -> [false: bb4, otherwise: bb2]; // scope 2 at src/codec/japanese.rs:902:14: 902:25
    }

    bb2: {
        _11 = Le(const 33_u16, (_8.1: u16)); // scope 2 at src/codec/japanese.rs:902:27: 902:38
        switchInt(move _11) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/japanese.rs:902:27: 902:38
    }

    bb3: {
        _12 = Le((_8.1: u16), const 126_u16); // scope 2 at src/codec/japanese.rs:902:27: 902:38
        switchInt(move _12) -> [false: bb4, otherwise: bb5]; // scope 2 at src/codec/japanese.rs:902:27: 902:38
    }

    bb4: {
        _7 = const u16::MAX;             // scope 2 at src/codec/japanese.rs:903:18: 903:24
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:903:18: 903:24
    }

    bb5: {
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:902:43: 902:69
        StorageLive(_16);                // scope 2 at src/codec/japanese.rs:902:43: 902:61
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:902:43: 902:56
        StorageLive(_18);                // scope 2 at src/codec/japanese.rs:902:44: 902:48
        _18 = _3;                        // scope 2 at src/codec/japanese.rs:902:44: 902:48
        _17 = Sub(move _18, const 33_u16); // scope 2 at src/codec/japanese.rs:902:43: 902:56
        StorageDead(_18);                // scope 2 at src/codec/japanese.rs:902:55: 902:56
        _16 = Mul(move _17, const 94_u16); // scope 2 at src/codec/japanese.rs:902:43: 902:61
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:902:60: 902:61
        StorageLive(_19);                // scope 2 at src/codec/japanese.rs:902:64: 902:69
        _19 = _5;                        // scope 2 at src/codec/japanese.rs:902:64: 902:69
        _15 = Add(move _16, move _19);   // scope 2 at src/codec/japanese.rs:902:43: 902:69
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:902:68: 902:69
        StorageDead(_16);                // scope 2 at src/codec/japanese.rs:902:68: 902:69
        _7 = Sub(move _15, const 33_u16); // scope 2 at src/codec/japanese.rs:902:43: 902:76
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:902:75: 902:76
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:902:75: 902:76
    }

    bb6: {
        StorageDead(_8);                 // scope 2 at src/codec/japanese.rs:904:10: 904:11
        StorageLive(_20);                // scope 3 at src/codec/japanese.rs:905:33: 905:38
        _20 = _7;                        // scope 3 at src/codec/japanese.rs:905:33: 905:38
        _0 = index_japanese::jis0212::forward(move _20) -> bb7; // scope 3 at src/codec/japanese.rs:905:9: 905:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:905:9: 905:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_japanese::jis0212::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:905:38: 905:39
        StorageDead(_7);                 // scope 2 at src/codec/japanese.rs:906:5: 906:6
        StorageDead(_5);                 // scope 1 at src/codec/japanese.rs:906:5: 906:6
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:906:5: 906:6
        return;                          // scope 0 at src/codec/japanese.rs:906:6: 906:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:37:10: 37:15>::clone(_1: &GB18030Encoding) -> GB18030Encoding {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:37:10: 37:15
    let mut _0: codec::simpchinese::GB18030Encoding; // return place in scope 0 at src/codec/simpchinese.rs:37:10: 37:15

    bb0: {
        return;                          // scope 0 at src/codec/simpchinese.rs:37:15: 37:15
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:49:1: 54:2>::raw_decoder(_1: &UTF8Encoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:53:20: 53:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_8.rs:53:30: 53:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_8.rs:53:48: 53:66
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_8.rs:53:48: 53:66

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:53:48: 53:66
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:53:48: 53:66
        _3 = UTF8Decoder::new() -> bb1;  // scope 0 at src/codec/utf_8.rs:53:48: 53:66
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:53:48: 53:64
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::utf_8::UTF8Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:53:48: 53:66
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:53:65: 53:66
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:53:48: 53:66
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:53:67: 53:68
        return;                          // scope 0 at src/codec/utf_8.rs:53:68: 53:68
    }
}

fn japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::is_ascii_compatible(_1: &ISO2022JPEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:800:28: 800:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:800:38: 800:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/japanese.rs:800:45: 800:49
        return;                          // scope 0 at src/codec/japanese.rs:800:51: 800:51
    }
}

fn hz::internal::map_two_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/simpchinese.rs:567:35: 567:39
    debug trail => _2;                   // in scope 0 at src/codec/simpchinese.rs:567:45: 567:50
    let mut _0: u32;                     // return place in scope 0 at src/codec/simpchinese.rs:567:59: 567:62
    let _3: u16;                         // in scope 0 at src/codec/simpchinese.rs:570:13: 570:17
    let mut _4: u8;                      // in scope 0 at src/codec/simpchinese.rs:570:20: 570:24
    let mut _6: u8;                      // in scope 0 at src/codec/simpchinese.rs:571:21: 571:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/simpchinese.rs:572:27: 572:40
    let mut _9: u16;                     // in scope 0 at src/codec/simpchinese.rs:572:28: 572:32
    let mut _10: u16;                    // in scope 0 at src/codec/simpchinese.rs:572:34: 572:39
    let mut _11: bool;                   // in scope 0 at src/codec/simpchinese.rs:573:27: 573:38
    let mut _12: bool;                   // in scope 0 at src/codec/simpchinese.rs:573:27: 573:38
    let mut _13: bool;                   // in scope 0 at src/codec/simpchinese.rs:573:14: 573:25
    let mut _14: bool;                   // in scope 0 at src/codec/simpchinese.rs:573:14: 573:25
    let mut _15: u16;                    // in scope 0 at src/codec/simpchinese.rs:573:43: 573:59
    let mut _16: u16;                    // in scope 0 at src/codec/simpchinese.rs:573:43: 573:53
    let mut _17: u16;                    // in scope 0 at src/codec/simpchinese.rs:573:44: 573:48
    let mut _18: u16;                    // in scope 0 at src/codec/simpchinese.rs:573:62: 573:76
    let mut _19: u16;                    // in scope 0 at src/codec/simpchinese.rs:573:63: 573:68
    let mut _20: u16;                    // in scope 0 at src/codec/simpchinese.rs:576:33: 576:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/simpchinese.rs:570:13: 570:17
        let _5: u16;                     // in scope 1 at src/codec/simpchinese.rs:571:13: 571:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/simpchinese.rs:571:13: 571:18
            let _7: u16;                 // in scope 2 at src/codec/simpchinese.rs:572:13: 572:18
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/simpchinese.rs:572:13: 572:18
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:570:13: 570:17
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:570:20: 570:24
        _4 = _1;                         // scope 0 at src/codec/simpchinese.rs:570:20: 570:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/simpchinese.rs:570:20: 570:31
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:570:30: 570:31
        StorageLive(_5);                 // scope 1 at src/codec/simpchinese.rs:571:13: 571:18
        StorageLive(_6);                 // scope 1 at src/codec/simpchinese.rs:571:21: 571:26
        _6 = _2;                         // scope 1 at src/codec/simpchinese.rs:571:21: 571:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/simpchinese.rs:571:21: 571:33
        StorageDead(_6);                 // scope 1 at src/codec/simpchinese.rs:571:32: 571:33
        StorageLive(_7);                 // scope 2 at src/codec/simpchinese.rs:572:13: 572:18
        StorageLive(_8);                 // scope 2 at src/codec/simpchinese.rs:572:27: 572:40
        StorageLive(_9);                 // scope 2 at src/codec/simpchinese.rs:572:28: 572:32
        _9 = _3;                         // scope 2 at src/codec/simpchinese.rs:572:28: 572:32
        StorageLive(_10);                // scope 2 at src/codec/simpchinese.rs:572:34: 572:39
        _10 = _5;                        // scope 2 at src/codec/simpchinese.rs:572:34: 572:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/simpchinese.rs:572:27: 572:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/simpchinese.rs:572:27: 572:40
        StorageDead(_10);                // scope 2 at src/codec/simpchinese.rs:572:39: 572:40
        StorageDead(_9);                 // scope 2 at src/codec/simpchinese.rs:572:39: 572:40
        _13 = Le(const 32_u16, (_8.0: u16)); // scope 2 at src/codec/simpchinese.rs:573:14: 573:25
        switchInt(move _13) -> [false: bb4, otherwise: bb1]; // scope 2 at src/codec/simpchinese.rs:573:14: 573:25
    }

    bb1: {
        _14 = Le((_8.0: u16), const 127_u16); // scope 2 at src/codec/simpchinese.rs:573:14: 573:25
        switchInt(move _14) -> [false: bb4, otherwise: bb2]; // scope 2 at src/codec/simpchinese.rs:573:14: 573:25
    }

    bb2: {
        _11 = Le(const 33_u16, (_8.1: u16)); // scope 2 at src/codec/simpchinese.rs:573:27: 573:38
        switchInt(move _11) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/simpchinese.rs:573:27: 573:38
    }

    bb3: {
        _12 = Le((_8.1: u16), const 126_u16); // scope 2 at src/codec/simpchinese.rs:573:27: 573:38
        switchInt(move _12) -> [false: bb4, otherwise: bb5]; // scope 2 at src/codec/simpchinese.rs:573:27: 573:38
    }

    bb4: {
        _7 = const u16::MAX;             // scope 2 at src/codec/simpchinese.rs:574:18: 574:24
        goto -> bb6;                     // scope 2 at src/codec/simpchinese.rs:574:18: 574:24
    }

    bb5: {
        StorageLive(_15);                // scope 2 at src/codec/simpchinese.rs:573:43: 573:59
        StorageLive(_16);                // scope 2 at src/codec/simpchinese.rs:573:43: 573:53
        StorageLive(_17);                // scope 2 at src/codec/simpchinese.rs:573:44: 573:48
        _17 = _3;                        // scope 2 at src/codec/simpchinese.rs:573:44: 573:48
        _16 = Sub(move _17, const 1_u16); // scope 2 at src/codec/simpchinese.rs:573:43: 573:53
        StorageDead(_17);                // scope 2 at src/codec/simpchinese.rs:573:52: 573:53
        _15 = Mul(move _16, const 190_u16); // scope 2 at src/codec/simpchinese.rs:573:43: 573:59
        StorageDead(_16);                // scope 2 at src/codec/simpchinese.rs:573:58: 573:59
        StorageLive(_18);                // scope 2 at src/codec/simpchinese.rs:573:62: 573:76
        StorageLive(_19);                // scope 2 at src/codec/simpchinese.rs:573:63: 573:68
        _19 = _5;                        // scope 2 at src/codec/simpchinese.rs:573:63: 573:68
        _18 = Add(move _19, const 63_u16); // scope 2 at src/codec/simpchinese.rs:573:62: 573:76
        StorageDead(_19);                // scope 2 at src/codec/simpchinese.rs:573:75: 573:76
        _7 = Add(move _15, move _18);    // scope 2 at src/codec/simpchinese.rs:573:43: 573:76
        StorageDead(_18);                // scope 2 at src/codec/simpchinese.rs:573:75: 573:76
        StorageDead(_15);                // scope 2 at src/codec/simpchinese.rs:573:75: 573:76
        goto -> bb6;                     // scope 2 at src/codec/simpchinese.rs:573:75: 573:76
    }

    bb6: {
        StorageDead(_8);                 // scope 2 at src/codec/simpchinese.rs:575:10: 575:11
        StorageLive(_20);                // scope 3 at src/codec/simpchinese.rs:576:33: 576:38
        _20 = _7;                        // scope 3 at src/codec/simpchinese.rs:576:33: 576:38
        _0 = index_simpchinese::gb18030::forward(move _20) -> bb7; // scope 3 at src/codec/simpchinese.rs:576:9: 576:39
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:576:9: 576:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_simpchinese::gb18030::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 3 at src/codec/simpchinese.rs:576:38: 576:39
        StorageDead(_7);                 // scope 2 at src/codec/simpchinese.rs:577:5: 577:6
        StorageDead(_5);                 // scope 1 at src/codec/simpchinese.rs:577:5: 577:6
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:577:5: 577:6
        return;                          // scope 0 at src/codec/simpchinese.rs:577:6: 577:6
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:85:1: 94:2>::from_self(_1: &UTF16LEEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:86:18: 86:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_16.rs:86:28: 86:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:86:46: 86:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:86:46: 86:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:86:46: 86:67
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:86:46: 86:67
        _3 = UTF16LEEncoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:86:46: 86:67
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:86:46: 86:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::utf_16::UTF16LEEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:86:46: 86:67
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:86:66: 86:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:86:46: 86:67
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:86:68: 86:69
        return;                          // scope 0 at src/codec/utf_16.rs:86:69: 86:69
    }
}

fn hz::raw_feed(_1: hz::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (hz::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::simpchinese::hz::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _17: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _18: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _19: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _20: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _21: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _22: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _24: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _25: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _26: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _27: (std::option::Option<encoding_types::CodecError>, codec::simpchinese::hz::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _28: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _29: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _30: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _31: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _32: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _33: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _34: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _35: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _36: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _37: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _39: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _40: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _41: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _42: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _43: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _44: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _45: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _46: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _48: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _49: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _50: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _51: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _52: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _53: (std::option::Option<encoding_types::CodecError>, codec::simpchinese::hz::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _54: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _55: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _56: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _57: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _58: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _59: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _60: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _61: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _62: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _63: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _65: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _66: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _67: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _68: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _69: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _70: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _71: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::simpchinese::hz::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _23: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _38: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _47: codec::simpchinese::hz::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 5 {
                    debug err => _38;    // in scope 5 at src/util.rs:252:27: 252:30
                }
                scope 6 {
                    debug st_ => _47;    // in scope 6 at src/util.rs:256:25: 256:28
                    let _64: encoding_types::CodecError; // in scope 6 at src/util.rs:267:31: 267:34
                    scope 7 {
                        debug err => _64; // in scope 7 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug lead => _23;       // in scope 4 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<hz::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::simpchinese::hz::State, T> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb6, 2_isize: bb8, 3_isize: bb10, 4_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_23);                // scope 2 at src/util.rs:245:36: 245:40
        _23 = ((_1 as B2).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_24);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_25);                // scope 4 at src/util.rs:245:62: 245:70
        _25 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _24 = &mut (*_25);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_26);                // scope 4 at src/util.rs:245:75: 245:79
        _26 = _23;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = hz::transient::B2::<T>(move _24, move _26) -> [return: bb12, unwind: bb42]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>, u8) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B2::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb13;                    // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageLive(_17);                // scope 2 at src/util.rs:242:64: 242:72
        StorageLive(_18);                // scope 2 at src/util.rs:242:64: 242:72
        _18 = &mut _9;                   // scope 2 at src/util.rs:242:64: 242:72
        _17 = &mut (*_18);               // scope 2 at src/util.rs:242:64: 242:72
        _15 = hz::start::B0::<T>(move _17) -> [return: bb7, unwind: bb42]; // scope 2 at src/util.rs:242:58: 242:86
                                         // mir::Constant
                                         // + span: src/util.rs:242:51: 242:63
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::start::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_18);                // scope 2 at src/util.rs:242:85: 242:86
        StorageDead(_17);                // scope 2 at src/util.rs:242:85: 242:86
        goto -> bb13;                    // scope 2 at src/util.rs:242:85: 242:86
    }

    bb8: {
        StorageLive(_19);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_20);                // scope 2 at src/util.rs:245:62: 245:70
        _20 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _19 = &mut (*_20);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = hz::transient::A1::<T>(move _19) -> [return: bb9, unwind: bb42]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_20);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_19);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb10: {
        StorageLive(_21);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_22);                // scope 2 at src/util.rs:245:62: 245:70
        _22 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _21 = &mut (*_22);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = hz::transient::B1::<T>(move _21) -> [return: bb11, unwind: bb42]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_22);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_21);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb12: {
        StorageDead(_26);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_25);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_24);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_23);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb13;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb13: {
        StorageLive(_27);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_28);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_29);                // scope 3 at src/util.rs:248:24: 248:31
        _29 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _28 = Option::<encoding_types::CodecError>::take(move _29) -> [return: bb14, unwind: bb42]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_29);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_30);                // scope 3 at src/util.rs:248:40: 248:43
        _30 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_27.0: std::option::Option<encoding_types::CodecError>) = move _28; // scope 3 at src/util.rs:248:23: 248:44
        (_27.1: codec::simpchinese::hz::State) = move _30; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_30);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_28);                // scope 3 at src/util.rs:248:43: 248:44
        _32 = discriminant((_27.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _32) -> [0_isize: bb15, 1_isize: bb16, otherwise: bb17]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb15: {
        _31 = discriminant((_27.1: codec::simpchinese::hz::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _31) -> [0_isize: bb18, 1_isize: bb18, otherwise: bb19]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb16: {
        StorageLive(_38);                // scope 3 at src/util.rs:252:27: 252:30
        _38 = move (((_27.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_39);                // scope 5 at src/util.rs:252:49: 252:52
        _39 = _15;                       // scope 5 at src/util.rs:252:49: 252:52
        StorageLive(_40);                // scope 5 at src/util.rs:252:54: 252:63
        _40 = _14;                       // scope 5 at src/util.rs:252:54: 252:63
        StorageLive(_41);                // scope 5 at src/util.rs:252:65: 252:74
        StorageLive(_42);                // scope 5 at src/util.rs:252:70: 252:73
        _42 = move _38;                  // scope 5 at src/util.rs:252:70: 252:73
        ((_41 as Some).0: encoding_types::CodecError) = move _42; // scope 5 at src/util.rs:252:65: 252:74
        discriminant(_41) = 1;           // scope 5 at src/util.rs:252:65: 252:74
        StorageDead(_42);                // scope 5 at src/util.rs:252:73: 252:74
        (_0.0: codec::simpchinese::hz::State) = move _39; // scope 5 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _40;        // scope 5 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _41; // scope 5 at src/util.rs:252:48: 252:75
        StorageDead(_41);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_40);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_39);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_38);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb38;                    // scope 3 at no-location
    }

    bb17: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb18: {
        StorageLive(_33);                // scope 3 at src/util.rs:249:70: 249:73
        _33 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _33;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_33);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_34);                // scope 3 at src/util.rs:249:87: 249:94
        _34 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _34;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_34);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_27);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb20;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb19: {
        StorageLive(_35);                // scope 3 at src/util.rs:251:44: 251:47
        _35 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_36);                // scope 3 at src/util.rs:251:49: 251:58
        _36 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_37);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_37) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::simpchinese::hz::State) = move _35; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _36;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _37; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_37);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_36);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_35);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb38;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb20: {
        StorageLive(_43);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_44);                // scope 3 at src/util.rs:255:23: 255:30
        _44 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_45);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_46);                // scope 3 at src/util.rs:255:33: 255:40
        _46 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _45 = core::slice::<impl [u8]>::len(move _46) -> [return: bb21, unwind: bb42]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb21: {
        StorageDead(_46);                // scope 3 at src/util.rs:255:45: 255:46
        _43 = Lt(move _44, move _45);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_45);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_44);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _43) -> [false: bb35, otherwise: bb22]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb22: {
        StorageLive(_47);                // scope 3 at src/util.rs:256:25: 256:28
        _48 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _48) -> [0_isize: bb24, 1_isize: bb26, otherwise: bb23]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb23: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb42; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb24: {
        StorageLive(_49);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_50);                // scope 3 at src/util.rs:257:49: 257:57
        _50 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _49 = &mut (*_50);               // scope 3 at src/util.rs:257:49: 257:57
        _47 = hz::start::A0::<T>(move _49) -> [return: bb25, unwind: bb42]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::start::A0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb25: {
        StorageDead(_50);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_49);                // scope 3 at src/util.rs:257:57: 257:58
        goto -> bb28;                    // scope 3 at src/util.rs:257:57: 257:58
    }

    bb26: {
        StorageLive(_51);                // scope 3 at src/util.rs:259:68: 259:76
        StorageLive(_52);                // scope 3 at src/util.rs:259:68: 259:76
        _52 = &mut _9;                   // scope 3 at src/util.rs:259:68: 259:76
        _51 = &mut (*_52);               // scope 3 at src/util.rs:259:68: 259:76
        _47 = hz::start::B0::<T>(move _51) -> [return: bb27, unwind: bb42]; // scope 3 at src/util.rs:259:62: 259:90
                                         // mir::Constant
                                         // + span: src/util.rs:259:55: 259:67
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::start::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb27: {
        StorageDead(_52);                // scope 3 at src/util.rs:259:89: 259:90
        StorageDead(_51);                // scope 3 at src/util.rs:259:89: 259:90
        goto -> bb28;                    // scope 3 at src/util.rs:259:89: 259:90
    }

    bb28: {
        StorageLive(_53);                // scope 6 at src/util.rs:263:27: 263:48
        StorageLive(_54);                // scope 6 at src/util.rs:263:28: 263:42
        StorageLive(_55);                // scope 6 at src/util.rs:263:28: 263:35
        _55 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 6 at src/util.rs:263:28: 263:35
        _54 = Option::<encoding_types::CodecError>::take(move _55) -> [return: bb29, unwind: bb42]; // scope 6 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb29: {
        StorageDead(_55);                // scope 6 at src/util.rs:263:41: 263:42
        StorageLive(_56);                // scope 6 at src/util.rs:263:44: 263:47
        _56 = _47;                       // scope 6 at src/util.rs:263:44: 263:47
        (_53.0: std::option::Option<encoding_types::CodecError>) = move _54; // scope 6 at src/util.rs:263:27: 263:48
        (_53.1: codec::simpchinese::hz::State) = move _56; // scope 6 at src/util.rs:263:27: 263:48
        StorageDead(_56);                // scope 6 at src/util.rs:263:47: 263:48
        StorageDead(_54);                // scope 6 at src/util.rs:263:47: 263:48
        _58 = discriminant((_53.0: std::option::Option<encoding_types::CodecError>)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _58) -> [0_isize: bb30, 1_isize: bb31, otherwise: bb32]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb30: {
        _57 = discriminant((_53.1: codec::simpchinese::hz::State)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _57) -> [0_isize: bb33, 1_isize: bb33, otherwise: bb34]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb31: {
        StorageLive(_64);                // scope 6 at src/util.rs:267:31: 267:34
        _64 = move (((_53.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 6 at src/util.rs:267:31: 267:34
        StorageLive(_65);                // scope 7 at src/util.rs:267:53: 267:56
        _65 = _47;                       // scope 7 at src/util.rs:267:53: 267:56
        StorageLive(_66);                // scope 7 at src/util.rs:267:58: 267:67
        _66 = _14;                       // scope 7 at src/util.rs:267:58: 267:67
        StorageLive(_67);                // scope 7 at src/util.rs:267:69: 267:78
        StorageLive(_68);                // scope 7 at src/util.rs:267:74: 267:77
        _68 = move _64;                  // scope 7 at src/util.rs:267:74: 267:77
        ((_67 as Some).0: encoding_types::CodecError) = move _68; // scope 7 at src/util.rs:267:69: 267:78
        discriminant(_67) = 1;           // scope 7 at src/util.rs:267:69: 267:78
        StorageDead(_68);                // scope 7 at src/util.rs:267:77: 267:78
        (_0.0: codec::simpchinese::hz::State) = move _65; // scope 7 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _66;        // scope 7 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _67; // scope 7 at src/util.rs:267:52: 267:79
        StorageDead(_67);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_66);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_65);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_64);                // scope 6 at src/util.rs:267:81: 267:82
        goto -> bb37;                    // scope 6 at no-location
    }

    bb32: {
        unreachable;                     // scope 6 at src/util.rs:263:27: 263:48
    }

    bb33: {
        StorageLive(_59);                // scope 6 at src/util.rs:264:74: 264:77
        _59 = _47;                       // scope 6 at src/util.rs:264:74: 264:77
        _1 = move _59;                   // scope 6 at src/util.rs:264:69: 264:77
        StorageDead(_59);                // scope 6 at src/util.rs:264:76: 264:77
        StorageLive(_60);                // scope 6 at src/util.rs:264:91: 264:98
        _60 = (_9.1: usize);             // scope 6 at src/util.rs:264:91: 264:98
        _14 = move _60;                  // scope 6 at src/util.rs:264:79: 264:98
        StorageDead(_60);                // scope 6 at src/util.rs:264:97: 264:98
        StorageDead(_47);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_53);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_43);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb20;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb34: {
        StorageLive(_61);                // scope 6 at src/util.rs:266:48: 266:51
        _61 = _47;                       // scope 6 at src/util.rs:266:48: 266:51
        StorageLive(_62);                // scope 6 at src/util.rs:266:53: 266:62
        _62 = _14;                       // scope 6 at src/util.rs:266:53: 266:62
        StorageLive(_63);                // scope 6 at src/util.rs:266:64: 266:68
        discriminant(_63) = 0;           // scope 6 at src/util.rs:266:64: 266:68
        (_0.0: codec::simpchinese::hz::State) = move _61; // scope 6 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _62;        // scope 6 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _63; // scope 6 at src/util.rs:266:47: 266:69
        StorageDead(_63);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_62);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_61);                // scope 6 at src/util.rs:266:68: 266:69
        goto -> bb37;                    // scope 6 at src/util.rs:266:40: 266:69
    }

    bb35: {
        StorageDead(_43);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_69);                // scope 3 at src/util.rs:271:18: 271:20
        _69 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_70);                // scope 3 at src/util.rs:271:22: 271:31
        _70 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_71);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_71) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::simpchinese::hz::State) = move _69; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _70;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _71; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_71);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_70);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_69);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb36;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb36: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb41;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb37: {
        StorageDead(_47);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_53);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_43);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb39;                    // scope 3 at no-location
    }

    bb38: {
        StorageDead(_27);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb39;                    // scope 3 at no-location
    }

    bb39: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb40;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb40: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb41;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb41: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb42 (cleanup): {
        drop(_9) -> bb43;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb43 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:37:10: 37:15>::clone(_1: &UTF16BEEncoding) -> UTF16BEEncoding {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:37:10: 37:15
    let mut _0: codec::utf_16::UTF16BEEncoding; // return place in scope 0 at src/codec/utf_16.rs:37:10: 37:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_16.rs:37:15: 37:15
    }
}

fn korean::<impl at src/codec/korean.rs:42:1: 70:2>::raw_finish(_1: &mut Windows949Encoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:67:19: 67:28
    debug _output => _2;                 // in scope 0 at src/codec/korean.rs:67:30: 67:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/korean.rs:67:59: 67:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/korean.rs:68:9: 68:13
        return;                          // scope 0 at src/codec/korean.rs:69:6: 69:6
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:90:1: 105:2>::from_self(_1: &BigFive2003HKSCS2008Decoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:91:18: 91:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/tradchinese.rs:91:28: 91:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/tradchinese.rs:91:46: 91:80
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/tradchinese.rs:91:46: 91:80

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:91:46: 91:80
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:91:46: 91:80
        _3 = BigFive2003HKSCS2008Decoder::new() -> bb1; // scope 0 at src/codec/tradchinese.rs:91:46: 91:80
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:91:46: 91:78
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::tradchinese::BigFive2003HKSCS2008Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:91:46: 91:80
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:91:79: 91:80
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:91:46: 91:80
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:91:81: 91:82
        return;                          // scope 0 at src/codec/tradchinese.rs:91:82: 91:82
    }
}

fn bigfive2003::<impl at src/util.rs:157:22: 157:31>::ne(_1: &bigfive2003::State, _2: &bigfive2003::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::tradchinese::bigfive2003::State, &codec::tradchinese::bigfive2003::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _26: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _27: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _18: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _19: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _18;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _19;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _20;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _21;  // in scope 3 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb10, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::tradchinese::bigfive2003::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::tradchinese::bigfive2003::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _17 = discriminant((*(_13.0: &codec::tradchinese::bigfive2003::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [1_isize: bb3, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::tradchinese::bigfive2003::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb4, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        StorageLive(_18);                // scope 2 at src/util.rs:164:25: 164:27
        _18 = &(((*(_13.0: &codec::tradchinese::bigfive2003::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_19);                // scope 2 at src/util.rs:164:32: 164:35
        _19 = &(((*(_13.0: &codec::tradchinese::bigfive2003::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.1: &codec::tradchinese::bigfive2003::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.1: &codec::tradchinese::bigfive2003::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _18;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        _22 = <() as PartialEq>::ne(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        _0 = const true;                 // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb6: {
        StorageLive(_25);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_26);                // scope 3 at src/util.rs:164:32: 164:35
        _26 = (*_19);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        _27 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        _25 = Ne(move _26, move _27);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_26);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _25;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb7: {
        StorageDead(_25);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_22);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_19);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_18);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:30: 157:31
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _22) -> [false: bb6, otherwise: bb5]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn japanese::<impl at src/codec/japanese.rs:452:1: 457:2>::raw_decoder(_1: &Windows31JEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:456:20: 456:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:456:30: 456:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:456:48: 456:72
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:456:48: 456:72

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:456:48: 456:72
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:456:48: 456:72
        _3 = Windows31JDecoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:456:48: 456:72
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:456:48: 456:70
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::japanese::Windows31JDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:456:48: 456:72
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:456:71: 456:72
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:456:48: 456:72
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:456:73: 456:74
        return;                          // scope 0 at src/codec/japanese.rs:456:74: 456:74
    }
}

fn codec::whatwg::<impl at src/codec/whatwg.rs:12:10: 12:15>::clone(_1: &EncoderOnlyUTF8Encoding) -> EncoderOnlyUTF8Encoding {
    debug self => _1;                    // in scope 0 at src/codec/whatwg.rs:12:10: 12:15
    let mut _0: codec::whatwg::EncoderOnlyUTF8Encoding; // return place in scope 0 at src/codec/whatwg.rs:12:10: 12:15

    bb0: {
        return;                          // scope 0 at src/codec/whatwg.rs:12:15: 12:15
    }
}

const WINDOWS_1252: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:61:68: 61:82
    let _5: &str;                        // in scope 0 at src/all.rs:61:68: 61:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1252::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1252, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1269 ~ encoding[5d2c]::all::WINDOWS_1252), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1252: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:61:68: 61:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:61:68: 61:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1252";       // scope 0 at src/all.rs:61:68: 61:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:61:68: 61:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:61:68: 61:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1252::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1252::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1252::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1252::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1252"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:61:68: 61:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:40:1: 45:2>::raw_decoder(_1: &GB18030Encoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:44:20: 44:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:44:30: 44:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:44:48: 44:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:44:48: 44:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:44:48: 44:69
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:44:48: 44:69
        _3 = GB18030Decoder::new() -> bb1; // scope 0 at src/codec/simpchinese.rs:44:48: 44:69
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:44:48: 44:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::simpchinese::GB18030Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:44:48: 44:69
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:44:68: 44:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:44:48: 44:69
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:44:70: 44:71
        return;                          // scope 0 at src/codec/simpchinese.rs:44:71: 44:71
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:46:10: 46:15>::clone(_1: &UTF8Encoding) -> UTF8Encoding {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:46:10: 46:15
    let mut _0: codec::utf_8::UTF8Encoding; // return place in scope 0 at src/codec/utf_8.rs:46:10: 46:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_8.rs:46:15: 46:15
    }
}

fn iso2022jp::transient::Trail0212(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>, _2: u8) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let _9: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:992:13: 995:14
    let mut _10: u32;                    // in scope 0 at src/codec/japanese.rs:992:19: 992:46
    let mut _11: u8;                     // in scope 0 at src/codec/japanese.rs:992:38: 992:42
    let mut _12: u8;                     // in scope 0 at src/codec/japanese.rs:992:44: 992:45
    let mut _13: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:993:27: 993:30
    let mut _15: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:994:23: 994:26
    let mut _16: u32;                    // in scope 0 at src/codec/japanese.rs:994:32: 994:41
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:996:22: 996:25
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _8: u8;                      // in scope 1 at src/codec/japanese.rs:991:14: 991:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/japanese.rs:991:14: 991:15
            let _14: u32;                // in scope 2 at src/codec/japanese.rs:994:17: 994:19
            scope 3 {
                debug ch => _14;         // in scope 3 at src/codec/japanese.rs:994:17: 994:19
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:991:14: 991:15
        _8 = _7;                         // scope 1 at src/codec/japanese.rs:991:14: 991:15
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:992:13: 995:14
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:992:19: 992:46
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:992:38: 992:42
        _11 = _2;                        // scope 2 at src/codec/japanese.rs:992:38: 992:42
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:992:44: 992:45
        _12 = _8;                        // scope 2 at src/codec/japanese.rs:992:44: 992:45
        _10 = iso2022jp::internal::map_two_0212_bytes(move _11, move _12) -> bb5; // scope 2 at src/codec/japanese.rs:992:19: 992:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:992:19: 992:37
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::japanese::iso2022jp::internal::map_two_0212_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as Trail0212).1: u8) = move _6; // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 9;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb12;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:992:45: 992:46
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:992:45: 992:46
        switchInt(_10) -> [65535_u32: bb7, otherwise: bb6]; // scope 2 at src/codec/japanese.rs:992:13: 992:46
    }

    bb6: {
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:994:17: 994:19
        _14 = _10;                       // scope 2 at src/codec/japanese.rs:994:17: 994:19
        StorageLive(_15);                // scope 3 at src/codec/japanese.rs:994:23: 994:26
        _15 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:994:23: 994:26
        StorageLive(_16);                // scope 3 at src/codec/japanese.rs:994:32: 994:41
        _16 = _14;                       // scope 3 at src/codec/japanese.rs:994:32: 994:34
        _9 = StatefulDecoderHelper::<iso2022jp::State, T>::emit(move _15, move _16) -> bb9; // scope 3 at src/codec/japanese.rs:994:23: 994:42
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:994:27: 994:31
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, u32) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:993:27: 993:30
        _13 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:993:27: 993:30
        _9 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _13, const "invalid sequence") -> bb8; // scope 2 at src/codec/japanese.rs:993:27: 993:54
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:993:31: 993:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:993:35: 993:53
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb8: {
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:993:53: 993:54
        goto -> bb10;                    // scope 2 at src/codec/japanese.rs:993:53: 993:54
    }

    bb9: {
        StorageDead(_16);                // scope 3 at src/codec/japanese.rs:994:41: 994:42
        StorageDead(_15);                // scope 3 at src/codec/japanese.rs:994:41: 994:42
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:994:41: 994:42
        goto -> bb10;                    // scope 2 at src/codec/japanese.rs:994:41: 994:42
    }

    bb10: {
        StorageDead(_10);                // scope 2 at src/util.rs:226:72: 226:73
        StorageDead(_9);                 // scope 2 at src/util.rs:226:72: 226:73
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:996:22: 996:25
        _17 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:996:22: 996:25
        _0 = iso2022jp::transient::Lead0212::<T>(move _17) -> bb11; // scope 2 at src/codec/japanese.rs:996:13: 996:26
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:996:13: 996:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Lead0212::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:996:25: 996:26
        StorageDead(_8);                 // scope 1 at src/util.rs:226:77: 226:78
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb12;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb12: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn windows949::State::S1(_1: (), _2: u8) -> windows949::State {
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn windows949::State::S1(_1: (), _2: u8) -> windows949::State {
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:283:10: 283:15>::clone(_1: &UTF16BEDecoder) -> UTF16BEDecoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:283:10: 283:15
    let mut _0: codec::utf_16::UTF16BEDecoder; // return place in scope 0 at src/codec/utf_16.rs:283:10: 283:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/utf_16.rs:283:10: 283:15
        return;                          // scope 0 at src/codec/utf_16.rs:283:15: 283:15
    }
}

fn hz::State::B2(_1: (), _2: u8) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as B2).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as B2).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 4;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn hz::State::B2(_1: (), _2: u8) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as B2).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as B2).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 4;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:64:1: 78:2>::raw_finish(_1: &mut UTF8Encoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:75:19: 75:28
    debug _output => _2;                 // in scope 0 at src/codec/utf_8.rs:75:30: 75:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_8.rs:75:59: 75:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/utf_8.rs:76:9: 76:13
        return;                          // scope 0 at src/codec/utf_8.rs:77:6: 77:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:858:1: 862:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:859:21: 859:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:860:9: 860:62
    let mut _2: std::boxed::Box<codec::japanese::ISO2022JPDecoder>; // in scope 0 at src/codec/japanese.rs:860:9: 860:62
    let mut _3: codec::japanese::ISO2022JPDecoder; // in scope 0 at src/codec/japanese.rs:860:18: 860:61
    let mut _4: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:860:41: 860:59

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/japanese.rs:860:9: 860:62
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:860:9: 860:62
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:860:18: 860:61
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:860:41: 860:59
        _4 = <iso2022jp::State as Default>::default() -> bb1; // scope 0 at src/codec/japanese.rs:860:41: 860:59
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:860:41: 860:57
                                         // + literal: Const { ty: fn() -> codec::japanese::iso2022jp::State {<codec::japanese::iso2022jp::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::japanese::iso2022jp::State) = move _4; // scope 0 at src/codec/japanese.rs:860:18: 860:61
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:860:60: 860:61
        _2 = Box::<ISO2022JPDecoder>::new(move _3) -> bb2; // scope 0 at src/codec/japanese.rs:860:9: 860:62
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:860:9: 860:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::japanese::ISO2022JPDecoder) -> std::boxed::Box<codec::japanese::ISO2022JPDecoder> {std::boxed::Box::<codec::japanese::ISO2022JPDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:860:9: 860:62
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:860:61: 860:62
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:860:61: 860:62
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:860:9: 860:62
        StorageDead(_1);                 // scope 0 at src/codec/japanese.rs:861:5: 861:6
        return;                          // scope 0 at src/codec/japanese.rs:861:6: 861:6
    }
}

const MAC_CYRILLIC: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:69:41: 69:63
    let mut _4: &str;                    // in scope 0 at src/all.rs:69:46: 69:62
    let _5: &str;                        // in scope 0 at src/all.rs:69:46: 69:62
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const MAC_CYRILLIC::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_CYRILLIC, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1276 ~ encoding[5d2c]::all::MAC_CYRILLIC), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in MAC_CYRILLIC: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:69:41: 69:63
    let mut _3: &str;                    // in scope 0 at src/all.rs:69:46: 69:62
    let mut _4: &str;                    // in scope 0 at src/all.rs:69:46: 69:62
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "x-mac-cyrillic";     // scope 0 at src/all.rs:69:46: 69:62
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/all.rs:69:46: 69:62
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:69:46: 69:62
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:69:41: 69:63
        discriminant(_2) = 1;            // scope 0 at src/all.rs:69:41: 69:63
        _5 = index_singlebyte::x_mac_cyrillic::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::x_mac_cyrillic::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::x_mac_cyrillic::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::x_mac_cyrillic::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "mac-cyrillic"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 45, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:69:18: 69:32
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 45, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:104:1: 113:2>::from_self(_1: &UTF16BEEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:105:18: 105:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_16.rs:105:28: 105:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:105:46: 105:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:105:46: 105:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:105:46: 105:67
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:105:46: 105:67
        _3 = UTF16BEEncoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:105:46: 105:67
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:105:46: 105:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::utf_16::UTF16BEEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:105:46: 105:67
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:105:66: 105:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:105:46: 105:67
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:105:68: 105:69
        return;                          // scope 0 at src/codec/utf_16.rs:105:69: 105:69
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:465:1: 470:2>::whatwg_name(_1: &HZEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:467:20: 467:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/simpchinese.rs:467:30: 467:50

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/simpchinese.rs:467:53: 467:57
        return;                          // scope 0 at src/codec/simpchinese.rs:467:59: 467:59
    }
}

fn iso2022jp::State::Trail0208(_1: (), _2: u8) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as Trail0208).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as Trail0208).1: u8) = move _2; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 8;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn iso2022jp::State::Trail0208(_1: (), _2: u8) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as Trail0208).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as Trail0208).1: u8) = move _2; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 8;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn korean::<impl at src/codec/korean.rs:84:1: 99:2>::raw_finish(_1: &mut Windows949Decoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:94:19: 94:28
    debug output => _2;                  // in scope 0 at src/codec/korean.rs:94:30: 94:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/korean.rs:95:18: 95:21
    let _3: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:95:14: 95:16
    let mut _4: (codec::korean::windows949::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/korean.rs:95:25: 95:69
    let mut _5: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:95:48: 95:55
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/korean.rs:95:57: 95:63
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/korean.rs:95:57: 95:63
    let mut _8: &();                     // in scope 0 at src/codec/korean.rs:95:65: 95:68
    let _9: &();                         // in scope 0 at src/codec/korean.rs:95:65: 95:68
    let mut _10: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:96:19: 96:21
    let mut _11: &();                    // in scope 0 at src/codec/korean.rs:95:65: 95:68
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/korean.rs:95:14: 95:16
        debug err => _0;                 // in scope 1 at src/codec/korean.rs:95:18: 95:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/korean.rs:95:25: 95:69
        StorageLive(_5);                 // scope 0 at src/codec/korean.rs:95:48: 95:55
        _5 = ((*_1).0: codec::korean::windows949::State); // scope 0 at src/codec/korean.rs:95:48: 95:55
        StorageLive(_6);                 // scope 0 at src/codec/korean.rs:95:57: 95:63
        StorageLive(_7);                 // scope 0 at src/codec/korean.rs:95:57: 95:63
        _7 = &mut (*_2);                 // scope 0 at src/codec/korean.rs:95:57: 95:63
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:95:57: 95:63
        StorageDead(_7);                 // scope 0 at src/codec/korean.rs:95:62: 95:63
        StorageLive(_8);                 // scope 0 at src/codec/korean.rs:95:65: 95:68
        StorageLive(_9);                 // scope 0 at src/codec/korean.rs:95:65: 95:68
        _11 = const <Windows949Decoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/korean.rs:95:65: 95:68
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<Windows949Decoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:95:65: 95:68
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:362 ~ encoding[5d2c]::codec::korean::{impl#4}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/korean.rs:95:65: 95:68
        _8 = _9;                         // scope 0 at src/codec/korean.rs:95:65: 95:68
        _4 = windows949::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/korean.rs:95:25: 95:69
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:95:25: 95:47
                                         // + literal: Const { ty: for<'r, 's> fn(codec::korean::windows949::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::korean::windows949::State, std::option::Option<encoding_types::CodecError>) {codec::korean::windows949::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/korean.rs:95:68: 95:69
        StorageDead(_6);                 // scope 0 at src/codec/korean.rs:95:68: 95:69
        StorageDead(_5);                 // scope 0 at src/codec/korean.rs:95:68: 95:69
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:95:14: 95:16
        _3 = (_4.0: codec::korean::windows949::State); // scope 0 at src/codec/korean.rs:95:14: 95:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/korean.rs:95:18: 95:21
        StorageDead(_9);                 // scope 0 at src/codec/korean.rs:95:69: 95:70
        StorageDead(_4);                 // scope 0 at src/codec/korean.rs:95:69: 95:70
        StorageLive(_10);                // scope 1 at src/codec/korean.rs:96:19: 96:21
        _10 = _3;                        // scope 1 at src/codec/korean.rs:96:19: 96:21
        ((*_1).0: codec::korean::windows949::State) = move _10; // scope 1 at src/codec/korean.rs:96:9: 96:21
        StorageDead(_10);                // scope 1 at src/codec/korean.rs:96:20: 96:21
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:98:5: 98:6
        return;                          // scope 0 at src/codec/korean.rs:98:6: 98:6
    }
}

promoted[0] in korean::<impl at src/codec/korean.rs:84:1: 99:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/korean.rs:95:65: 95:68
    let mut _1: ();                      // in scope 0 at src/codec/korean.rs:95:66: 95:68

    bb0: {
        nop;                             // scope 0 at src/codec/korean.rs:95:66: 95:68
        _0 = &_1;                        // scope 0 at src/codec/korean.rs:95:65: 95:68
        return;                          // scope 0 at src/codec/korean.rs:95:65: 95:68
    }
}

fn iso_8859_1::backward(_1: u32) -> u8 {
    debug code => _1;                    // in scope 0 at src/codec/singlebyte.rs:116:31: 116:35
    let mut _0: u8;                      // return place in scope 0 at src/codec/singlebyte.rs:116:45: 116:47
    let mut _2: u32;                     // in scope 0 at src/codec/singlebyte.rs:116:53: 116:67
    let mut _3: u32;                     // in scope 0 at src/codec/singlebyte.rs:116:54: 116:58
    let mut _4: u32;                     // in scope 0 at src/codec/singlebyte.rs:116:61: 116:66
    let mut _5: u32;                     // in scope 0 at src/codec/singlebyte.rs:116:77: 116:81

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:116:53: 116:67
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:116:54: 116:58
        _3 = _1;                         // scope 0 at src/codec/singlebyte.rs:116:54: 116:58
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:116:61: 116:66
        _4 = const 4294967168_u32;       // scope 0 at src/codec/singlebyte.rs:116:61: 116:66
        _2 = BitAnd(move _3, move _4);   // scope 0 at src/codec/singlebyte.rs:116:53: 116:67
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:116:66: 116:67
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:116:66: 116:67
        switchInt(move _2) -> [128_u32: bb1, otherwise: bb2]; // scope 0 at src/codec/singlebyte.rs:116:53: 116:75
    }

    bb1: {
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:116:53: 116:75
        StorageLive(_5);                 // scope 0 at src/codec/singlebyte.rs:116:77: 116:81
        _5 = _1;                         // scope 0 at src/codec/singlebyte.rs:116:77: 116:81
        _0 = move _5 as u8 (Misc);       // scope 0 at src/codec/singlebyte.rs:116:77: 116:87
        StorageDead(_5);                 // scope 0 at src/codec/singlebyte.rs:116:86: 116:87
        goto -> bb3;                     // scope 0 at src/codec/singlebyte.rs:116:50: 116:97
    }

    bb2: {
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:116:53: 116:75
        _0 = const 0_u8;                 // scope 0 at src/codec/singlebyte.rs:116:95: 116:96
        goto -> bb3;                     // scope 0 at src/codec/singlebyte.rs:116:50: 116:97
    }

    bb3: {
        return;                          // scope 0 at src/codec/singlebyte.rs:116:99: 116:99
    }
}

fn japanese::<impl at src/codec/japanese.rs:467:1: 506:2>::raw_finish(_1: &mut Windows31JEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:503:19: 503:28
    debug _output => _2;                 // in scope 0 at src/codec/japanese.rs:503:30: 503:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/japanese.rs:503:59: 503:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/japanese.rs:504:9: 504:13
        return;                          // scope 0 at src/codec/japanese.rs:505:6: 505:6
    }
}

fn codec::error::<impl at src/codec/error.rs:11:10: 11:15>::clone(_1: &ErrorEncoding) -> ErrorEncoding {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:11:10: 11:15
    let mut _0: codec::error::ErrorEncoding; // return place in scope 0 at src/codec/error.rs:11:10: 11:15

    bb0: {
        return;                          // scope 0 at src/codec/error.rs:11:15: 11:15
    }
}

fn windows949::start::S0(_1: &mut StatefulDecoderHelper<windows949::State, T>) -> windows949::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/korean.rs:120:18: 120:29
    let mut _7: bool;                    // in scope 0 at src/codec/korean.rs:120:18: 120:29
    let mut _8: bool;                    // in scope 0 at src/codec/korean.rs:119:18: 119:29
    let mut _9: bool;                    // in scope 0 at src/codec/korean.rs:119:18: 119:29
    let mut _11: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/codec/korean.rs:119:33: 119:36
    let mut _12: u32;                    // in scope 0 at src/codec/korean.rs:119:42: 119:50
    let mut _13: u8;                     // in scope 0 at src/codec/korean.rs:119:42: 119:43
    let mut _15: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/codec/korean.rs:120:36: 120:39
    let mut _16: u8;                     // in scope 0 at src/codec/korean.rs:120:41: 120:42
    let mut _17: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/codec/korean.rs:121:19: 121:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _10: u8;                     // in scope 1 at src/codec/korean.rs:119:14: 119:29
        let _14: u8;                     // in scope 1 at src/codec/korean.rs:120:14: 120:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/korean.rs:119:14: 119:29
        }
        scope 3 {
            debug b => _14;              // in scope 3 at src/codec/korean.rs:120:14: 120:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<windows949::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        _8 = Le(const 0_u8, _5);         // scope 1 at src/codec/korean.rs:119:18: 119:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/korean.rs:119:18: 119:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb15;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _9 = Le(_5, const 127_u8);       // scope 1 at src/codec/korean.rs:119:18: 119:29
        switchInt(move _9) -> [false: bb6, otherwise: bb9]; // scope 1 at src/codec/korean.rs:119:18: 119:29
    }

    bb6: {
        _6 = Le(const 129_u8, _5);       // scope 1 at src/codec/korean.rs:120:18: 120:29
        switchInt(move _6) -> [false: bb8, otherwise: bb7]; // scope 1 at src/codec/korean.rs:120:18: 120:29
    }

    bb7: {
        _7 = Le(_5, const 254_u8);       // scope 1 at src/codec/korean.rs:120:18: 120:29
        switchInt(move _7) -> [false: bb8, otherwise: bb11]; // scope 1 at src/codec/korean.rs:120:18: 120:29
    }

    bb8: {
        StorageLive(_17);                // scope 1 at src/codec/korean.rs:121:19: 121:22
        _17 = &mut (*_1);                // scope 1 at src/codec/korean.rs:121:19: 121:22
        _0 = StatefulDecoderHelper::<windows949::State, T>::err(move _17, const "invalid sequence") -> bb13; // scope 1 at src/codec/korean.rs:121:19: 121:46
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:121:23: 121:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>, &'static str) -> codec::korean::windows949::State {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:121:27: 121:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb9: {
        StorageLive(_10);                // scope 1 at src/codec/korean.rs:119:14: 119:29
        _10 = _5;                        // scope 1 at src/codec/korean.rs:119:14: 119:29
        StorageLive(_11);                // scope 2 at src/codec/korean.rs:119:33: 119:36
        _11 = &mut (*_1);                // scope 2 at src/codec/korean.rs:119:33: 119:36
        StorageLive(_12);                // scope 2 at src/codec/korean.rs:119:42: 119:50
        StorageLive(_13);                // scope 2 at src/codec/korean.rs:119:42: 119:43
        _13 = _10;                       // scope 2 at src/codec/korean.rs:119:42: 119:43
        _12 = move _13 as u32 (Misc);    // scope 2 at src/codec/korean.rs:119:42: 119:50
        StorageDead(_13);                // scope 2 at src/codec/korean.rs:119:49: 119:50
        _0 = StatefulDecoderHelper::<windows949::State, T>::emit(move _11, move _12) -> bb10; // scope 2 at src/codec/korean.rs:119:33: 119:51
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:119:37: 119:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>, u32) -> codec::korean::windows949::State {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_12);                // scope 2 at src/codec/korean.rs:119:50: 119:51
        StorageDead(_11);                // scope 2 at src/codec/korean.rs:119:50: 119:51
        StorageDead(_10);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb14;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb11: {
        StorageLive(_14);                // scope 1 at src/codec/korean.rs:120:14: 120:29
        _14 = _5;                        // scope 1 at src/codec/korean.rs:120:14: 120:29
        StorageLive(_15);                // scope 3 at src/codec/korean.rs:120:36: 120:39
        _15 = &mut (*_1);                // scope 3 at src/codec/korean.rs:120:36: 120:39
        StorageLive(_16);                // scope 3 at src/codec/korean.rs:120:41: 120:42
        _16 = _14;                       // scope 3 at src/codec/korean.rs:120:41: 120:42
        _0 = windows949::transient::S1::<T>(move _15, move _16) -> bb12; // scope 3 at src/codec/korean.rs:120:33: 120:43
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:120:33: 120:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::korean::windows949::State, T>, u8) -> codec::korean::windows949::State {codec::korean::windows949::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_16);                // scope 3 at src/codec/korean.rs:120:42: 120:43
        StorageDead(_15);                // scope 3 at src/codec/korean.rs:120:42: 120:43
        StorageDead(_14);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb14;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb13: {
        StorageDead(_17);                // scope 1 at src/codec/korean.rs:121:45: 121:46
        goto -> bb14;                    // scope 1 at src/codec/korean.rs:121:45: 121:46
    }

    bb14: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb15;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb15: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:55:1: 62:2>::raw_finish(_1: &mut GB18030Encoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:61:19: 61:28
    debug _output => _2;                 // in scope 0 at src/codec/simpchinese.rs:61:30: 61:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/simpchinese.rs:61:59: 61:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/simpchinese.rs:61:80: 61:84
        return;                          // scope 0 at src/codec/simpchinese.rs:61:86: 61:86
    }
}

const ISO_8859_3: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:44:64: 44:76
    let _5: &str;                        // in scope 0 at src/all.rs:44:64: 44:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_3::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_3, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1252 ~ encoding[5d2c]::all::ISO_8859_3), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_3: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:44:64: 44:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:44:64: 44:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-3";         // scope 0 at src/all.rs:44:64: 44:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:44:64: 44:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:44:64: 44:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_3::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_3::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_3::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_3::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-3"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:44:64: 44:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn hz::State::B1(_1: ()) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as B1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 3;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn hz::State::B1(_1: ()) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as B1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 3;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn japanese::<impl at src/codec/japanese.rs:43:1: 45:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:44:21: 44:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:44:39: 44:61
    let mut _2: std::boxed::Box<codec::japanese::EUCJPEncoder>; // in scope 0 at src/codec/japanese.rs:44:39: 44:61
    let mut _3: codec::japanese::EUCJPEncoder; // in scope 0 at src/codec/japanese.rs:44:48: 44:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/japanese.rs:44:39: 44:61
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:44:39: 44:61
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:44:48: 44:60
        _2 = Box::<EUCJPEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/japanese.rs:44:39: 44:61
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:44:39: 44:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::japanese::EUCJPEncoder) -> std::boxed::Box<codec::japanese::EUCJPEncoder> {std::boxed::Box::<codec::japanese::EUCJPEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:44:39: 44:61
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:44:60: 44:61
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:44:60: 44:61
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:44:39: 44:61
        StorageDead(_1);                 // scope 0 at src/codec/japanese.rs:44:62: 44:63
        return;                          // scope 0 at src/codec/japanese.rs:44:63: 44:63
    }
}

STATE_TRANSITIONS::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at src/codec/utf_8.rs:118:32: 118:35

    bb0: {
        _0 = const 110_usize;            // scope 0 at src/codec/utf_8.rs:118:32: 118:35
        return;                          // scope 0 at src/codec/utf_8.rs:118:32: 118:35
    }
}

const ISO_2022_JP: &ISO2022JPEncoding = {
    let mut _0: &codec::japanese::ISO2022JPEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const ISO_2022_JP::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPEncoding
                                         // + val: Unevaluated(ISO_2022_JP, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1283 ~ encoding[5d2c]::all::ISO_2022_JP), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in ISO_2022_JP: &ISO2022JPEncoding = {
    let mut _0: &codec::japanese::ISO2022JPEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::japanese::ISO2022JPEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn hz::transient::A0(_1: &mut StatefulDecoderHelper<hz::State, T>) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

fn eucjp::State::S2(_1: ()) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S2).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 2;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn eucjp::State::S2(_1: ()) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S2).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 2;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:482:1: 533:2>::is_ascii_compatible(_1: &HZEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:484:28: 484:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/simpchinese.rs:484:38: 484:42

    bb0: {
        _0 = const false;                // scope 0 at src/codec/simpchinese.rs:484:45: 484:50
        return;                          // scope 0 at src/codec/simpchinese.rs:484:52: 484:52
    }
}

fn bigfive2003::<impl at src/util.rs:168:13: 170:14>::default() -> bigfive2003::State {
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn windows31j::raw_feed(_1: windows31j::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (windows31j::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::japanese::windows31j::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _18: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _19: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _20: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _21: (std::option::Option<encoding_types::CodecError>, codec::japanese::windows31j::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _22: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _23: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _24: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _25: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _26: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _27: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _28: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _29: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _30: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _31: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _33: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _34: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _35: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _36: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _37: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _38: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _39: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _40: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _42: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _43: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _44: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _45: (std::option::Option<encoding_types::CodecError>, codec::japanese::windows31j::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _46: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _47: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _48: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _49: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _50: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _51: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _52: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _53: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _54: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _55: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _57: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _58: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _59: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _60: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _61: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _62: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _63: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::japanese::windows31j::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _17: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _32: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _41: codec::japanese::windows31j::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 5 {
                    debug err => _32;    // in scope 5 at src/util.rs:252:27: 252:30
                }
                scope 6 {
                    debug st_ => _41;    // in scope 6 at src/util.rs:256:25: 256:28
                    let _56: encoding_types::CodecError; // in scope 6 at src/util.rs:267:31: 267:34
                    scope 7 {
                        debug err => _56; // in scope 7 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug lead => _17;       // in scope 4 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<windows31j::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::japanese::windows31j::State, T> {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_17);                // scope 2 at src/util.rs:245:36: 245:40
        _17 = ((_1 as S1).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_18);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_19);                // scope 4 at src/util.rs:245:62: 245:70
        _19 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _18 = &mut (*_19);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_20);                // scope 4 at src/util.rs:245:75: 245:79
        _20 = _17;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = windows31j::transient::S1::<T>(move _18, move _20) -> [return: bb6, unwind: bb33]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::windows31j::State, T>, u8) -> codec::japanese::windows31j::State {codec::japanese::windows31j::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb7;                     // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageDead(_20);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_19);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_18);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_17);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb7;                     // scope 2 at src/util.rs:245:81: 245:82
    }

    bb7: {
        StorageLive(_21);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_22);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_23);                // scope 3 at src/util.rs:248:24: 248:31
        _23 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _22 = Option::<encoding_types::CodecError>::take(move _23) -> [return: bb8, unwind: bb33]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_23);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_24);                // scope 3 at src/util.rs:248:40: 248:43
        _24 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_21.0: std::option::Option<encoding_types::CodecError>) = move _22; // scope 3 at src/util.rs:248:23: 248:44
        (_21.1: codec::japanese::windows31j::State) = move _24; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_24);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_22);                // scope 3 at src/util.rs:248:43: 248:44
        _26 = discriminant((_21.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _26) -> [0_isize: bb9, 1_isize: bb10, otherwise: bb11]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb9: {
        _25 = discriminant((_21.1: codec::japanese::windows31j::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _25) -> [0_isize: bb12, otherwise: bb13]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb10: {
        StorageLive(_32);                // scope 3 at src/util.rs:252:27: 252:30
        _32 = move (((_21.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_33);                // scope 5 at src/util.rs:252:49: 252:52
        _33 = _15;                       // scope 5 at src/util.rs:252:49: 252:52
        StorageLive(_34);                // scope 5 at src/util.rs:252:54: 252:63
        _34 = _14;                       // scope 5 at src/util.rs:252:54: 252:63
        StorageLive(_35);                // scope 5 at src/util.rs:252:65: 252:74
        StorageLive(_36);                // scope 5 at src/util.rs:252:70: 252:73
        _36 = move _32;                  // scope 5 at src/util.rs:252:70: 252:73
        ((_35 as Some).0: encoding_types::CodecError) = move _36; // scope 5 at src/util.rs:252:65: 252:74
        discriminant(_35) = 1;           // scope 5 at src/util.rs:252:65: 252:74
        StorageDead(_36);                // scope 5 at src/util.rs:252:73: 252:74
        (_0.0: codec::japanese::windows31j::State) = move _33; // scope 5 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _34;        // scope 5 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _35; // scope 5 at src/util.rs:252:48: 252:75
        StorageDead(_35);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_34);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_33);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_32);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb29;                    // scope 3 at no-location
    }

    bb11: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb12: {
        StorageLive(_27);                // scope 3 at src/util.rs:249:70: 249:73
        _27 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _27;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_27);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_28);                // scope 3 at src/util.rs:249:87: 249:94
        _28 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _28;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_28);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_21);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb14;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb13: {
        StorageLive(_29);                // scope 3 at src/util.rs:251:44: 251:47
        _29 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_30);                // scope 3 at src/util.rs:251:49: 251:58
        _30 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_31);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_31) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::japanese::windows31j::State) = move _29; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _30;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _31; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_31);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_30);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_29);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb29;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb14: {
        StorageLive(_37);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_38);                // scope 3 at src/util.rs:255:23: 255:30
        _38 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_39);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_40);                // scope 3 at src/util.rs:255:33: 255:40
        _40 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _39 = core::slice::<impl [u8]>::len(move _40) -> [return: bb15, unwind: bb33]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_40);                // scope 3 at src/util.rs:255:45: 255:46
        _37 = Lt(move _38, move _39);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_39);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_38);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _37) -> [false: bb26, otherwise: bb16]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb16: {
        StorageLive(_41);                // scope 3 at src/util.rs:256:25: 256:28
        _42 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _42) -> [0_isize: bb18, otherwise: bb17]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb17: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb33; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb18: {
        StorageLive(_43);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_44);                // scope 3 at src/util.rs:257:49: 257:57
        _44 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _43 = &mut (*_44);               // scope 3 at src/util.rs:257:49: 257:57
        _41 = windows31j::start::S0::<T>(move _43) -> [return: bb19, unwind: bb33]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::windows31j::State, T>) -> codec::japanese::windows31j::State {codec::japanese::windows31j::start::S0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_44);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_43);                // scope 3 at src/util.rs:257:57: 257:58
        StorageLive(_45);                // scope 6 at src/util.rs:263:27: 263:48
        StorageLive(_46);                // scope 6 at src/util.rs:263:28: 263:42
        StorageLive(_47);                // scope 6 at src/util.rs:263:28: 263:35
        _47 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 6 at src/util.rs:263:28: 263:35
        _46 = Option::<encoding_types::CodecError>::take(move _47) -> [return: bb20, unwind: bb33]; // scope 6 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_47);                // scope 6 at src/util.rs:263:41: 263:42
        StorageLive(_48);                // scope 6 at src/util.rs:263:44: 263:47
        _48 = _41;                       // scope 6 at src/util.rs:263:44: 263:47
        (_45.0: std::option::Option<encoding_types::CodecError>) = move _46; // scope 6 at src/util.rs:263:27: 263:48
        (_45.1: codec::japanese::windows31j::State) = move _48; // scope 6 at src/util.rs:263:27: 263:48
        StorageDead(_48);                // scope 6 at src/util.rs:263:47: 263:48
        StorageDead(_46);                // scope 6 at src/util.rs:263:47: 263:48
        _50 = discriminant((_45.0: std::option::Option<encoding_types::CodecError>)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _50) -> [0_isize: bb21, 1_isize: bb22, otherwise: bb23]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb21: {
        _49 = discriminant((_45.1: codec::japanese::windows31j::State)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _49) -> [0_isize: bb24, otherwise: bb25]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb22: {
        StorageLive(_56);                // scope 6 at src/util.rs:267:31: 267:34
        _56 = move (((_45.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 6 at src/util.rs:267:31: 267:34
        StorageLive(_57);                // scope 7 at src/util.rs:267:53: 267:56
        _57 = _41;                       // scope 7 at src/util.rs:267:53: 267:56
        StorageLive(_58);                // scope 7 at src/util.rs:267:58: 267:67
        _58 = _14;                       // scope 7 at src/util.rs:267:58: 267:67
        StorageLive(_59);                // scope 7 at src/util.rs:267:69: 267:78
        StorageLive(_60);                // scope 7 at src/util.rs:267:74: 267:77
        _60 = move _56;                  // scope 7 at src/util.rs:267:74: 267:77
        ((_59 as Some).0: encoding_types::CodecError) = move _60; // scope 7 at src/util.rs:267:69: 267:78
        discriminant(_59) = 1;           // scope 7 at src/util.rs:267:69: 267:78
        StorageDead(_60);                // scope 7 at src/util.rs:267:77: 267:78
        (_0.0: codec::japanese::windows31j::State) = move _57; // scope 7 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _58;        // scope 7 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _59; // scope 7 at src/util.rs:267:52: 267:79
        StorageDead(_59);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_58);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_57);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_56);                // scope 6 at src/util.rs:267:81: 267:82
        goto -> bb28;                    // scope 6 at no-location
    }

    bb23: {
        unreachable;                     // scope 6 at src/util.rs:263:27: 263:48
    }

    bb24: {
        StorageLive(_51);                // scope 6 at src/util.rs:264:74: 264:77
        _51 = _41;                       // scope 6 at src/util.rs:264:74: 264:77
        _1 = move _51;                   // scope 6 at src/util.rs:264:69: 264:77
        StorageDead(_51);                // scope 6 at src/util.rs:264:76: 264:77
        StorageLive(_52);                // scope 6 at src/util.rs:264:91: 264:98
        _52 = (_9.1: usize);             // scope 6 at src/util.rs:264:91: 264:98
        _14 = move _52;                  // scope 6 at src/util.rs:264:79: 264:98
        StorageDead(_52);                // scope 6 at src/util.rs:264:97: 264:98
        StorageDead(_41);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb14;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb25: {
        StorageLive(_53);                // scope 6 at src/util.rs:266:48: 266:51
        _53 = _41;                       // scope 6 at src/util.rs:266:48: 266:51
        StorageLive(_54);                // scope 6 at src/util.rs:266:53: 266:62
        _54 = _14;                       // scope 6 at src/util.rs:266:53: 266:62
        StorageLive(_55);                // scope 6 at src/util.rs:266:64: 266:68
        discriminant(_55) = 0;           // scope 6 at src/util.rs:266:64: 266:68
        (_0.0: codec::japanese::windows31j::State) = move _53; // scope 6 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _54;        // scope 6 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _55; // scope 6 at src/util.rs:266:47: 266:69
        StorageDead(_55);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_54);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_53);                // scope 6 at src/util.rs:266:68: 266:69
        goto -> bb28;                    // scope 6 at src/util.rs:266:40: 266:69
    }

    bb26: {
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_61);                // scope 3 at src/util.rs:271:18: 271:20
        _61 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_62);                // scope 3 at src/util.rs:271:22: 271:31
        _62 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_63);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_63) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::japanese::windows31j::State) = move _61; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _62;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _63; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_63);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_62);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_61);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb27;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb27: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb32;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb28: {
        StorageDead(_41);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb30;                    // scope 3 at no-location
    }

    bb29: {
        StorageDead(_21);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb30;                    // scope 3 at no-location
    }

    bb30: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb31;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb31: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb32;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb32: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb33 (cleanup): {
        drop(_9) -> bb34;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb34 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

fn simpchinese::gb18030::start::S0(_1: &mut StatefulDecoderHelper<simpchinese::gb18030::State, T>) -> simpchinese::gb18030::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/simpchinese.rs:214:18: 214:29
    let mut _7: bool;                    // in scope 0 at src/codec/simpchinese.rs:214:18: 214:29
    let mut _8: bool;                    // in scope 0 at src/codec/simpchinese.rs:212:18: 212:29
    let mut _9: bool;                    // in scope 0 at src/codec/simpchinese.rs:212:18: 212:29
    let mut _11: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:212:33: 212:36
    let mut _12: u32;                    // in scope 0 at src/codec/simpchinese.rs:212:42: 212:50
    let mut _13: u8;                     // in scope 0 at src/codec/simpchinese.rs:212:42: 212:43
    let mut _14: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:213:22: 213:25
    let mut _16: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:214:36: 214:39
    let mut _17: u8;                     // in scope 0 at src/codec/simpchinese.rs:214:41: 214:42
    let mut _18: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:215:19: 215:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _10: u8;                     // in scope 1 at src/codec/simpchinese.rs:212:14: 212:29
        let _15: u8;                     // in scope 1 at src/codec/simpchinese.rs:214:14: 214:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/simpchinese.rs:212:14: 212:29
        }
        scope 3 {
            debug b => _15;              // in scope 3 at src/codec/simpchinese.rs:214:14: 214:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        _8 = Le(const 0_u8, _5);         // scope 1 at src/codec/simpchinese.rs:212:18: 212:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/simpchinese.rs:212:18: 212:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb18;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _9 = Le(_5, const 127_u8);       // scope 1 at src/codec/simpchinese.rs:212:18: 212:29
        switchInt(move _9) -> [false: bb6, otherwise: bb10]; // scope 1 at src/codec/simpchinese.rs:212:18: 212:29
    }

    bb6: {
        switchInt(_5) -> [128_u8: bb12, otherwise: bb7]; // scope 1 at src/util.rs:187:36: 187:43
    }

    bb7: {
        _6 = Le(const 129_u8, _5);       // scope 1 at src/codec/simpchinese.rs:214:18: 214:29
        switchInt(move _6) -> [false: bb9, otherwise: bb8]; // scope 1 at src/codec/simpchinese.rs:214:18: 214:29
    }

    bb8: {
        _7 = Le(_5, const 254_u8);       // scope 1 at src/codec/simpchinese.rs:214:18: 214:29
        switchInt(move _7) -> [false: bb9, otherwise: bb14]; // scope 1 at src/codec/simpchinese.rs:214:18: 214:29
    }

    bb9: {
        StorageLive(_18);                // scope 1 at src/codec/simpchinese.rs:215:19: 215:22
        _18 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:215:19: 215:22
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::err(move _18, const "invalid sequence") -> bb16; // scope 1 at src/codec/simpchinese.rs:215:19: 215:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:215:23: 215:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:215:27: 215:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb10: {
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:212:14: 212:29
        _10 = _5;                        // scope 1 at src/codec/simpchinese.rs:212:14: 212:29
        StorageLive(_11);                // scope 2 at src/codec/simpchinese.rs:212:33: 212:36
        _11 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:212:33: 212:36
        StorageLive(_12);                // scope 2 at src/codec/simpchinese.rs:212:42: 212:50
        StorageLive(_13);                // scope 2 at src/codec/simpchinese.rs:212:42: 212:43
        _13 = _10;                       // scope 2 at src/codec/simpchinese.rs:212:42: 212:43
        _12 = move _13 as u32 (Misc);    // scope 2 at src/codec/simpchinese.rs:212:42: 212:50
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:212:49: 212:50
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::emit(move _11, move _12) -> bb11; // scope 2 at src/codec/simpchinese.rs:212:33: 212:51
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:212:37: 212:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, u32) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_12);                // scope 2 at src/codec/simpchinese.rs:212:50: 212:51
        StorageDead(_11);                // scope 2 at src/codec/simpchinese.rs:212:50: 212:51
        StorageDead(_10);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb17;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb12: {
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:213:22: 213:25
        _14 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:213:22: 213:25
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::emit(move _14, const 8364_u32) -> bb13; // scope 1 at src/codec/simpchinese.rs:213:22: 213:38
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:213:26: 213:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, u32) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_14);                // scope 1 at src/codec/simpchinese.rs:213:37: 213:38
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:213:37: 213:38
    }

    bb14: {
        StorageLive(_15);                // scope 1 at src/codec/simpchinese.rs:214:14: 214:29
        _15 = _5;                        // scope 1 at src/codec/simpchinese.rs:214:14: 214:29
        StorageLive(_16);                // scope 3 at src/codec/simpchinese.rs:214:36: 214:39
        _16 = &mut (*_1);                // scope 3 at src/codec/simpchinese.rs:214:36: 214:39
        StorageLive(_17);                // scope 3 at src/codec/simpchinese.rs:214:41: 214:42
        _17 = _15;                       // scope 3 at src/codec/simpchinese.rs:214:41: 214:42
        _0 = simpchinese::gb18030::transient::S1::<T>(move _16, move _17) -> bb15; // scope 3 at src/codec/simpchinese.rs:214:33: 214:43
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:214:33: 214:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>, u8) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_17);                // scope 3 at src/codec/simpchinese.rs:214:42: 214:43
        StorageDead(_16);                // scope 3 at src/codec/simpchinese.rs:214:42: 214:43
        StorageDead(_15);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb17;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb16: {
        StorageDead(_18);                // scope 1 at src/codec/simpchinese.rs:215:45: 215:46
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:215:45: 215:46
    }

    bb17: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb18;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb18: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

fn windows949::transient::S1(_1: &mut StatefulDecoderHelper<windows949::State, T>, _2: u8) -> windows949::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _9: u32;                     // in scope 0 at src/codec/korean.rs:127:25: 127:47
    let mut _10: u8;                     // in scope 0 at src/codec/korean.rs:127:39: 127:43
    let mut _11: u8;                     // in scope 0 at src/codec/korean.rs:127:45: 127:46
    let mut _13: bool;                   // in scope 0 at src/codec/korean.rs:129:33: 129:41
    let mut _14: u8;                     // in scope 0 at src/codec/korean.rs:129:33: 129:34
    let mut _15: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/codec/korean.rs:130:17: 130:20
    let mut _16: usize;                  // in scope 0 at src/codec/korean.rs:130:36: 130:42
    let mut _18: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/codec/korean.rs:132:19: 132:22
    let mut _19: u32;                    // in scope 0 at src/codec/korean.rs:132:28: 132:37
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _8: u8;                      // in scope 1 at src/codec/korean.rs:127:14: 127:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/korean.rs:127:14: 127:15
            let _12: usize;              // in scope 2 at src/codec/korean.rs:129:21: 129:27
            let _17: u32;                // in scope 2 at src/codec/korean.rs:132:13: 132:15
            scope 3 {
                debug backup => _12;     // in scope 3 at src/codec/korean.rs:129:21: 129:27
            }
            scope 4 {
                debug ch => _17;         // in scope 4 at src/codec/korean.rs:132:13: 132:15
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<windows949::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        StorageLive(_8);                 // scope 1 at src/codec/korean.rs:127:14: 127:15
        _8 = _7;                         // scope 1 at src/codec/korean.rs:127:14: 127:15
        StorageLive(_9);                 // scope 2 at src/codec/korean.rs:127:25: 127:47
        StorageLive(_10);                // scope 2 at src/codec/korean.rs:127:39: 127:43
        _10 = _2;                        // scope 2 at src/codec/korean.rs:127:39: 127:43
        StorageLive(_11);                // scope 2 at src/codec/korean.rs:127:45: 127:46
        _11 = _8;                        // scope 2 at src/codec/korean.rs:127:45: 127:46
        _9 = windows949::internal::map_two_bytes(move _10, move _11) -> bb5; // scope 2 at src/codec/korean.rs:127:25: 127:47
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:127:25: 127:38
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::korean::windows949::internal::map_two_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S1).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 1;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb14;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageDead(_11);                // scope 2 at src/codec/korean.rs:127:46: 127:47
        StorageDead(_10);                // scope 2 at src/codec/korean.rs:127:46: 127:47
        switchInt(_9) -> [65535_u32: bb7, otherwise: bb6]; // scope 2 at src/codec/korean.rs:127:19: 127:47
    }

    bb6: {
        StorageLive(_17);                // scope 2 at src/codec/korean.rs:132:13: 132:15
        _17 = _9;                        // scope 2 at src/codec/korean.rs:132:13: 132:15
        StorageLive(_18);                // scope 4 at src/codec/korean.rs:132:19: 132:22
        _18 = &mut (*_1);                // scope 4 at src/codec/korean.rs:132:19: 132:22
        StorageLive(_19);                // scope 4 at src/codec/korean.rs:132:28: 132:37
        _19 = _17;                       // scope 4 at src/codec/korean.rs:132:28: 132:30
        _0 = StatefulDecoderHelper::<windows949::State, T>::emit(move _18, move _19) -> bb12; // scope 4 at src/codec/korean.rs:132:19: 132:38
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:132:23: 132:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>, u32) -> codec::korean::windows949::State {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageLive(_12);                // scope 2 at src/codec/korean.rs:129:21: 129:27
        StorageLive(_13);                // scope 2 at src/codec/korean.rs:129:33: 129:41
        StorageLive(_14);                // scope 2 at src/codec/korean.rs:129:33: 129:34
        _14 = _8;                        // scope 2 at src/codec/korean.rs:129:33: 129:34
        _13 = Lt(move _14, const 128_u8); // scope 2 at src/codec/korean.rs:129:33: 129:41
        StorageDead(_14);                // scope 2 at src/codec/korean.rs:129:40: 129:41
        switchInt(move _13) -> [false: bb9, otherwise: bb8]; // scope 2 at src/codec/korean.rs:129:33: 129:41
    }

    bb8: {
        _12 = const 1_usize;             // scope 2 at src/codec/korean.rs:129:43: 129:44
        goto -> bb10;                    // scope 2 at src/codec/korean.rs:129:30: 129:54
    }

    bb9: {
        _12 = const 0_usize;             // scope 2 at src/codec/korean.rs:129:52: 129:53
        goto -> bb10;                    // scope 2 at src/codec/korean.rs:129:30: 129:54
    }

    bb10: {
        StorageDead(_13);                // scope 2 at src/codec/korean.rs:129:53: 129:54
        StorageLive(_15);                // scope 3 at src/codec/korean.rs:130:17: 130:20
        _15 = &mut (*_1);                // scope 3 at src/codec/korean.rs:130:17: 130:20
        StorageLive(_16);                // scope 3 at src/codec/korean.rs:130:36: 130:42
        _16 = _12;                       // scope 3 at src/codec/korean.rs:130:36: 130:42
        _0 = StatefulDecoderHelper::<windows949::State, T>::backup_and_err(move _15, move _16, const "invalid sequence") -> bb11; // scope 3 at src/codec/korean.rs:130:17: 130:63
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:130:21: 130:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>, usize, &'static str) -> codec::korean::windows949::State {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:130:44: 130:62
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb11: {
        StorageDead(_16);                // scope 3 at src/codec/korean.rs:130:62: 130:63
        StorageDead(_15);                // scope 3 at src/codec/korean.rs:130:62: 130:63
        StorageDead(_12);                // scope 2 at src/codec/korean.rs:131:13: 131:14
        goto -> bb13;                    // scope 2 at src/codec/korean.rs:131:13: 131:14
    }

    bb12: {
        StorageDead(_19);                // scope 4 at src/codec/korean.rs:132:37: 132:38
        StorageDead(_18);                // scope 4 at src/codec/korean.rs:132:37: 132:38
        StorageDead(_17);                // scope 2 at src/codec/korean.rs:132:37: 132:38
        goto -> bb13;                    // scope 2 at src/codec/korean.rs:132:37: 132:38
    }

    bb13: {
        StorageDead(_9);                 // scope 2 at src/util.rs:226:77: 226:78
        StorageDead(_8);                 // scope 1 at src/util.rs:226:77: 226:78
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb14;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb14: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn japanese::<impl at src/codec/japanese.rs:520:1: 535:2>::raw_finish(_1: &mut Windows31JDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:530:19: 530:28
    debug output => _2;                  // in scope 0 at src/codec/japanese.rs:530:30: 530:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/japanese.rs:531:18: 531:21
    let _3: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:531:14: 531:16
    let mut _4: (codec::japanese::windows31j::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/japanese.rs:531:25: 531:69
    let mut _5: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:531:48: 531:55
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:531:57: 531:63
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:531:57: 531:63
    let mut _8: &();                     // in scope 0 at src/codec/japanese.rs:531:65: 531:68
    let _9: &();                         // in scope 0 at src/codec/japanese.rs:531:65: 531:68
    let mut _10: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:532:19: 532:21
    let mut _11: &();                    // in scope 0 at src/codec/japanese.rs:531:65: 531:68
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/japanese.rs:531:14: 531:16
        debug err => _0;                 // in scope 1 at src/codec/japanese.rs:531:18: 531:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:531:25: 531:69
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:531:48: 531:55
        _5 = ((*_1).0: codec::japanese::windows31j::State); // scope 0 at src/codec/japanese.rs:531:48: 531:55
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:531:57: 531:63
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:531:57: 531:63
        _7 = &mut (*_2);                 // scope 0 at src/codec/japanese.rs:531:57: 531:63
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:531:57: 531:63
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:531:62: 531:63
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:531:65: 531:68
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:531:65: 531:68
        _11 = const <Windows31JDecoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/japanese.rs:531:65: 531:68
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<Windows31JDecoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:531:65: 531:68
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:424 ~ encoding[5d2c]::codec::japanese::{impl#9}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/japanese.rs:531:65: 531:68
        _8 = _9;                         // scope 0 at src/codec/japanese.rs:531:65: 531:68
        _4 = windows31j::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/japanese.rs:531:25: 531:69
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:531:25: 531:47
                                         // + literal: Const { ty: for<'r, 's> fn(codec::japanese::windows31j::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::japanese::windows31j::State, std::option::Option<encoding_types::CodecError>) {codec::japanese::windows31j::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:531:68: 531:69
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:531:68: 531:69
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:531:68: 531:69
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:531:14: 531:16
        _3 = (_4.0: codec::japanese::windows31j::State); // scope 0 at src/codec/japanese.rs:531:14: 531:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/japanese.rs:531:18: 531:21
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:531:69: 531:70
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:531:69: 531:70
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:532:19: 532:21
        _10 = _3;                        // scope 1 at src/codec/japanese.rs:532:19: 532:21
        ((*_1).0: codec::japanese::windows31j::State) = move _10; // scope 1 at src/codec/japanese.rs:532:9: 532:21
        StorageDead(_10);                // scope 1 at src/codec/japanese.rs:532:20: 532:21
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:534:5: 534:6
        return;                          // scope 0 at src/codec/japanese.rs:534:6: 534:6
    }
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:520:1: 535:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/japanese.rs:531:65: 531:68
    let mut _1: ();                      // in scope 0 at src/codec/japanese.rs:531:66: 531:68

    bb0: {
        nop;                             // scope 0 at src/codec/japanese.rs:531:66: 531:68
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:531:65: 531:68
        return;                          // scope 0 at src/codec/japanese.rs:531:65: 531:68
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::emit(_1: &mut StatefulDecoderHelper<St, Data>, _2: u32) -> St {
    debug self => _1;                    // in scope 0 at src/util.rs:98:17: 98:26
    debug c => _2;                       // in scope 0 at src/util.rs:98:28: 98:29
    let mut _0: St;                      // return place in scope 0 at src/util.rs:98:39: 98:41
    let _3: ();                          // in scope 0 at src/util.rs:99:9: 99:59
    let mut _4: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:99:9: 99:20
    let mut _5: char;                    // in scope 0 at src/util.rs:99:32: 99:58
    let mut _6: u32;                     // in scope 0 at src/util.rs:99:55: 99:56
    scope 1 {
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:99:9: 99:59
        StorageLive(_4);                 // scope 0 at src/util.rs:99:9: 99:20
        _4 = &mut (*((*_1).2: &mut dyn encoding_types::StringWriter)); // scope 0 at src/util.rs:99:9: 99:20
        StorageLive(_5);                 // scope 0 at src/util.rs:99:32: 99:58
        StorageLive(_6);                 // scope 1 at src/util.rs:99:55: 99:56
        _6 = _2;                         // scope 1 at src/util.rs:99:55: 99:56
        _5 = transmute::<u32, char>(move _6) -> bb1; // scope 1 at src/util.rs:99:40: 99:57
                                         // mir::Constant
                                         // + span: src/util.rs:99:40: 99:54
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(u32) -> char {std::intrinsics::transmute::<u32, char>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 1 at src/util.rs:99:56: 99:57
        _3 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char(move _4, move _5) -> bb2; // scope 0 at src/util.rs:99:9: 99:59
                                         // mir::Constant
                                         // + span: src/util.rs:99:21: 99:31
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, char) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_char}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_5);                 // scope 0 at src/util.rs:99:58: 99:59
        StorageDead(_4);                 // scope 0 at src/util.rs:99:58: 99:59
        StorageDead(_3);                 // scope 0 at src/util.rs:99:59: 99:60
        _0 = <St as Default>::default() -> bb3; // scope 0 at src/util.rs:100:9: 100:27
                                         // mir::Constant
                                         // + span: src/util.rs:100:9: 100:25
                                         // + literal: Const { ty: fn() -> St {<St as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        return;                          // scope 0 at src/util.rs:101:6: 101:6
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:40:1: 45:2>::name(_1: &UTF16BEEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:41:13: 41:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/utf_16.rs:41:23: 41:35

    bb0: {
        _0 = const "utf-16be";           // scope 0 at src/codec/utf_16.rs:41:38: 41:48
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 98, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:41:38: 41:48
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 98, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
        return;                          // scope 0 at src/codec/utf_16.rs:41:50: 41:50
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:95:1: 97:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:96:21: 96:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:96:39: 96:59
    let mut _2: std::boxed::Box<codec::simpchinese::GBKEncoder>; // in scope 0 at src/codec/simpchinese.rs:96:39: 96:59
    let mut _3: codec::simpchinese::GBKEncoder; // in scope 0 at src/codec/simpchinese.rs:96:48: 96:58

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/simpchinese.rs:96:39: 96:59
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:96:39: 96:59
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:96:48: 96:58
        _2 = Box::<GBKEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/simpchinese.rs:96:39: 96:59
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:96:39: 96:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::simpchinese::GBKEncoder) -> std::boxed::Box<codec::simpchinese::GBKEncoder> {std::boxed::Box::<codec::simpchinese::GBKEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:96:39: 96:59
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:96:58: 96:59
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:96:58: 96:59
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:96:39: 96:59
        StorageDead(_1);                 // scope 0 at src/codec/simpchinese.rs:96:60: 96:61
        return;                          // scope 0 at src/codec/simpchinese.rs:96:61: 96:61
    }
}

utf_8::<impl at src/codec/utf_8.rs:81:10: 81:15>::clone::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at src/codec/utf_8.rs:84:17: 84:18

    bb0: {
        _0 = const 4_usize;              // scope 0 at src/codec/utf_8.rs:84:17: 84:18
        return;                          // scope 0 at src/codec/utf_8.rs:84:17: 84:18
    }
}

fn korean::<impl at src/codec/korean.rs:27:1: 32:2>::name(_1: &Windows949Encoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:28:13: 28:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/korean.rs:28:23: 28:35

    bb0: {
        _0 = const "windows-949";        // scope 0 at src/codec/korean.rs:28:38: 28:51
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 57, 52, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:28:38: 28:51
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 57, 52, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        return;                          // scope 0 at src/codec/korean.rs:28:53: 28:53
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:536:10: 536:15>::clone(_1: &HZDecoder) -> HZDecoder {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:536:10: 536:15
    let mut _0: codec::simpchinese::HZDecoder; // return place in scope 0 at src/codec/simpchinese.rs:536:10: 536:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/simpchinese.rs:536:10: 536:15
        return;                          // scope 0 at src/codec/simpchinese.rs:536:15: 536:15
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:20:1: 25:2>::raw_decoder(_1: &SingleByteEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:24:20: 24:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/singlebyte.rs:24:30: 24:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/singlebyte.rs:24:48: 24:90
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/singlebyte.rs:24:48: 24:90
    let mut _4: fn(u8) -> u16;           // in scope 0 at src/codec/singlebyte.rs:24:71: 24:89

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:24:48: 24:90
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:24:48: 24:90
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:24:71: 24:89
        _4 = ((*_1).2: fn(u8) -> u16);   // scope 0 at src/codec/singlebyte.rs:24:71: 24:89
        _3 = SingleByteDecoder::new(move _4) -> bb1; // scope 0 at src/codec/singlebyte.rs:24:48: 24:90
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:24:48: 24:70
                                         // + literal: Const { ty: fn(fn(u8) -> u16) -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::singlebyte::SingleByteDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:24:48: 24:90
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:24:89: 24:90
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:24:89: 24:90
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:24:48: 24:90
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:24:91: 24:92
        return;                          // scope 0 at src/codec/singlebyte.rs:24:92: 24:92
    }
}

fn japanese::<impl at src/codec/japanese.rs:92:1: 96:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:93:21: 93:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:94:9: 94:62
    let mut _2: std::boxed::Box<codec::japanese::EUCJP0212Decoder>; // in scope 0 at src/codec/japanese.rs:94:9: 94:62
    let mut _3: codec::japanese::EUCJP0212Decoder; // in scope 0 at src/codec/japanese.rs:94:18: 94:61
    let mut _4: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:94:41: 94:59

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/japanese.rs:94:9: 94:62
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:94:9: 94:62
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:94:18: 94:61
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:94:41: 94:59
        _4 = <eucjp::State as Default>::default() -> bb1; // scope 0 at src/codec/japanese.rs:94:41: 94:59
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:94:41: 94:57
                                         // + literal: Const { ty: fn() -> codec::japanese::eucjp::State {<codec::japanese::eucjp::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::japanese::eucjp::State) = move _4; // scope 0 at src/codec/japanese.rs:94:18: 94:61
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:94:60: 94:61
        _2 = Box::<EUCJP0212Decoder>::new(move _3) -> bb2; // scope 0 at src/codec/japanese.rs:94:9: 94:62
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:94:9: 94:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::japanese::EUCJP0212Decoder) -> std::boxed::Box<codec::japanese::EUCJP0212Decoder> {std::boxed::Box::<codec::japanese::EUCJP0212Decoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:94:9: 94:62
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:94:61: 94:62
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:94:61: 94:62
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:94:9: 94:62
        StorageDead(_1);                 // scope 0 at src/codec/japanese.rs:95:5: 95:6
        return;                          // scope 0 at src/codec/japanese.rs:95:6: 95:6
    }
}

fn util::<impl at src/util.rs:25:1: 39:2>::next(_1: &mut StrCharIndexIterator) -> Option<((usize, usize), char)> {
    debug self => _1;                    // in scope 0 at src/util.rs:29:13: 29:22
    let mut _0: std::option::Option<((usize, usize), char)>; // return place in scope 0 at src/util.rs:29:27: 29:56
    let mut _2: std::option::Option<char>; // in scope 0 at src/util.rs:30:27: 30:44
    let mut _3: &mut std::str::Chars;    // in scope 0 at src/util.rs:30:27: 30:37
    let mut _4: isize;                   // in scope 0 at src/util.rs:30:16: 30:24
    let _5: char;                        // in scope 0 at src/util.rs:30:21: 30:23
    let _6: usize;                       // in scope 0 at src/util.rs:31:17: 31:21
    let mut _8: usize;                   // in scope 0 at src/util.rs:32:24: 32:28
    let mut _9: usize;                   // in scope 0 at src/util.rs:32:31: 32:44
    let mut _10: char;                   // in scope 0 at src/util.rs:32:31: 32:33
    let mut _11: usize;                  // in scope 0 at src/util.rs:33:26: 33:30
    let mut _12: ((usize, usize), char); // in scope 0 at src/util.rs:34:18: 34:36
    let mut _13: (usize, usize);         // in scope 0 at src/util.rs:34:19: 34:31
    let mut _14: usize;                  // in scope 0 at src/util.rs:34:20: 34:24
    let mut _15: usize;                  // in scope 0 at src/util.rs:34:26: 34:30
    let mut _16: char;                   // in scope 0 at src/util.rs:34:33: 34:35
    scope 1 {
        debug ch => _5;                  // in scope 1 at src/util.rs:30:21: 30:23
    }
    scope 2 {
        debug prev => _6;                // in scope 2 at src/util.rs:31:17: 31:21
        let _7: usize;                   // in scope 2 at src/util.rs:32:17: 32:21
        scope 3 {
            debug next => _7;            // in scope 3 at src/util.rs:32:17: 32:21
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:30:27: 30:44
        StorageLive(_3);                 // scope 0 at src/util.rs:30:27: 30:37
        _3 = &mut ((*_1).1: std::str::Chars); // scope 0 at src/util.rs:30:27: 30:37
        _2 = <Chars as Iterator>::next(move _3) -> bb1; // scope 0 at src/util.rs:30:27: 30:44
                                         // mir::Constant
                                         // + span: src/util.rs:30:38: 30:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::str::Chars) -> std::option::Option<<std::str::Chars as std::iter::Iterator>::Item> {<std::str::Chars as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:30:43: 30:44
        _4 = discriminant(_2);           // scope 0 at src/util.rs:30:16: 30:24
        switchInt(move _4) -> [1_isize: bb2, otherwise: bb4]; // scope 0 at src/util.rs:30:16: 30:24
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:30:21: 30:23
        _5 = ((_2 as Some).0: char);     // scope 0 at src/util.rs:30:21: 30:23
        StorageLive(_6);                 // scope 0 at src/util.rs:31:17: 31:21
        _6 = ((*_1).0: usize);           // scope 0 at src/util.rs:31:24: 31:34
        StorageLive(_7);                 // scope 2 at src/util.rs:32:17: 32:21
        StorageLive(_8);                 // scope 2 at src/util.rs:32:24: 32:28
        _8 = _6;                         // scope 2 at src/util.rs:32:24: 32:28
        StorageLive(_9);                 // scope 2 at src/util.rs:32:31: 32:44
        StorageLive(_10);                // scope 2 at src/util.rs:32:31: 32:33
        _10 = _5;                        // scope 2 at src/util.rs:32:31: 32:33
        _9 = char::methods::<impl char>::len_utf8(move _10) -> bb3; // scope 2 at src/util.rs:32:31: 32:44
                                         // mir::Constant
                                         // + span: src/util.rs:32:34: 32:42
                                         // + literal: Const { ty: fn(char) -> usize {std::char::methods::<impl char>::len_utf8}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_10);                // scope 2 at src/util.rs:32:43: 32:44
        _7 = Add(move _8, move _9);      // scope 2 at src/util.rs:32:24: 32:44
        StorageDead(_9);                 // scope 2 at src/util.rs:32:43: 32:44
        StorageDead(_8);                 // scope 2 at src/util.rs:32:43: 32:44
        StorageLive(_11);                // scope 3 at src/util.rs:33:26: 33:30
        _11 = _7;                        // scope 3 at src/util.rs:33:26: 33:30
        ((*_1).0: usize) = move _11;     // scope 3 at src/util.rs:33:13: 33:30
        StorageDead(_11);                // scope 3 at src/util.rs:33:29: 33:30
        StorageLive(_12);                // scope 3 at src/util.rs:34:18: 34:36
        StorageLive(_13);                // scope 3 at src/util.rs:34:19: 34:31
        StorageLive(_14);                // scope 3 at src/util.rs:34:20: 34:24
        _14 = _6;                        // scope 3 at src/util.rs:34:20: 34:24
        StorageLive(_15);                // scope 3 at src/util.rs:34:26: 34:30
        _15 = _7;                        // scope 3 at src/util.rs:34:26: 34:30
        (_13.0: usize) = move _14;       // scope 3 at src/util.rs:34:19: 34:31
        (_13.1: usize) = move _15;       // scope 3 at src/util.rs:34:19: 34:31
        StorageDead(_15);                // scope 3 at src/util.rs:34:30: 34:31
        StorageDead(_14);                // scope 3 at src/util.rs:34:30: 34:31
        StorageLive(_16);                // scope 3 at src/util.rs:34:33: 34:35
        _16 = _5;                        // scope 3 at src/util.rs:34:33: 34:35
        (_12.0: (usize, usize)) = move _13; // scope 3 at src/util.rs:34:18: 34:36
        (_12.1: char) = move _16;        // scope 3 at src/util.rs:34:18: 34:36
        StorageDead(_16);                // scope 3 at src/util.rs:34:35: 34:36
        StorageDead(_13);                // scope 3 at src/util.rs:34:35: 34:36
        ((_0 as Some).0: ((usize, usize), char)) = move _12; // scope 3 at src/util.rs:34:13: 34:37
        discriminant(_0) = 1;            // scope 3 at src/util.rs:34:13: 34:37
        StorageDead(_12);                // scope 3 at src/util.rs:34:36: 34:37
        StorageDead(_7);                 // scope 2 at src/util.rs:35:9: 35:10
        StorageDead(_6);                 // scope 0 at src/util.rs:35:9: 35:10
        StorageDead(_5);                 // scope 0 at src/util.rs:35:9: 35:10
        goto -> bb5;                     // scope 0 at src/util.rs:30:9: 37:10
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:36:13: 36:17
        goto -> bb5;                     // scope 0 at src/util.rs:30:9: 37:10
    }

    bb5: {
        StorageDead(_2);                 // scope 0 at src/util.rs:38:5: 38:6
        return;                          // scope 0 at src/util.rs:38:6: 38:6
    }
}

fn encoding_from_whatwg_label(_1: &str) -> Option<&dyn encoding_types::Encoding + Send + Sync> {
    debug label => _1;                   // in scope 0 at src/label.rs:12:35: 12:40
    let mut _0: std::option::Option<&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync>; // return place in scope 0 at src/label.rs:12:51: 12:70
    let _2: &str;                        // in scope 0 at src/label.rs:13:9: 13:14
    let mut _3: &str;                    // in scope 0 at src/label.rs:13:17: 13:22
    let mut _4: &[char];                 // in scope 0 at src/label.rs:13:36: 13:72
    let _5: &[char];                     // in scope 0 at src/label.rs:13:37: 13:72
    let mut _6: &[char; 5];              // in scope 0 at src/label.rs:13:37: 13:68
    let mut _7: std::ops::RangeFull;     // in scope 0 at src/label.rs:13:69: 13:71
    let mut _9: std::iter::Map<std::str::Chars, [closure@src/label.rs:15:27: 15:86]>; // in scope 0 at src/label.rs:15:9: 15:87
    let mut _10: std::str::Chars;        // in scope 0 at src/label.rs:15:9: 15:22
    let mut _11: &str;                   // in scope 0 at src/label.rs:15:9: 15:14
    let mut _12: [closure@src/label.rs:15:27: 15:86]; // in scope 0 at src/label.rs:15:27: 15:86
    let mut _13: &str;                   // in scope 0 at src/label.rs:16:11: 16:21
    let _14: &str;                       // in scope 0 at src/label.rs:16:12: 16:21
    let mut _15: &std::string::String;   // in scope 0 at src/label.rs:16:12: 16:17
    let mut _16: std::ops::RangeFull;    // in scope 0 at src/label.rs:16:18: 16:20
    let mut _17: bool;                   // in scope 0 at src/label.rs:17:9: 17:28
    let mut _18: bool;                   // in scope 0 at src/label.rs:18:9: 18:16
    let mut _19: bool;                   // in scope 0 at src/label.rs:19:9: 19:15
    let mut _20: bool;                   // in scope 0 at src/label.rs:21:9: 21:14
    let mut _21: bool;                   // in scope 0 at src/label.rs:22:9: 22:16
    let mut _22: bool;                   // in scope 0 at src/label.rs:23:9: 23:19
    let mut _23: bool;                   // in scope 0 at src/label.rs:24:9: 24:17
    let mut _24: bool;                   // in scope 0 at src/label.rs:26:9: 26:22
    let mut _25: bool;                   // in scope 0 at src/label.rs:27:9: 27:21
    let mut _26: bool;                   // in scope 0 at src/label.rs:28:9: 28:21
    let mut _27: bool;                   // in scope 0 at src/label.rs:29:9: 29:20
    let mut _28: bool;                   // in scope 0 at src/label.rs:30:9: 30:19
    let mut _29: bool;                   // in scope 0 at src/label.rs:31:9: 31:21
    let mut _30: bool;                   // in scope 0 at src/label.rs:32:9: 32:26
    let mut _31: bool;                   // in scope 0 at src/label.rs:33:9: 33:13
    let mut _32: bool;                   // in scope 0 at src/label.rs:34:9: 34:17
    let mut _33: bool;                   // in scope 0 at src/label.rs:36:9: 36:22
    let mut _34: bool;                   // in scope 0 at src/label.rs:37:9: 37:21
    let mut _35: bool;                   // in scope 0 at src/label.rs:38:9: 38:21
    let mut _36: bool;                   // in scope 0 at src/label.rs:39:9: 39:20
    let mut _37: bool;                   // in scope 0 at src/label.rs:40:9: 40:19
    let mut _38: bool;                   // in scope 0 at src/label.rs:41:9: 41:21
    let mut _39: bool;                   // in scope 0 at src/label.rs:42:9: 42:26
    let mut _40: bool;                   // in scope 0 at src/label.rs:43:9: 43:13
    let mut _41: bool;                   // in scope 0 at src/label.rs:44:9: 44:17
    let mut _42: bool;                   // in scope 0 at src/label.rs:46:9: 46:22
    let mut _43: bool;                   // in scope 0 at src/label.rs:47:9: 47:21
    let mut _44: bool;                   // in scope 0 at src/label.rs:48:9: 48:21
    let mut _45: bool;                   // in scope 0 at src/label.rs:49:9: 49:20
    let mut _46: bool;                   // in scope 0 at src/label.rs:50:9: 50:19
    let mut _47: bool;                   // in scope 0 at src/label.rs:51:9: 51:21
    let mut _48: bool;                   // in scope 0 at src/label.rs:52:9: 52:26
    let mut _49: bool;                   // in scope 0 at src/label.rs:53:9: 53:13
    let mut _50: bool;                   // in scope 0 at src/label.rs:54:9: 54:17
    let mut _51: bool;                   // in scope 0 at src/label.rs:56:9: 56:29
    let mut _52: bool;                   // in scope 0 at src/label.rs:57:9: 57:19
    let mut _53: bool;                   // in scope 0 at src/label.rs:58:9: 58:21
    let mut _54: bool;                   // in scope 0 at src/label.rs:59:9: 59:21
    let mut _55: bool;                   // in scope 0 at src/label.rs:60:9: 60:20
    let mut _56: bool;                   // in scope 0 at src/label.rs:61:9: 61:19
    let mut _57: bool;                   // in scope 0 at src/label.rs:62:9: 62:21
    let mut _58: bool;                   // in scope 0 at src/label.rs:63:9: 63:26
    let mut _59: bool;                   // in scope 0 at src/label.rs:65:9: 65:17
    let mut _60: bool;                   // in scope 0 at src/label.rs:66:9: 66:19
    let mut _61: bool;                   // in scope 0 at src/label.rs:67:9: 67:22
    let mut _62: bool;                   // in scope 0 at src/label.rs:68:9: 68:22
    let mut _63: bool;                   // in scope 0 at src/label.rs:69:9: 69:27
    let mut _64: bool;                   // in scope 0 at src/label.rs:70:9: 70:19
    let mut _65: bool;                   // in scope 0 at src/label.rs:71:9: 71:21
    let mut _66: bool;                   // in scope 0 at src/label.rs:72:9: 72:23
    let mut _67: bool;                   // in scope 0 at src/label.rs:73:9: 73:23
    let mut _68: bool;                   // in scope 0 at src/label.rs:74:9: 74:21
    let mut _69: bool;                   // in scope 0 at src/label.rs:75:9: 75:20
    let mut _70: bool;                   // in scope 0 at src/label.rs:76:9: 76:19
    let mut _71: bool;                   // in scope 0 at src/label.rs:77:9: 77:21
    let mut _72: bool;                   // in scope 0 at src/label.rs:78:9: 78:26
    let mut _73: bool;                   // in scope 0 at src/label.rs:80:9: 80:26
    let mut _74: bool;                   // in scope 0 at src/label.rs:81:9: 81:19
    let mut _75: bool;                   // in scope 0 at src/label.rs:82:9: 82:19
    let mut _76: bool;                   // in scope 0 at src/label.rs:83:9: 83:16
    let mut _77: bool;                   // in scope 0 at src/label.rs:84:9: 84:17
    let mut _78: bool;                   // in scope 0 at src/label.rs:85:9: 85:21
    let mut _79: bool;                   // in scope 0 at src/label.rs:86:9: 86:21
    let mut _80: bool;                   // in scope 0 at src/label.rs:87:9: 87:20
    let mut _81: bool;                   // in scope 0 at src/label.rs:88:9: 88:19
    let mut _82: bool;                   // in scope 0 at src/label.rs:89:9: 89:21
    let mut _83: bool;                   // in scope 0 at src/label.rs:90:9: 90:26
    let mut _84: bool;                   // in scope 0 at src/label.rs:91:9: 91:23
    let mut _85: bool;                   // in scope 0 at src/label.rs:93:9: 93:22
    let mut _86: bool;                   // in scope 0 at src/label.rs:94:9: 94:27
    let mut _87: bool;                   // in scope 0 at src/label.rs:95:9: 95:17
    let mut _88: bool;                   // in scope 0 at src/label.rs:96:9: 96:21
    let mut _89: bool;                   // in scope 0 at src/label.rs:97:9: 97:23
    let mut _90: bool;                   // in scope 0 at src/label.rs:98:9: 98:21
    let mut _91: bool;                   // in scope 0 at src/label.rs:99:9: 99:20
    let mut _92: bool;                   // in scope 0 at src/label.rs:100:9: 100:19
    let mut _93: bool;                   // in scope 0 at src/label.rs:101:9: 101:21
    let mut _94: bool;                   // in scope 0 at src/label.rs:102:9: 102:26
    let mut _95: bool;                   // in scope 0 at src/label.rs:103:9: 103:17
    let mut _96: bool;                   // in scope 0 at src/label.rs:105:9: 105:22
    let mut _97: bool;                   // in scope 0 at src/label.rs:106:9: 106:23
    let mut _98: bool;                   // in scope 0 at src/label.rs:107:9: 107:18
    let mut _99: bool;                   // in scope 0 at src/label.rs:109:9: 109:22
    let mut _100: bool;                  // in scope 0 at src/label.rs:110:9: 110:22
    let mut _101: bool;                  // in scope 0 at src/label.rs:111:9: 111:21
    let mut _102: bool;                  // in scope 0 at src/label.rs:112:9: 112:21
    let mut _103: bool;                  // in scope 0 at src/label.rs:113:9: 113:20
    let mut _104: bool;                  // in scope 0 at src/label.rs:114:9: 114:13
    let mut _105: bool;                  // in scope 0 at src/label.rs:115:9: 115:17
    let mut _106: bool;                  // in scope 0 at src/label.rs:117:9: 117:22
    let mut _107: bool;                  // in scope 0 at src/label.rs:118:9: 118:21
    let mut _108: bool;                  // in scope 0 at src/label.rs:119:9: 119:20
    let mut _109: bool;                  // in scope 0 at src/label.rs:121:9: 121:22
    let mut _110: bool;                  // in scope 0 at src/label.rs:122:9: 122:21
    let mut _111: bool;                  // in scope 0 at src/label.rs:123:9: 123:20
    let mut _112: bool;                  // in scope 0 at src/label.rs:125:9: 125:22
    let mut _113: bool;                  // in scope 0 at src/label.rs:126:9: 126:22
    let mut _114: bool;                  // in scope 0 at src/label.rs:127:9: 127:21
    let mut _115: bool;                  // in scope 0 at src/label.rs:128:9: 128:20
    let mut _116: bool;                  // in scope 0 at src/label.rs:129:9: 129:22
    let mut _117: bool;                  // in scope 0 at src/label.rs:130:9: 130:13
    let mut _118: bool;                  // in scope 0 at src/label.rs:132:9: 132:22
    let mut _119: bool;                  // in scope 0 at src/label.rs:134:9: 134:18
    let mut _120: bool;                  // in scope 0 at src/label.rs:135:9: 135:14
    let mut _121: bool;                  // in scope 0 at src/label.rs:136:9: 136:15
    let mut _122: bool;                  // in scope 0 at src/label.rs:137:9: 137:17
    let mut _123: bool;                  // in scope 0 at src/label.rs:138:9: 138:17
    let mut _124: bool;                  // in scope 0 at src/label.rs:140:9: 140:18
    let mut _125: bool;                  // in scope 0 at src/label.rs:141:9: 141:17
    let mut _126: bool;                  // in scope 0 at src/label.rs:143:9: 143:22
    let mut _127: bool;                  // in scope 0 at src/label.rs:144:9: 144:14
    let mut _128: bool;                  // in scope 0 at src/label.rs:145:9: 145:20
    let mut _129: bool;                  // in scope 0 at src/label.rs:146:9: 146:22
    let mut _130: bool;                  // in scope 0 at src/label.rs:148:9: 148:18
    let mut _131: bool;                  // in scope 0 at src/label.rs:149:9: 149:22
    let mut _132: bool;                  // in scope 0 at src/label.rs:150:9: 150:21
    let mut _133: bool;                  // in scope 0 at src/label.rs:151:9: 151:20
    let mut _134: bool;                  // in scope 0 at src/label.rs:152:9: 152:18
    let mut _135: bool;                  // in scope 0 at src/label.rs:153:9: 153:22
    let mut _136: bool;                  // in scope 0 at src/label.rs:155:9: 155:17
    let mut _137: bool;                  // in scope 0 at src/label.rs:156:9: 156:23
    let mut _138: bool;                  // in scope 0 at src/label.rs:157:9: 157:19
    let mut _139: bool;                  // in scope 0 at src/label.rs:159:9: 159:17
    let mut _140: bool;                  // in scope 0 at src/label.rs:160:9: 160:23
    let mut _141: bool;                  // in scope 0 at src/label.rs:161:9: 161:19
    let mut _142: bool;                  // in scope 0 at src/label.rs:163:9: 163:25
    let mut _143: bool;                  // in scope 0 at src/label.rs:164:9: 164:16
    let mut _144: bool;                  // in scope 0 at src/label.rs:165:9: 165:17
    let mut _145: bool;                  // in scope 0 at src/label.rs:166:9: 166:16
    let mut _146: bool;                  // in scope 0 at src/label.rs:167:9: 167:22
    let mut _147: bool;                  // in scope 0 at src/label.rs:168:9: 168:17
    let mut _148: bool;                  // in scope 0 at src/label.rs:169:9: 169:21
    let mut _149: bool;                  // in scope 0 at src/label.rs:170:9: 170:21
    let mut _150: bool;                  // in scope 0 at src/label.rs:171:9: 171:20
    let mut _151: bool;                  // in scope 0 at src/label.rs:172:9: 172:19
    let mut _152: bool;                  // in scope 0 at src/label.rs:173:9: 173:21
    let mut _153: bool;                  // in scope 0 at src/label.rs:174:9: 174:26
    let mut _154: bool;                  // in scope 0 at src/label.rs:175:9: 175:13
    let mut _155: bool;                  // in scope 0 at src/label.rs:176:9: 176:17
    let mut _156: bool;                  // in scope 0 at src/label.rs:177:9: 177:19
    let mut _157: bool;                  // in scope 0 at src/label.rs:178:9: 178:23
    let mut _158: bool;                  // in scope 0 at src/label.rs:179:9: 179:19
    let mut _159: bool;                  // in scope 0 at src/label.rs:181:9: 181:17
    let mut _160: bool;                  // in scope 0 at src/label.rs:182:9: 182:23
    let mut _161: bool;                  // in scope 0 at src/label.rs:183:9: 183:19
    let mut _162: bool;                  // in scope 0 at src/label.rs:185:9: 185:17
    let mut _163: bool;                  // in scope 0 at src/label.rs:186:9: 186:22
    let mut _164: bool;                  // in scope 0 at src/label.rs:187:9: 187:21
    let mut _165: bool;                  // in scope 0 at src/label.rs:188:9: 188:21
    let mut _166: bool;                  // in scope 0 at src/label.rs:189:9: 189:20
    let mut _167: bool;                  // in scope 0 at src/label.rs:190:9: 190:19
    let mut _168: bool;                  // in scope 0 at src/label.rs:191:9: 191:21
    let mut _169: bool;                  // in scope 0 at src/label.rs:192:9: 192:26
    let mut _170: bool;                  // in scope 0 at src/label.rs:193:9: 193:13
    let mut _171: bool;                  // in scope 0 at src/label.rs:194:9: 194:17
    let mut _172: bool;                  // in scope 0 at src/label.rs:195:9: 195:23
    let mut _173: bool;                  // in scope 0 at src/label.rs:196:9: 196:19
    let mut _174: bool;                  // in scope 0 at src/label.rs:198:9: 198:17
    let mut _175: bool;                  // in scope 0 at src/label.rs:199:9: 199:23
    let mut _176: bool;                  // in scope 0 at src/label.rs:200:9: 200:19
    let mut _177: bool;                  // in scope 0 at src/label.rs:202:9: 202:17
    let mut _178: bool;                  // in scope 0 at src/label.rs:203:9: 203:23
    let mut _179: bool;                  // in scope 0 at src/label.rs:204:9: 204:19
    let mut _180: bool;                  // in scope 0 at src/label.rs:206:9: 206:17
    let mut _181: bool;                  // in scope 0 at src/label.rs:207:9: 207:23
    let mut _182: bool;                  // in scope 0 at src/label.rs:208:9: 208:19
    let mut _183: bool;                  // in scope 0 at src/label.rs:210:9: 210:17
    let mut _184: bool;                  // in scope 0 at src/label.rs:211:9: 211:23
    let mut _185: bool;                  // in scope 0 at src/label.rs:212:9: 212:19
    let mut _186: bool;                  // in scope 0 at src/label.rs:214:9: 214:25
    let mut _187: bool;                  // in scope 0 at src/label.rs:215:9: 215:26
    let mut _188: bool;                  // in scope 0 at src/label.rs:217:9: 217:18
    let mut _189: bool;                  // in scope 0 at src/label.rs:218:9: 218:19
    let mut _190: bool;                  // in scope 0 at src/label.rs:219:9: 219:26
    let mut _191: bool;                  // in scope 0 at src/label.rs:220:9: 220:17
    let mut _192: bool;                  // in scope 0 at src/label.rs:221:9: 221:18
    let mut _193: bool;                  // in scope 0 at src/label.rs:222:9: 222:21
    let mut _194: bool;                  // in scope 0 at src/label.rs:223:9: 223:14
    let mut _195: bool;                  // in scope 0 at src/label.rs:224:9: 224:20
    let mut _196: bool;                  // in scope 0 at src/label.rs:225:9: 225:16
    let mut _197: bool;                  // in scope 0 at src/label.rs:227:9: 227:18
    let mut _198: bool;                  // in scope 0 at src/label.rs:229:9: 229:15
    let mut _199: bool;                  // in scope 0 at src/label.rs:230:9: 230:21
    let mut _200: bool;                  // in scope 0 at src/label.rs:231:9: 231:18
    let mut _201: bool;                  // in scope 0 at src/label.rs:232:9: 232:17
    let mut _202: bool;                  // in scope 0 at src/label.rs:233:9: 233:19
    let mut _203: bool;                  // in scope 0 at src/label.rs:235:9: 235:30
    let mut _204: bool;                  // in scope 0 at src/label.rs:236:9: 236:17
    let mut _205: bool;                  // in scope 0 at src/label.rs:237:9: 237:19
    let mut _206: bool;                  // in scope 0 at src/label.rs:239:9: 239:22
    let mut _207: bool;                  // in scope 0 at src/label.rs:240:9: 240:22
    let mut _208: bool;                  // in scope 0 at src/label.rs:242:9: 242:21
    let mut _209: bool;                  // in scope 0 at src/label.rs:243:9: 243:16
    let mut _210: bool;                  // in scope 0 at src/label.rs:244:9: 244:19
    let mut _211: bool;                  // in scope 0 at src/label.rs:245:9: 245:20
    let mut _212: bool;                  // in scope 0 at src/label.rs:246:9: 246:20
    let mut _213: bool;                  // in scope 0 at src/label.rs:247:9: 247:15
    let mut _214: bool;                  // in scope 0 at src/label.rs:248:9: 248:22
    let mut _215: bool;                  // in scope 0 at src/label.rs:249:9: 249:17
    let mut _216: bool;                  // in scope 0 at src/label.rs:251:9: 251:18
    let mut _217: bool;                  // in scope 0 at src/label.rs:252:9: 252:24
    let mut _218: bool;                  // in scope 0 at src/label.rs:253:9: 253:17
    let mut _219: bool;                  // in scope 0 at src/label.rs:254:9: 254:21
    let mut _220: bool;                  // in scope 0 at src/label.rs:255:9: 255:17
    let mut _221: bool;                  // in scope 0 at src/label.rs:256:9: 256:25
    let mut _222: bool;                  // in scope 0 at src/label.rs:257:9: 257:25
    let mut _223: bool;                  // in scope 0 at src/label.rs:258:9: 258:18
    let mut _224: bool;                  // in scope 0 at src/label.rs:259:9: 259:19
    let mut _225: bool;                  // in scope 0 at src/label.rs:260:9: 260:22
    let mut _226: bool;                  // in scope 0 at src/label.rs:262:9: 262:22
    let mut _227: bool;                  // in scope 0 at src/label.rs:263:9: 263:21
    let mut _228: bool;                  // in scope 0 at src/label.rs:264:9: 264:22
    let mut _229: bool;                  // in scope 0 at src/label.rs:265:9: 265:22
    let mut _230: bool;                  // in scope 0 at src/label.rs:266:9: 266:26
    let mut _231: bool;                  // in scope 0 at src/label.rs:268:9: 268:19
    let mut _232: bool;                  // in scope 0 at src/label.rs:270:9: 270:17
    let mut _233: bool;                  // in scope 0 at src/label.rs:271:9: 271:19
    let mut _234: bool;                  // in scope 0 at src/label.rs:273:9: 273:25
    let mut _235: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:20:18: 20:43
    let mut _236: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:20:18: 20:43
    let _237: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:20:18: 20:43
    let mut _238: &codec::utf_8::UTF8Encoding; // in scope 0 at src/label.rs:20:18: 20:28
    let _239: &codec::utf_8::UTF8Encoding; // in scope 0 at src/label.rs:20:18: 20:28
    let mut _240: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:25:18: 25:44
    let mut _241: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:25:18: 25:44
    let _242: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:25:18: 25:44
    let mut _243: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:25:18: 25:29
    let _244: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:25:18: 25:29
    let mut _245: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:35:18: 35:48
    let mut _246: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:35:18: 35:48
    let _247: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:35:18: 35:48
    let mut _248: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:35:18: 35:33
    let _249: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:35:18: 35:33
    let mut _250: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:45:18: 45:48
    let mut _251: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:45:18: 45:48
    let _252: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:45:18: 45:48
    let mut _253: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:45:18: 45:33
    let _254: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:45:18: 45:33
    let mut _255: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:55:18: 55:48
    let mut _256: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:55:18: 55:48
    let _257: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:55:18: 55:48
    let mut _258: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:55:18: 55:33
    let _259: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:55:18: 55:33
    let mut _260: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:64:18: 64:48
    let mut _261: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:64:18: 64:48
    let _262: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:64:18: 64:48
    let mut _263: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:64:18: 64:33
    let _264: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:64:18: 64:33
    let mut _265: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:79:18: 79:48
    let mut _266: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:79:18: 79:48
    let _267: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:79:18: 79:48
    let mut _268: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:79:18: 79:33
    let _269: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:79:18: 79:33
    let mut _270: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:92:18: 92:48
    let mut _271: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:92:18: 92:48
    let _272: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:92:18: 92:48
    let mut _273: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:92:18: 92:33
    let _274: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:92:18: 92:33
    let mut _275: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:104:18: 104:48
    let mut _276: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:104:18: 104:48
    let _277: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:104:18: 104:48
    let mut _278: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:104:18: 104:33
    let _279: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:104:18: 104:33
    let mut _280: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:108:18: 108:58
    let mut _281: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:108:18: 108:58
    let _282: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:108:18: 108:58
    let mut _283: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:108:18: 108:43
    let _284: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:108:18: 108:43
    let mut _285: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:116:18: 116:49
    let mut _286: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:116:18: 116:49
    let _287: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:116:18: 116:49
    let mut _288: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:116:18: 116:34
    let _289: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:116:18: 116:34
    let mut _290: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:120:18: 120:49
    let mut _291: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:120:18: 120:49
    let _292: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:120:18: 120:49
    let mut _293: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:120:18: 120:34
    let _294: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:120:18: 120:34
    let mut _295: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:124:18: 124:49
    let mut _296: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:124:18: 124:49
    let _297: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:124:18: 124:49
    let mut _298: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:124:18: 124:34
    let _299: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:124:18: 124:34
    let mut _300: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:131:18: 131:49
    let mut _301: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:131:18: 131:49
    let _302: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:131:18: 131:49
    let mut _303: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:131:18: 131:34
    let _304: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:131:18: 131:34
    let mut _305: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:133:18: 133:49
    let mut _306: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:133:18: 133:49
    let _307: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:133:18: 133:49
    let mut _308: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:133:18: 133:34
    let _309: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:133:18: 133:34
    let mut _310: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:139:18: 139:44
    let mut _311: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:139:18: 139:44
    let _312: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:139:18: 139:44
    let mut _313: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:139:18: 139:29
    let _314: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:139:18: 139:29
    let mut _315: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:142:18: 142:44
    let mut _316: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:142:18: 142:44
    let _317: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:142:18: 142:44
    let mut _318: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:142:18: 142:29
    let _319: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:142:18: 142:29
    let mut _320: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:147:18: 147:47
    let mut _321: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:147:18: 147:47
    let _322: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:147:18: 147:47
    let mut _323: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:147:18: 147:32
    let _324: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:147:18: 147:32
    let mut _325: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:154:18: 154:49
    let mut _326: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:154:18: 154:49
    let _327: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:154:18: 154:49
    let mut _328: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:154:18: 154:34
    let _329: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:154:18: 154:34
    let mut _330: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:158:18: 158:50
    let mut _331: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:158:18: 158:50
    let _332: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:158:18: 158:50
    let mut _333: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:158:18: 158:35
    let _334: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:158:18: 158:35
    let mut _335: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:162:18: 162:50
    let mut _336: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:162:18: 162:50
    let _337: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:162:18: 162:50
    let mut _338: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:162:18: 162:35
    let _339: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:162:18: 162:35
    let mut _340: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:180:18: 180:50
    let mut _341: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:180:18: 180:50
    let _342: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:180:18: 180:50
    let mut _343: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:180:18: 180:35
    let _344: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:180:18: 180:35
    let mut _345: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:184:18: 184:50
    let mut _346: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:184:18: 184:50
    let _347: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:184:18: 184:50
    let mut _348: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:184:18: 184:35
    let _349: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:184:18: 184:35
    let mut _350: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:197:18: 197:50
    let mut _351: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:197:18: 197:50
    let _352: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:197:18: 197:50
    let mut _353: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:197:18: 197:35
    let _354: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:197:18: 197:35
    let mut _355: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:201:18: 201:50
    let mut _356: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:201:18: 201:50
    let _357: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:201:18: 201:50
    let mut _358: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:201:18: 201:35
    let _359: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:201:18: 201:35
    let mut _360: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:205:18: 205:50
    let mut _361: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:205:18: 205:50
    let _362: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:205:18: 205:50
    let mut _363: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:205:18: 205:35
    let _364: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:205:18: 205:35
    let mut _365: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:209:18: 209:50
    let mut _366: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:209:18: 209:50
    let _367: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:209:18: 209:50
    let mut _368: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:209:18: 209:35
    let _369: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:209:18: 209:35
    let mut _370: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:213:18: 213:50
    let mut _371: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:213:18: 213:50
    let _372: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:213:18: 213:50
    let mut _373: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:213:18: 213:35
    let _374: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:213:18: 213:35
    let mut _375: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:216:18: 216:50
    let mut _376: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:216:18: 216:50
    let _377: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:216:18: 216:50
    let mut _378: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:216:18: 216:35
    let _379: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:216:18: 216:35
    let mut _380: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:226:18: 226:41
    let mut _381: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:226:18: 226:41
    let _382: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:226:18: 226:41
    let mut _383: &codec::simpchinese::GBKEncoding; // in scope 0 at src/label.rs:226:18: 226:26
    let _384: &codec::simpchinese::GBKEncoding; // in scope 0 at src/label.rs:226:18: 226:26
    let mut _385: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:228:18: 228:45
    let mut _386: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:228:18: 228:45
    let _387: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:228:18: 228:45
    let mut _388: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/label.rs:228:18: 228:30
    let _389: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/label.rs:228:18: 228:30
    let mut _390: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:234:18: 234:47
    let mut _391: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:234:18: 234:47
    let _392: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:234:18: 234:47
    let mut _393: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/label.rs:234:18: 234:32
    let _394: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/label.rs:234:18: 234:32
    let mut _395: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:238:18: 238:44
    let mut _396: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:238:18: 238:44
    let _397: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:238:18: 238:44
    let mut _398: &codec::japanese::EUCJPEncoding; // in scope 0 at src/label.rs:238:18: 238:29
    let _399: &codec::japanese::EUCJPEncoding; // in scope 0 at src/label.rs:238:18: 238:29
    let mut _400: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:241:18: 241:49
    let mut _401: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:241:18: 241:49
    let _402: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:241:18: 241:49
    let mut _403: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/label.rs:241:18: 241:34
    let _404: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/label.rs:241:18: 241:34
    let mut _405: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:250:18: 250:49
    let mut _406: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:250:18: 250:49
    let _407: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:250:18: 250:49
    let mut _408: &codec::japanese::Windows31JEncoding; // in scope 0 at src/label.rs:250:18: 250:34
    let _409: &codec::japanese::Windows31JEncoding; // in scope 0 at src/label.rs:250:18: 250:34
    let mut _410: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:261:18: 261:49
    let mut _411: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:261:18: 261:49
    let _412: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:261:18: 261:49
    let mut _413: &codec::korean::Windows949Encoding; // in scope 0 at src/label.rs:261:18: 261:34
    let _414: &codec::korean::Windows949Encoding; // in scope 0 at src/label.rs:261:18: 261:34
    let mut _415: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:267:18: 267:57
    let mut _416: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:267:18: 267:57
    let _417: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:267:18: 267:57
    let mut _418: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/label.rs:267:18: 267:42
    let _419: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/label.rs:267:18: 267:42
    let mut _420: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:269:18: 269:46
    let mut _421: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:269:18: 269:46
    let _422: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:269:18: 269:46
    let mut _423: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/label.rs:269:18: 269:31
    let _424: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/label.rs:269:18: 269:31
    let mut _425: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:272:18: 272:46
    let mut _426: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:272:18: 272:46
    let _427: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:272:18: 272:46
    let mut _428: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/label.rs:272:18: 272:31
    let _429: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/label.rs:272:18: 272:31
    let mut _430: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:274:18: 274:60
    let mut _431: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:274:18: 274:60
    let _432: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:274:18: 274:60
    let mut _433: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:274:18: 274:45
    let _434: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:274:18: 274:45
    let mut _435: &[char; 5];            // in scope 0 at src/label.rs:13:37: 13:68
    scope 1 {
        debug label => _2;               // in scope 1 at src/label.rs:13:9: 13:14
        let _8: std::string::String;     // in scope 1 at src/label.rs:14:9: 14:14
        scope 2 {
            debug label => _8;           // in scope 2 at src/label.rs:14:9: 14:14
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/label.rs:13:9: 13:14
        StorageLive(_3);                 // scope 0 at src/label.rs:13:17: 13:22
        _3 = _1;                         // scope 0 at src/label.rs:13:17: 13:22
        StorageLive(_4);                 // scope 0 at src/label.rs:13:36: 13:72
        StorageLive(_5);                 // scope 0 at src/label.rs:13:37: 13:72
        StorageLive(_6);                 // scope 0 at src/label.rs:13:37: 13:68
        _435 = const encoding_from_whatwg_label::promoted[0]; // scope 0 at src/label.rs:13:37: 13:68
                                         // ty::Const
                                         // + ty: &[char; 5]
                                         // + val: Unevaluated(encoding_from_whatwg_label, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/label.rs:13:37: 13:68
                                         // + literal: Const { ty: &[char; 5], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:589 ~ encoding[5d2c]::label::encoding_from_whatwg_label), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _6 = _435;                       // scope 0 at src/label.rs:13:37: 13:68
        StorageLive(_7);                 // scope 0 at src/label.rs:13:69: 13:71
        _5 = <[char; 5] as Index<RangeFull>>::index(move _6, move _7) -> bb1; // scope 0 at src/label.rs:13:37: 13:72
                                         // mir::Constant
                                         // + span: src/label.rs:13:37: 13:72
                                         // + literal: Const { ty: for<'r> fn(&'r [char; 5], std::ops::RangeFull) -> &'r <[char; 5] as std::ops::Index<std::ops::RangeFull>>::Output {<[char; 5] as std::ops::Index<std::ops::RangeFull>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/label.rs:13:71: 13:72
        StorageDead(_6);                 // scope 0 at src/label.rs:13:71: 13:72
        _4 = _5;                         // scope 0 at src/label.rs:13:36: 13:72
        _2 = core::str::<impl str>::trim_matches::<&[char]>(move _3, move _4) -> bb2; // scope 0 at src/label.rs:13:17: 13:73
                                         // mir::Constant
                                         // + span: src/label.rs:13:23: 13:35
                                         // + literal: Const { ty: fn(&str, &[char]) -> &str {core::str::<impl str>::trim_matches::<&[char]>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_4);                 // scope 0 at src/label.rs:13:72: 13:73
        StorageDead(_3);                 // scope 0 at src/label.rs:13:72: 13:73
        StorageDead(_5);                 // scope 0 at src/label.rs:13:73: 13:74
        StorageLive(_8);                 // scope 1 at src/label.rs:14:9: 14:14
        StorageLive(_9);                 // scope 1 at src/label.rs:15:9: 15:87
        StorageLive(_10);                // scope 1 at src/label.rs:15:9: 15:22
        StorageLive(_11);                // scope 1 at src/label.rs:15:9: 15:14
        _11 = _2;                        // scope 1 at src/label.rs:15:9: 15:14
        _10 = core::str::<impl str>::chars(move _11) -> bb3; // scope 1 at src/label.rs:15:9: 15:22
                                         // mir::Constant
                                         // + span: src/label.rs:15:15: 15:20
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> std::str::Chars<'r> {core::str::<impl str>::chars}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_11);                // scope 1 at src/label.rs:15:21: 15:22
        StorageLive(_12);                // scope 1 at src/label.rs:15:27: 15:86
        _9 = <Chars as Iterator>::map::<char, [closure@src/label.rs:15:27: 15:86]>(move _10, move _12) -> bb4; // scope 1 at src/label.rs:15:9: 15:87
                                         // mir::Constant
                                         // + span: src/label.rs:15:23: 15:26
                                         // + literal: Const { ty: fn(std::str::Chars, [closure@src/label.rs:15:27: 15:86]) -> std::iter::Map<std::str::Chars, [closure@src/label.rs:15:27: 15:86]> {<std::str::Chars as std::iter::Iterator>::map::<char, [closure@src/label.rs:15:27: 15:86]>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_12);                // scope 1 at src/label.rs:15:86: 15:87
        StorageDead(_10);                // scope 1 at src/label.rs:15:86: 15:87
        _8 = <Map<Chars, [closure@src/label.rs:15:27: 15:86]> as Iterator>::collect::<String>(move _9) -> bb5; // scope 1 at src/label.rs:15:9: 15:97
                                         // mir::Constant
                                         // + span: src/label.rs:15:88: 15:95
                                         // + literal: Const { ty: fn(std::iter::Map<std::str::Chars, [closure@src/label.rs:15:27: 15:86]>) -> std::string::String {<std::iter::Map<std::str::Chars, [closure@src/label.rs:15:27: 15:86]> as std::iter::Iterator>::collect::<std::string::String>}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        StorageDead(_9);                 // scope 1 at src/label.rs:15:96: 15:97
        StorageLive(_13);                // scope 2 at src/label.rs:16:11: 16:21
        StorageLive(_14);                // scope 2 at src/label.rs:16:12: 16:21
        StorageLive(_15);                // scope 2 at src/label.rs:16:12: 16:17
        _15 = &_8;                       // scope 2 at src/label.rs:16:12: 16:17
        StorageLive(_16);                // scope 2 at src/label.rs:16:18: 16:20
        _14 = <String as Index<RangeFull>>::index(move _15, move _16) -> [return: bb6, unwind: bb485]; // scope 2 at src/label.rs:16:12: 16:21
                                         // mir::Constant
                                         // + span: src/label.rs:16:12: 16:21
                                         // + literal: Const { ty: for<'r> fn(&'r std::string::String, std::ops::RangeFull) -> &'r <std::string::String as std::ops::Index<std::ops::RangeFull>>::Output {<std::string::String as std::ops::Index<std::ops::RangeFull>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_16);                // scope 2 at src/label.rs:16:20: 16:21
        StorageDead(_15);                // scope 2 at src/label.rs:16:20: 16:21
        _13 = _14;                       // scope 2 at src/label.rs:16:11: 16:21
        _17 = <str as PartialEq>::eq(_13, const "unicode-1-1-utf-8") -> [return: bb7, unwind: bb485]; // scope 2 at src/label.rs:17:9: 17:28
                                         // mir::Constant
                                         // + span: src/label.rs:17:9: 17:28
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 105, 99, 111, 100, 101, 45, 49, 45, 49, 45, 117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [131071], len: Size { raw: 17 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 17 })
                                         // mir::Constant
                                         // + span: src/label.rs:17:9: 17:28
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 105, 99, 111, 100, 101, 45, 49, 45, 49, 45, 117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [131071], len: Size { raw: 17 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 17 }) }
    }

    bb7: {
        switchInt(move _17) -> [false: bb8, otherwise: bb443]; // scope 2 at src/label.rs:17:9: 17:28
    }

    bb8: {
        _18 = <str as PartialEq>::eq(_13, const "utf-8") -> [return: bb9, unwind: bb485]; // scope 2 at src/label.rs:18:9: 18:16
                                         // mir::Constant
                                         // + span: src/label.rs:18:9: 18:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:18:9: 18:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb9: {
        switchInt(move _18) -> [false: bb10, otherwise: bb443]; // scope 2 at src/label.rs:18:9: 18:16
    }

    bb10: {
        _19 = <str as PartialEq>::eq(_13, const "utf8") -> [return: bb11, unwind: bb485]; // scope 2 at src/label.rs:19:9: 19:15
                                         // mir::Constant
                                         // + span: src/label.rs:19:9: 19:15
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/label.rs:19:9: 19:15
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
    }

    bb11: {
        switchInt(move _19) -> [false: bb12, otherwise: bb443]; // scope 2 at src/label.rs:19:9: 19:15
    }

    bb12: {
        _20 = <str as PartialEq>::eq(_13, const "866") -> [return: bb13, unwind: bb485]; // scope 2 at src/label.rs:21:9: 21:14
                                         // mir::Constant
                                         // + span: src/label.rs:21:9: 21:14
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 })
                                         // mir::Constant
                                         // + span: src/label.rs:21:9: 21:14
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 }) }
    }

    bb13: {
        switchInt(move _20) -> [false: bb14, otherwise: bb444]; // scope 2 at src/label.rs:21:9: 21:14
    }

    bb14: {
        _21 = <str as PartialEq>::eq(_13, const "cp866") -> [return: bb15, unwind: bb485]; // scope 2 at src/label.rs:22:9: 22:16
                                         // mir::Constant
                                         // + span: src/label.rs:22:9: 22:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:22:9: 22:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb15: {
        switchInt(move _21) -> [false: bb16, otherwise: bb444]; // scope 2 at src/label.rs:22:9: 22:16
    }

    bb16: {
        _22 = <str as PartialEq>::eq(_13, const "csibm866") -> [return: bb17, unwind: bb485]; // scope 2 at src/label.rs:23:9: 23:19
                                         // mir::Constant
                                         // + span: src/label.rs:23:9: 23:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:23:9: 23:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb17: {
        switchInt(move _22) -> [false: bb18, otherwise: bb444]; // scope 2 at src/label.rs:23:9: 23:19
    }

    bb18: {
        _23 = <str as PartialEq>::eq(_13, const "ibm866") -> [return: bb19, unwind: bb485]; // scope 2 at src/label.rs:24:9: 24:17
                                         // mir::Constant
                                         // + span: src/label.rs:24:9: 24:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:24:9: 24:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb19: {
        switchInt(move _23) -> [false: bb20, otherwise: bb444]; // scope 2 at src/label.rs:24:9: 24:17
    }

    bb20: {
        _24 = <str as PartialEq>::eq(_13, const "csisolatin2") -> [return: bb21, unwind: bb485]; // scope 2 at src/label.rs:26:9: 26:22
                                         // mir::Constant
                                         // + span: src/label.rs:26:9: 26:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:26:9: 26:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb21: {
        switchInt(move _24) -> [false: bb22, otherwise: bb445]; // scope 2 at src/label.rs:26:9: 26:22
    }

    bb22: {
        _25 = <str as PartialEq>::eq(_13, const "iso-8859-2") -> [return: bb23, unwind: bb485]; // scope 2 at src/label.rs:27:9: 27:21
                                         // mir::Constant
                                         // + span: src/label.rs:27:9: 27:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:27:9: 27:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb23: {
        switchInt(move _25) -> [false: bb24, otherwise: bb445]; // scope 2 at src/label.rs:27:9: 27:21
    }

    bb24: {
        _26 = <str as PartialEq>::eq(_13, const "iso-ir-101") -> [return: bb25, unwind: bb485]; // scope 2 at src/label.rs:28:9: 28:21
                                         // mir::Constant
                                         // + span: src/label.rs:28:9: 28:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 48, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:28:9: 28:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 48, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb25: {
        switchInt(move _26) -> [false: bb26, otherwise: bb445]; // scope 2 at src/label.rs:28:9: 28:21
    }

    bb26: {
        _27 = <str as PartialEq>::eq(_13, const "iso8859-2") -> [return: bb27, unwind: bb485]; // scope 2 at src/label.rs:29:9: 29:20
                                         // mir::Constant
                                         // + span: src/label.rs:29:9: 29:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:29:9: 29:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb27: {
        switchInt(move _27) -> [false: bb28, otherwise: bb445]; // scope 2 at src/label.rs:29:9: 29:20
    }

    bb28: {
        _28 = <str as PartialEq>::eq(_13, const "iso88592") -> [return: bb29, unwind: bb485]; // scope 2 at src/label.rs:30:9: 30:19
                                         // mir::Constant
                                         // + span: src/label.rs:30:9: 30:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:30:9: 30:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb29: {
        switchInt(move _28) -> [false: bb30, otherwise: bb445]; // scope 2 at src/label.rs:30:9: 30:19
    }

    bb30: {
        _29 = <str as PartialEq>::eq(_13, const "iso_8859-2") -> [return: bb31, unwind: bb485]; // scope 2 at src/label.rs:31:9: 31:21
                                         // mir::Constant
                                         // + span: src/label.rs:31:9: 31:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:31:9: 31:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb31: {
        switchInt(move _29) -> [false: bb32, otherwise: bb445]; // scope 2 at src/label.rs:31:9: 31:21
    }

    bb32: {
        _30 = <str as PartialEq>::eq(_13, const "iso_8859-2:1987") -> [return: bb33, unwind: bb485]; // scope 2 at src/label.rs:32:9: 32:26
                                         // mir::Constant
                                         // + span: src/label.rs:32:9: 32:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 50, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:32:9: 32:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 50, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb33: {
        switchInt(move _30) -> [false: bb34, otherwise: bb445]; // scope 2 at src/label.rs:32:9: 32:26
    }

    bb34: {
        _31 = <str as PartialEq>::eq(_13, const "l2") -> [return: bb35, unwind: bb485]; // scope 2 at src/label.rs:33:9: 33:13
                                         // mir::Constant
                                         // + span: src/label.rs:33:9: 33:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:33:9: 33:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb35: {
        switchInt(move _31) -> [false: bb36, otherwise: bb445]; // scope 2 at src/label.rs:33:9: 33:13
    }

    bb36: {
        _32 = <str as PartialEq>::eq(_13, const "latin2") -> [return: bb37, unwind: bb485]; // scope 2 at src/label.rs:34:9: 34:17
                                         // mir::Constant
                                         // + span: src/label.rs:34:9: 34:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:34:9: 34:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb37: {
        switchInt(move _32) -> [false: bb38, otherwise: bb445]; // scope 2 at src/label.rs:34:9: 34:17
    }

    bb38: {
        _33 = <str as PartialEq>::eq(_13, const "csisolatin3") -> [return: bb39, unwind: bb485]; // scope 2 at src/label.rs:36:9: 36:22
                                         // mir::Constant
                                         // + span: src/label.rs:36:9: 36:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:36:9: 36:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb39: {
        switchInt(move _33) -> [false: bb40, otherwise: bb446]; // scope 2 at src/label.rs:36:9: 36:22
    }

    bb40: {
        _34 = <str as PartialEq>::eq(_13, const "iso-8859-3") -> [return: bb41, unwind: bb485]; // scope 2 at src/label.rs:37:9: 37:21
                                         // mir::Constant
                                         // + span: src/label.rs:37:9: 37:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:37:9: 37:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb41: {
        switchInt(move _34) -> [false: bb42, otherwise: bb446]; // scope 2 at src/label.rs:37:9: 37:21
    }

    bb42: {
        _35 = <str as PartialEq>::eq(_13, const "iso-ir-109") -> [return: bb43, unwind: bb485]; // scope 2 at src/label.rs:38:9: 38:21
                                         // mir::Constant
                                         // + span: src/label.rs:38:9: 38:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 48, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:38:9: 38:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 48, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb43: {
        switchInt(move _35) -> [false: bb44, otherwise: bb446]; // scope 2 at src/label.rs:38:9: 38:21
    }

    bb44: {
        _36 = <str as PartialEq>::eq(_13, const "iso8859-3") -> [return: bb45, unwind: bb485]; // scope 2 at src/label.rs:39:9: 39:20
                                         // mir::Constant
                                         // + span: src/label.rs:39:9: 39:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:39:9: 39:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb45: {
        switchInt(move _36) -> [false: bb46, otherwise: bb446]; // scope 2 at src/label.rs:39:9: 39:20
    }

    bb46: {
        _37 = <str as PartialEq>::eq(_13, const "iso88593") -> [return: bb47, unwind: bb485]; // scope 2 at src/label.rs:40:9: 40:19
                                         // mir::Constant
                                         // + span: src/label.rs:40:9: 40:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:40:9: 40:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb47: {
        switchInt(move _37) -> [false: bb48, otherwise: bb446]; // scope 2 at src/label.rs:40:9: 40:19
    }

    bb48: {
        _38 = <str as PartialEq>::eq(_13, const "iso_8859-3") -> [return: bb49, unwind: bb485]; // scope 2 at src/label.rs:41:9: 41:21
                                         // mir::Constant
                                         // + span: src/label.rs:41:9: 41:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:41:9: 41:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb49: {
        switchInt(move _38) -> [false: bb50, otherwise: bb446]; // scope 2 at src/label.rs:41:9: 41:21
    }

    bb50: {
        _39 = <str as PartialEq>::eq(_13, const "iso_8859-3:1988") -> [return: bb51, unwind: bb485]; // scope 2 at src/label.rs:42:9: 42:26
                                         // mir::Constant
                                         // + span: src/label.rs:42:9: 42:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 51, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:42:9: 42:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 51, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb51: {
        switchInt(move _39) -> [false: bb52, otherwise: bb446]; // scope 2 at src/label.rs:42:9: 42:26
    }

    bb52: {
        _40 = <str as PartialEq>::eq(_13, const "l3") -> [return: bb53, unwind: bb485]; // scope 2 at src/label.rs:43:9: 43:13
                                         // mir::Constant
                                         // + span: src/label.rs:43:9: 43:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:43:9: 43:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb53: {
        switchInt(move _40) -> [false: bb54, otherwise: bb446]; // scope 2 at src/label.rs:43:9: 43:13
    }

    bb54: {
        _41 = <str as PartialEq>::eq(_13, const "latin3") -> [return: bb55, unwind: bb485]; // scope 2 at src/label.rs:44:9: 44:17
                                         // mir::Constant
                                         // + span: src/label.rs:44:9: 44:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:44:9: 44:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb55: {
        switchInt(move _41) -> [false: bb56, otherwise: bb446]; // scope 2 at src/label.rs:44:9: 44:17
    }

    bb56: {
        _42 = <str as PartialEq>::eq(_13, const "csisolatin4") -> [return: bb57, unwind: bb485]; // scope 2 at src/label.rs:46:9: 46:22
                                         // mir::Constant
                                         // + span: src/label.rs:46:9: 46:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:46:9: 46:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb57: {
        switchInt(move _42) -> [false: bb58, otherwise: bb447]; // scope 2 at src/label.rs:46:9: 46:22
    }

    bb58: {
        _43 = <str as PartialEq>::eq(_13, const "iso-8859-4") -> [return: bb59, unwind: bb485]; // scope 2 at src/label.rs:47:9: 47:21
                                         // mir::Constant
                                         // + span: src/label.rs:47:9: 47:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:47:9: 47:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb59: {
        switchInt(move _43) -> [false: bb60, otherwise: bb447]; // scope 2 at src/label.rs:47:9: 47:21
    }

    bb60: {
        _44 = <str as PartialEq>::eq(_13, const "iso-ir-110") -> [return: bb61, unwind: bb485]; // scope 2 at src/label.rs:48:9: 48:21
                                         // mir::Constant
                                         // + span: src/label.rs:48:9: 48:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:48:9: 48:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb61: {
        switchInt(move _44) -> [false: bb62, otherwise: bb447]; // scope 2 at src/label.rs:48:9: 48:21
    }

    bb62: {
        _45 = <str as PartialEq>::eq(_13, const "iso8859-4") -> [return: bb63, unwind: bb485]; // scope 2 at src/label.rs:49:9: 49:20
                                         // mir::Constant
                                         // + span: src/label.rs:49:9: 49:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:49:9: 49:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb63: {
        switchInt(move _45) -> [false: bb64, otherwise: bb447]; // scope 2 at src/label.rs:49:9: 49:20
    }

    bb64: {
        _46 = <str as PartialEq>::eq(_13, const "iso88594") -> [return: bb65, unwind: bb485]; // scope 2 at src/label.rs:50:9: 50:19
                                         // mir::Constant
                                         // + span: src/label.rs:50:9: 50:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:50:9: 50:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb65: {
        switchInt(move _46) -> [false: bb66, otherwise: bb447]; // scope 2 at src/label.rs:50:9: 50:19
    }

    bb66: {
        _47 = <str as PartialEq>::eq(_13, const "iso_8859-4") -> [return: bb67, unwind: bb485]; // scope 2 at src/label.rs:51:9: 51:21
                                         // mir::Constant
                                         // + span: src/label.rs:51:9: 51:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:51:9: 51:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb67: {
        switchInt(move _47) -> [false: bb68, otherwise: bb447]; // scope 2 at src/label.rs:51:9: 51:21
    }

    bb68: {
        _48 = <str as PartialEq>::eq(_13, const "iso_8859-4:1988") -> [return: bb69, unwind: bb485]; // scope 2 at src/label.rs:52:9: 52:26
                                         // mir::Constant
                                         // + span: src/label.rs:52:9: 52:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 52, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:52:9: 52:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 52, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb69: {
        switchInt(move _48) -> [false: bb70, otherwise: bb447]; // scope 2 at src/label.rs:52:9: 52:26
    }

    bb70: {
        _49 = <str as PartialEq>::eq(_13, const "l4") -> [return: bb71, unwind: bb485]; // scope 2 at src/label.rs:53:9: 53:13
                                         // mir::Constant
                                         // + span: src/label.rs:53:9: 53:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:53:9: 53:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb71: {
        switchInt(move _49) -> [false: bb72, otherwise: bb447]; // scope 2 at src/label.rs:53:9: 53:13
    }

    bb72: {
        _50 = <str as PartialEq>::eq(_13, const "latin4") -> [return: bb73, unwind: bb485]; // scope 2 at src/label.rs:54:9: 54:17
                                         // mir::Constant
                                         // + span: src/label.rs:54:9: 54:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:54:9: 54:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb73: {
        switchInt(move _50) -> [false: bb74, otherwise: bb447]; // scope 2 at src/label.rs:54:9: 54:17
    }

    bb74: {
        _51 = <str as PartialEq>::eq(_13, const "csisolatincyrillic") -> [return: bb75, unwind: bb485]; // scope 2 at src/label.rs:56:9: 56:29
                                         // mir::Constant
                                         // + span: src/label.rs:56:9: 56:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [262143], len: Size { raw: 18 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 18 })
                                         // mir::Constant
                                         // + span: src/label.rs:56:9: 56:29
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [262143], len: Size { raw: 18 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 18 }) }
    }

    bb75: {
        switchInt(move _51) -> [false: bb76, otherwise: bb448]; // scope 2 at src/label.rs:56:9: 56:29
    }

    bb76: {
        _52 = <str as PartialEq>::eq(_13, const "cyrillic") -> [return: bb77, unwind: bb485]; // scope 2 at src/label.rs:57:9: 57:19
                                         // mir::Constant
                                         // + span: src/label.rs:57:9: 57:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:57:9: 57:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb77: {
        switchInt(move _52) -> [false: bb78, otherwise: bb448]; // scope 2 at src/label.rs:57:9: 57:19
    }

    bb78: {
        _53 = <str as PartialEq>::eq(_13, const "iso-8859-5") -> [return: bb79, unwind: bb485]; // scope 2 at src/label.rs:58:9: 58:21
                                         // mir::Constant
                                         // + span: src/label.rs:58:9: 58:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:58:9: 58:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb79: {
        switchInt(move _53) -> [false: bb80, otherwise: bb448]; // scope 2 at src/label.rs:58:9: 58:21
    }

    bb80: {
        _54 = <str as PartialEq>::eq(_13, const "iso-ir-144") -> [return: bb81, unwind: bb485]; // scope 2 at src/label.rs:59:9: 59:21
                                         // mir::Constant
                                         // + span: src/label.rs:59:9: 59:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 52, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:59:9: 59:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 52, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb81: {
        switchInt(move _54) -> [false: bb82, otherwise: bb448]; // scope 2 at src/label.rs:59:9: 59:21
    }

    bb82: {
        _55 = <str as PartialEq>::eq(_13, const "iso8859-5") -> [return: bb83, unwind: bb485]; // scope 2 at src/label.rs:60:9: 60:20
                                         // mir::Constant
                                         // + span: src/label.rs:60:9: 60:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:60:9: 60:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb83: {
        switchInt(move _55) -> [false: bb84, otherwise: bb448]; // scope 2 at src/label.rs:60:9: 60:20
    }

    bb84: {
        _56 = <str as PartialEq>::eq(_13, const "iso88595") -> [return: bb85, unwind: bb485]; // scope 2 at src/label.rs:61:9: 61:19
                                         // mir::Constant
                                         // + span: src/label.rs:61:9: 61:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:61:9: 61:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb85: {
        switchInt(move _56) -> [false: bb86, otherwise: bb448]; // scope 2 at src/label.rs:61:9: 61:19
    }

    bb86: {
        _57 = <str as PartialEq>::eq(_13, const "iso_8859-5") -> [return: bb87, unwind: bb485]; // scope 2 at src/label.rs:62:9: 62:21
                                         // mir::Constant
                                         // + span: src/label.rs:62:9: 62:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:62:9: 62:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb87: {
        switchInt(move _57) -> [false: bb88, otherwise: bb448]; // scope 2 at src/label.rs:62:9: 62:21
    }

    bb88: {
        _58 = <str as PartialEq>::eq(_13, const "iso_8859-5:1988") -> [return: bb89, unwind: bb485]; // scope 2 at src/label.rs:63:9: 63:26
                                         // mir::Constant
                                         // + span: src/label.rs:63:9: 63:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 53, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:63:9: 63:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 53, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb89: {
        switchInt(move _58) -> [false: bb90, otherwise: bb448]; // scope 2 at src/label.rs:63:9: 63:26
    }

    bb90: {
        _59 = <str as PartialEq>::eq(_13, const "arabic") -> [return: bb91, unwind: bb485]; // scope 2 at src/label.rs:65:9: 65:17
                                         // mir::Constant
                                         // + span: src/label.rs:65:9: 65:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 114, 97, 98, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:65:9: 65:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 114, 97, 98, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb91: {
        switchInt(move _59) -> [false: bb92, otherwise: bb449]; // scope 2 at src/label.rs:65:9: 65:17
    }

    bb92: {
        _60 = <str as PartialEq>::eq(_13, const "asmo-708") -> [return: bb93, unwind: bb485]; // scope 2 at src/label.rs:66:9: 66:19
                                         // mir::Constant
                                         // + span: src/label.rs:66:9: 66:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 115, 109, 111, 45, 55, 48, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:66:9: 66:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 115, 109, 111, 45, 55, 48, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb93: {
        switchInt(move _60) -> [false: bb94, otherwise: bb449]; // scope 2 at src/label.rs:66:9: 66:19
    }

    bb94: {
        _61 = <str as PartialEq>::eq(_13, const "csiso88596e") -> [return: bb95, unwind: bb485]; // scope 2 at src/label.rs:67:9: 67:22
                                         // mir::Constant
                                         // + span: src/label.rs:67:9: 67:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 54, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:67:9: 67:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 54, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb95: {
        switchInt(move _61) -> [false: bb96, otherwise: bb449]; // scope 2 at src/label.rs:67:9: 67:22
    }

    bb96: {
        _62 = <str as PartialEq>::eq(_13, const "csiso88596i") -> [return: bb97, unwind: bb485]; // scope 2 at src/label.rs:68:9: 68:22
                                         // mir::Constant
                                         // + span: src/label.rs:68:9: 68:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 54, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:68:9: 68:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 54, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb97: {
        switchInt(move _62) -> [false: bb98, otherwise: bb449]; // scope 2 at src/label.rs:68:9: 68:22
    }

    bb98: {
        _63 = <str as PartialEq>::eq(_13, const "csisolatinarabic") -> [return: bb99, unwind: bb485]; // scope 2 at src/label.rs:69:9: 69:27
                                         // mir::Constant
                                         // + span: src/label.rs:69:9: 69:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 97, 114, 97, 98, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/label.rs:69:9: 69:27
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 97, 114, 97, 98, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb99: {
        switchInt(move _63) -> [false: bb100, otherwise: bb449]; // scope 2 at src/label.rs:69:9: 69:27
    }

    bb100: {
        _64 = <str as PartialEq>::eq(_13, const "ecma-114") -> [return: bb101, unwind: bb485]; // scope 2 at src/label.rs:70:9: 70:19
                                         // mir::Constant
                                         // + span: src/label.rs:70:9: 70:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 99, 109, 97, 45, 49, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:70:9: 70:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 99, 109, 97, 45, 49, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb101: {
        switchInt(move _64) -> [false: bb102, otherwise: bb449]; // scope 2 at src/label.rs:70:9: 70:19
    }

    bb102: {
        _65 = <str as PartialEq>::eq(_13, const "iso-8859-6") -> [return: bb103, unwind: bb485]; // scope 2 at src/label.rs:71:9: 71:21
                                         // mir::Constant
                                         // + span: src/label.rs:71:9: 71:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:71:9: 71:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb103: {
        switchInt(move _65) -> [false: bb104, otherwise: bb449]; // scope 2 at src/label.rs:71:9: 71:21
    }

    bb104: {
        _66 = <str as PartialEq>::eq(_13, const "iso-8859-6-e") -> [return: bb105, unwind: bb485]; // scope 2 at src/label.rs:72:9: 72:23
                                         // mir::Constant
                                         // + span: src/label.rs:72:9: 72:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54, 45, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:72:9: 72:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54, 45, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb105: {
        switchInt(move _66) -> [false: bb106, otherwise: bb449]; // scope 2 at src/label.rs:72:9: 72:23
    }

    bb106: {
        _67 = <str as PartialEq>::eq(_13, const "iso-8859-6-i") -> [return: bb107, unwind: bb485]; // scope 2 at src/label.rs:73:9: 73:23
                                         // mir::Constant
                                         // + span: src/label.rs:73:9: 73:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:73:9: 73:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 54, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb107: {
        switchInt(move _67) -> [false: bb108, otherwise: bb449]; // scope 2 at src/label.rs:73:9: 73:23
    }

    bb108: {
        _68 = <str as PartialEq>::eq(_13, const "iso-ir-127") -> [return: bb109, unwind: bb485]; // scope 2 at src/label.rs:74:9: 74:21
                                         // mir::Constant
                                         // + span: src/label.rs:74:9: 74:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 50, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:74:9: 74:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 50, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb109: {
        switchInt(move _68) -> [false: bb110, otherwise: bb449]; // scope 2 at src/label.rs:74:9: 74:21
    }

    bb110: {
        _69 = <str as PartialEq>::eq(_13, const "iso8859-6") -> [return: bb111, unwind: bb485]; // scope 2 at src/label.rs:75:9: 75:20
                                         // mir::Constant
                                         // + span: src/label.rs:75:9: 75:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:75:9: 75:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb111: {
        switchInt(move _69) -> [false: bb112, otherwise: bb449]; // scope 2 at src/label.rs:75:9: 75:20
    }

    bb112: {
        _70 = <str as PartialEq>::eq(_13, const "iso88596") -> [return: bb113, unwind: bb485]; // scope 2 at src/label.rs:76:9: 76:19
                                         // mir::Constant
                                         // + span: src/label.rs:76:9: 76:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:76:9: 76:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb113: {
        switchInt(move _70) -> [false: bb114, otherwise: bb449]; // scope 2 at src/label.rs:76:9: 76:19
    }

    bb114: {
        _71 = <str as PartialEq>::eq(_13, const "iso_8859-6") -> [return: bb115, unwind: bb485]; // scope 2 at src/label.rs:77:9: 77:21
                                         // mir::Constant
                                         // + span: src/label.rs:77:9: 77:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:77:9: 77:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb115: {
        switchInt(move _71) -> [false: bb116, otherwise: bb449]; // scope 2 at src/label.rs:77:9: 77:21
    }

    bb116: {
        _72 = <str as PartialEq>::eq(_13, const "iso_8859-6:1987") -> [return: bb117, unwind: bb485]; // scope 2 at src/label.rs:78:9: 78:26
                                         // mir::Constant
                                         // + span: src/label.rs:78:9: 78:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 54, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:78:9: 78:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 54, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb117: {
        switchInt(move _72) -> [false: bb118, otherwise: bb449]; // scope 2 at src/label.rs:78:9: 78:26
    }

    bb118: {
        _73 = <str as PartialEq>::eq(_13, const "csisolatingreek") -> [return: bb119, unwind: bb485]; // scope 2 at src/label.rs:80:9: 80:26
                                         // mir::Constant
                                         // + span: src/label.rs:80:9: 80:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 103, 114, 101, 101, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:80:9: 80:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 103, 114, 101, 101, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb119: {
        switchInt(move _73) -> [false: bb120, otherwise: bb450]; // scope 2 at src/label.rs:80:9: 80:26
    }

    bb120: {
        _74 = <str as PartialEq>::eq(_13, const "ecma-118") -> [return: bb121, unwind: bb485]; // scope 2 at src/label.rs:81:9: 81:19
                                         // mir::Constant
                                         // + span: src/label.rs:81:9: 81:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 99, 109, 97, 45, 49, 49, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:81:9: 81:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 99, 109, 97, 45, 49, 49, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb121: {
        switchInt(move _74) -> [false: bb122, otherwise: bb450]; // scope 2 at src/label.rs:81:9: 81:19
    }

    bb122: {
        _75 = <str as PartialEq>::eq(_13, const "elot_928") -> [return: bb123, unwind: bb485]; // scope 2 at src/label.rs:82:9: 82:19
                                         // mir::Constant
                                         // + span: src/label.rs:82:9: 82:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 108, 111, 116, 95, 57, 50, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:82:9: 82:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 108, 111, 116, 95, 57, 50, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb123: {
        switchInt(move _75) -> [false: bb124, otherwise: bb450]; // scope 2 at src/label.rs:82:9: 82:19
    }

    bb124: {
        _76 = <str as PartialEq>::eq(_13, const "greek") -> [return: bb125, unwind: bb485]; // scope 2 at src/label.rs:83:9: 83:16
                                         // mir::Constant
                                         // + span: src/label.rs:83:9: 83:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 114, 101, 101, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:83:9: 83:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 114, 101, 101, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb125: {
        switchInt(move _76) -> [false: bb126, otherwise: bb450]; // scope 2 at src/label.rs:83:9: 83:16
    }

    bb126: {
        _77 = <str as PartialEq>::eq(_13, const "greek8") -> [return: bb127, unwind: bb485]; // scope 2 at src/label.rs:84:9: 84:17
                                         // mir::Constant
                                         // + span: src/label.rs:84:9: 84:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 114, 101, 101, 107, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:84:9: 84:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 114, 101, 101, 107, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb127: {
        switchInt(move _77) -> [false: bb128, otherwise: bb450]; // scope 2 at src/label.rs:84:9: 84:17
    }

    bb128: {
        _78 = <str as PartialEq>::eq(_13, const "iso-8859-7") -> [return: bb129, unwind: bb485]; // scope 2 at src/label.rs:85:9: 85:21
                                         // mir::Constant
                                         // + span: src/label.rs:85:9: 85:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:85:9: 85:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb129: {
        switchInt(move _78) -> [false: bb130, otherwise: bb450]; // scope 2 at src/label.rs:85:9: 85:21
    }

    bb130: {
        _79 = <str as PartialEq>::eq(_13, const "iso-ir-126") -> [return: bb131, unwind: bb485]; // scope 2 at src/label.rs:86:9: 86:21
                                         // mir::Constant
                                         // + span: src/label.rs:86:9: 86:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 50, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:86:9: 86:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 50, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb131: {
        switchInt(move _79) -> [false: bb132, otherwise: bb450]; // scope 2 at src/label.rs:86:9: 86:21
    }

    bb132: {
        _80 = <str as PartialEq>::eq(_13, const "iso8859-7") -> [return: bb133, unwind: bb485]; // scope 2 at src/label.rs:87:9: 87:20
                                         // mir::Constant
                                         // + span: src/label.rs:87:9: 87:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:87:9: 87:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb133: {
        switchInt(move _80) -> [false: bb134, otherwise: bb450]; // scope 2 at src/label.rs:87:9: 87:20
    }

    bb134: {
        _81 = <str as PartialEq>::eq(_13, const "iso88597") -> [return: bb135, unwind: bb485]; // scope 2 at src/label.rs:88:9: 88:19
                                         // mir::Constant
                                         // + span: src/label.rs:88:9: 88:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:88:9: 88:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb135: {
        switchInt(move _81) -> [false: bb136, otherwise: bb450]; // scope 2 at src/label.rs:88:9: 88:19
    }

    bb136: {
        _82 = <str as PartialEq>::eq(_13, const "iso_8859-7") -> [return: bb137, unwind: bb485]; // scope 2 at src/label.rs:89:9: 89:21
                                         // mir::Constant
                                         // + span: src/label.rs:89:9: 89:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:89:9: 89:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb137: {
        switchInt(move _82) -> [false: bb138, otherwise: bb450]; // scope 2 at src/label.rs:89:9: 89:21
    }

    bb138: {
        _83 = <str as PartialEq>::eq(_13, const "iso_8859-7:1987") -> [return: bb139, unwind: bb485]; // scope 2 at src/label.rs:90:9: 90:26
                                         // mir::Constant
                                         // + span: src/label.rs:90:9: 90:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 55, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:90:9: 90:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 55, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb139: {
        switchInt(move _83) -> [false: bb140, otherwise: bb450]; // scope 2 at src/label.rs:90:9: 90:26
    }

    bb140: {
        _84 = <str as PartialEq>::eq(_13, const "sun_eu_greek") -> [return: bb141, unwind: bb485]; // scope 2 at src/label.rs:91:9: 91:23
                                         // mir::Constant
                                         // + span: src/label.rs:91:9: 91:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [115, 117, 110, 95, 101, 117, 95, 103, 114, 101, 101, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:91:9: 91:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [115, 117, 110, 95, 101, 117, 95, 103, 114, 101, 101, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb141: {
        switchInt(move _84) -> [false: bb142, otherwise: bb450]; // scope 2 at src/label.rs:91:9: 91:23
    }

    bb142: {
        _85 = <str as PartialEq>::eq(_13, const "csiso88598e") -> [return: bb143, unwind: bb485]; // scope 2 at src/label.rs:93:9: 93:22
                                         // mir::Constant
                                         // + span: src/label.rs:93:9: 93:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 56, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:93:9: 93:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 56, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb143: {
        switchInt(move _85) -> [false: bb144, otherwise: bb451]; // scope 2 at src/label.rs:93:9: 93:22
    }

    bb144: {
        _86 = <str as PartialEq>::eq(_13, const "csisolatinhebrew") -> [return: bb145, unwind: bb485]; // scope 2 at src/label.rs:94:9: 94:27
                                         // mir::Constant
                                         // + span: src/label.rs:94:9: 94:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 104, 101, 98, 114, 101, 119], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/label.rs:94:9: 94:27
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 104, 101, 98, 114, 101, 119], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb145: {
        switchInt(move _86) -> [false: bb146, otherwise: bb451]; // scope 2 at src/label.rs:94:9: 94:27
    }

    bb146: {
        _87 = <str as PartialEq>::eq(_13, const "hebrew") -> [return: bb147, unwind: bb485]; // scope 2 at src/label.rs:95:9: 95:17
                                         // mir::Constant
                                         // + span: src/label.rs:95:9: 95:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [104, 101, 98, 114, 101, 119], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:95:9: 95:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [104, 101, 98, 114, 101, 119], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb147: {
        switchInt(move _87) -> [false: bb148, otherwise: bb451]; // scope 2 at src/label.rs:95:9: 95:17
    }

    bb148: {
        _88 = <str as PartialEq>::eq(_13, const "iso-8859-8") -> [return: bb149, unwind: bb485]; // scope 2 at src/label.rs:96:9: 96:21
                                         // mir::Constant
                                         // + span: src/label.rs:96:9: 96:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:96:9: 96:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb149: {
        switchInt(move _88) -> [false: bb150, otherwise: bb451]; // scope 2 at src/label.rs:96:9: 96:21
    }

    bb150: {
        _89 = <str as PartialEq>::eq(_13, const "iso-8859-8-e") -> [return: bb151, unwind: bb485]; // scope 2 at src/label.rs:97:9: 97:23
                                         // mir::Constant
                                         // + span: src/label.rs:97:9: 97:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:97:9: 97:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb151: {
        switchInt(move _89) -> [false: bb152, otherwise: bb451]; // scope 2 at src/label.rs:97:9: 97:23
    }

    bb152: {
        _90 = <str as PartialEq>::eq(_13, const "iso-ir-138") -> [return: bb153, unwind: bb485]; // scope 2 at src/label.rs:98:9: 98:21
                                         // mir::Constant
                                         // + span: src/label.rs:98:9: 98:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 51, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:98:9: 98:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 51, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb153: {
        switchInt(move _90) -> [false: bb154, otherwise: bb451]; // scope 2 at src/label.rs:98:9: 98:21
    }

    bb154: {
        _91 = <str as PartialEq>::eq(_13, const "iso8859-8") -> [return: bb155, unwind: bb485]; // scope 2 at src/label.rs:99:9: 99:20
                                         // mir::Constant
                                         // + span: src/label.rs:99:9: 99:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:99:9: 99:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb155: {
        switchInt(move _91) -> [false: bb156, otherwise: bb451]; // scope 2 at src/label.rs:99:9: 99:20
    }

    bb156: {
        _92 = <str as PartialEq>::eq(_13, const "iso88598") -> [return: bb157, unwind: bb485]; // scope 2 at src/label.rs:100:9: 100:19
                                         // mir::Constant
                                         // + span: src/label.rs:100:9: 100:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:100:9: 100:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb157: {
        switchInt(move _92) -> [false: bb158, otherwise: bb451]; // scope 2 at src/label.rs:100:9: 100:19
    }

    bb158: {
        _93 = <str as PartialEq>::eq(_13, const "iso_8859-8") -> [return: bb159, unwind: bb485]; // scope 2 at src/label.rs:101:9: 101:21
                                         // mir::Constant
                                         // + span: src/label.rs:101:9: 101:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:101:9: 101:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb159: {
        switchInt(move _93) -> [false: bb160, otherwise: bb451]; // scope 2 at src/label.rs:101:9: 101:21
    }

    bb160: {
        _94 = <str as PartialEq>::eq(_13, const "iso_8859-8:1988") -> [return: bb161, unwind: bb485]; // scope 2 at src/label.rs:102:9: 102:26
                                         // mir::Constant
                                         // + span: src/label.rs:102:9: 102:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 56, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:102:9: 102:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 56, 58, 49, 57, 56, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb161: {
        switchInt(move _94) -> [false: bb162, otherwise: bb451]; // scope 2 at src/label.rs:102:9: 102:26
    }

    bb162: {
        _95 = <str as PartialEq>::eq(_13, const "visual") -> [return: bb163, unwind: bb485]; // scope 2 at src/label.rs:103:9: 103:17
                                         // mir::Constant
                                         // + span: src/label.rs:103:9: 103:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [118, 105, 115, 117, 97, 108], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:103:9: 103:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [118, 105, 115, 117, 97, 108], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb163: {
        switchInt(move _95) -> [false: bb164, otherwise: bb451]; // scope 2 at src/label.rs:103:9: 103:17
    }

    bb164: {
        _96 = <str as PartialEq>::eq(_13, const "csiso88598i") -> [return: bb165, unwind: bb485]; // scope 2 at src/label.rs:105:9: 105:22
                                         // mir::Constant
                                         // + span: src/label.rs:105:9: 105:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 56, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:105:9: 105:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 56, 56, 53, 57, 56, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb165: {
        switchInt(move _96) -> [false: bb166, otherwise: bb452]; // scope 2 at src/label.rs:105:9: 105:22
    }

    bb166: {
        _97 = <str as PartialEq>::eq(_13, const "iso-8859-8-i") -> [return: bb167, unwind: bb485]; // scope 2 at src/label.rs:106:9: 106:23
                                         // mir::Constant
                                         // + span: src/label.rs:106:9: 106:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:106:9: 106:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56, 45, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb167: {
        switchInt(move _97) -> [false: bb168, otherwise: bb452]; // scope 2 at src/label.rs:106:9: 106:23
    }

    bb168: {
        _98 = <str as PartialEq>::eq(_13, const "logical") -> [return: bb169, unwind: bb485]; // scope 2 at src/label.rs:107:9: 107:18
                                         // mir::Constant
                                         // + span: src/label.rs:107:9: 107:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 111, 103, 105, 99, 97, 108], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:107:9: 107:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 111, 103, 105, 99, 97, 108], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb169: {
        switchInt(move _98) -> [false: bb170, otherwise: bb452]; // scope 2 at src/label.rs:107:9: 107:18
    }

    bb170: {
        _99 = <str as PartialEq>::eq(_13, const "csisolatin6") -> [return: bb171, unwind: bb485]; // scope 2 at src/label.rs:109:9: 109:22
                                         // mir::Constant
                                         // + span: src/label.rs:109:9: 109:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:109:9: 109:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb171: {
        switchInt(move _99) -> [false: bb172, otherwise: bb453]; // scope 2 at src/label.rs:109:9: 109:22
    }

    bb172: {
        _100 = <str as PartialEq>::eq(_13, const "iso-8859-10") -> [return: bb173, unwind: bb485]; // scope 2 at src/label.rs:110:9: 110:22
                                         // mir::Constant
                                         // + span: src/label.rs:110:9: 110:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:110:9: 110:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb173: {
        switchInt(move _100) -> [false: bb174, otherwise: bb453]; // scope 2 at src/label.rs:110:9: 110:22
    }

    bb174: {
        _101 = <str as PartialEq>::eq(_13, const "iso-ir-157") -> [return: bb175, unwind: bb485]; // scope 2 at src/label.rs:111:9: 111:21
                                         // mir::Constant
                                         // + span: src/label.rs:111:9: 111:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:111:9: 111:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb175: {
        switchInt(move _101) -> [false: bb176, otherwise: bb453]; // scope 2 at src/label.rs:111:9: 111:21
    }

    bb176: {
        _102 = <str as PartialEq>::eq(_13, const "iso8859-10") -> [return: bb177, unwind: bb485]; // scope 2 at src/label.rs:112:9: 112:21
                                         // mir::Constant
                                         // + span: src/label.rs:112:9: 112:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:112:9: 112:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb177: {
        switchInt(move _102) -> [false: bb178, otherwise: bb453]; // scope 2 at src/label.rs:112:9: 112:21
    }

    bb178: {
        _103 = <str as PartialEq>::eq(_13, const "iso885910") -> [return: bb179, unwind: bb485]; // scope 2 at src/label.rs:113:9: 113:20
                                         // mir::Constant
                                         // + span: src/label.rs:113:9: 113:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:113:9: 113:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb179: {
        switchInt(move _103) -> [false: bb180, otherwise: bb453]; // scope 2 at src/label.rs:113:9: 113:20
    }

    bb180: {
        _104 = <str as PartialEq>::eq(_13, const "l6") -> [return: bb181, unwind: bb485]; // scope 2 at src/label.rs:114:9: 114:13
                                         // mir::Constant
                                         // + span: src/label.rs:114:9: 114:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:114:9: 114:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb181: {
        switchInt(move _104) -> [false: bb182, otherwise: bb453]; // scope 2 at src/label.rs:114:9: 114:13
    }

    bb182: {
        _105 = <str as PartialEq>::eq(_13, const "latin6") -> [return: bb183, unwind: bb485]; // scope 2 at src/label.rs:115:9: 115:17
                                         // mir::Constant
                                         // + span: src/label.rs:115:9: 115:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:115:9: 115:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb183: {
        switchInt(move _105) -> [false: bb184, otherwise: bb453]; // scope 2 at src/label.rs:115:9: 115:17
    }

    bb184: {
        _106 = <str as PartialEq>::eq(_13, const "iso-8859-13") -> [return: bb185, unwind: bb485]; // scope 2 at src/label.rs:117:9: 117:22
                                         // mir::Constant
                                         // + span: src/label.rs:117:9: 117:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:117:9: 117:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb185: {
        switchInt(move _106) -> [false: bb186, otherwise: bb454]; // scope 2 at src/label.rs:117:9: 117:22
    }

    bb186: {
        _107 = <str as PartialEq>::eq(_13, const "iso8859-13") -> [return: bb187, unwind: bb485]; // scope 2 at src/label.rs:118:9: 118:21
                                         // mir::Constant
                                         // + span: src/label.rs:118:9: 118:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:118:9: 118:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb187: {
        switchInt(move _107) -> [false: bb188, otherwise: bb454]; // scope 2 at src/label.rs:118:9: 118:21
    }

    bb188: {
        _108 = <str as PartialEq>::eq(_13, const "iso885913") -> [return: bb189, unwind: bb485]; // scope 2 at src/label.rs:119:9: 119:20
                                         // mir::Constant
                                         // + span: src/label.rs:119:9: 119:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:119:9: 119:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb189: {
        switchInt(move _108) -> [false: bb190, otherwise: bb454]; // scope 2 at src/label.rs:119:9: 119:20
    }

    bb190: {
        _109 = <str as PartialEq>::eq(_13, const "iso-8859-14") -> [return: bb191, unwind: bb485]; // scope 2 at src/label.rs:121:9: 121:22
                                         // mir::Constant
                                         // + span: src/label.rs:121:9: 121:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:121:9: 121:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb191: {
        switchInt(move _109) -> [false: bb192, otherwise: bb455]; // scope 2 at src/label.rs:121:9: 121:22
    }

    bb192: {
        _110 = <str as PartialEq>::eq(_13, const "iso8859-14") -> [return: bb193, unwind: bb485]; // scope 2 at src/label.rs:122:9: 122:21
                                         // mir::Constant
                                         // + span: src/label.rs:122:9: 122:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:122:9: 122:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb193: {
        switchInt(move _110) -> [false: bb194, otherwise: bb455]; // scope 2 at src/label.rs:122:9: 122:21
    }

    bb194: {
        _111 = <str as PartialEq>::eq(_13, const "iso885914") -> [return: bb195, unwind: bb485]; // scope 2 at src/label.rs:123:9: 123:20
                                         // mir::Constant
                                         // + span: src/label.rs:123:9: 123:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:123:9: 123:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb195: {
        switchInt(move _111) -> [false: bb196, otherwise: bb455]; // scope 2 at src/label.rs:123:9: 123:20
    }

    bb196: {
        _112 = <str as PartialEq>::eq(_13, const "csisolatin9") -> [return: bb197, unwind: bb485]; // scope 2 at src/label.rs:125:9: 125:22
                                         // mir::Constant
                                         // + span: src/label.rs:125:9: 125:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:125:9: 125:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb197: {
        switchInt(move _112) -> [false: bb198, otherwise: bb456]; // scope 2 at src/label.rs:125:9: 125:22
    }

    bb198: {
        _113 = <str as PartialEq>::eq(_13, const "iso-8859-15") -> [return: bb199, unwind: bb485]; // scope 2 at src/label.rs:126:9: 126:22
                                         // mir::Constant
                                         // + span: src/label.rs:126:9: 126:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:126:9: 126:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb199: {
        switchInt(move _113) -> [false: bb200, otherwise: bb456]; // scope 2 at src/label.rs:126:9: 126:22
    }

    bb200: {
        _114 = <str as PartialEq>::eq(_13, const "iso8859-15") -> [return: bb201, unwind: bb485]; // scope 2 at src/label.rs:127:9: 127:21
                                         // mir::Constant
                                         // + span: src/label.rs:127:9: 127:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:127:9: 127:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb201: {
        switchInt(move _114) -> [false: bb202, otherwise: bb456]; // scope 2 at src/label.rs:127:9: 127:21
    }

    bb202: {
        _115 = <str as PartialEq>::eq(_13, const "iso885915") -> [return: bb203, unwind: bb485]; // scope 2 at src/label.rs:128:9: 128:20
                                         // mir::Constant
                                         // + span: src/label.rs:128:9: 128:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:128:9: 128:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb203: {
        switchInt(move _115) -> [false: bb204, otherwise: bb456]; // scope 2 at src/label.rs:128:9: 128:20
    }

    bb204: {
        _116 = <str as PartialEq>::eq(_13, const "iso_8859-15") -> [return: bb205, unwind: bb485]; // scope 2 at src/label.rs:129:9: 129:22
                                         // mir::Constant
                                         // + span: src/label.rs:129:9: 129:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:129:9: 129:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 49, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb205: {
        switchInt(move _116) -> [false: bb206, otherwise: bb456]; // scope 2 at src/label.rs:129:9: 129:22
    }

    bb206: {
        _117 = <str as PartialEq>::eq(_13, const "l9") -> [return: bb207, unwind: bb485]; // scope 2 at src/label.rs:130:9: 130:13
                                         // mir::Constant
                                         // + span: src/label.rs:130:9: 130:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:130:9: 130:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb207: {
        switchInt(move _117) -> [false: bb208, otherwise: bb456]; // scope 2 at src/label.rs:130:9: 130:13
    }

    bb208: {
        _118 = <str as PartialEq>::eq(_13, const "iso-8859-16") -> [return: bb209, unwind: bb485]; // scope 2 at src/label.rs:132:9: 132:22
                                         // mir::Constant
                                         // + span: src/label.rs:132:9: 132:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:132:9: 132:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb209: {
        switchInt(move _118) -> [false: bb210, otherwise: bb457]; // scope 2 at src/label.rs:132:9: 132:22
    }

    bb210: {
        _119 = <str as PartialEq>::eq(_13, const "cskoi8r") -> [return: bb211, unwind: bb485]; // scope 2 at src/label.rs:134:9: 134:18
                                         // mir::Constant
                                         // + span: src/label.rs:134:9: 134:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 107, 111, 105, 56, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:134:9: 134:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 107, 111, 105, 56, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb211: {
        switchInt(move _119) -> [false: bb212, otherwise: bb458]; // scope 2 at src/label.rs:134:9: 134:18
    }

    bb212: {
        _120 = <str as PartialEq>::eq(_13, const "koi") -> [return: bb213, unwind: bb485]; // scope 2 at src/label.rs:135:9: 135:14
                                         // mir::Constant
                                         // + span: src/label.rs:135:9: 135:14
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 })
                                         // mir::Constant
                                         // + span: src/label.rs:135:9: 135:14
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 }) }
    }

    bb213: {
        switchInt(move _120) -> [false: bb214, otherwise: bb458]; // scope 2 at src/label.rs:135:9: 135:14
    }

    bb214: {
        _121 = <str as PartialEq>::eq(_13, const "koi8") -> [return: bb215, unwind: bb485]; // scope 2 at src/label.rs:136:9: 136:15
                                         // mir::Constant
                                         // + span: src/label.rs:136:9: 136:15
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/label.rs:136:9: 136:15
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
    }

    bb215: {
        switchInt(move _121) -> [false: bb216, otherwise: bb458]; // scope 2 at src/label.rs:136:9: 136:15
    }

    bb216: {
        _122 = <str as PartialEq>::eq(_13, const "koi8-r") -> [return: bb217, unwind: bb485]; // scope 2 at src/label.rs:137:9: 137:17
                                         // mir::Constant
                                         // + span: src/label.rs:137:9: 137:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:137:9: 137:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb217: {
        switchInt(move _122) -> [false: bb218, otherwise: bb458]; // scope 2 at src/label.rs:137:9: 137:17
    }

    bb218: {
        _123 = <str as PartialEq>::eq(_13, const "koi8_r") -> [return: bb219, unwind: bb485]; // scope 2 at src/label.rs:138:9: 138:17
                                         // mir::Constant
                                         // + span: src/label.rs:138:9: 138:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 95, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:138:9: 138:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 95, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb219: {
        switchInt(move _123) -> [false: bb220, otherwise: bb458]; // scope 2 at src/label.rs:138:9: 138:17
    }

    bb220: {
        _124 = <str as PartialEq>::eq(_13, const "koi8-ru") -> [return: bb221, unwind: bb485]; // scope 2 at src/label.rs:140:9: 140:18
                                         // mir::Constant
                                         // + span: src/label.rs:140:9: 140:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:140:9: 140:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb221: {
        switchInt(move _124) -> [false: bb222, otherwise: bb459]; // scope 2 at src/label.rs:140:9: 140:18
    }

    bb222: {
        _125 = <str as PartialEq>::eq(_13, const "koi8-u") -> [return: bb223, unwind: bb485]; // scope 2 at src/label.rs:141:9: 141:17
                                         // mir::Constant
                                         // + span: src/label.rs:141:9: 141:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:141:9: 141:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb223: {
        switchInt(move _125) -> [false: bb224, otherwise: bb459]; // scope 2 at src/label.rs:141:9: 141:17
    }

    bb224: {
        _126 = <str as PartialEq>::eq(_13, const "csmacintosh") -> [return: bb225, unwind: bb485]; // scope 2 at src/label.rs:143:9: 143:22
                                         // mir::Constant
                                         // + span: src/label.rs:143:9: 143:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 109, 97, 99, 105, 110, 116, 111, 115, 104], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:143:9: 143:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 109, 97, 99, 105, 110, 116, 111, 115, 104], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb225: {
        switchInt(move _126) -> [false: bb226, otherwise: bb460]; // scope 2 at src/label.rs:143:9: 143:22
    }

    bb226: {
        _127 = <str as PartialEq>::eq(_13, const "mac") -> [return: bb227, unwind: bb485]; // scope 2 at src/label.rs:144:9: 144:14
                                         // mir::Constant
                                         // + span: src/label.rs:144:9: 144:14
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 97, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 })
                                         // mir::Constant
                                         // + span: src/label.rs:144:9: 144:14
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 97, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 }) }
    }

    bb227: {
        switchInt(move _127) -> [false: bb228, otherwise: bb460]; // scope 2 at src/label.rs:144:9: 144:14
    }

    bb228: {
        _128 = <str as PartialEq>::eq(_13, const "macintosh") -> [return: bb229, unwind: bb485]; // scope 2 at src/label.rs:145:9: 145:20
                                         // mir::Constant
                                         // + span: src/label.rs:145:9: 145:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 105, 110, 116, 111, 115, 104], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:145:9: 145:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 97, 99, 105, 110, 116, 111, 115, 104], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb229: {
        switchInt(move _128) -> [false: bb230, otherwise: bb460]; // scope 2 at src/label.rs:145:9: 145:20
    }

    bb230: {
        _129 = <str as PartialEq>::eq(_13, const "x-mac-roman") -> [return: bb231, unwind: bb485]; // scope 2 at src/label.rs:146:9: 146:22
                                         // mir::Constant
                                         // + span: src/label.rs:146:9: 146:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 114, 111, 109, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:146:9: 146:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 114, 111, 109, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb231: {
        switchInt(move _129) -> [false: bb232, otherwise: bb460]; // scope 2 at src/label.rs:146:9: 146:22
    }

    bb232: {
        _130 = <str as PartialEq>::eq(_13, const "dos-874") -> [return: bb233, unwind: bb485]; // scope 2 at src/label.rs:148:9: 148:18
                                         // mir::Constant
                                         // + span: src/label.rs:148:9: 148:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [100, 111, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:148:9: 148:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [100, 111, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb233: {
        switchInt(move _130) -> [false: bb234, otherwise: bb461]; // scope 2 at src/label.rs:148:9: 148:18
    }

    bb234: {
        _131 = <str as PartialEq>::eq(_13, const "iso-8859-11") -> [return: bb235, unwind: bb485]; // scope 2 at src/label.rs:149:9: 149:22
                                         // mir::Constant
                                         // + span: src/label.rs:149:9: 149:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:149:9: 149:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb235: {
        switchInt(move _131) -> [false: bb236, otherwise: bb461]; // scope 2 at src/label.rs:149:9: 149:22
    }

    bb236: {
        _132 = <str as PartialEq>::eq(_13, const "iso8859-11") -> [return: bb237, unwind: bb485]; // scope 2 at src/label.rs:150:9: 150:21
                                         // mir::Constant
                                         // + span: src/label.rs:150:9: 150:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:150:9: 150:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb237: {
        switchInt(move _132) -> [false: bb238, otherwise: bb461]; // scope 2 at src/label.rs:150:9: 150:21
    }

    bb238: {
        _133 = <str as PartialEq>::eq(_13, const "iso885911") -> [return: bb239, unwind: bb485]; // scope 2 at src/label.rs:151:9: 151:20
                                         // mir::Constant
                                         // + span: src/label.rs:151:9: 151:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:151:9: 151:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb239: {
        switchInt(move _133) -> [false: bb240, otherwise: bb461]; // scope 2 at src/label.rs:151:9: 151:20
    }

    bb240: {
        _134 = <str as PartialEq>::eq(_13, const "tis-620") -> [return: bb241, unwind: bb485]; // scope 2 at src/label.rs:152:9: 152:18
                                         // mir::Constant
                                         // + span: src/label.rs:152:9: 152:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [116, 105, 115, 45, 54, 50, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:152:9: 152:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [116, 105, 115, 45, 54, 50, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb241: {
        switchInt(move _134) -> [false: bb242, otherwise: bb461]; // scope 2 at src/label.rs:152:9: 152:18
    }

    bb242: {
        _135 = <str as PartialEq>::eq(_13, const "windows-874") -> [return: bb243, unwind: bb485]; // scope 2 at src/label.rs:153:9: 153:22
                                         // mir::Constant
                                         // + span: src/label.rs:153:9: 153:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:153:9: 153:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb243: {
        switchInt(move _135) -> [false: bb244, otherwise: bb461]; // scope 2 at src/label.rs:153:9: 153:22
    }

    bb244: {
        _136 = <str as PartialEq>::eq(_13, const "cp1250") -> [return: bb245, unwind: bb485]; // scope 2 at src/label.rs:155:9: 155:17
                                         // mir::Constant
                                         // + span: src/label.rs:155:9: 155:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:155:9: 155:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb245: {
        switchInt(move _136) -> [false: bb246, otherwise: bb462]; // scope 2 at src/label.rs:155:9: 155:17
    }

    bb246: {
        _137 = <str as PartialEq>::eq(_13, const "windows-1250") -> [return: bb247, unwind: bb485]; // scope 2 at src/label.rs:156:9: 156:23
                                         // mir::Constant
                                         // + span: src/label.rs:156:9: 156:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:156:9: 156:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb247: {
        switchInt(move _137) -> [false: bb248, otherwise: bb462]; // scope 2 at src/label.rs:156:9: 156:23
    }

    bb248: {
        _138 = <str as PartialEq>::eq(_13, const "x-cp1250") -> [return: bb249, unwind: bb485]; // scope 2 at src/label.rs:157:9: 157:19
                                         // mir::Constant
                                         // + span: src/label.rs:157:9: 157:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:157:9: 157:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb249: {
        switchInt(move _138) -> [false: bb250, otherwise: bb462]; // scope 2 at src/label.rs:157:9: 157:19
    }

    bb250: {
        _139 = <str as PartialEq>::eq(_13, const "cp1251") -> [return: bb251, unwind: bb485]; // scope 2 at src/label.rs:159:9: 159:17
                                         // mir::Constant
                                         // + span: src/label.rs:159:9: 159:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:159:9: 159:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb251: {
        switchInt(move _139) -> [false: bb252, otherwise: bb463]; // scope 2 at src/label.rs:159:9: 159:17
    }

    bb252: {
        _140 = <str as PartialEq>::eq(_13, const "windows-1251") -> [return: bb253, unwind: bb485]; // scope 2 at src/label.rs:160:9: 160:23
                                         // mir::Constant
                                         // + span: src/label.rs:160:9: 160:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:160:9: 160:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb253: {
        switchInt(move _140) -> [false: bb254, otherwise: bb463]; // scope 2 at src/label.rs:160:9: 160:23
    }

    bb254: {
        _141 = <str as PartialEq>::eq(_13, const "x-cp1251") -> [return: bb255, unwind: bb485]; // scope 2 at src/label.rs:161:9: 161:19
                                         // mir::Constant
                                         // + span: src/label.rs:161:9: 161:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:161:9: 161:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb255: {
        switchInt(move _141) -> [false: bb256, otherwise: bb463]; // scope 2 at src/label.rs:161:9: 161:19
    }

    bb256: {
        _142 = <str as PartialEq>::eq(_13, const "ansi_x3.4-1968") -> [return: bb257, unwind: bb485]; // scope 2 at src/label.rs:163:9: 163:25
                                         // mir::Constant
                                         // + span: src/label.rs:163:9: 163:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 110, 115, 105, 95, 120, 51, 46, 52, 45, 49, 57, 54, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/label.rs:163:9: 163:25
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 110, 115, 105, 95, 120, 51, 46, 52, 45, 49, 57, 54, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
    }

    bb257: {
        switchInt(move _142) -> [false: bb258, otherwise: bb464]; // scope 2 at src/label.rs:163:9: 163:25
    }

    bb258: {
        _143 = <str as PartialEq>::eq(_13, const "ascii") -> [return: bb259, unwind: bb485]; // scope 2 at src/label.rs:164:9: 164:16
                                         // mir::Constant
                                         // + span: src/label.rs:164:9: 164:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 115, 99, 105, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:164:9: 164:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 115, 99, 105, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb259: {
        switchInt(move _143) -> [false: bb260, otherwise: bb464]; // scope 2 at src/label.rs:164:9: 164:16
    }

    bb260: {
        _144 = <str as PartialEq>::eq(_13, const "cp1252") -> [return: bb261, unwind: bb485]; // scope 2 at src/label.rs:165:9: 165:17
                                         // mir::Constant
                                         // + span: src/label.rs:165:9: 165:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:165:9: 165:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb261: {
        switchInt(move _144) -> [false: bb262, otherwise: bb464]; // scope 2 at src/label.rs:165:9: 165:17
    }

    bb262: {
        _145 = <str as PartialEq>::eq(_13, const "cp819") -> [return: bb263, unwind: bb485]; // scope 2 at src/label.rs:166:9: 166:16
                                         // mir::Constant
                                         // + span: src/label.rs:166:9: 166:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 56, 49, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:166:9: 166:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 56, 49, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb263: {
        switchInt(move _145) -> [false: bb264, otherwise: bb464]; // scope 2 at src/label.rs:166:9: 166:16
    }

    bb264: {
        _146 = <str as PartialEq>::eq(_13, const "csisolatin1") -> [return: bb265, unwind: bb485]; // scope 2 at src/label.rs:167:9: 167:22
                                         // mir::Constant
                                         // + span: src/label.rs:167:9: 167:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:167:9: 167:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb265: {
        switchInt(move _146) -> [false: bb266, otherwise: bb464]; // scope 2 at src/label.rs:167:9: 167:22
    }

    bb266: {
        _147 = <str as PartialEq>::eq(_13, const "ibm819") -> [return: bb267, unwind: bb485]; // scope 2 at src/label.rs:168:9: 168:17
                                         // mir::Constant
                                         // + span: src/label.rs:168:9: 168:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 49, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:168:9: 168:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 49, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb267: {
        switchInt(move _147) -> [false: bb268, otherwise: bb464]; // scope 2 at src/label.rs:168:9: 168:17
    }

    bb268: {
        _148 = <str as PartialEq>::eq(_13, const "iso-8859-1") -> [return: bb269, unwind: bb485]; // scope 2 at src/label.rs:169:9: 169:21
                                         // mir::Constant
                                         // + span: src/label.rs:169:9: 169:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:169:9: 169:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb269: {
        switchInt(move _148) -> [false: bb270, otherwise: bb464]; // scope 2 at src/label.rs:169:9: 169:21
    }

    bb270: {
        _149 = <str as PartialEq>::eq(_13, const "iso-ir-100") -> [return: bb271, unwind: bb485]; // scope 2 at src/label.rs:170:9: 170:21
                                         // mir::Constant
                                         // + span: src/label.rs:170:9: 170:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 48, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:170:9: 170:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 48, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb271: {
        switchInt(move _149) -> [false: bb272, otherwise: bb464]; // scope 2 at src/label.rs:170:9: 170:21
    }

    bb272: {
        _150 = <str as PartialEq>::eq(_13, const "iso8859-1") -> [return: bb273, unwind: bb485]; // scope 2 at src/label.rs:171:9: 171:20
                                         // mir::Constant
                                         // + span: src/label.rs:171:9: 171:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:171:9: 171:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb273: {
        switchInt(move _150) -> [false: bb274, otherwise: bb464]; // scope 2 at src/label.rs:171:9: 171:20
    }

    bb274: {
        _151 = <str as PartialEq>::eq(_13, const "iso88591") -> [return: bb275, unwind: bb485]; // scope 2 at src/label.rs:172:9: 172:19
                                         // mir::Constant
                                         // + span: src/label.rs:172:9: 172:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:172:9: 172:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb275: {
        switchInt(move _151) -> [false: bb276, otherwise: bb464]; // scope 2 at src/label.rs:172:9: 172:19
    }

    bb276: {
        _152 = <str as PartialEq>::eq(_13, const "iso_8859-1") -> [return: bb277, unwind: bb485]; // scope 2 at src/label.rs:173:9: 173:21
                                         // mir::Constant
                                         // + span: src/label.rs:173:9: 173:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:173:9: 173:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb277: {
        switchInt(move _152) -> [false: bb278, otherwise: bb464]; // scope 2 at src/label.rs:173:9: 173:21
    }

    bb278: {
        _153 = <str as PartialEq>::eq(_13, const "iso_8859-1:1987") -> [return: bb279, unwind: bb485]; // scope 2 at src/label.rs:174:9: 174:26
                                         // mir::Constant
                                         // + span: src/label.rs:174:9: 174:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 49, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:174:9: 174:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 49, 58, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb279: {
        switchInt(move _153) -> [false: bb280, otherwise: bb464]; // scope 2 at src/label.rs:174:9: 174:26
    }

    bb280: {
        _154 = <str as PartialEq>::eq(_13, const "l1") -> [return: bb281, unwind: bb485]; // scope 2 at src/label.rs:175:9: 175:13
                                         // mir::Constant
                                         // + span: src/label.rs:175:9: 175:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:175:9: 175:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb281: {
        switchInt(move _154) -> [false: bb282, otherwise: bb464]; // scope 2 at src/label.rs:175:9: 175:13
    }

    bb282: {
        _155 = <str as PartialEq>::eq(_13, const "latin1") -> [return: bb283, unwind: bb485]; // scope 2 at src/label.rs:176:9: 176:17
                                         // mir::Constant
                                         // + span: src/label.rs:176:9: 176:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:176:9: 176:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb283: {
        switchInt(move _155) -> [false: bb284, otherwise: bb464]; // scope 2 at src/label.rs:176:9: 176:17
    }

    bb284: {
        _156 = <str as PartialEq>::eq(_13, const "us-ascii") -> [return: bb285, unwind: bb485]; // scope 2 at src/label.rs:177:9: 177:19
                                         // mir::Constant
                                         // + span: src/label.rs:177:9: 177:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 115, 45, 97, 115, 99, 105, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:177:9: 177:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 115, 45, 97, 115, 99, 105, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb285: {
        switchInt(move _156) -> [false: bb286, otherwise: bb464]; // scope 2 at src/label.rs:177:9: 177:19
    }

    bb286: {
        _157 = <str as PartialEq>::eq(_13, const "windows-1252") -> [return: bb287, unwind: bb485]; // scope 2 at src/label.rs:178:9: 178:23
                                         // mir::Constant
                                         // + span: src/label.rs:178:9: 178:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:178:9: 178:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb287: {
        switchInt(move _157) -> [false: bb288, otherwise: bb464]; // scope 2 at src/label.rs:178:9: 178:23
    }

    bb288: {
        _158 = <str as PartialEq>::eq(_13, const "x-cp1252") -> [return: bb289, unwind: bb485]; // scope 2 at src/label.rs:179:9: 179:19
                                         // mir::Constant
                                         // + span: src/label.rs:179:9: 179:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:179:9: 179:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb289: {
        switchInt(move _158) -> [false: bb290, otherwise: bb464]; // scope 2 at src/label.rs:179:9: 179:19
    }

    bb290: {
        _159 = <str as PartialEq>::eq(_13, const "cp1253") -> [return: bb291, unwind: bb485]; // scope 2 at src/label.rs:181:9: 181:17
                                         // mir::Constant
                                         // + span: src/label.rs:181:9: 181:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:181:9: 181:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb291: {
        switchInt(move _159) -> [false: bb292, otherwise: bb465]; // scope 2 at src/label.rs:181:9: 181:17
    }

    bb292: {
        _160 = <str as PartialEq>::eq(_13, const "windows-1253") -> [return: bb293, unwind: bb485]; // scope 2 at src/label.rs:182:9: 182:23
                                         // mir::Constant
                                         // + span: src/label.rs:182:9: 182:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:182:9: 182:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb293: {
        switchInt(move _160) -> [false: bb294, otherwise: bb465]; // scope 2 at src/label.rs:182:9: 182:23
    }

    bb294: {
        _161 = <str as PartialEq>::eq(_13, const "x-cp1253") -> [return: bb295, unwind: bb485]; // scope 2 at src/label.rs:183:9: 183:19
                                         // mir::Constant
                                         // + span: src/label.rs:183:9: 183:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:183:9: 183:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb295: {
        switchInt(move _161) -> [false: bb296, otherwise: bb465]; // scope 2 at src/label.rs:183:9: 183:19
    }

    bb296: {
        _162 = <str as PartialEq>::eq(_13, const "cp1254") -> [return: bb297, unwind: bb485]; // scope 2 at src/label.rs:185:9: 185:17
                                         // mir::Constant
                                         // + span: src/label.rs:185:9: 185:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:185:9: 185:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb297: {
        switchInt(move _162) -> [false: bb298, otherwise: bb466]; // scope 2 at src/label.rs:185:9: 185:17
    }

    bb298: {
        _163 = <str as PartialEq>::eq(_13, const "csisolatin5") -> [return: bb299, unwind: bb485]; // scope 2 at src/label.rs:186:9: 186:22
                                         // mir::Constant
                                         // + span: src/label.rs:186:9: 186:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:186:9: 186:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 108, 97, 116, 105, 110, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb299: {
        switchInt(move _163) -> [false: bb300, otherwise: bb466]; // scope 2 at src/label.rs:186:9: 186:22
    }

    bb300: {
        _164 = <str as PartialEq>::eq(_13, const "iso-8859-9") -> [return: bb301, unwind: bb485]; // scope 2 at src/label.rs:187:9: 187:21
                                         // mir::Constant
                                         // + span: src/label.rs:187:9: 187:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:187:9: 187:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb301: {
        switchInt(move _164) -> [false: bb302, otherwise: bb466]; // scope 2 at src/label.rs:187:9: 187:21
    }

    bb302: {
        _165 = <str as PartialEq>::eq(_13, const "iso-ir-148") -> [return: bb303, unwind: bb485]; // scope 2 at src/label.rs:188:9: 188:21
                                         // mir::Constant
                                         // + span: src/label.rs:188:9: 188:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 52, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:188:9: 188:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 52, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb303: {
        switchInt(move _165) -> [false: bb304, otherwise: bb466]; // scope 2 at src/label.rs:188:9: 188:21
    }

    bb304: {
        _166 = <str as PartialEq>::eq(_13, const "iso8859-9") -> [return: bb305, unwind: bb485]; // scope 2 at src/label.rs:189:9: 189:20
                                         // mir::Constant
                                         // + span: src/label.rs:189:9: 189:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:189:9: 189:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 45, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb305: {
        switchInt(move _166) -> [false: bb306, otherwise: bb466]; // scope 2 at src/label.rs:189:9: 189:20
    }

    bb306: {
        _167 = <str as PartialEq>::eq(_13, const "iso88599") -> [return: bb307, unwind: bb485]; // scope 2 at src/label.rs:190:9: 190:19
                                         // mir::Constant
                                         // + span: src/label.rs:190:9: 190:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:190:9: 190:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 56, 56, 53, 57, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb307: {
        switchInt(move _167) -> [false: bb308, otherwise: bb466]; // scope 2 at src/label.rs:190:9: 190:19
    }

    bb308: {
        _168 = <str as PartialEq>::eq(_13, const "iso_8859-9") -> [return: bb309, unwind: bb485]; // scope 2 at src/label.rs:191:9: 191:21
                                         // mir::Constant
                                         // + span: src/label.rs:191:9: 191:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:191:9: 191:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb309: {
        switchInt(move _168) -> [false: bb310, otherwise: bb466]; // scope 2 at src/label.rs:191:9: 191:21
    }

    bb310: {
        _169 = <str as PartialEq>::eq(_13, const "iso_8859-9:1989") -> [return: bb311, unwind: bb485]; // scope 2 at src/label.rs:192:9: 192:26
                                         // mir::Constant
                                         // + span: src/label.rs:192:9: 192:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 57, 58, 49, 57, 56, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:192:9: 192:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 95, 56, 56, 53, 57, 45, 57, 58, 49, 57, 56, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb311: {
        switchInt(move _169) -> [false: bb312, otherwise: bb466]; // scope 2 at src/label.rs:192:9: 192:26
    }

    bb312: {
        _170 = <str as PartialEq>::eq(_13, const "l5") -> [return: bb313, unwind: bb485]; // scope 2 at src/label.rs:193:9: 193:13
                                         // mir::Constant
                                         // + span: src/label.rs:193:9: 193:13
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })
                                         // mir::Constant
                                         // + span: src/label.rs:193:9: 193:13
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }
    }

    bb313: {
        switchInt(move _170) -> [false: bb314, otherwise: bb466]; // scope 2 at src/label.rs:193:9: 193:13
    }

    bb314: {
        _171 = <str as PartialEq>::eq(_13, const "latin5") -> [return: bb315, unwind: bb485]; // scope 2 at src/label.rs:194:9: 194:17
                                         // mir::Constant
                                         // + span: src/label.rs:194:9: 194:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:194:9: 194:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [108, 97, 116, 105, 110, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb315: {
        switchInt(move _171) -> [false: bb316, otherwise: bb466]; // scope 2 at src/label.rs:194:9: 194:17
    }

    bb316: {
        _172 = <str as PartialEq>::eq(_13, const "windows-1254") -> [return: bb317, unwind: bb485]; // scope 2 at src/label.rs:195:9: 195:23
                                         // mir::Constant
                                         // + span: src/label.rs:195:9: 195:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:195:9: 195:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb317: {
        switchInt(move _172) -> [false: bb318, otherwise: bb466]; // scope 2 at src/label.rs:195:9: 195:23
    }

    bb318: {
        _173 = <str as PartialEq>::eq(_13, const "x-cp1254") -> [return: bb319, unwind: bb485]; // scope 2 at src/label.rs:196:9: 196:19
                                         // mir::Constant
                                         // + span: src/label.rs:196:9: 196:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:196:9: 196:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb319: {
        switchInt(move _173) -> [false: bb320, otherwise: bb466]; // scope 2 at src/label.rs:196:9: 196:19
    }

    bb320: {
        _174 = <str as PartialEq>::eq(_13, const "cp1255") -> [return: bb321, unwind: bb485]; // scope 2 at src/label.rs:198:9: 198:17
                                         // mir::Constant
                                         // + span: src/label.rs:198:9: 198:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:198:9: 198:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb321: {
        switchInt(move _174) -> [false: bb322, otherwise: bb467]; // scope 2 at src/label.rs:198:9: 198:17
    }

    bb322: {
        _175 = <str as PartialEq>::eq(_13, const "windows-1255") -> [return: bb323, unwind: bb485]; // scope 2 at src/label.rs:199:9: 199:23
                                         // mir::Constant
                                         // + span: src/label.rs:199:9: 199:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:199:9: 199:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb323: {
        switchInt(move _175) -> [false: bb324, otherwise: bb467]; // scope 2 at src/label.rs:199:9: 199:23
    }

    bb324: {
        _176 = <str as PartialEq>::eq(_13, const "x-cp1255") -> [return: bb325, unwind: bb485]; // scope 2 at src/label.rs:200:9: 200:19
                                         // mir::Constant
                                         // + span: src/label.rs:200:9: 200:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:200:9: 200:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb325: {
        switchInt(move _176) -> [false: bb326, otherwise: bb467]; // scope 2 at src/label.rs:200:9: 200:19
    }

    bb326: {
        _177 = <str as PartialEq>::eq(_13, const "cp1256") -> [return: bb327, unwind: bb485]; // scope 2 at src/label.rs:202:9: 202:17
                                         // mir::Constant
                                         // + span: src/label.rs:202:9: 202:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:202:9: 202:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb327: {
        switchInt(move _177) -> [false: bb328, otherwise: bb468]; // scope 2 at src/label.rs:202:9: 202:17
    }

    bb328: {
        _178 = <str as PartialEq>::eq(_13, const "windows-1256") -> [return: bb329, unwind: bb485]; // scope 2 at src/label.rs:203:9: 203:23
                                         // mir::Constant
                                         // + span: src/label.rs:203:9: 203:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:203:9: 203:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb329: {
        switchInt(move _178) -> [false: bb330, otherwise: bb468]; // scope 2 at src/label.rs:203:9: 203:23
    }

    bb330: {
        _179 = <str as PartialEq>::eq(_13, const "x-cp1256") -> [return: bb331, unwind: bb485]; // scope 2 at src/label.rs:204:9: 204:19
                                         // mir::Constant
                                         // + span: src/label.rs:204:9: 204:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:204:9: 204:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb331: {
        switchInt(move _179) -> [false: bb332, otherwise: bb468]; // scope 2 at src/label.rs:204:9: 204:19
    }

    bb332: {
        _180 = <str as PartialEq>::eq(_13, const "cp1257") -> [return: bb333, unwind: bb485]; // scope 2 at src/label.rs:206:9: 206:17
                                         // mir::Constant
                                         // + span: src/label.rs:206:9: 206:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:206:9: 206:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb333: {
        switchInt(move _180) -> [false: bb334, otherwise: bb469]; // scope 2 at src/label.rs:206:9: 206:17
    }

    bb334: {
        _181 = <str as PartialEq>::eq(_13, const "windows-1257") -> [return: bb335, unwind: bb485]; // scope 2 at src/label.rs:207:9: 207:23
                                         // mir::Constant
                                         // + span: src/label.rs:207:9: 207:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:207:9: 207:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb335: {
        switchInt(move _181) -> [false: bb336, otherwise: bb469]; // scope 2 at src/label.rs:207:9: 207:23
    }

    bb336: {
        _182 = <str as PartialEq>::eq(_13, const "x-cp1257") -> [return: bb337, unwind: bb485]; // scope 2 at src/label.rs:208:9: 208:19
                                         // mir::Constant
                                         // + span: src/label.rs:208:9: 208:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:208:9: 208:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb337: {
        switchInt(move _182) -> [false: bb338, otherwise: bb469]; // scope 2 at src/label.rs:208:9: 208:19
    }

    bb338: {
        _183 = <str as PartialEq>::eq(_13, const "cp1258") -> [return: bb339, unwind: bb485]; // scope 2 at src/label.rs:210:9: 210:17
                                         // mir::Constant
                                         // + span: src/label.rs:210:9: 210:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:210:9: 210:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 112, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb339: {
        switchInt(move _183) -> [false: bb340, otherwise: bb470]; // scope 2 at src/label.rs:210:9: 210:17
    }

    bb340: {
        _184 = <str as PartialEq>::eq(_13, const "windows-1258") -> [return: bb341, unwind: bb485]; // scope 2 at src/label.rs:211:9: 211:23
                                         // mir::Constant
                                         // + span: src/label.rs:211:9: 211:23
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/label.rs:211:9: 211:23
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
    }

    bb341: {
        switchInt(move _184) -> [false: bb342, otherwise: bb470]; // scope 2 at src/label.rs:211:9: 211:23
    }

    bb342: {
        _185 = <str as PartialEq>::eq(_13, const "x-cp1258") -> [return: bb343, unwind: bb485]; // scope 2 at src/label.rs:212:9: 212:19
                                         // mir::Constant
                                         // + span: src/label.rs:212:9: 212:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:212:9: 212:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 99, 112, 49, 50, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb343: {
        switchInt(move _185) -> [false: bb344, otherwise: bb470]; // scope 2 at src/label.rs:212:9: 212:19
    }

    bb344: {
        _186 = <str as PartialEq>::eq(_13, const "x-mac-cyrillic") -> [return: bb345, unwind: bb485]; // scope 2 at src/label.rs:214:9: 214:25
                                         // mir::Constant
                                         // + span: src/label.rs:214:9: 214:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/label.rs:214:9: 214:25
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 99, 121, 114, 105, 108, 108, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
    }

    bb345: {
        switchInt(move _186) -> [false: bb346, otherwise: bb471]; // scope 2 at src/label.rs:214:9: 214:25
    }

    bb346: {
        _187 = <str as PartialEq>::eq(_13, const "x-mac-ukrainian") -> [return: bb347, unwind: bb485]; // scope 2 at src/label.rs:215:9: 215:26
                                         // mir::Constant
                                         // + span: src/label.rs:215:9: 215:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 117, 107, 114, 97, 105, 110, 105, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:215:9: 215:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 109, 97, 99, 45, 117, 107, 114, 97, 105, 110, 105, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb347: {
        switchInt(move _187) -> [false: bb348, otherwise: bb471]; // scope 2 at src/label.rs:215:9: 215:26
    }

    bb348: {
        _188 = <str as PartialEq>::eq(_13, const "chinese") -> [return: bb349, unwind: bb485]; // scope 2 at src/label.rs:217:9: 217:18
                                         // mir::Constant
                                         // + span: src/label.rs:217:9: 217:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 104, 105, 110, 101, 115, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:217:9: 217:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 104, 105, 110, 101, 115, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb349: {
        switchInt(move _188) -> [false: bb350, otherwise: bb472]; // scope 2 at src/label.rs:217:9: 217:18
    }

    bb350: {
        _189 = <str as PartialEq>::eq(_13, const "csgb2312") -> [return: bb351, unwind: bb485]; // scope 2 at src/label.rs:218:9: 218:19
                                         // mir::Constant
                                         // + span: src/label.rs:218:9: 218:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 103, 98, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:218:9: 218:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 103, 98, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb351: {
        switchInt(move _189) -> [false: bb352, otherwise: bb472]; // scope 2 at src/label.rs:218:9: 218:19
    }

    bb352: {
        _190 = <str as PartialEq>::eq(_13, const "csiso58gb231280") -> [return: bb353, unwind: bb485]; // scope 2 at src/label.rs:219:9: 219:26
                                         // mir::Constant
                                         // + span: src/label.rs:219:9: 219:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 53, 56, 103, 98, 50, 51, 49, 50, 56, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:219:9: 219:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 53, 56, 103, 98, 50, 51, 49, 50, 56, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb353: {
        switchInt(move _190) -> [false: bb354, otherwise: bb472]; // scope 2 at src/label.rs:219:9: 219:26
    }

    bb354: {
        _191 = <str as PartialEq>::eq(_13, const "gb2312") -> [return: bb355, unwind: bb485]; // scope 2 at src/label.rs:220:9: 220:17
                                         // mir::Constant
                                         // + span: src/label.rs:220:9: 220:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:220:9: 220:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb355: {
        switchInt(move _191) -> [false: bb356, otherwise: bb472]; // scope 2 at src/label.rs:220:9: 220:17
    }

    bb356: {
        _192 = <str as PartialEq>::eq(_13, const "gb_2312") -> [return: bb357, unwind: bb485]; // scope 2 at src/label.rs:221:9: 221:18
                                         // mir::Constant
                                         // + span: src/label.rs:221:9: 221:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 95, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:221:9: 221:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 95, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb357: {
        switchInt(move _192) -> [false: bb358, otherwise: bb472]; // scope 2 at src/label.rs:221:9: 221:18
    }

    bb358: {
        _193 = <str as PartialEq>::eq(_13, const "gb_2312-80") -> [return: bb359, unwind: bb485]; // scope 2 at src/label.rs:222:9: 222:21
                                         // mir::Constant
                                         // + span: src/label.rs:222:9: 222:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 95, 50, 51, 49, 50, 45, 56, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:222:9: 222:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 95, 50, 51, 49, 50, 45, 56, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb359: {
        switchInt(move _193) -> [false: bb360, otherwise: bb472]; // scope 2 at src/label.rs:222:9: 222:21
    }

    bb360: {
        _194 = <str as PartialEq>::eq(_13, const "gbk") -> [return: bb361, unwind: bb485]; // scope 2 at src/label.rs:223:9: 223:14
                                         // mir::Constant
                                         // + span: src/label.rs:223:9: 223:14
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 })
                                         // mir::Constant
                                         // + span: src/label.rs:223:9: 223:14
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 }) }
    }

    bb361: {
        switchInt(move _194) -> [false: bb362, otherwise: bb472]; // scope 2 at src/label.rs:223:9: 223:14
    }

    bb362: {
        _195 = <str as PartialEq>::eq(_13, const "iso-ir-58") -> [return: bb363, unwind: bb485]; // scope 2 at src/label.rs:224:9: 224:20
                                         // mir::Constant
                                         // + span: src/label.rs:224:9: 224:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:224:9: 224:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 53, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb363: {
        switchInt(move _195) -> [false: bb364, otherwise: bb472]; // scope 2 at src/label.rs:224:9: 224:20
    }

    bb364: {
        _196 = <str as PartialEq>::eq(_13, const "x-gbk") -> [return: bb365, unwind: bb485]; // scope 2 at src/label.rs:225:9: 225:16
                                         // mir::Constant
                                         // + span: src/label.rs:225:9: 225:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:225:9: 225:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb365: {
        switchInt(move _196) -> [false: bb366, otherwise: bb472]; // scope 2 at src/label.rs:225:9: 225:16
    }

    bb366: {
        _197 = <str as PartialEq>::eq(_13, const "gb18030") -> [return: bb367, unwind: bb485]; // scope 2 at src/label.rs:227:9: 227:18
                                         // mir::Constant
                                         // + span: src/label.rs:227:9: 227:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 49, 56, 48, 51, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:227:9: 227:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 49, 56, 48, 51, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb367: {
        switchInt(move _197) -> [false: bb368, otherwise: bb473]; // scope 2 at src/label.rs:227:9: 227:18
    }

    bb368: {
        _198 = <str as PartialEq>::eq(_13, const "big5") -> [return: bb369, unwind: bb485]; // scope 2 at src/label.rs:229:9: 229:15
                                         // mir::Constant
                                         // + span: src/label.rs:229:9: 229:15
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/label.rs:229:9: 229:15
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
    }

    bb369: {
        switchInt(move _198) -> [false: bb370, otherwise: bb474]; // scope 2 at src/label.rs:229:9: 229:15
    }

    bb370: {
        _199 = <str as PartialEq>::eq(_13, const "big5-hkscs") -> [return: bb371, unwind: bb485]; // scope 2 at src/label.rs:230:9: 230:21
                                         // mir::Constant
                                         // + span: src/label.rs:230:9: 230:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53, 45, 104, 107, 115, 99, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:230:9: 230:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53, 45, 104, 107, 115, 99, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb371: {
        switchInt(move _199) -> [false: bb372, otherwise: bb474]; // scope 2 at src/label.rs:230:9: 230:21
    }

    bb372: {
        _200 = <str as PartialEq>::eq(_13, const "cn-big5") -> [return: bb373, unwind: bb485]; // scope 2 at src/label.rs:231:9: 231:18
                                         // mir::Constant
                                         // + span: src/label.rs:231:9: 231:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 110, 45, 98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:231:9: 231:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 110, 45, 98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb373: {
        switchInt(move _200) -> [false: bb374, otherwise: bb474]; // scope 2 at src/label.rs:231:9: 231:18
    }

    bb374: {
        _201 = <str as PartialEq>::eq(_13, const "csbig5") -> [return: bb375, unwind: bb485]; // scope 2 at src/label.rs:232:9: 232:17
                                         // mir::Constant
                                         // + span: src/label.rs:232:9: 232:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:232:9: 232:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb375: {
        switchInt(move _201) -> [false: bb376, otherwise: bb474]; // scope 2 at src/label.rs:232:9: 232:17
    }

    bb376: {
        _202 = <str as PartialEq>::eq(_13, const "x-x-big5") -> [return: bb377, unwind: bb485]; // scope 2 at src/label.rs:233:9: 233:19
                                         // mir::Constant
                                         // + span: src/label.rs:233:9: 233:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 120, 45, 98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:233:9: 233:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 120, 45, 98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb377: {
        switchInt(move _202) -> [false: bb378, otherwise: bb474]; // scope 2 at src/label.rs:233:9: 233:19
    }

    bb378: {
        _203 = <str as PartialEq>::eq(_13, const "cseucpkdfmtjapanese") -> [return: bb379, unwind: bb485]; // scope 2 at src/label.rs:235:9: 235:30
                                         // mir::Constant
                                         // + span: src/label.rs:235:9: 235:30
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 101, 117, 99, 112, 107, 100, 102, 109, 116, 106, 97, 112, 97, 110, 101, 115, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/label.rs:235:9: 235:30
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 101, 117, 99, 112, 107, 100, 102, 109, 116, 106, 97, 112, 97, 110, 101, 115, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb379: {
        switchInt(move _203) -> [false: bb380, otherwise: bb475]; // scope 2 at src/label.rs:235:9: 235:30
    }

    bb380: {
        _204 = <str as PartialEq>::eq(_13, const "euc-jp") -> [return: bb381, unwind: bb485]; // scope 2 at src/label.rs:236:9: 236:17
                                         // mir::Constant
                                         // + span: src/label.rs:236:9: 236:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:236:9: 236:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb381: {
        switchInt(move _204) -> [false: bb382, otherwise: bb475]; // scope 2 at src/label.rs:236:9: 236:17
    }

    bb382: {
        _205 = <str as PartialEq>::eq(_13, const "x-euc-jp") -> [return: bb383, unwind: bb485]; // scope 2 at src/label.rs:237:9: 237:19
                                         // mir::Constant
                                         // + span: src/label.rs:237:9: 237:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:237:9: 237:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb383: {
        switchInt(move _205) -> [false: bb384, otherwise: bb475]; // scope 2 at src/label.rs:237:9: 237:19
    }

    bb384: {
        _206 = <str as PartialEq>::eq(_13, const "csiso2022jp") -> [return: bb385, unwind: bb485]; // scope 2 at src/label.rs:239:9: 239:22
                                         // mir::Constant
                                         // + span: src/label.rs:239:9: 239:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 50, 48, 50, 50, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:239:9: 239:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 50, 48, 50, 50, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb385: {
        switchInt(move _206) -> [false: bb386, otherwise: bb476]; // scope 2 at src/label.rs:239:9: 239:22
    }

    bb386: {
        _207 = <str as PartialEq>::eq(_13, const "iso-2022-jp") -> [return: bb387, unwind: bb485]; // scope 2 at src/label.rs:240:9: 240:22
                                         // mir::Constant
                                         // + span: src/label.rs:240:9: 240:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:240:9: 240:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb387: {
        switchInt(move _207) -> [false: bb388, otherwise: bb476]; // scope 2 at src/label.rs:240:9: 240:22
    }

    bb388: {
        _208 = <str as PartialEq>::eq(_13, const "csshiftjis") -> [return: bb389, unwind: bb485]; // scope 2 at src/label.rs:242:9: 242:21
                                         // mir::Constant
                                         // + span: src/label.rs:242:9: 242:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 115, 104, 105, 102, 116, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:242:9: 242:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 115, 104, 105, 102, 116, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb389: {
        switchInt(move _208) -> [false: bb390, otherwise: bb477]; // scope 2 at src/label.rs:242:9: 242:21
    }

    bb390: {
        _209 = <str as PartialEq>::eq(_13, const "ms932") -> [return: bb391, unwind: bb485]; // scope 2 at src/label.rs:243:9: 243:16
                                         // mir::Constant
                                         // + span: src/label.rs:243:9: 243:16
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 115, 57, 51, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/label.rs:243:9: 243:16
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 115, 57, 51, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
    }

    bb391: {
        switchInt(move _209) -> [false: bb392, otherwise: bb477]; // scope 2 at src/label.rs:243:9: 243:16
    }

    bb392: {
        _210 = <str as PartialEq>::eq(_13, const "ms_kanji") -> [return: bb393, unwind: bb485]; // scope 2 at src/label.rs:244:9: 244:19
                                         // mir::Constant
                                         // + span: src/label.rs:244:9: 244:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [109, 115, 95, 107, 97, 110, 106, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:244:9: 244:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [109, 115, 95, 107, 97, 110, 106, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb393: {
        switchInt(move _210) -> [false: bb394, otherwise: bb477]; // scope 2 at src/label.rs:244:9: 244:19
    }

    bb394: {
        _211 = <str as PartialEq>::eq(_13, const "shift-jis") -> [return: bb395, unwind: bb485]; // scope 2 at src/label.rs:245:9: 245:20
                                         // mir::Constant
                                         // + span: src/label.rs:245:9: 245:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [115, 104, 105, 102, 116, 45, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:245:9: 245:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [115, 104, 105, 102, 116, 45, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb395: {
        switchInt(move _211) -> [false: bb396, otherwise: bb477]; // scope 2 at src/label.rs:245:9: 245:20
    }

    bb396: {
        _212 = <str as PartialEq>::eq(_13, const "shift_jis") -> [return: bb397, unwind: bb485]; // scope 2 at src/label.rs:246:9: 246:20
                                         // mir::Constant
                                         // + span: src/label.rs:246:9: 246:20
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [115, 104, 105, 102, 116, 95, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/label.rs:246:9: 246:20
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [115, 104, 105, 102, 116, 95, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
    }

    bb397: {
        switchInt(move _212) -> [false: bb398, otherwise: bb477]; // scope 2 at src/label.rs:246:9: 246:20
    }

    bb398: {
        _213 = <str as PartialEq>::eq(_13, const "sjis") -> [return: bb399, unwind: bb485]; // scope 2 at src/label.rs:247:9: 247:15
                                         // mir::Constant
                                         // + span: src/label.rs:247:9: 247:15
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [115, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/label.rs:247:9: 247:15
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [115, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
    }

    bb399: {
        switchInt(move _213) -> [false: bb400, otherwise: bb477]; // scope 2 at src/label.rs:247:9: 247:15
    }

    bb400: {
        _214 = <str as PartialEq>::eq(_13, const "windows-31j") -> [return: bb401, unwind: bb485]; // scope 2 at src/label.rs:248:9: 248:22
                                         // mir::Constant
                                         // + span: src/label.rs:248:9: 248:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 51, 49, 106], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:248:9: 248:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 51, 49, 106], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb401: {
        switchInt(move _214) -> [false: bb402, otherwise: bb477]; // scope 2 at src/label.rs:248:9: 248:22
    }

    bb402: {
        _215 = <str as PartialEq>::eq(_13, const "x-sjis") -> [return: bb403, unwind: bb485]; // scope 2 at src/label.rs:249:9: 249:17
                                         // mir::Constant
                                         // + span: src/label.rs:249:9: 249:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 115, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:249:9: 249:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 115, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb403: {
        switchInt(move _215) -> [false: bb404, otherwise: bb477]; // scope 2 at src/label.rs:249:9: 249:17
    }

    bb404: {
        _216 = <str as PartialEq>::eq(_13, const "cseuckr") -> [return: bb405, unwind: bb485]; // scope 2 at src/label.rs:251:9: 251:18
                                         // mir::Constant
                                         // + span: src/label.rs:251:9: 251:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 101, 117, 99, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:251:9: 251:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 101, 117, 99, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb405: {
        switchInt(move _216) -> [false: bb406, otherwise: bb478]; // scope 2 at src/label.rs:251:9: 251:18
    }

    bb406: {
        _217 = <str as PartialEq>::eq(_13, const "csksc56011987") -> [return: bb407, unwind: bb485]; // scope 2 at src/label.rs:252:9: 252:24
                                         // mir::Constant
                                         // + span: src/label.rs:252:9: 252:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 107, 115, 99, 53, 54, 48, 49, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [8191], len: Size { raw: 13 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 13 })
                                         // mir::Constant
                                         // + span: src/label.rs:252:9: 252:24
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 107, 115, 99, 53, 54, 48, 49, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [8191], len: Size { raw: 13 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 13 }) }
    }

    bb407: {
        switchInt(move _217) -> [false: bb408, otherwise: bb478]; // scope 2 at src/label.rs:252:9: 252:24
    }

    bb408: {
        _218 = <str as PartialEq>::eq(_13, const "euc-kr") -> [return: bb409, unwind: bb485]; // scope 2 at src/label.rs:253:9: 253:17
                                         // mir::Constant
                                         // + span: src/label.rs:253:9: 253:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:253:9: 253:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb409: {
        switchInt(move _218) -> [false: bb410, otherwise: bb478]; // scope 2 at src/label.rs:253:9: 253:17
    }

    bb410: {
        _219 = <str as PartialEq>::eq(_13, const "iso-ir-149") -> [return: bb411, unwind: bb485]; // scope 2 at src/label.rs:254:9: 254:21
                                         // mir::Constant
                                         // + span: src/label.rs:254:9: 254:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 52, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:254:9: 254:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 105, 114, 45, 49, 52, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb411: {
        switchInt(move _219) -> [false: bb412, otherwise: bb478]; // scope 2 at src/label.rs:254:9: 254:21
    }

    bb412: {
        _220 = <str as PartialEq>::eq(_13, const "korean") -> [return: bb413, unwind: bb485]; // scope 2 at src/label.rs:255:9: 255:17
                                         // mir::Constant
                                         // + span: src/label.rs:255:9: 255:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 114, 101, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:255:9: 255:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 114, 101, 97, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb413: {
        switchInt(move _220) -> [false: bb414, otherwise: bb478]; // scope 2 at src/label.rs:255:9: 255:17
    }

    bb414: {
        _221 = <str as PartialEq>::eq(_13, const "ks_c_5601-1987") -> [return: bb415, unwind: bb485]; // scope 2 at src/label.rs:256:9: 256:25
                                         // mir::Constant
                                         // + span: src/label.rs:256:9: 256:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 115, 95, 99, 95, 53, 54, 48, 49, 45, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/label.rs:256:9: 256:25
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 115, 95, 99, 95, 53, 54, 48, 49, 45, 49, 57, 56, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
    }

    bb415: {
        switchInt(move _221) -> [false: bb416, otherwise: bb478]; // scope 2 at src/label.rs:256:9: 256:25
    }

    bb416: {
        _222 = <str as PartialEq>::eq(_13, const "ks_c_5601-1989") -> [return: bb417, unwind: bb485]; // scope 2 at src/label.rs:257:9: 257:25
                                         // mir::Constant
                                         // + span: src/label.rs:257:9: 257:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 115, 95, 99, 95, 53, 54, 48, 49, 45, 49, 57, 56, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/label.rs:257:9: 257:25
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 115, 95, 99, 95, 53, 54, 48, 49, 45, 49, 57, 56, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
    }

    bb417: {
        switchInt(move _222) -> [false: bb418, otherwise: bb478]; // scope 2 at src/label.rs:257:9: 257:25
    }

    bb418: {
        _223 = <str as PartialEq>::eq(_13, const "ksc5601") -> [return: bb419, unwind: bb485]; // scope 2 at src/label.rs:258:9: 258:18
                                         // mir::Constant
                                         // + span: src/label.rs:258:9: 258:18
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 115, 99, 53, 54, 48, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/label.rs:258:9: 258:18
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 115, 99, 53, 54, 48, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
    }

    bb419: {
        switchInt(move _223) -> [false: bb420, otherwise: bb478]; // scope 2 at src/label.rs:258:9: 258:18
    }

    bb420: {
        _224 = <str as PartialEq>::eq(_13, const "ksc_5601") -> [return: bb421, unwind: bb485]; // scope 2 at src/label.rs:259:9: 259:19
                                         // mir::Constant
                                         // + span: src/label.rs:259:9: 259:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 115, 99, 95, 53, 54, 48, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:259:9: 259:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 115, 99, 95, 53, 54, 48, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb421: {
        switchInt(move _224) -> [false: bb422, otherwise: bb478]; // scope 2 at src/label.rs:259:9: 259:19
    }

    bb422: {
        _225 = <str as PartialEq>::eq(_13, const "windows-949") -> [return: bb423, unwind: bb485]; // scope 2 at src/label.rs:260:9: 260:22
                                         // mir::Constant
                                         // + span: src/label.rs:260:9: 260:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 57, 52, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:260:9: 260:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 57, 52, 57], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb423: {
        switchInt(move _225) -> [false: bb424, otherwise: bb478]; // scope 2 at src/label.rs:260:9: 260:22
    }

    bb424: {
        _226 = <str as PartialEq>::eq(_13, const "csiso2022kr") -> [return: bb425, unwind: bb485]; // scope 2 at src/label.rs:262:9: 262:22
                                         // mir::Constant
                                         // + span: src/label.rs:262:9: 262:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 50, 48, 50, 50, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:262:9: 262:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [99, 115, 105, 115, 111, 50, 48, 50, 50, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb425: {
        switchInt(move _226) -> [false: bb426, otherwise: bb479]; // scope 2 at src/label.rs:262:9: 262:22
    }

    bb426: {
        _227 = <str as PartialEq>::eq(_13, const "hz-gb-2312") -> [return: bb427, unwind: bb485]; // scope 2 at src/label.rs:263:9: 263:21
                                         // mir::Constant
                                         // + span: src/label.rs:263:9: 263:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [104, 122, 45, 103, 98, 45, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/label.rs:263:9: 263:21
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [104, 122, 45, 103, 98, 45, 50, 51, 49, 50], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
    }

    bb427: {
        switchInt(move _227) -> [false: bb428, otherwise: bb479]; // scope 2 at src/label.rs:263:9: 263:21
    }

    bb428: {
        _228 = <str as PartialEq>::eq(_13, const "iso-2022-kr") -> [return: bb429, unwind: bb485]; // scope 2 at src/label.rs:264:9: 264:22
                                         // mir::Constant
                                         // + span: src/label.rs:264:9: 264:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:264:9: 264:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb429: {
        switchInt(move _228) -> [false: bb430, otherwise: bb479]; // scope 2 at src/label.rs:264:9: 264:22
    }

    bb430: {
        _229 = <str as PartialEq>::eq(_13, const "iso-2022-cn") -> [return: bb431, unwind: bb485]; // scope 2 at src/label.rs:265:9: 265:22
                                         // mir::Constant
                                         // + span: src/label.rs:265:9: 265:22
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 99, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/label.rs:265:9: 265:22
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 99, 110], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
    }

    bb431: {
        switchInt(move _229) -> [false: bb432, otherwise: bb479]; // scope 2 at src/label.rs:265:9: 265:22
    }

    bb432: {
        _230 = <str as PartialEq>::eq(_13, const "iso-2022-cn-ext") -> [return: bb433, unwind: bb485]; // scope 2 at src/label.rs:266:9: 266:26
                                         // mir::Constant
                                         // + span: src/label.rs:266:9: 266:26
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 99, 110, 45, 101, 120, 116], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 })
                                         // mir::Constant
                                         // + span: src/label.rs:266:9: 266:26
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 99, 110, 45, 101, 120, 116], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [32767], len: Size { raw: 15 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 15 }) }
    }

    bb433: {
        switchInt(move _230) -> [false: bb434, otherwise: bb479]; // scope 2 at src/label.rs:266:9: 266:26
    }

    bb434: {
        _231 = <str as PartialEq>::eq(_13, const "utf-16be") -> [return: bb435, unwind: bb485]; // scope 2 at src/label.rs:268:9: 268:19
                                         // mir::Constant
                                         // + span: src/label.rs:268:9: 268:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 98, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:268:9: 268:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 98, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb435: {
        switchInt(move _231) -> [false: bb436, otherwise: bb480]; // scope 2 at src/label.rs:268:9: 268:19
    }

    bb436: {
        _232 = <str as PartialEq>::eq(_13, const "utf-16") -> [return: bb437, unwind: bb485]; // scope 2 at src/label.rs:270:9: 270:17
                                         // mir::Constant
                                         // + span: src/label.rs:270:9: 270:17
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/label.rs:270:9: 270:17
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
    }

    bb437: {
        switchInt(move _232) -> [false: bb438, otherwise: bb481]; // scope 2 at src/label.rs:270:9: 270:17
    }

    bb438: {
        _233 = <str as PartialEq>::eq(_13, const "utf-16le") -> [return: bb439, unwind: bb485]; // scope 2 at src/label.rs:271:9: 271:19
                                         // mir::Constant
                                         // + span: src/label.rs:271:9: 271:19
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 108, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/label.rs:271:9: 271:19
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 108, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
    }

    bb439: {
        switchInt(move _233) -> [false: bb440, otherwise: bb481]; // scope 2 at src/label.rs:271:9: 271:19
    }

    bb440: {
        _234 = <str as PartialEq>::eq(_13, const "x-user-defined") -> [return: bb441, unwind: bb485]; // scope 2 at src/label.rs:273:9: 273:25
                                         // mir::Constant
                                         // + span: src/label.rs:273:9: 273:25
                                         // + literal: Const { ty: for<'r, 's> fn(&'r str, &'s str) -> bool {<str as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 117, 115, 101, 114, 45, 100, 101, 102, 105, 110, 101, 100], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/label.rs:273:9: 273:25
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 117, 115, 101, 114, 45, 100, 101, 102, 105, 110, 101, 100], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
    }

    bb441: {
        switchInt(move _234) -> [false: bb442, otherwise: bb482]; // scope 2 at src/label.rs:273:9: 273:25
    }

    bb442: {
        discriminant(_0) = 0;            // scope 2 at src/label.rs:275:14: 275:18
        goto -> bb483;                   // scope 2 at src/label.rs:275:14: 275:18
    }

    bb443: {
        StorageLive(_235);               // scope 2 at src/label.rs:20:18: 20:43
        StorageLive(_236);               // scope 2 at src/label.rs:20:18: 20:43
        StorageLive(_237);               // scope 2 at src/label.rs:20:18: 20:43
        StorageLive(_238);               // scope 2 at src/label.rs:20:18: 20:28
        StorageLive(_239);               // scope 2 at src/label.rs:20:18: 20:28
        _239 = const UTF_8;              // scope 2 at src/label.rs:20:18: 20:28
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(UTF_8, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:20:18: 20:28
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1277 ~ encoding[5d2c]::all::UTF_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _238 = _239;                     // scope 2 at src/label.rs:20:18: 20:28
        _237 = move _238 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:20:18: 20:28
        StorageDead(_238);               // scope 2 at src/label.rs:20:27: 20:28
        _236 = _237;                     // scope 2 at src/label.rs:20:18: 20:43
        _235 = move _236 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:20:18: 20:43
        StorageDead(_236);               // scope 2 at src/label.rs:20:42: 20:43
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _235; // scope 2 at src/label.rs:20:13: 20:44
        discriminant(_0) = 1;            // scope 2 at src/label.rs:20:13: 20:44
        StorageDead(_239);               // scope 2 at src/label.rs:20:43: 20:44
        StorageDead(_237);               // scope 2 at src/label.rs:20:43: 20:44
        StorageDead(_235);               // scope 2 at src/label.rs:20:43: 20:44
        goto -> bb483;                   // scope 2 at src/label.rs:20:43: 20:44
    }

    bb444: {
        StorageLive(_240);               // scope 2 at src/label.rs:25:18: 25:44
        StorageLive(_241);               // scope 2 at src/label.rs:25:18: 25:44
        StorageLive(_242);               // scope 2 at src/label.rs:25:18: 25:44
        StorageLive(_243);               // scope 2 at src/label.rs:25:18: 25:29
        StorageLive(_244);               // scope 2 at src/label.rs:25:18: 25:29
        _244 = const IBM866;             // scope 2 at src/label.rs:25:18: 25:29
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(IBM866, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:25:18: 25:29
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1249 ~ encoding[5d2c]::all::IBM866), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _243 = _244;                     // scope 2 at src/label.rs:25:18: 25:29
        _242 = move _243 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:25:18: 25:29
        StorageDead(_243);               // scope 2 at src/label.rs:25:28: 25:29
        _241 = _242;                     // scope 2 at src/label.rs:25:18: 25:44
        _240 = move _241 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:25:18: 25:44
        StorageDead(_241);               // scope 2 at src/label.rs:25:43: 25:44
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _240; // scope 2 at src/label.rs:25:13: 25:45
        discriminant(_0) = 1;            // scope 2 at src/label.rs:25:13: 25:45
        StorageDead(_244);               // scope 2 at src/label.rs:25:44: 25:45
        StorageDead(_242);               // scope 2 at src/label.rs:25:44: 25:45
        StorageDead(_240);               // scope 2 at src/label.rs:25:44: 25:45
        goto -> bb483;                   // scope 2 at src/label.rs:25:44: 25:45
    }

    bb445: {
        StorageLive(_245);               // scope 2 at src/label.rs:35:18: 35:48
        StorageLive(_246);               // scope 2 at src/label.rs:35:18: 35:48
        StorageLive(_247);               // scope 2 at src/label.rs:35:18: 35:48
        StorageLive(_248);               // scope 2 at src/label.rs:35:18: 35:33
        StorageLive(_249);               // scope 2 at src/label.rs:35:18: 35:33
        _249 = const ISO_8859_2;         // scope 2 at src/label.rs:35:18: 35:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_2, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:35:18: 35:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1251 ~ encoding[5d2c]::all::ISO_8859_2), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _248 = _249;                     // scope 2 at src/label.rs:35:18: 35:33
        _247 = move _248 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:35:18: 35:33
        StorageDead(_248);               // scope 2 at src/label.rs:35:32: 35:33
        _246 = _247;                     // scope 2 at src/label.rs:35:18: 35:48
        _245 = move _246 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:35:18: 35:48
        StorageDead(_246);               // scope 2 at src/label.rs:35:47: 35:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _245; // scope 2 at src/label.rs:35:13: 35:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:35:13: 35:49
        StorageDead(_249);               // scope 2 at src/label.rs:35:48: 35:49
        StorageDead(_247);               // scope 2 at src/label.rs:35:48: 35:49
        StorageDead(_245);               // scope 2 at src/label.rs:35:48: 35:49
        goto -> bb483;                   // scope 2 at src/label.rs:35:48: 35:49
    }

    bb446: {
        StorageLive(_250);               // scope 2 at src/label.rs:45:18: 45:48
        StorageLive(_251);               // scope 2 at src/label.rs:45:18: 45:48
        StorageLive(_252);               // scope 2 at src/label.rs:45:18: 45:48
        StorageLive(_253);               // scope 2 at src/label.rs:45:18: 45:33
        StorageLive(_254);               // scope 2 at src/label.rs:45:18: 45:33
        _254 = const ISO_8859_3;         // scope 2 at src/label.rs:45:18: 45:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_3, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:45:18: 45:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1252 ~ encoding[5d2c]::all::ISO_8859_3), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _253 = _254;                     // scope 2 at src/label.rs:45:18: 45:33
        _252 = move _253 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:45:18: 45:33
        StorageDead(_253);               // scope 2 at src/label.rs:45:32: 45:33
        _251 = _252;                     // scope 2 at src/label.rs:45:18: 45:48
        _250 = move _251 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:45:18: 45:48
        StorageDead(_251);               // scope 2 at src/label.rs:45:47: 45:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _250; // scope 2 at src/label.rs:45:13: 45:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:45:13: 45:49
        StorageDead(_254);               // scope 2 at src/label.rs:45:48: 45:49
        StorageDead(_252);               // scope 2 at src/label.rs:45:48: 45:49
        StorageDead(_250);               // scope 2 at src/label.rs:45:48: 45:49
        goto -> bb483;                   // scope 2 at src/label.rs:45:48: 45:49
    }

    bb447: {
        StorageLive(_255);               // scope 2 at src/label.rs:55:18: 55:48
        StorageLive(_256);               // scope 2 at src/label.rs:55:18: 55:48
        StorageLive(_257);               // scope 2 at src/label.rs:55:18: 55:48
        StorageLive(_258);               // scope 2 at src/label.rs:55:18: 55:33
        StorageLive(_259);               // scope 2 at src/label.rs:55:18: 55:33
        _259 = const ISO_8859_4;         // scope 2 at src/label.rs:55:18: 55:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_4, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:55:18: 55:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1253 ~ encoding[5d2c]::all::ISO_8859_4), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _258 = _259;                     // scope 2 at src/label.rs:55:18: 55:33
        _257 = move _258 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:55:18: 55:33
        StorageDead(_258);               // scope 2 at src/label.rs:55:32: 55:33
        _256 = _257;                     // scope 2 at src/label.rs:55:18: 55:48
        _255 = move _256 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:55:18: 55:48
        StorageDead(_256);               // scope 2 at src/label.rs:55:47: 55:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _255; // scope 2 at src/label.rs:55:13: 55:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:55:13: 55:49
        StorageDead(_259);               // scope 2 at src/label.rs:55:48: 55:49
        StorageDead(_257);               // scope 2 at src/label.rs:55:48: 55:49
        StorageDead(_255);               // scope 2 at src/label.rs:55:48: 55:49
        goto -> bb483;                   // scope 2 at src/label.rs:55:48: 55:49
    }

    bb448: {
        StorageLive(_260);               // scope 2 at src/label.rs:64:18: 64:48
        StorageLive(_261);               // scope 2 at src/label.rs:64:18: 64:48
        StorageLive(_262);               // scope 2 at src/label.rs:64:18: 64:48
        StorageLive(_263);               // scope 2 at src/label.rs:64:18: 64:33
        StorageLive(_264);               // scope 2 at src/label.rs:64:18: 64:33
        _264 = const ISO_8859_5;         // scope 2 at src/label.rs:64:18: 64:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_5, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:64:18: 64:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1254 ~ encoding[5d2c]::all::ISO_8859_5), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _263 = _264;                     // scope 2 at src/label.rs:64:18: 64:33
        _262 = move _263 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:64:18: 64:33
        StorageDead(_263);               // scope 2 at src/label.rs:64:32: 64:33
        _261 = _262;                     // scope 2 at src/label.rs:64:18: 64:48
        _260 = move _261 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:64:18: 64:48
        StorageDead(_261);               // scope 2 at src/label.rs:64:47: 64:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _260; // scope 2 at src/label.rs:64:13: 64:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:64:13: 64:49
        StorageDead(_264);               // scope 2 at src/label.rs:64:48: 64:49
        StorageDead(_262);               // scope 2 at src/label.rs:64:48: 64:49
        StorageDead(_260);               // scope 2 at src/label.rs:64:48: 64:49
        goto -> bb483;                   // scope 2 at src/label.rs:64:48: 64:49
    }

    bb449: {
        StorageLive(_265);               // scope 2 at src/label.rs:79:18: 79:48
        StorageLive(_266);               // scope 2 at src/label.rs:79:18: 79:48
        StorageLive(_267);               // scope 2 at src/label.rs:79:18: 79:48
        StorageLive(_268);               // scope 2 at src/label.rs:79:18: 79:33
        StorageLive(_269);               // scope 2 at src/label.rs:79:18: 79:33
        _269 = const ISO_8859_6;         // scope 2 at src/label.rs:79:18: 79:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_6, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:79:18: 79:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1255 ~ encoding[5d2c]::all::ISO_8859_6), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _268 = _269;                     // scope 2 at src/label.rs:79:18: 79:33
        _267 = move _268 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:79:18: 79:33
        StorageDead(_268);               // scope 2 at src/label.rs:79:32: 79:33
        _266 = _267;                     // scope 2 at src/label.rs:79:18: 79:48
        _265 = move _266 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:79:18: 79:48
        StorageDead(_266);               // scope 2 at src/label.rs:79:47: 79:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _265; // scope 2 at src/label.rs:79:13: 79:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:79:13: 79:49
        StorageDead(_269);               // scope 2 at src/label.rs:79:48: 79:49
        StorageDead(_267);               // scope 2 at src/label.rs:79:48: 79:49
        StorageDead(_265);               // scope 2 at src/label.rs:79:48: 79:49
        goto -> bb483;                   // scope 2 at src/label.rs:79:48: 79:49
    }

    bb450: {
        StorageLive(_270);               // scope 2 at src/label.rs:92:18: 92:48
        StorageLive(_271);               // scope 2 at src/label.rs:92:18: 92:48
        StorageLive(_272);               // scope 2 at src/label.rs:92:18: 92:48
        StorageLive(_273);               // scope 2 at src/label.rs:92:18: 92:33
        StorageLive(_274);               // scope 2 at src/label.rs:92:18: 92:33
        _274 = const ISO_8859_7;         // scope 2 at src/label.rs:92:18: 92:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_7, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:92:18: 92:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1256 ~ encoding[5d2c]::all::ISO_8859_7), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _273 = _274;                     // scope 2 at src/label.rs:92:18: 92:33
        _272 = move _273 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:92:18: 92:33
        StorageDead(_273);               // scope 2 at src/label.rs:92:32: 92:33
        _271 = _272;                     // scope 2 at src/label.rs:92:18: 92:48
        _270 = move _271 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:92:18: 92:48
        StorageDead(_271);               // scope 2 at src/label.rs:92:47: 92:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _270; // scope 2 at src/label.rs:92:13: 92:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:92:13: 92:49
        StorageDead(_274);               // scope 2 at src/label.rs:92:48: 92:49
        StorageDead(_272);               // scope 2 at src/label.rs:92:48: 92:49
        StorageDead(_270);               // scope 2 at src/label.rs:92:48: 92:49
        goto -> bb483;                   // scope 2 at src/label.rs:92:48: 92:49
    }

    bb451: {
        StorageLive(_275);               // scope 2 at src/label.rs:104:18: 104:48
        StorageLive(_276);               // scope 2 at src/label.rs:104:18: 104:48
        StorageLive(_277);               // scope 2 at src/label.rs:104:18: 104:48
        StorageLive(_278);               // scope 2 at src/label.rs:104:18: 104:33
        StorageLive(_279);               // scope 2 at src/label.rs:104:18: 104:33
        _279 = const ISO_8859_8;         // scope 2 at src/label.rs:104:18: 104:33
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:104:18: 104:33
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1257 ~ encoding[5d2c]::all::ISO_8859_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _278 = _279;                     // scope 2 at src/label.rs:104:18: 104:33
        _277 = move _278 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:104:18: 104:33
        StorageDead(_278);               // scope 2 at src/label.rs:104:32: 104:33
        _276 = _277;                     // scope 2 at src/label.rs:104:18: 104:48
        _275 = move _276 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:104:18: 104:48
        StorageDead(_276);               // scope 2 at src/label.rs:104:47: 104:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _275; // scope 2 at src/label.rs:104:13: 104:49
        discriminant(_0) = 1;            // scope 2 at src/label.rs:104:13: 104:49
        StorageDead(_279);               // scope 2 at src/label.rs:104:48: 104:49
        StorageDead(_277);               // scope 2 at src/label.rs:104:48: 104:49
        StorageDead(_275);               // scope 2 at src/label.rs:104:48: 104:49
        goto -> bb483;                   // scope 2 at src/label.rs:104:48: 104:49
    }

    bb452: {
        StorageLive(_280);               // scope 2 at src/label.rs:108:18: 108:58
        StorageLive(_281);               // scope 2 at src/label.rs:108:18: 108:58
        StorageLive(_282);               // scope 2 at src/label.rs:108:18: 108:58
        StorageLive(_283);               // scope 2 at src/label.rs:108:18: 108:43
        StorageLive(_284);               // scope 2 at src/label.rs:108:18: 108:43
        _284 = const ISO_8859_8_I;       // scope 2 at src/label.rs:108:18: 108:43
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8_I, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:108:18: 108:43
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1289 ~ encoding[5d2c]::all::whatwg::ISO_8859_8_I), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _283 = _284;                     // scope 2 at src/label.rs:108:18: 108:43
        _282 = move _283 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:108:18: 108:43
        StorageDead(_283);               // scope 2 at src/label.rs:108:42: 108:43
        _281 = _282;                     // scope 2 at src/label.rs:108:18: 108:58
        _280 = move _281 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:108:18: 108:58
        StorageDead(_281);               // scope 2 at src/label.rs:108:57: 108:58
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _280; // scope 2 at src/label.rs:108:13: 108:59
        discriminant(_0) = 1;            // scope 2 at src/label.rs:108:13: 108:59
        StorageDead(_284);               // scope 2 at src/label.rs:108:58: 108:59
        StorageDead(_282);               // scope 2 at src/label.rs:108:58: 108:59
        StorageDead(_280);               // scope 2 at src/label.rs:108:58: 108:59
        goto -> bb483;                   // scope 2 at src/label.rs:108:58: 108:59
    }

    bb453: {
        StorageLive(_285);               // scope 2 at src/label.rs:116:18: 116:49
        StorageLive(_286);               // scope 2 at src/label.rs:116:18: 116:49
        StorageLive(_287);               // scope 2 at src/label.rs:116:18: 116:49
        StorageLive(_288);               // scope 2 at src/label.rs:116:18: 116:34
        StorageLive(_289);               // scope 2 at src/label.rs:116:18: 116:34
        _289 = const ISO_8859_10;        // scope 2 at src/label.rs:116:18: 116:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_10, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:116:18: 116:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1258 ~ encoding[5d2c]::all::ISO_8859_10), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _288 = _289;                     // scope 2 at src/label.rs:116:18: 116:34
        _287 = move _288 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:116:18: 116:34
        StorageDead(_288);               // scope 2 at src/label.rs:116:33: 116:34
        _286 = _287;                     // scope 2 at src/label.rs:116:18: 116:49
        _285 = move _286 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:116:18: 116:49
        StorageDead(_286);               // scope 2 at src/label.rs:116:48: 116:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _285; // scope 2 at src/label.rs:116:13: 116:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:116:13: 116:50
        StorageDead(_289);               // scope 2 at src/label.rs:116:49: 116:50
        StorageDead(_287);               // scope 2 at src/label.rs:116:49: 116:50
        StorageDead(_285);               // scope 2 at src/label.rs:116:49: 116:50
        goto -> bb483;                   // scope 2 at src/label.rs:116:49: 116:50
    }

    bb454: {
        StorageLive(_290);               // scope 2 at src/label.rs:120:18: 120:49
        StorageLive(_291);               // scope 2 at src/label.rs:120:18: 120:49
        StorageLive(_292);               // scope 2 at src/label.rs:120:18: 120:49
        StorageLive(_293);               // scope 2 at src/label.rs:120:18: 120:34
        StorageLive(_294);               // scope 2 at src/label.rs:120:18: 120:34
        _294 = const ISO_8859_13;        // scope 2 at src/label.rs:120:18: 120:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_13, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:120:18: 120:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1259 ~ encoding[5d2c]::all::ISO_8859_13), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _293 = _294;                     // scope 2 at src/label.rs:120:18: 120:34
        _292 = move _293 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:120:18: 120:34
        StorageDead(_293);               // scope 2 at src/label.rs:120:33: 120:34
        _291 = _292;                     // scope 2 at src/label.rs:120:18: 120:49
        _290 = move _291 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:120:18: 120:49
        StorageDead(_291);               // scope 2 at src/label.rs:120:48: 120:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _290; // scope 2 at src/label.rs:120:13: 120:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:120:13: 120:50
        StorageDead(_294);               // scope 2 at src/label.rs:120:49: 120:50
        StorageDead(_292);               // scope 2 at src/label.rs:120:49: 120:50
        StorageDead(_290);               // scope 2 at src/label.rs:120:49: 120:50
        goto -> bb483;                   // scope 2 at src/label.rs:120:49: 120:50
    }

    bb455: {
        StorageLive(_295);               // scope 2 at src/label.rs:124:18: 124:49
        StorageLive(_296);               // scope 2 at src/label.rs:124:18: 124:49
        StorageLive(_297);               // scope 2 at src/label.rs:124:18: 124:49
        StorageLive(_298);               // scope 2 at src/label.rs:124:18: 124:34
        StorageLive(_299);               // scope 2 at src/label.rs:124:18: 124:34
        _299 = const ISO_8859_14;        // scope 2 at src/label.rs:124:18: 124:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_14, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:124:18: 124:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1260 ~ encoding[5d2c]::all::ISO_8859_14), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _298 = _299;                     // scope 2 at src/label.rs:124:18: 124:34
        _297 = move _298 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:124:18: 124:34
        StorageDead(_298);               // scope 2 at src/label.rs:124:33: 124:34
        _296 = _297;                     // scope 2 at src/label.rs:124:18: 124:49
        _295 = move _296 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:124:18: 124:49
        StorageDead(_296);               // scope 2 at src/label.rs:124:48: 124:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _295; // scope 2 at src/label.rs:124:13: 124:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:124:13: 124:50
        StorageDead(_299);               // scope 2 at src/label.rs:124:49: 124:50
        StorageDead(_297);               // scope 2 at src/label.rs:124:49: 124:50
        StorageDead(_295);               // scope 2 at src/label.rs:124:49: 124:50
        goto -> bb483;                   // scope 2 at src/label.rs:124:49: 124:50
    }

    bb456: {
        StorageLive(_300);               // scope 2 at src/label.rs:131:18: 131:49
        StorageLive(_301);               // scope 2 at src/label.rs:131:18: 131:49
        StorageLive(_302);               // scope 2 at src/label.rs:131:18: 131:49
        StorageLive(_303);               // scope 2 at src/label.rs:131:18: 131:34
        StorageLive(_304);               // scope 2 at src/label.rs:131:18: 131:34
        _304 = const ISO_8859_15;        // scope 2 at src/label.rs:131:18: 131:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_15, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:131:18: 131:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1261 ~ encoding[5d2c]::all::ISO_8859_15), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _303 = _304;                     // scope 2 at src/label.rs:131:18: 131:34
        _302 = move _303 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:131:18: 131:34
        StorageDead(_303);               // scope 2 at src/label.rs:131:33: 131:34
        _301 = _302;                     // scope 2 at src/label.rs:131:18: 131:49
        _300 = move _301 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:131:18: 131:49
        StorageDead(_301);               // scope 2 at src/label.rs:131:48: 131:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _300; // scope 2 at src/label.rs:131:13: 131:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:131:13: 131:50
        StorageDead(_304);               // scope 2 at src/label.rs:131:49: 131:50
        StorageDead(_302);               // scope 2 at src/label.rs:131:49: 131:50
        StorageDead(_300);               // scope 2 at src/label.rs:131:49: 131:50
        goto -> bb483;                   // scope 2 at src/label.rs:131:49: 131:50
    }

    bb457: {
        StorageLive(_305);               // scope 2 at src/label.rs:133:18: 133:49
        StorageLive(_306);               // scope 2 at src/label.rs:133:18: 133:49
        StorageLive(_307);               // scope 2 at src/label.rs:133:18: 133:49
        StorageLive(_308);               // scope 2 at src/label.rs:133:18: 133:34
        StorageLive(_309);               // scope 2 at src/label.rs:133:18: 133:34
        _309 = const ISO_8859_16;        // scope 2 at src/label.rs:133:18: 133:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_16, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:133:18: 133:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1262 ~ encoding[5d2c]::all::ISO_8859_16), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _308 = _309;                     // scope 2 at src/label.rs:133:18: 133:34
        _307 = move _308 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:133:18: 133:34
        StorageDead(_308);               // scope 2 at src/label.rs:133:33: 133:34
        _306 = _307;                     // scope 2 at src/label.rs:133:18: 133:49
        _305 = move _306 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:133:18: 133:49
        StorageDead(_306);               // scope 2 at src/label.rs:133:48: 133:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _305; // scope 2 at src/label.rs:133:13: 133:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:133:13: 133:50
        StorageDead(_309);               // scope 2 at src/label.rs:133:49: 133:50
        StorageDead(_307);               // scope 2 at src/label.rs:133:49: 133:50
        StorageDead(_305);               // scope 2 at src/label.rs:133:49: 133:50
        goto -> bb483;                   // scope 2 at src/label.rs:133:49: 133:50
    }

    bb458: {
        StorageLive(_310);               // scope 2 at src/label.rs:139:18: 139:44
        StorageLive(_311);               // scope 2 at src/label.rs:139:18: 139:44
        StorageLive(_312);               // scope 2 at src/label.rs:139:18: 139:44
        StorageLive(_313);               // scope 2 at src/label.rs:139:18: 139:29
        StorageLive(_314);               // scope 2 at src/label.rs:139:18: 139:29
        _314 = const KOI8_R;             // scope 2 at src/label.rs:139:18: 139:29
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_R, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:139:18: 139:29
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1263 ~ encoding[5d2c]::all::KOI8_R), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _313 = _314;                     // scope 2 at src/label.rs:139:18: 139:29
        _312 = move _313 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:139:18: 139:29
        StorageDead(_313);               // scope 2 at src/label.rs:139:28: 139:29
        _311 = _312;                     // scope 2 at src/label.rs:139:18: 139:44
        _310 = move _311 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:139:18: 139:44
        StorageDead(_311);               // scope 2 at src/label.rs:139:43: 139:44
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _310; // scope 2 at src/label.rs:139:13: 139:45
        discriminant(_0) = 1;            // scope 2 at src/label.rs:139:13: 139:45
        StorageDead(_314);               // scope 2 at src/label.rs:139:44: 139:45
        StorageDead(_312);               // scope 2 at src/label.rs:139:44: 139:45
        StorageDead(_310);               // scope 2 at src/label.rs:139:44: 139:45
        goto -> bb483;                   // scope 2 at src/label.rs:139:44: 139:45
    }

    bb459: {
        StorageLive(_315);               // scope 2 at src/label.rs:142:18: 142:44
        StorageLive(_316);               // scope 2 at src/label.rs:142:18: 142:44
        StorageLive(_317);               // scope 2 at src/label.rs:142:18: 142:44
        StorageLive(_318);               // scope 2 at src/label.rs:142:18: 142:29
        StorageLive(_319);               // scope 2 at src/label.rs:142:18: 142:29
        _319 = const KOI8_U;             // scope 2 at src/label.rs:142:18: 142:29
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_U, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:142:18: 142:29
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1264 ~ encoding[5d2c]::all::KOI8_U), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _318 = _319;                     // scope 2 at src/label.rs:142:18: 142:29
        _317 = move _318 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:142:18: 142:29
        StorageDead(_318);               // scope 2 at src/label.rs:142:28: 142:29
        _316 = _317;                     // scope 2 at src/label.rs:142:18: 142:44
        _315 = move _316 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:142:18: 142:44
        StorageDead(_316);               // scope 2 at src/label.rs:142:43: 142:44
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _315; // scope 2 at src/label.rs:142:13: 142:45
        discriminant(_0) = 1;            // scope 2 at src/label.rs:142:13: 142:45
        StorageDead(_319);               // scope 2 at src/label.rs:142:44: 142:45
        StorageDead(_317);               // scope 2 at src/label.rs:142:44: 142:45
        StorageDead(_315);               // scope 2 at src/label.rs:142:44: 142:45
        goto -> bb483;                   // scope 2 at src/label.rs:142:44: 142:45
    }

    bb460: {
        StorageLive(_320);               // scope 2 at src/label.rs:147:18: 147:47
        StorageLive(_321);               // scope 2 at src/label.rs:147:18: 147:47
        StorageLive(_322);               // scope 2 at src/label.rs:147:18: 147:47
        StorageLive(_323);               // scope 2 at src/label.rs:147:18: 147:32
        StorageLive(_324);               // scope 2 at src/label.rs:147:18: 147:32
        _324 = const MAC_ROMAN;          // scope 2 at src/label.rs:147:18: 147:32
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_ROMAN, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:147:18: 147:32
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1265 ~ encoding[5d2c]::all::MAC_ROMAN), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _323 = _324;                     // scope 2 at src/label.rs:147:18: 147:32
        _322 = move _323 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:147:18: 147:32
        StorageDead(_323);               // scope 2 at src/label.rs:147:31: 147:32
        _321 = _322;                     // scope 2 at src/label.rs:147:18: 147:47
        _320 = move _321 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:147:18: 147:47
        StorageDead(_321);               // scope 2 at src/label.rs:147:46: 147:47
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _320; // scope 2 at src/label.rs:147:13: 147:48
        discriminant(_0) = 1;            // scope 2 at src/label.rs:147:13: 147:48
        StorageDead(_324);               // scope 2 at src/label.rs:147:47: 147:48
        StorageDead(_322);               // scope 2 at src/label.rs:147:47: 147:48
        StorageDead(_320);               // scope 2 at src/label.rs:147:47: 147:48
        goto -> bb483;                   // scope 2 at src/label.rs:147:47: 147:48
    }

    bb461: {
        StorageLive(_325);               // scope 2 at src/label.rs:154:18: 154:49
        StorageLive(_326);               // scope 2 at src/label.rs:154:18: 154:49
        StorageLive(_327);               // scope 2 at src/label.rs:154:18: 154:49
        StorageLive(_328);               // scope 2 at src/label.rs:154:18: 154:34
        StorageLive(_329);               // scope 2 at src/label.rs:154:18: 154:34
        _329 = const WINDOWS_874;        // scope 2 at src/label.rs:154:18: 154:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_874, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:154:18: 154:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1266 ~ encoding[5d2c]::all::WINDOWS_874), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _328 = _329;                     // scope 2 at src/label.rs:154:18: 154:34
        _327 = move _328 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:154:18: 154:34
        StorageDead(_328);               // scope 2 at src/label.rs:154:33: 154:34
        _326 = _327;                     // scope 2 at src/label.rs:154:18: 154:49
        _325 = move _326 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:154:18: 154:49
        StorageDead(_326);               // scope 2 at src/label.rs:154:48: 154:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _325; // scope 2 at src/label.rs:154:13: 154:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:154:13: 154:50
        StorageDead(_329);               // scope 2 at src/label.rs:154:49: 154:50
        StorageDead(_327);               // scope 2 at src/label.rs:154:49: 154:50
        StorageDead(_325);               // scope 2 at src/label.rs:154:49: 154:50
        goto -> bb483;                   // scope 2 at src/label.rs:154:49: 154:50
    }

    bb462: {
        StorageLive(_330);               // scope 2 at src/label.rs:158:18: 158:50
        StorageLive(_331);               // scope 2 at src/label.rs:158:18: 158:50
        StorageLive(_332);               // scope 2 at src/label.rs:158:18: 158:50
        StorageLive(_333);               // scope 2 at src/label.rs:158:18: 158:35
        StorageLive(_334);               // scope 2 at src/label.rs:158:18: 158:35
        _334 = const WINDOWS_1250;       // scope 2 at src/label.rs:158:18: 158:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1250, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:158:18: 158:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1267 ~ encoding[5d2c]::all::WINDOWS_1250), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _333 = _334;                     // scope 2 at src/label.rs:158:18: 158:35
        _332 = move _333 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:158:18: 158:35
        StorageDead(_333);               // scope 2 at src/label.rs:158:34: 158:35
        _331 = _332;                     // scope 2 at src/label.rs:158:18: 158:50
        _330 = move _331 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:158:18: 158:50
        StorageDead(_331);               // scope 2 at src/label.rs:158:49: 158:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _330; // scope 2 at src/label.rs:158:13: 158:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:158:13: 158:51
        StorageDead(_334);               // scope 2 at src/label.rs:158:50: 158:51
        StorageDead(_332);               // scope 2 at src/label.rs:158:50: 158:51
        StorageDead(_330);               // scope 2 at src/label.rs:158:50: 158:51
        goto -> bb483;                   // scope 2 at src/label.rs:158:50: 158:51
    }

    bb463: {
        StorageLive(_335);               // scope 2 at src/label.rs:162:18: 162:50
        StorageLive(_336);               // scope 2 at src/label.rs:162:18: 162:50
        StorageLive(_337);               // scope 2 at src/label.rs:162:18: 162:50
        StorageLive(_338);               // scope 2 at src/label.rs:162:18: 162:35
        StorageLive(_339);               // scope 2 at src/label.rs:162:18: 162:35
        _339 = const WINDOWS_1251;       // scope 2 at src/label.rs:162:18: 162:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1251, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:162:18: 162:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1268 ~ encoding[5d2c]::all::WINDOWS_1251), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _338 = _339;                     // scope 2 at src/label.rs:162:18: 162:35
        _337 = move _338 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:162:18: 162:35
        StorageDead(_338);               // scope 2 at src/label.rs:162:34: 162:35
        _336 = _337;                     // scope 2 at src/label.rs:162:18: 162:50
        _335 = move _336 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:162:18: 162:50
        StorageDead(_336);               // scope 2 at src/label.rs:162:49: 162:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _335; // scope 2 at src/label.rs:162:13: 162:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:162:13: 162:51
        StorageDead(_339);               // scope 2 at src/label.rs:162:50: 162:51
        StorageDead(_337);               // scope 2 at src/label.rs:162:50: 162:51
        StorageDead(_335);               // scope 2 at src/label.rs:162:50: 162:51
        goto -> bb483;                   // scope 2 at src/label.rs:162:50: 162:51
    }

    bb464: {
        StorageLive(_340);               // scope 2 at src/label.rs:180:18: 180:50
        StorageLive(_341);               // scope 2 at src/label.rs:180:18: 180:50
        StorageLive(_342);               // scope 2 at src/label.rs:180:18: 180:50
        StorageLive(_343);               // scope 2 at src/label.rs:180:18: 180:35
        StorageLive(_344);               // scope 2 at src/label.rs:180:18: 180:35
        _344 = const WINDOWS_1252;       // scope 2 at src/label.rs:180:18: 180:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1252, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:180:18: 180:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1269 ~ encoding[5d2c]::all::WINDOWS_1252), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _343 = _344;                     // scope 2 at src/label.rs:180:18: 180:35
        _342 = move _343 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:180:18: 180:35
        StorageDead(_343);               // scope 2 at src/label.rs:180:34: 180:35
        _341 = _342;                     // scope 2 at src/label.rs:180:18: 180:50
        _340 = move _341 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:180:18: 180:50
        StorageDead(_341);               // scope 2 at src/label.rs:180:49: 180:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _340; // scope 2 at src/label.rs:180:13: 180:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:180:13: 180:51
        StorageDead(_344);               // scope 2 at src/label.rs:180:50: 180:51
        StorageDead(_342);               // scope 2 at src/label.rs:180:50: 180:51
        StorageDead(_340);               // scope 2 at src/label.rs:180:50: 180:51
        goto -> bb483;                   // scope 2 at src/label.rs:180:50: 180:51
    }

    bb465: {
        StorageLive(_345);               // scope 2 at src/label.rs:184:18: 184:50
        StorageLive(_346);               // scope 2 at src/label.rs:184:18: 184:50
        StorageLive(_347);               // scope 2 at src/label.rs:184:18: 184:50
        StorageLive(_348);               // scope 2 at src/label.rs:184:18: 184:35
        StorageLive(_349);               // scope 2 at src/label.rs:184:18: 184:35
        _349 = const WINDOWS_1253;       // scope 2 at src/label.rs:184:18: 184:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1253, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:184:18: 184:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1270 ~ encoding[5d2c]::all::WINDOWS_1253), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _348 = _349;                     // scope 2 at src/label.rs:184:18: 184:35
        _347 = move _348 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:184:18: 184:35
        StorageDead(_348);               // scope 2 at src/label.rs:184:34: 184:35
        _346 = _347;                     // scope 2 at src/label.rs:184:18: 184:50
        _345 = move _346 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:184:18: 184:50
        StorageDead(_346);               // scope 2 at src/label.rs:184:49: 184:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _345; // scope 2 at src/label.rs:184:13: 184:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:184:13: 184:51
        StorageDead(_349);               // scope 2 at src/label.rs:184:50: 184:51
        StorageDead(_347);               // scope 2 at src/label.rs:184:50: 184:51
        StorageDead(_345);               // scope 2 at src/label.rs:184:50: 184:51
        goto -> bb483;                   // scope 2 at src/label.rs:184:50: 184:51
    }

    bb466: {
        StorageLive(_350);               // scope 2 at src/label.rs:197:18: 197:50
        StorageLive(_351);               // scope 2 at src/label.rs:197:18: 197:50
        StorageLive(_352);               // scope 2 at src/label.rs:197:18: 197:50
        StorageLive(_353);               // scope 2 at src/label.rs:197:18: 197:35
        StorageLive(_354);               // scope 2 at src/label.rs:197:18: 197:35
        _354 = const WINDOWS_1254;       // scope 2 at src/label.rs:197:18: 197:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1254, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:197:18: 197:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1271 ~ encoding[5d2c]::all::WINDOWS_1254), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _353 = _354;                     // scope 2 at src/label.rs:197:18: 197:35
        _352 = move _353 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:197:18: 197:35
        StorageDead(_353);               // scope 2 at src/label.rs:197:34: 197:35
        _351 = _352;                     // scope 2 at src/label.rs:197:18: 197:50
        _350 = move _351 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:197:18: 197:50
        StorageDead(_351);               // scope 2 at src/label.rs:197:49: 197:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _350; // scope 2 at src/label.rs:197:13: 197:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:197:13: 197:51
        StorageDead(_354);               // scope 2 at src/label.rs:197:50: 197:51
        StorageDead(_352);               // scope 2 at src/label.rs:197:50: 197:51
        StorageDead(_350);               // scope 2 at src/label.rs:197:50: 197:51
        goto -> bb483;                   // scope 2 at src/label.rs:197:50: 197:51
    }

    bb467: {
        StorageLive(_355);               // scope 2 at src/label.rs:201:18: 201:50
        StorageLive(_356);               // scope 2 at src/label.rs:201:18: 201:50
        StorageLive(_357);               // scope 2 at src/label.rs:201:18: 201:50
        StorageLive(_358);               // scope 2 at src/label.rs:201:18: 201:35
        StorageLive(_359);               // scope 2 at src/label.rs:201:18: 201:35
        _359 = const WINDOWS_1255;       // scope 2 at src/label.rs:201:18: 201:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1255, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:201:18: 201:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1272 ~ encoding[5d2c]::all::WINDOWS_1255), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _358 = _359;                     // scope 2 at src/label.rs:201:18: 201:35
        _357 = move _358 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:201:18: 201:35
        StorageDead(_358);               // scope 2 at src/label.rs:201:34: 201:35
        _356 = _357;                     // scope 2 at src/label.rs:201:18: 201:50
        _355 = move _356 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:201:18: 201:50
        StorageDead(_356);               // scope 2 at src/label.rs:201:49: 201:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _355; // scope 2 at src/label.rs:201:13: 201:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:201:13: 201:51
        StorageDead(_359);               // scope 2 at src/label.rs:201:50: 201:51
        StorageDead(_357);               // scope 2 at src/label.rs:201:50: 201:51
        StorageDead(_355);               // scope 2 at src/label.rs:201:50: 201:51
        goto -> bb483;                   // scope 2 at src/label.rs:201:50: 201:51
    }

    bb468: {
        StorageLive(_360);               // scope 2 at src/label.rs:205:18: 205:50
        StorageLive(_361);               // scope 2 at src/label.rs:205:18: 205:50
        StorageLive(_362);               // scope 2 at src/label.rs:205:18: 205:50
        StorageLive(_363);               // scope 2 at src/label.rs:205:18: 205:35
        StorageLive(_364);               // scope 2 at src/label.rs:205:18: 205:35
        _364 = const WINDOWS_1256;       // scope 2 at src/label.rs:205:18: 205:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1256, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:205:18: 205:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1273 ~ encoding[5d2c]::all::WINDOWS_1256), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _363 = _364;                     // scope 2 at src/label.rs:205:18: 205:35
        _362 = move _363 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:205:18: 205:35
        StorageDead(_363);               // scope 2 at src/label.rs:205:34: 205:35
        _361 = _362;                     // scope 2 at src/label.rs:205:18: 205:50
        _360 = move _361 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:205:18: 205:50
        StorageDead(_361);               // scope 2 at src/label.rs:205:49: 205:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _360; // scope 2 at src/label.rs:205:13: 205:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:205:13: 205:51
        StorageDead(_364);               // scope 2 at src/label.rs:205:50: 205:51
        StorageDead(_362);               // scope 2 at src/label.rs:205:50: 205:51
        StorageDead(_360);               // scope 2 at src/label.rs:205:50: 205:51
        goto -> bb483;                   // scope 2 at src/label.rs:205:50: 205:51
    }

    bb469: {
        StorageLive(_365);               // scope 2 at src/label.rs:209:18: 209:50
        StorageLive(_366);               // scope 2 at src/label.rs:209:18: 209:50
        StorageLive(_367);               // scope 2 at src/label.rs:209:18: 209:50
        StorageLive(_368);               // scope 2 at src/label.rs:209:18: 209:35
        StorageLive(_369);               // scope 2 at src/label.rs:209:18: 209:35
        _369 = const WINDOWS_1257;       // scope 2 at src/label.rs:209:18: 209:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1257, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:209:18: 209:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1274 ~ encoding[5d2c]::all::WINDOWS_1257), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _368 = _369;                     // scope 2 at src/label.rs:209:18: 209:35
        _367 = move _368 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:209:18: 209:35
        StorageDead(_368);               // scope 2 at src/label.rs:209:34: 209:35
        _366 = _367;                     // scope 2 at src/label.rs:209:18: 209:50
        _365 = move _366 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:209:18: 209:50
        StorageDead(_366);               // scope 2 at src/label.rs:209:49: 209:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _365; // scope 2 at src/label.rs:209:13: 209:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:209:13: 209:51
        StorageDead(_369);               // scope 2 at src/label.rs:209:50: 209:51
        StorageDead(_367);               // scope 2 at src/label.rs:209:50: 209:51
        StorageDead(_365);               // scope 2 at src/label.rs:209:50: 209:51
        goto -> bb483;                   // scope 2 at src/label.rs:209:50: 209:51
    }

    bb470: {
        StorageLive(_370);               // scope 2 at src/label.rs:213:18: 213:50
        StorageLive(_371);               // scope 2 at src/label.rs:213:18: 213:50
        StorageLive(_372);               // scope 2 at src/label.rs:213:18: 213:50
        StorageLive(_373);               // scope 2 at src/label.rs:213:18: 213:35
        StorageLive(_374);               // scope 2 at src/label.rs:213:18: 213:35
        _374 = const WINDOWS_1258;       // scope 2 at src/label.rs:213:18: 213:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1258, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:213:18: 213:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1275 ~ encoding[5d2c]::all::WINDOWS_1258), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _373 = _374;                     // scope 2 at src/label.rs:213:18: 213:35
        _372 = move _373 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:213:18: 213:35
        StorageDead(_373);               // scope 2 at src/label.rs:213:34: 213:35
        _371 = _372;                     // scope 2 at src/label.rs:213:18: 213:50
        _370 = move _371 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:213:18: 213:50
        StorageDead(_371);               // scope 2 at src/label.rs:213:49: 213:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _370; // scope 2 at src/label.rs:213:13: 213:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:213:13: 213:51
        StorageDead(_374);               // scope 2 at src/label.rs:213:50: 213:51
        StorageDead(_372);               // scope 2 at src/label.rs:213:50: 213:51
        StorageDead(_370);               // scope 2 at src/label.rs:213:50: 213:51
        goto -> bb483;                   // scope 2 at src/label.rs:213:50: 213:51
    }

    bb471: {
        StorageLive(_375);               // scope 2 at src/label.rs:216:18: 216:50
        StorageLive(_376);               // scope 2 at src/label.rs:216:18: 216:50
        StorageLive(_377);               // scope 2 at src/label.rs:216:18: 216:50
        StorageLive(_378);               // scope 2 at src/label.rs:216:18: 216:35
        StorageLive(_379);               // scope 2 at src/label.rs:216:18: 216:35
        _379 = const MAC_CYRILLIC;       // scope 2 at src/label.rs:216:18: 216:35
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_CYRILLIC, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:216:18: 216:35
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1276 ~ encoding[5d2c]::all::MAC_CYRILLIC), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _378 = _379;                     // scope 2 at src/label.rs:216:18: 216:35
        _377 = move _378 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:216:18: 216:35
        StorageDead(_378);               // scope 2 at src/label.rs:216:34: 216:35
        _376 = _377;                     // scope 2 at src/label.rs:216:18: 216:50
        _375 = move _376 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:216:18: 216:50
        StorageDead(_376);               // scope 2 at src/label.rs:216:49: 216:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _375; // scope 2 at src/label.rs:216:13: 216:51
        discriminant(_0) = 1;            // scope 2 at src/label.rs:216:13: 216:51
        StorageDead(_379);               // scope 2 at src/label.rs:216:50: 216:51
        StorageDead(_377);               // scope 2 at src/label.rs:216:50: 216:51
        StorageDead(_375);               // scope 2 at src/label.rs:216:50: 216:51
        goto -> bb483;                   // scope 2 at src/label.rs:216:50: 216:51
    }

    bb472: {
        StorageLive(_380);               // scope 2 at src/label.rs:226:18: 226:41
        StorageLive(_381);               // scope 2 at src/label.rs:226:18: 226:41
        StorageLive(_382);               // scope 2 at src/label.rs:226:18: 226:41
        StorageLive(_383);               // scope 2 at src/label.rs:226:18: 226:26
        StorageLive(_384);               // scope 2 at src/label.rs:226:18: 226:26
        _384 = const GBK;                // scope 2 at src/label.rs:226:18: 226:26
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GBKEncoding
                                         // + val: Unevaluated(GBK, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:226:18: 226:26
                                         // + literal: Const { ty: &codec::simpchinese::GBKEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1284 ~ encoding[5d2c]::all::GBK), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _383 = _384;                     // scope 2 at src/label.rs:226:18: 226:26
        _382 = move _383 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:226:18: 226:26
        StorageDead(_383);               // scope 2 at src/label.rs:226:25: 226:26
        _381 = _382;                     // scope 2 at src/label.rs:226:18: 226:41
        _380 = move _381 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:226:18: 226:41
        StorageDead(_381);               // scope 2 at src/label.rs:226:40: 226:41
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _380; // scope 2 at src/label.rs:226:13: 226:42
        discriminant(_0) = 1;            // scope 2 at src/label.rs:226:13: 226:42
        StorageDead(_384);               // scope 2 at src/label.rs:226:41: 226:42
        StorageDead(_382);               // scope 2 at src/label.rs:226:41: 226:42
        StorageDead(_380);               // scope 2 at src/label.rs:226:41: 226:42
        goto -> bb483;                   // scope 2 at src/label.rs:226:41: 226:42
    }

    bb473: {
        StorageLive(_385);               // scope 2 at src/label.rs:228:18: 228:45
        StorageLive(_386);               // scope 2 at src/label.rs:228:18: 228:45
        StorageLive(_387);               // scope 2 at src/label.rs:228:18: 228:45
        StorageLive(_388);               // scope 2 at src/label.rs:228:18: 228:30
        StorageLive(_389);               // scope 2 at src/label.rs:228:18: 228:30
        _389 = const GB18030;            // scope 2 at src/label.rs:228:18: 228:30
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GB18030Encoding
                                         // + val: Unevaluated(GB18030, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:228:18: 228:30
                                         // + literal: Const { ty: &codec::simpchinese::GB18030Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1285 ~ encoding[5d2c]::all::GB18030), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _388 = _389;                     // scope 2 at src/label.rs:228:18: 228:30
        _387 = move _388 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:228:18: 228:30
        StorageDead(_388);               // scope 2 at src/label.rs:228:29: 228:30
        _386 = _387;                     // scope 2 at src/label.rs:228:18: 228:45
        _385 = move _386 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:228:18: 228:45
        StorageDead(_386);               // scope 2 at src/label.rs:228:44: 228:45
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _385; // scope 2 at src/label.rs:228:13: 228:46
        discriminant(_0) = 1;            // scope 2 at src/label.rs:228:13: 228:46
        StorageDead(_389);               // scope 2 at src/label.rs:228:45: 228:46
        StorageDead(_387);               // scope 2 at src/label.rs:228:45: 228:46
        StorageDead(_385);               // scope 2 at src/label.rs:228:45: 228:46
        goto -> bb483;                   // scope 2 at src/label.rs:228:45: 228:46
    }

    bb474: {
        StorageLive(_390);               // scope 2 at src/label.rs:234:18: 234:47
        StorageLive(_391);               // scope 2 at src/label.rs:234:18: 234:47
        StorageLive(_392);               // scope 2 at src/label.rs:234:18: 234:47
        StorageLive(_393);               // scope 2 at src/label.rs:234:18: 234:32
        StorageLive(_394);               // scope 2 at src/label.rs:234:18: 234:32
        _394 = const BIG5_2003;          // scope 2 at src/label.rs:234:18: 234:32
                                         // ty::Const
                                         // + ty: &codec::tradchinese::BigFive2003Encoding
                                         // + val: Unevaluated(BIG5_2003, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:234:18: 234:32
                                         // + literal: Const { ty: &codec::tradchinese::BigFive2003Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1287 ~ encoding[5d2c]::all::BIG5_2003), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _393 = _394;                     // scope 2 at src/label.rs:234:18: 234:32
        _392 = move _393 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:234:18: 234:32
        StorageDead(_393);               // scope 2 at src/label.rs:234:31: 234:32
        _391 = _392;                     // scope 2 at src/label.rs:234:18: 234:47
        _390 = move _391 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:234:18: 234:47
        StorageDead(_391);               // scope 2 at src/label.rs:234:46: 234:47
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _390; // scope 2 at src/label.rs:234:13: 234:48
        discriminant(_0) = 1;            // scope 2 at src/label.rs:234:13: 234:48
        StorageDead(_394);               // scope 2 at src/label.rs:234:47: 234:48
        StorageDead(_392);               // scope 2 at src/label.rs:234:47: 234:48
        StorageDead(_390);               // scope 2 at src/label.rs:234:47: 234:48
        goto -> bb483;                   // scope 2 at src/label.rs:234:47: 234:48
    }

    bb475: {
        StorageLive(_395);               // scope 2 at src/label.rs:238:18: 238:44
        StorageLive(_396);               // scope 2 at src/label.rs:238:18: 238:44
        StorageLive(_397);               // scope 2 at src/label.rs:238:18: 238:44
        StorageLive(_398);               // scope 2 at src/label.rs:238:18: 238:29
        StorageLive(_399);               // scope 2 at src/label.rs:238:18: 238:29
        _399 = const EUC_JP;             // scope 2 at src/label.rs:238:18: 238:29
                                         // ty::Const
                                         // + ty: &codec::japanese::EUCJPEncoding
                                         // + val: Unevaluated(EUC_JP, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:238:18: 238:29
                                         // + literal: Const { ty: &codec::japanese::EUCJPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1281 ~ encoding[5d2c]::all::EUC_JP), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _398 = _399;                     // scope 2 at src/label.rs:238:18: 238:29
        _397 = move _398 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:238:18: 238:29
        StorageDead(_398);               // scope 2 at src/label.rs:238:28: 238:29
        _396 = _397;                     // scope 2 at src/label.rs:238:18: 238:44
        _395 = move _396 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:238:18: 238:44
        StorageDead(_396);               // scope 2 at src/label.rs:238:43: 238:44
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _395; // scope 2 at src/label.rs:238:13: 238:45
        discriminant(_0) = 1;            // scope 2 at src/label.rs:238:13: 238:45
        StorageDead(_399);               // scope 2 at src/label.rs:238:44: 238:45
        StorageDead(_397);               // scope 2 at src/label.rs:238:44: 238:45
        StorageDead(_395);               // scope 2 at src/label.rs:238:44: 238:45
        goto -> bb483;                   // scope 2 at src/label.rs:238:44: 238:45
    }

    bb476: {
        StorageLive(_400);               // scope 2 at src/label.rs:241:18: 241:49
        StorageLive(_401);               // scope 2 at src/label.rs:241:18: 241:49
        StorageLive(_402);               // scope 2 at src/label.rs:241:18: 241:49
        StorageLive(_403);               // scope 2 at src/label.rs:241:18: 241:34
        StorageLive(_404);               // scope 2 at src/label.rs:241:18: 241:34
        _404 = const ISO_2022_JP;        // scope 2 at src/label.rs:241:18: 241:34
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPEncoding
                                         // + val: Unevaluated(ISO_2022_JP, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:241:18: 241:34
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1283 ~ encoding[5d2c]::all::ISO_2022_JP), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _403 = _404;                     // scope 2 at src/label.rs:241:18: 241:34
        _402 = move _403 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:241:18: 241:34
        StorageDead(_403);               // scope 2 at src/label.rs:241:33: 241:34
        _401 = _402;                     // scope 2 at src/label.rs:241:18: 241:49
        _400 = move _401 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:241:18: 241:49
        StorageDead(_401);               // scope 2 at src/label.rs:241:48: 241:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _400; // scope 2 at src/label.rs:241:13: 241:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:241:13: 241:50
        StorageDead(_404);               // scope 2 at src/label.rs:241:49: 241:50
        StorageDead(_402);               // scope 2 at src/label.rs:241:49: 241:50
        StorageDead(_400);               // scope 2 at src/label.rs:241:49: 241:50
        goto -> bb483;                   // scope 2 at src/label.rs:241:49: 241:50
    }

    bb477: {
        StorageLive(_405);               // scope 2 at src/label.rs:250:18: 250:49
        StorageLive(_406);               // scope 2 at src/label.rs:250:18: 250:49
        StorageLive(_407);               // scope 2 at src/label.rs:250:18: 250:49
        StorageLive(_408);               // scope 2 at src/label.rs:250:18: 250:34
        StorageLive(_409);               // scope 2 at src/label.rs:250:18: 250:34
        _409 = const WINDOWS_31J;        // scope 2 at src/label.rs:250:18: 250:34
                                         // ty::Const
                                         // + ty: &codec::japanese::Windows31JEncoding
                                         // + val: Unevaluated(WINDOWS_31J, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:250:18: 250:34
                                         // + literal: Const { ty: &codec::japanese::Windows31JEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1282 ~ encoding[5d2c]::all::WINDOWS_31J), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _408 = _409;                     // scope 2 at src/label.rs:250:18: 250:34
        _407 = move _408 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:250:18: 250:34
        StorageDead(_408);               // scope 2 at src/label.rs:250:33: 250:34
        _406 = _407;                     // scope 2 at src/label.rs:250:18: 250:49
        _405 = move _406 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:250:18: 250:49
        StorageDead(_406);               // scope 2 at src/label.rs:250:48: 250:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _405; // scope 2 at src/label.rs:250:13: 250:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:250:13: 250:50
        StorageDead(_409);               // scope 2 at src/label.rs:250:49: 250:50
        StorageDead(_407);               // scope 2 at src/label.rs:250:49: 250:50
        StorageDead(_405);               // scope 2 at src/label.rs:250:49: 250:50
        goto -> bb483;                   // scope 2 at src/label.rs:250:49: 250:50
    }

    bb478: {
        StorageLive(_410);               // scope 2 at src/label.rs:261:18: 261:49
        StorageLive(_411);               // scope 2 at src/label.rs:261:18: 261:49
        StorageLive(_412);               // scope 2 at src/label.rs:261:18: 261:49
        StorageLive(_413);               // scope 2 at src/label.rs:261:18: 261:34
        StorageLive(_414);               // scope 2 at src/label.rs:261:18: 261:34
        _414 = const WINDOWS_949;        // scope 2 at src/label.rs:261:18: 261:34
                                         // ty::Const
                                         // + ty: &codec::korean::Windows949Encoding
                                         // + val: Unevaluated(WINDOWS_949, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:261:18: 261:34
                                         // + literal: Const { ty: &codec::korean::Windows949Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1280 ~ encoding[5d2c]::all::WINDOWS_949), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _413 = _414;                     // scope 2 at src/label.rs:261:18: 261:34
        _412 = move _413 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:261:18: 261:34
        StorageDead(_413);               // scope 2 at src/label.rs:261:33: 261:34
        _411 = _412;                     // scope 2 at src/label.rs:261:18: 261:49
        _410 = move _411 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:261:18: 261:49
        StorageDead(_411);               // scope 2 at src/label.rs:261:48: 261:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _410; // scope 2 at src/label.rs:261:13: 261:50
        discriminant(_0) = 1;            // scope 2 at src/label.rs:261:13: 261:50
        StorageDead(_414);               // scope 2 at src/label.rs:261:49: 261:50
        StorageDead(_412);               // scope 2 at src/label.rs:261:49: 261:50
        StorageDead(_410);               // scope 2 at src/label.rs:261:49: 261:50
        goto -> bb483;                   // scope 2 at src/label.rs:261:49: 261:50
    }

    bb479: {
        StorageLive(_415);               // scope 2 at src/label.rs:267:18: 267:57
        StorageLive(_416);               // scope 2 at src/label.rs:267:18: 267:57
        StorageLive(_417);               // scope 2 at src/label.rs:267:18: 267:57
        StorageLive(_418);               // scope 2 at src/label.rs:267:18: 267:42
        StorageLive(_419);               // scope 2 at src/label.rs:267:18: 267:42
        _419 = const REPLACEMENT;        // scope 2 at src/label.rs:267:18: 267:42
                                         // ty::Const
                                         // + ty: &codec::whatwg::EncoderOnlyUTF8Encoding
                                         // + val: Unevaluated(REPLACEMENT, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:267:18: 267:42
                                         // + literal: Const { ty: &codec::whatwg::EncoderOnlyUTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1290 ~ encoding[5d2c]::all::whatwg::REPLACEMENT), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _418 = _419;                     // scope 2 at src/label.rs:267:18: 267:42
        _417 = move _418 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:267:18: 267:42
        StorageDead(_418);               // scope 2 at src/label.rs:267:41: 267:42
        _416 = _417;                     // scope 2 at src/label.rs:267:18: 267:57
        _415 = move _416 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:267:18: 267:57
        StorageDead(_416);               // scope 2 at src/label.rs:267:56: 267:57
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _415; // scope 2 at src/label.rs:267:13: 267:58
        discriminant(_0) = 1;            // scope 2 at src/label.rs:267:13: 267:58
        StorageDead(_419);               // scope 2 at src/label.rs:267:57: 267:58
        StorageDead(_417);               // scope 2 at src/label.rs:267:57: 267:58
        StorageDead(_415);               // scope 2 at src/label.rs:267:57: 267:58
        goto -> bb483;                   // scope 2 at src/label.rs:267:57: 267:58
    }

    bb480: {
        StorageLive(_420);               // scope 2 at src/label.rs:269:18: 269:46
        StorageLive(_421);               // scope 2 at src/label.rs:269:18: 269:46
        StorageLive(_422);               // scope 2 at src/label.rs:269:18: 269:46
        StorageLive(_423);               // scope 2 at src/label.rs:269:18: 269:31
        StorageLive(_424);               // scope 2 at src/label.rs:269:18: 269:31
        _424 = const UTF_16BE;           // scope 2 at src/label.rs:269:18: 269:31
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16BEEncoding
                                         // + val: Unevaluated(UTF_16BE, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:269:18: 269:31
                                         // + literal: Const { ty: &codec::utf_16::UTF16BEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1279 ~ encoding[5d2c]::all::UTF_16BE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _423 = _424;                     // scope 2 at src/label.rs:269:18: 269:31
        _422 = move _423 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:269:18: 269:31
        StorageDead(_423);               // scope 2 at src/label.rs:269:30: 269:31
        _421 = _422;                     // scope 2 at src/label.rs:269:18: 269:46
        _420 = move _421 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:269:18: 269:46
        StorageDead(_421);               // scope 2 at src/label.rs:269:45: 269:46
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _420; // scope 2 at src/label.rs:269:13: 269:47
        discriminant(_0) = 1;            // scope 2 at src/label.rs:269:13: 269:47
        StorageDead(_424);               // scope 2 at src/label.rs:269:46: 269:47
        StorageDead(_422);               // scope 2 at src/label.rs:269:46: 269:47
        StorageDead(_420);               // scope 2 at src/label.rs:269:46: 269:47
        goto -> bb483;                   // scope 2 at src/label.rs:269:46: 269:47
    }

    bb481: {
        StorageLive(_425);               // scope 2 at src/label.rs:272:18: 272:46
        StorageLive(_426);               // scope 2 at src/label.rs:272:18: 272:46
        StorageLive(_427);               // scope 2 at src/label.rs:272:18: 272:46
        StorageLive(_428);               // scope 2 at src/label.rs:272:18: 272:31
        StorageLive(_429);               // scope 2 at src/label.rs:272:18: 272:31
        _429 = const UTF_16LE;           // scope 2 at src/label.rs:272:18: 272:31
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16LEEncoding
                                         // + val: Unevaluated(UTF_16LE, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:272:18: 272:31
                                         // + literal: Const { ty: &codec::utf_16::UTF16LEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1278 ~ encoding[5d2c]::all::UTF_16LE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _428 = _429;                     // scope 2 at src/label.rs:272:18: 272:31
        _427 = move _428 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:272:18: 272:31
        StorageDead(_428);               // scope 2 at src/label.rs:272:30: 272:31
        _426 = _427;                     // scope 2 at src/label.rs:272:18: 272:46
        _425 = move _426 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:272:18: 272:46
        StorageDead(_426);               // scope 2 at src/label.rs:272:45: 272:46
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _425; // scope 2 at src/label.rs:272:13: 272:47
        discriminant(_0) = 1;            // scope 2 at src/label.rs:272:13: 272:47
        StorageDead(_429);               // scope 2 at src/label.rs:272:46: 272:47
        StorageDead(_427);               // scope 2 at src/label.rs:272:46: 272:47
        StorageDead(_425);               // scope 2 at src/label.rs:272:46: 272:47
        goto -> bb483;                   // scope 2 at src/label.rs:272:46: 272:47
    }

    bb482: {
        StorageLive(_430);               // scope 2 at src/label.rs:274:18: 274:60
        StorageLive(_431);               // scope 2 at src/label.rs:274:18: 274:60
        StorageLive(_432);               // scope 2 at src/label.rs:274:18: 274:60
        StorageLive(_433);               // scope 2 at src/label.rs:274:18: 274:45
        StorageLive(_434);               // scope 2 at src/label.rs:274:18: 274:45
        _434 = const X_USER_DEFINED;     // scope 2 at src/label.rs:274:18: 274:45
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(X_USER_DEFINED, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:274:18: 274:45
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1288 ~ encoding[5d2c]::all::whatwg::X_USER_DEFINED), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _433 = _434;                     // scope 2 at src/label.rs:274:18: 274:45
        _432 = move _433 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:274:18: 274:45
        StorageDead(_433);               // scope 2 at src/label.rs:274:44: 274:45
        _431 = _432;                     // scope 2 at src/label.rs:274:18: 274:60
        _430 = move _431 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 2 at src/label.rs:274:18: 274:60
        StorageDead(_431);               // scope 2 at src/label.rs:274:59: 274:60
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _430; // scope 2 at src/label.rs:274:13: 274:61
        discriminant(_0) = 1;            // scope 2 at src/label.rs:274:13: 274:61
        StorageDead(_434);               // scope 2 at src/label.rs:274:60: 274:61
        StorageDead(_432);               // scope 2 at src/label.rs:274:60: 274:61
        StorageDead(_430);               // scope 2 at src/label.rs:274:60: 274:61
        goto -> bb483;                   // scope 2 at src/label.rs:274:60: 274:61
    }

    bb483: {
        drop(_8) -> bb484;               // scope 1 at src/label.rs:277:1: 277:2
    }

    bb484: {
        StorageDead(_8);                 // scope 1 at src/label.rs:277:1: 277:2
        StorageDead(_2);                 // scope 0 at src/label.rs:277:1: 277:2
        StorageDead(_14);                // scope 0 at src/label.rs:277:1: 277:2
        StorageDead(_13);                // scope 0 at src/label.rs:277:1: 277:2
        return;                          // scope 0 at src/label.rs:277:2: 277:2
    }

    bb485 (cleanup): {
        drop(_8) -> bb486;               // scope 1 at src/label.rs:277:1: 277:2
    }

    bb486 (cleanup): {
        resume;                          // scope 0 at src/label.rs:12:1: 277:2
    }
}

promoted[0] in encoding_from_whatwg_label: &[char; 5] = {
    let mut _0: &[char; 5];              // return place in scope 0 at src/label.rs:13:37: 13:68
    let mut _1: [char; 5];               // in scope 0 at src/label.rs:13:37: 13:68

    bb0: {
        _1 = [const ' ', const '\n', const '\r', const '\t', const '\u{c}']; // scope 0 at src/label.rs:13:37: 13:68
        _0 = &_1;                        // scope 0 at src/label.rs:13:37: 13:68
        return;                          // scope 0 at src/label.rs:13:37: 13:68
    }
}

fn iso2022jp::transient::EscapeStart(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:946:37: 946:40
    let mut _7: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:947:37: 947:40
    let mut _8: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:948:19: 948:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_5) -> [36_u8: bb6, 40_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 4;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb12;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:948:19: 948:22
        _8 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:948:19: 948:22
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::backup_and_err(move _8, const 1_usize, const "invalid sequence") -> bb10; // scope 1 at src/codec/japanese.rs:948:19: 948:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:948:23: 948:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, usize, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:948:41: 948:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:946:37: 946:40
        _6 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:946:37: 946:40
        _0 = iso2022jp::transient::EscapeMiddle24::<T>(move _6) -> bb7; // scope 1 at src/codec/japanese.rs:946:22: 946:41
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:946:22: 946:36
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeMiddle24::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:946:40: 946:41
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:946:40: 946:41
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:947:37: 947:40
        _7 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:947:37: 947:40
        _0 = iso2022jp::transient::EscapeMiddle28::<T>(move _7) -> bb9; // scope 1 at src/codec/japanese.rs:947:22: 947:41
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:947:22: 947:36
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeMiddle28::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:947:40: 947:41
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:947:40: 947:41
    }

    bb10: {
        StorageDead(_8);                 // scope 1 at src/codec/japanese.rs:948:59: 948:60
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:948:59: 948:60
    }

    bb11: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb12;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb12: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:28:10: 28:15>::clone(_1: &SingleByteEncoder) -> SingleByteEncoder {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:28:10: 28:15
    let mut _0: codec::singlebyte::SingleByteEncoder; // return place in scope 0 at src/codec/singlebyte.rs:28:10: 28:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/singlebyte.rs:28:10: 28:15
        return;                          // scope 0 at src/codec/singlebyte.rs:28:15: 28:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:272:1: 280:2>::raw_feed::{closure#0}(_1: &[closure@src/codec/utf_16.rs:275:44: 275:95], _2: u16, _3: u8) -> u16 {
    debug lead => _2;                    // in scope 0 at src/codec/utf_16.rs:275:45: 275:49
    debug trail => _3;                   // in scope 0 at src/codec/utf_16.rs:275:56: 275:61
    let mut _0: u16;                     // return place in scope 0 at src/codec/utf_16.rs:275:67: 275:67
    let mut _4: u16;                     // in scope 0 at src/codec/utf_16.rs:275:67: 275:71
    let mut _5: u16;                     // in scope 0 at src/codec/utf_16.rs:275:74: 275:95
    let mut _6: u16;                     // in scope 0 at src/codec/utf_16.rs:275:75: 275:89
    let mut _7: u8;                      // in scope 0 at src/codec/utf_16.rs:275:76: 275:81

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:275:67: 275:71
        _4 = _2;                         // scope 0 at src/codec/utf_16.rs:275:67: 275:71
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:275:74: 275:95
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:275:75: 275:89
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:275:76: 275:81
        _7 = _3;                         // scope 0 at src/codec/utf_16.rs:275:76: 275:81
        _6 = move _7 as u16 (Misc);      // scope 0 at src/codec/utf_16.rs:275:75: 275:89
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:275:88: 275:89
        _5 = Shl(move _6, const 8_i32);  // scope 0 at src/codec/utf_16.rs:275:74: 275:95
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:275:94: 275:95
        _0 = BitOr(move _4, move _5);    // scope 0 at src/codec/utf_16.rs:275:67: 275:95
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:275:94: 275:95
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:275:94: 275:95
        return;                          // scope 0 at src/codec/utf_16.rs:275:95: 275:95
    }
}

const ISO_8859_13: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:51:66: 51:79
    let _5: &str;                        // in scope 0 at src/all.rs:51:66: 51:79
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_13::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_13, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1259 ~ encoding[5d2c]::all::ISO_8859_13), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_13: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:51:66: 51:79
    let mut _4: &str;                    // in scope 0 at src/all.rs:51:66: 51:79
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-13";        // scope 0 at src/all.rs:51:66: 51:79
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:51:66: 51:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:51:66: 51:79
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_13::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_13::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_13::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_13::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-13"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:51:66: 51:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:65:1: 67:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/ascii.rs:66:21: 66:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/ascii.rs:66:39: 66:61
    let mut _2: std::boxed::Box<codec::ascii::ASCIIDecoder>; // in scope 0 at src/codec/ascii.rs:66:39: 66:61
    let mut _3: codec::ascii::ASCIIDecoder; // in scope 0 at src/codec/ascii.rs:66:48: 66:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/ascii.rs:66:39: 66:61
        StorageLive(_2);                 // scope 0 at src/codec/ascii.rs:66:39: 66:61
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:66:48: 66:60
        _2 = Box::<ASCIIDecoder>::new(move _3) -> bb1; // scope 0 at src/codec/ascii.rs:66:39: 66:61
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:66:39: 66:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::ascii::ASCIIDecoder) -> std::boxed::Box<codec::ascii::ASCIIDecoder> {std::boxed::Box::<codec::ascii::ASCIIDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:66:39: 66:61
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:66:60: 66:61
        StorageDead(_2);                 // scope 0 at src/codec/ascii.rs:66:60: 66:61
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:66:39: 66:61
        StorageDead(_1);                 // scope 0 at src/codec/ascii.rs:66:62: 66:63
        return;                          // scope 0 at src/codec/ascii.rs:66:63: 66:63
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:116:10: 116:15>::clone(_1: &UTF16Decoder) -> UTF16Decoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:116:10: 116:15
    let mut _0: codec::utf_16::UTF16Decoder; // return place in scope 0 at src/codec/utf_16.rs:116:10: 116:15
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 2 at src/codec/utf_16.rs:116:10: 116:15
        return;                          // scope 0 at src/codec/utf_16.rs:116:15: 116:15
    }
}

fn simpchinese::gb18030::transient::S1(_1: &mut StatefulDecoderHelper<simpchinese::gb18030::State, T>, _2: u8) -> simpchinese::gb18030::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug first => _2;                   // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _8: bool;                    // in scope 0 at src/codec/simpchinese.rs:221:18: 221:29
    let mut _9: bool;                    // in scope 0 at src/codec/simpchinese.rs:221:18: 221:29
    let mut _11: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:221:36: 221:39
    let mut _12: u8;                     // in scope 0 at src/codec/simpchinese.rs:221:41: 221:46
    let mut _13: u8;                     // in scope 0 at src/codec/simpchinese.rs:221:48: 221:49
    let mut _15: u32;                    // in scope 0 at src/codec/simpchinese.rs:222:25: 222:48
    let mut _16: u8;                     // in scope 0 at src/codec/simpchinese.rs:222:39: 222:44
    let mut _17: u8;                     // in scope 0 at src/codec/simpchinese.rs:222:46: 222:47
    let mut _18: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:223:23: 223:26
    let mut _20: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:224:19: 224:22
    let mut _21: u32;                    // in scope 0 at src/codec/simpchinese.rs:224:28: 224:30
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _10: u8;                     // in scope 1 at src/codec/simpchinese.rs:221:14: 221:29
        let _14: u8;                     // in scope 1 at src/codec/simpchinese.rs:222:14: 222:15
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/simpchinese.rs:221:14: 221:29
        }
        scope 3 {
            debug b => _14;              // in scope 3 at src/codec/simpchinese.rs:222:14: 222:15
            let _19: u32;                // in scope 3 at src/codec/simpchinese.rs:224:13: 224:15
            scope 4 {
                debug ch => _19;         // in scope 4 at src/codec/simpchinese.rs:224:13: 224:15
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        _8 = Le(const 48_u8, _7);        // scope 1 at src/codec/simpchinese.rs:221:18: 221:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/simpchinese.rs:221:18: 221:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S1).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 1;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb16;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _9 = Le(_7, const 57_u8);        // scope 1 at src/codec/simpchinese.rs:221:18: 221:29
        switchInt(move _9) -> [false: bb6, otherwise: bb7]; // scope 1 at src/codec/simpchinese.rs:221:18: 221:29
    }

    bb6: {
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:222:14: 222:15
        _14 = _7;                        // scope 1 at src/codec/simpchinese.rs:222:14: 222:15
        StorageLive(_15);                // scope 3 at src/codec/simpchinese.rs:222:25: 222:48
        StorageLive(_16);                // scope 3 at src/codec/simpchinese.rs:222:39: 222:44
        _16 = _2;                        // scope 3 at src/codec/simpchinese.rs:222:39: 222:44
        StorageLive(_17);                // scope 3 at src/codec/simpchinese.rs:222:46: 222:47
        _17 = _14;                       // scope 3 at src/codec/simpchinese.rs:222:46: 222:47
        _15 = simpchinese::gb18030::internal::map_two_bytes(move _16, move _17) -> bb9; // scope 3 at src/codec/simpchinese.rs:222:25: 222:48
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:222:25: 222:38
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::simpchinese::gb18030::internal::map_two_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:221:14: 221:29
        _10 = _7;                        // scope 1 at src/codec/simpchinese.rs:221:14: 221:29
        StorageLive(_11);                // scope 2 at src/codec/simpchinese.rs:221:36: 221:39
        _11 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:221:36: 221:39
        StorageLive(_12);                // scope 2 at src/codec/simpchinese.rs:221:41: 221:46
        _12 = _2;                        // scope 2 at src/codec/simpchinese.rs:221:41: 221:46
        StorageLive(_13);                // scope 2 at src/codec/simpchinese.rs:221:48: 221:49
        _13 = _10;                       // scope 2 at src/codec/simpchinese.rs:221:48: 221:49
        _0 = simpchinese::gb18030::transient::S2::<T>(move _11, move _12, move _13) -> bb8; // scope 2 at src/codec/simpchinese.rs:221:33: 221:50
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:221:33: 221:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::gb18030::State, T>, u8, u8) -> codec::simpchinese::gb18030::State {codec::simpchinese::gb18030::transient::S2::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:221:49: 221:50
        StorageDead(_12);                // scope 2 at src/codec/simpchinese.rs:221:49: 221:50
        StorageDead(_11);                // scope 2 at src/codec/simpchinese.rs:221:49: 221:50
        StorageDead(_10);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb15;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb9: {
        StorageDead(_17);                // scope 3 at src/codec/simpchinese.rs:222:47: 222:48
        StorageDead(_16);                // scope 3 at src/codec/simpchinese.rs:222:47: 222:48
        switchInt(_15) -> [65535_u32: bb11, otherwise: bb10]; // scope 3 at src/codec/simpchinese.rs:222:19: 222:48
    }

    bb10: {
        StorageLive(_19);                // scope 3 at src/codec/simpchinese.rs:224:13: 224:15
        _19 = _15;                       // scope 3 at src/codec/simpchinese.rs:224:13: 224:15
        StorageLive(_20);                // scope 4 at src/codec/simpchinese.rs:224:19: 224:22
        _20 = &mut (*_1);                // scope 4 at src/codec/simpchinese.rs:224:19: 224:22
        StorageLive(_21);                // scope 4 at src/codec/simpchinese.rs:224:28: 224:30
        _21 = _19;                       // scope 4 at src/codec/simpchinese.rs:224:28: 224:30
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::emit(move _20, move _21) -> bb13; // scope 4 at src/codec/simpchinese.rs:224:19: 224:31
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:224:23: 224:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, u32) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageLive(_18);                // scope 3 at src/codec/simpchinese.rs:223:23: 223:26
        _18 = &mut (*_1);                // scope 3 at src/codec/simpchinese.rs:223:23: 223:26
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::backup_and_err(move _18, const 1_usize, const "invalid sequence") -> bb12; // scope 3 at src/codec/simpchinese.rs:223:23: 223:64
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:223:27: 223:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, usize, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:223:45: 223:63
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb12: {
        StorageDead(_18);                // scope 3 at src/codec/simpchinese.rs:223:63: 223:64
        goto -> bb14;                    // scope 3 at src/codec/simpchinese.rs:223:63: 223:64
    }

    bb13: {
        StorageDead(_21);                // scope 4 at src/codec/simpchinese.rs:224:30: 224:31
        StorageDead(_20);                // scope 4 at src/codec/simpchinese.rs:224:30: 224:31
        StorageDead(_19);                // scope 3 at src/codec/simpchinese.rs:224:30: 224:31
        goto -> bb14;                    // scope 3 at src/codec/simpchinese.rs:224:30: 224:31
    }

    bb14: {
        StorageDead(_15);                // scope 3 at src/util.rs:226:77: 226:78
        StorageDead(_14);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb15;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb15: {
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb16;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb16: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:49:1: 54:2>::name(_1: &UTF8Encoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:50:13: 50:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/utf_8.rs:50:23: 50:35

    bb0: {
        _0 = const "utf-8";              // scope 0 at src/codec/utf_8.rs:50:38: 50:45
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:50:38: 50:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
        return;                          // scope 0 at src/codec/utf_8.rs:50:47: 50:47
    }
}

fn japanese::<impl at src/codec/japanese.rs:794:1: 796:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:795:21: 795:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:795:39: 795:79
    let mut _2: std::boxed::Box<codec::japanese::ISO2022JPEncoder>; // in scope 0 at src/codec/japanese.rs:795:39: 795:79
    let mut _3: codec::japanese::ISO2022JPEncoder; // in scope 0 at src/codec/japanese.rs:795:48: 795:78

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/japanese.rs:795:39: 795:79
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:795:39: 795:79
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:795:48: 795:78
        (_3.0: codec::japanese::ISO2022JPState) = const ISO2022JPState::ASCII; // scope 0 at src/codec/japanese.rs:795:48: 795:78
                                         // ty::Const
                                         // + ty: codec::japanese::ISO2022JPState
                                         // + val: Value(Scalar(0x00))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:795:48: 795:78
                                         // + literal: Const { ty: codec::japanese::ISO2022JPState, val: Value(Scalar(0x00)) }
        _2 = Box::<ISO2022JPEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/japanese.rs:795:39: 795:79
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:795:39: 795:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::japanese::ISO2022JPEncoder) -> std::boxed::Box<codec::japanese::ISO2022JPEncoder> {std::boxed::Box::<codec::japanese::ISO2022JPEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:795:39: 795:79
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:795:78: 795:79
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:795:78: 795:79
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:795:39: 795:79
        StorageDead(_1);                 // scope 0 at src/codec/japanese.rs:795:80: 795:81
        return;                          // scope 0 at src/codec/japanese.rs:795:81: 795:81
    }
}

const WINDOWS_874: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:58:66: 58:79
    let _5: &str;                        // in scope 0 at src/all.rs:58:66: 58:79
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_874::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_874, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1266 ~ encoding[5d2c]::all::WINDOWS_874), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_874: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:58:66: 58:79
    let mut _4: &str;                    // in scope 0 at src/all.rs:58:66: 58:79
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-874";        // scope 0 at src/all.rs:58:66: 58:79
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:58:66: 58:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:58:66: 58:79
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_874::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_874::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_874::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_874::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-874"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:58:66: 58:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 56, 55, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn eucjp::transient::S2(_1: &mut StatefulDecoderHelper<eucjp::State, T>) -> eucjp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: bool;                    // in scope 0 at src/codec/japanese.rs:163:18: 163:29
    let mut _7: bool;                    // in scope 0 at src/codec/japanese.rs:163:18: 163:29
    let mut _9: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:163:36: 163:39
    let mut _10: u8;                     // in scope 0 at src/codec/japanese.rs:163:41: 163:42
    let mut _11: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:164:19: 164:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _8: u8;                      // in scope 1 at src/codec/japanese.rs:163:14: 163:29
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/japanese.rs:163:14: 163:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<eucjp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        _6 = Le(const 161_u8, _5);       // scope 1 at src/codec/japanese.rs:163:18: 163:29
        switchInt(move _6) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/japanese.rs:163:18: 163:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 2;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb11;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _7 = Le(_5, const 254_u8);       // scope 1 at src/codec/japanese.rs:163:18: 163:29
        switchInt(move _7) -> [false: bb6, otherwise: bb7]; // scope 1 at src/codec/japanese.rs:163:18: 163:29
    }

    bb6: {
        StorageLive(_11);                // scope 1 at src/codec/japanese.rs:164:19: 164:22
        _11 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:164:19: 164:22
        _0 = StatefulDecoderHelper::<eucjp::State, T>::backup_and_err(move _11, const 1_usize, const "invalid sequence") -> bb9; // scope 1 at src/codec/japanese.rs:164:19: 164:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:164:23: 164:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, usize, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:164:41: 164:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb7: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:163:14: 163:29
        _8 = _5;                         // scope 1 at src/codec/japanese.rs:163:14: 163:29
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:163:36: 163:39
        _9 = &mut (*_1);                 // scope 2 at src/codec/japanese.rs:163:36: 163:39
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:163:41: 163:42
        _10 = _8;                        // scope 2 at src/codec/japanese.rs:163:41: 163:42
        _0 = eucjp::transient::S4::<T>(move _9, move _10) -> bb8; // scope 2 at src/codec/japanese.rs:163:33: 163:43
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:163:33: 163:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>, u8) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S4::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:163:42: 163:43
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:163:42: 163:43
        StorageDead(_8);                 // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb10;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb9: {
        StorageDead(_11);                // scope 1 at src/codec/japanese.rs:164:59: 164:60
        goto -> bb10;                    // scope 1 at src/codec/japanese.rs:164:59: 164:60
    }

    bb10: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb11;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb11: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:112:1: 151:2>::raw_feed(_1: &mut GBEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter, _4: bool) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:113:17: 113:26
    debug input => _2;                   // in scope 0 at src/codec/simpchinese.rs:113:28: 113:33
    debug output => _3;                  // in scope 0 at src/codec/simpchinese.rs:113:41: 113:47
    debug gbk_flag => _4;                // in scope 0 at src/codec/simpchinese.rs:114:17: 114:25
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/simpchinese.rs:114:36: 114:63
    let _5: ();                          // in scope 0 at src/codec/simpchinese.rs:115:9: 115:40
    let mut _6: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:115:9: 115:15
    let mut _7: usize;                   // in scope 0 at src/codec/simpchinese.rs:115:28: 115:39
    let mut _8: &str;                    // in scope 0 at src/codec/simpchinese.rs:115:28: 115:33
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:117:29: 117:47
    let mut _10: util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:117:29: 117:47
    let mut _11: &&str;                  // in scope 0 at src/codec/simpchinese.rs:117:29: 117:34
    let mut _12: util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:117:29: 117:47
    let mut _14: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/simpchinese.rs:117:29: 117:47
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:117:29: 117:47
    let mut _16: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:117:29: 117:47
    let mut _17: isize;                  // in scope 0 at src/codec/simpchinese.rs:117:13: 117:25
    let mut _19: ((usize, usize), char); // in scope 0 at src/codec/simpchinese.rs:117:13: 117:25
    let _23: ();                         // in scope 0 at src/codec/simpchinese.rs:118:13: 147:14
    let mut _24: bool;                   // in scope 0 at src/codec/simpchinese.rs:118:16: 118:29
    let mut _25: char;                   // in scope 0 at src/codec/simpchinese.rs:118:16: 118:18
    let _26: ();                         // in scope 0 at src/codec/simpchinese.rs:119:17: 119:44
    let mut _27: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:119:17: 119:23
    let mut _28: u8;                     // in scope 0 at src/codec/simpchinese.rs:119:35: 119:43
    let mut _29: char;                   // in scope 0 at src/codec/simpchinese.rs:119:35: 119:37
    let mut _30: bool;                   // in scope 0 at src/codec/simpchinese.rs:120:23: 120:51
    let mut _31: bool;                   // in scope 0 at src/codec/simpchinese.rs:120:23: 120:31
    let mut _32: bool;                   // in scope 0 at src/codec/simpchinese.rs:120:35: 120:51
    let mut _33: char;                   // in scope 0 at src/codec/simpchinese.rs:120:35: 120:37
    let mut _34: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:121:17: 121:23
    let mut _35: u8;                     // in scope 0 at src/codec/simpchinese.rs:121:35: 121:49
    let mut _37: u32;                    // in scope 0 at src/codec/simpchinese.rs:123:52: 123:61
    let mut _38: char;                   // in scope 0 at src/codec/simpchinese.rs:123:52: 123:54
    let mut _39: u16;                    // in scope 0 at src/codec/simpchinese.rs:124:20: 124:23
    let mut _40: bool;                   // in scope 0 at src/codec/simpchinese.rs:125:24: 125:32
    let mut _41: usize;                  // in scope 0 at src/codec/simpchinese.rs:126:33: 126:34
    let mut _42: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:126:36: 129:27
    let mut _43: encoding_types::CodecError; // in scope 0 at src/codec/simpchinese.rs:126:41: 129:26
    let mut _44: isize;                  // in scope 0 at src/codec/simpchinese.rs:127:35: 127:45
    let mut _45: usize;                  // in scope 0 at src/codec/simpchinese.rs:127:35: 127:36
    let mut _46: std::borrow::Cow<str>;  // in scope 0 at src/codec/simpchinese.rs:128:36: 128:83
    let mut _47: &str;                   // in scope 0 at src/codec/simpchinese.rs:128:36: 128:76
    let _48: &str;                       // in scope 0 at src/codec/simpchinese.rs:128:36: 128:76
    let mut _50: u32;                    // in scope 0 at src/codec/simpchinese.rs:131:63: 131:72
    let mut _51: char;                   // in scope 0 at src/codec/simpchinese.rs:131:63: 131:65
    let mut _52: bool;                   // in scope 0 at src/codec/simpchinese.rs:132:21: 132:48
    let mut _53: bool;                   // in scope 0 at src/codec/simpchinese.rs:132:29: 132:46
    let mut _54: u32;                    // in scope 0 at src/codec/simpchinese.rs:132:29: 132:32
    let mut _57: (u32, u32);             // in scope 0 at src/codec/simpchinese.rs:133:40: 133:60
    let mut _58: u32;                    // in scope 0 at src/codec/simpchinese.rs:133:41: 133:49
    let mut _59: u32;                    // in scope 0 at src/codec/simpchinese.rs:133:41: 133:44
    let mut _60: u32;                    // in scope 0 at src/codec/simpchinese.rs:133:51: 133:59
    let mut _61: u32;                    // in scope 0 at src/codec/simpchinese.rs:133:51: 133:54
    let mut _64: (u32, u32);             // in scope 0 at src/codec/simpchinese.rs:134:40: 134:62
    let mut _65: u32;                    // in scope 0 at src/codec/simpchinese.rs:134:41: 134:50
    let mut _66: u32;                    // in scope 0 at src/codec/simpchinese.rs:134:41: 134:44
    let mut _67: u32;                    // in scope 0 at src/codec/simpchinese.rs:134:52: 134:61
    let mut _68: u32;                    // in scope 0 at src/codec/simpchinese.rs:134:52: 134:55
    let mut _71: (u32, u32);             // in scope 0 at src/codec/simpchinese.rs:135:42: 135:62
    let mut _72: u32;                    // in scope 0 at src/codec/simpchinese.rs:135:43: 135:51
    let mut _73: u32;                    // in scope 0 at src/codec/simpchinese.rs:135:43: 135:46
    let mut _74: u32;                    // in scope 0 at src/codec/simpchinese.rs:135:53: 135:61
    let mut _75: u32;                    // in scope 0 at src/codec/simpchinese.rs:135:53: 135:56
    let _76: ();                         // in scope 0 at src/codec/simpchinese.rs:136:21: 136:60
    let mut _77: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:136:21: 136:27
    let mut _78: u8;                     // in scope 0 at src/codec/simpchinese.rs:136:39: 136:59
    let mut _79: u32;                    // in scope 0 at src/codec/simpchinese.rs:136:39: 136:53
    let mut _80: u32;                    // in scope 0 at src/codec/simpchinese.rs:136:40: 136:45
    let _81: ();                         // in scope 0 at src/codec/simpchinese.rs:137:21: 137:60
    let mut _82: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:137:21: 137:27
    let mut _83: u8;                     // in scope 0 at src/codec/simpchinese.rs:137:39: 137:59
    let mut _84: u32;                    // in scope 0 at src/codec/simpchinese.rs:137:39: 137:53
    let mut _85: u32;                    // in scope 0 at src/codec/simpchinese.rs:137:40: 137:45
    let _86: ();                         // in scope 0 at src/codec/simpchinese.rs:138:21: 138:60
    let mut _87: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:138:21: 138:27
    let mut _88: u8;                     // in scope 0 at src/codec/simpchinese.rs:138:39: 138:59
    let mut _89: u32;                    // in scope 0 at src/codec/simpchinese.rs:138:39: 138:53
    let mut _90: u32;                    // in scope 0 at src/codec/simpchinese.rs:138:40: 138:45
    let _91: ();                         // in scope 0 at src/codec/simpchinese.rs:139:21: 139:60
    let mut _92: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:139:21: 139:27
    let mut _93: u8;                     // in scope 0 at src/codec/simpchinese.rs:139:39: 139:59
    let mut _94: u32;                    // in scope 0 at src/codec/simpchinese.rs:139:39: 139:53
    let mut _95: u32;                    // in scope 0 at src/codec/simpchinese.rs:139:40: 139:45
    let mut _97: u16;                    // in scope 0 at src/codec/simpchinese.rs:141:32: 141:41
    let mut _98: u16;                    // in scope 0 at src/codec/simpchinese.rs:141:32: 141:35
    let mut _100: u16;                   // in scope 0 at src/codec/simpchinese.rs:142:33: 142:36
    let mut _102: bool;                  // in scope 0 at src/codec/simpchinese.rs:143:42: 143:54
    let mut _103: u16;                   // in scope 0 at src/codec/simpchinese.rs:143:42: 143:47
    let _104: ();                        // in scope 0 at src/codec/simpchinese.rs:144:21: 144:50
    let mut _105: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:144:21: 144:27
    let mut _106: u8;                    // in scope 0 at src/codec/simpchinese.rs:144:39: 144:49
    let mut _107: u16;                   // in scope 0 at src/codec/simpchinese.rs:144:39: 144:43
    let _108: ();                        // in scope 0 at src/codec/simpchinese.rs:145:21: 145:67
    let mut _109: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:145:21: 145:27
    let mut _110: u8;                    // in scope 0 at src/codec/simpchinese.rs:145:39: 145:66
    let mut _111: u16;                   // in scope 0 at src/codec/simpchinese.rs:145:39: 145:60
    let mut _112: u16;                   // in scope 0 at src/codec/simpchinese.rs:145:40: 145:45
    let mut _113: u16;                   // in scope 0 at src/codec/simpchinese.rs:145:48: 145:59
    let mut _114: usize;                 // in scope 0 at src/codec/simpchinese.rs:149:10: 149:21
    let mut _115: &str;                  // in scope 0 at src/codec/simpchinese.rs:149:10: 149:15
    let mut _116: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:149:23: 149:27
    scope 1 {
        debug iter => _12;               // in scope 1 at src/codec/simpchinese.rs:117:29: 117:47
        let mut _13: ((usize, usize), char); // in scope 1 at src/codec/simpchinese.rs:117:29: 117:47
        scope 2 {
            debug __next => _13;         // in scope 2 at src/codec/simpchinese.rs:117:29: 117:47
            let _18: ((usize, usize), char); // in scope 2 at src/codec/simpchinese.rs:117:13: 117:25
            let _20: usize;              // in scope 2 at src/codec/simpchinese.rs:117:15: 117:16
            let _21: usize;              // in scope 2 at src/codec/simpchinese.rs:117:18: 117:19
            let _22: char;               // in scope 2 at src/codec/simpchinese.rs:117:22: 117:24
            scope 3 {
                debug val => _18;        // in scope 3 at src/codec/simpchinese.rs:117:13: 117:25
            }
            scope 4 {
                debug i => _20;          // in scope 4 at src/codec/simpchinese.rs:117:15: 117:16
                debug j => _21;          // in scope 4 at src/codec/simpchinese.rs:117:18: 117:19
                debug ch => _22;         // in scope 4 at src/codec/simpchinese.rs:117:22: 117:24
                let _36: u16;            // in scope 4 at src/codec/simpchinese.rs:123:21: 123:24
                scope 5 {
                    debug ptr => _36;    // in scope 5 at src/codec/simpchinese.rs:123:21: 123:24
                    let _49: u32;        // in scope 5 at src/codec/simpchinese.rs:131:25: 131:28
                    let _96: u16;        // in scope 5 at src/codec/simpchinese.rs:141:25: 141:29
                    scope 6 {
                        debug ptr => _49; // in scope 6 at src/codec/simpchinese.rs:131:25: 131:28
                        let _55: u32;    // in scope 6 at src/codec/simpchinese.rs:133:26: 133:29
                        let _56: u32;    // in scope 6 at src/codec/simpchinese.rs:133:31: 133:36
                        scope 7 {
                            debug ptr => _55; // in scope 7 at src/codec/simpchinese.rs:133:26: 133:29
                            debug byte4 => _56; // in scope 7 at src/codec/simpchinese.rs:133:31: 133:36
                            let _62: u32; // in scope 7 at src/codec/simpchinese.rs:134:26: 134:29
                            let _63: u32; // in scope 7 at src/codec/simpchinese.rs:134:31: 134:36
                            scope 8 {
                                debug ptr => _62; // in scope 8 at src/codec/simpchinese.rs:134:26: 134:29
                                debug byte3 => _63; // in scope 8 at src/codec/simpchinese.rs:134:31: 134:36
                                let _69: u32; // in scope 8 at src/codec/simpchinese.rs:135:26: 135:31
                                let _70: u32; // in scope 8 at src/codec/simpchinese.rs:135:33: 135:38
                                scope 9 {
                                    debug byte1 => _69; // in scope 9 at src/codec/simpchinese.rs:135:26: 135:31
                                    debug byte2 => _70; // in scope 9 at src/codec/simpchinese.rs:135:33: 135:38
                                }
                            }
                        }
                    }
                    scope 10 {
                        debug lead => _96; // in scope 10 at src/codec/simpchinese.rs:141:25: 141:29
                        let _99: u16;    // in scope 10 at src/codec/simpchinese.rs:142:25: 142:30
                        scope 11 {
                            debug trail => _99; // in scope 11 at src/codec/simpchinese.rs:142:25: 142:30
                            let _101: u16; // in scope 11 at src/codec/simpchinese.rs:143:25: 143:36
                            scope 12 {
                                debug trailoffset => _101; // in scope 12 at src/codec/simpchinese.rs:143:25: 143:36
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:115:9: 115:40
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:115:9: 115:15
        _6 = &mut (*_3);                 // scope 0 at src/codec/simpchinese.rs:115:9: 115:15
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:115:28: 115:39
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:115:28: 115:33
        _8 = _2;                         // scope 0 at src/codec/simpchinese.rs:115:28: 115:33
        _7 = core::str::<impl str>::len(move _8) -> bb1; // scope 0 at src/codec/simpchinese.rs:115:28: 115:39
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:115:34: 115:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:115:38: 115:39
        _5 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _6, move _7) -> bb2; // scope 0 at src/codec/simpchinese.rs:115:9: 115:40
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:115:16: 115:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:115:39: 115:40
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:115:39: 115:40
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:115:40: 115:41
        StorageLive(_9);                 // scope 0 at src/codec/simpchinese.rs:117:29: 117:47
        StorageLive(_10);                // scope 0 at src/codec/simpchinese.rs:117:29: 117:47
        StorageLive(_11);                // scope 0 at src/codec/simpchinese.rs:117:29: 117:34
        _11 = &_2;                       // scope 0 at src/codec/simpchinese.rs:117:29: 117:34
        _10 = <&str as StrCharIndex>::index_iter(move _11) -> bb3; // scope 0 at src/codec/simpchinese.rs:117:29: 117:47
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:117:35: 117:45
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_11);                // scope 0 at src/codec/simpchinese.rs:117:46: 117:47
        _9 = <StrCharIndexIterator as IntoIterator>::into_iter(move _10) -> bb4; // scope 0 at src/codec/simpchinese.rs:117:29: 117:47
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:117:29: 117:47
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_10);                // scope 0 at src/codec/simpchinese.rs:117:46: 117:47
        StorageLive(_12);                // scope 0 at src/codec/simpchinese.rs:117:29: 117:47
        _12 = move _9;                   // scope 0 at src/codec/simpchinese.rs:117:29: 117:47
        goto -> bb5;                     // scope 1 at src/codec/simpchinese.rs:117:9: 148:10
    }

    bb5: {
        StorageLive(_13);                // scope 1 at src/codec/simpchinese.rs:117:29: 117:47
        StorageLive(_14);                // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
        StorageLive(_15);                // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
        StorageLive(_16);                // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
        _16 = &mut _12;                  // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
        _15 = &mut (*_16);               // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
        _14 = <StrCharIndexIterator as Iterator>::next(move _15) -> bb6; // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:117:29: 117:47
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_15);                // scope 2 at src/codec/simpchinese.rs:117:46: 117:47
        _17 = discriminant(_14);         // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
        switchInt(move _17) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
    }

    bb7: {
        StorageDead(_16);                // scope 2 at src/codec/simpchinese.rs:117:46: 117:47
        StorageDead(_14);                // scope 2 at src/codec/simpchinese.rs:117:46: 117:47
        StorageDead(_13);                // scope 1 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_12);                // scope 0 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:117:46: 117:47
        StorageLive(_114);               // scope 0 at src/codec/simpchinese.rs:149:10: 149:21
        StorageLive(_115);               // scope 0 at src/codec/simpchinese.rs:149:10: 149:15
        _115 = _2;                       // scope 0 at src/codec/simpchinese.rs:149:10: 149:15
        _114 = core::str::<impl str>::len(move _115) -> bb40; // scope 0 at src/codec/simpchinese.rs:149:10: 149:21
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:149:16: 149:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/simpchinese.rs:117:29: 117:47
    }

    bb9: {
        StorageLive(_18);                // scope 2 at src/codec/simpchinese.rs:117:13: 117:25
        _18 = ((_14 as Some).0: ((usize, usize), char)); // scope 2 at src/codec/simpchinese.rs:117:13: 117:25
        StorageLive(_19);                // scope 3 at src/codec/simpchinese.rs:117:13: 117:25
        _19 = _18;                       // scope 3 at src/codec/simpchinese.rs:117:13: 117:25
        _13 = move _19;                  // scope 3 at src/codec/simpchinese.rs:117:13: 117:25
        StorageDead(_19);                // scope 3 at src/codec/simpchinese.rs:117:24: 117:25
        StorageDead(_18);                // scope 2 at src/codec/simpchinese.rs:117:24: 117:25
        StorageDead(_16);                // scope 2 at src/codec/simpchinese.rs:117:46: 117:47
        StorageDead(_14);                // scope 2 at src/codec/simpchinese.rs:117:46: 117:47
        StorageLive(_20);                // scope 2 at src/codec/simpchinese.rs:117:15: 117:16
        _20 = ((_13.0: (usize, usize)).0: usize); // scope 2 at src/codec/simpchinese.rs:117:15: 117:16
        StorageLive(_21);                // scope 2 at src/codec/simpchinese.rs:117:18: 117:19
        _21 = ((_13.0: (usize, usize)).1: usize); // scope 2 at src/codec/simpchinese.rs:117:18: 117:19
        StorageLive(_22);                // scope 2 at src/codec/simpchinese.rs:117:22: 117:24
        _22 = (_13.1: char);             // scope 2 at src/codec/simpchinese.rs:117:22: 117:24
        StorageLive(_23);                // scope 4 at src/codec/simpchinese.rs:117:48: 148:10
        StorageLive(_24);                // scope 4 at src/codec/simpchinese.rs:118:16: 118:29
        StorageLive(_25);                // scope 4 at src/codec/simpchinese.rs:118:16: 118:18
        _25 = _22;                       // scope 4 at src/codec/simpchinese.rs:118:16: 118:18
        _24 = Lt(move _25, const '\u{80}'); // scope 4 at src/codec/simpchinese.rs:118:16: 118:29
        StorageDead(_25);                // scope 4 at src/codec/simpchinese.rs:118:28: 118:29
        switchInt(move _24) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/simpchinese.rs:118:16: 118:29
    }

    bb10: {
        StorageLive(_26);                // scope 4 at src/codec/simpchinese.rs:119:17: 119:44
        StorageLive(_27);                // scope 4 at src/codec/simpchinese.rs:119:17: 119:23
        _27 = &mut (*_3);                // scope 4 at src/codec/simpchinese.rs:119:17: 119:23
        StorageLive(_28);                // scope 4 at src/codec/simpchinese.rs:119:35: 119:43
        StorageLive(_29);                // scope 4 at src/codec/simpchinese.rs:119:35: 119:37
        _29 = _22;                       // scope 4 at src/codec/simpchinese.rs:119:35: 119:37
        _28 = move _29 as u8 (Misc);     // scope 4 at src/codec/simpchinese.rs:119:35: 119:43
        StorageDead(_29);                // scope 4 at src/codec/simpchinese.rs:119:42: 119:43
        _26 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _27, move _28) -> bb12; // scope 4 at src/codec/simpchinese.rs:119:17: 119:44
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:119:24: 119:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageLive(_30);                // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
        StorageLive(_31);                // scope 4 at src/codec/simpchinese.rs:120:23: 120:31
        _31 = _4;                        // scope 4 at src/codec/simpchinese.rs:120:23: 120:31
        switchInt(move _31) -> [false: bb13, otherwise: bb14]; // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
    }

    bb12: {
        StorageDead(_28);                // scope 4 at src/codec/simpchinese.rs:119:43: 119:44
        StorageDead(_27);                // scope 4 at src/codec/simpchinese.rs:119:43: 119:44
        StorageDead(_26);                // scope 4 at src/codec/simpchinese.rs:119:44: 119:45
        goto -> bb39;                    // scope 4 at src/codec/simpchinese.rs:118:13: 147:14
    }

    bb13: {
        _30 = const false;               // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
        goto -> bb15;                    // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
    }

    bb14: {
        StorageLive(_32);                // scope 4 at src/codec/simpchinese.rs:120:35: 120:51
        StorageLive(_33);                // scope 4 at src/codec/simpchinese.rs:120:35: 120:37
        _33 = _22;                       // scope 4 at src/codec/simpchinese.rs:120:35: 120:37
        _32 = Eq(move _33, const '');   // scope 4 at src/codec/simpchinese.rs:120:35: 120:51
        StorageDead(_33);                // scope 4 at src/codec/simpchinese.rs:120:50: 120:51
        _30 = move _32;                  // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
        goto -> bb15;                    // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
    }

    bb15: {
        StorageDead(_32);                // scope 4 at src/codec/simpchinese.rs:120:50: 120:51
        StorageDead(_31);                // scope 4 at src/codec/simpchinese.rs:120:50: 120:51
        switchInt(move _30) -> [false: bb18, otherwise: bb16]; // scope 4 at src/codec/simpchinese.rs:120:23: 120:51
    }

    bb16: {
        StorageLive(_34);                // scope 4 at src/codec/simpchinese.rs:121:17: 121:23
        _34 = &mut (*_3);                // scope 4 at src/codec/simpchinese.rs:121:17: 121:23
        StorageLive(_35);                // scope 4 at src/codec/simpchinese.rs:121:35: 121:49
        _35 = const 128_u8;              // scope 4 at src/codec/simpchinese.rs:121:35: 121:49
        _23 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _34, move _35) -> bb17; // scope 4 at src/codec/simpchinese.rs:121:17: 121:50
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:121:24: 121:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_35);                // scope 4 at src/codec/simpchinese.rs:121:49: 121:50
        StorageDead(_34);                // scope 4 at src/codec/simpchinese.rs:121:49: 121:50
        goto -> bb38;                    // scope 4 at src/codec/simpchinese.rs:120:20: 147:14
    }

    bb18: {
        StorageLive(_36);                // scope 4 at src/codec/simpchinese.rs:123:21: 123:24
        StorageLive(_37);                // scope 4 at src/codec/simpchinese.rs:123:52: 123:61
        StorageLive(_38);                // scope 4 at src/codec/simpchinese.rs:123:52: 123:54
        _38 = _22;                       // scope 4 at src/codec/simpchinese.rs:123:52: 123:54
        _37 = move _38 as u32 (Misc);    // scope 4 at src/codec/simpchinese.rs:123:52: 123:61
        StorageDead(_38);                // scope 4 at src/codec/simpchinese.rs:123:60: 123:61
        _36 = index_simpchinese::gb18030::backward(move _37) -> bb19; // scope 4 at src/codec/simpchinese.rs:123:27: 123:62
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:123:27: 123:51
                                         // + literal: Const { ty: fn(u32) -> u16 {index_simpchinese::gb18030::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_37);                // scope 4 at src/codec/simpchinese.rs:123:61: 123:62
        StorageLive(_39);                // scope 5 at src/codec/simpchinese.rs:124:20: 124:23
        _39 = _36;                       // scope 5 at src/codec/simpchinese.rs:124:20: 124:23
        switchInt(move _39) -> [u16::MAX: bb20, otherwise: bb31]; // scope 5 at src/codec/simpchinese.rs:124:20: 124:33
    }

    bb20: {
        StorageDead(_39);                // scope 5 at src/codec/simpchinese.rs:124:20: 124:33
        StorageLive(_40);                // scope 5 at src/codec/simpchinese.rs:125:24: 125:32
        _40 = _4;                        // scope 5 at src/codec/simpchinese.rs:125:24: 125:32
        switchInt(move _40) -> [false: bb23, otherwise: bb21]; // scope 5 at src/codec/simpchinese.rs:125:24: 125:32
    }

    bb21: {
        StorageLive(_41);                // scope 5 at src/codec/simpchinese.rs:126:33: 126:34
        _41 = _20;                       // scope 5 at src/codec/simpchinese.rs:126:33: 126:34
        StorageLive(_42);                // scope 5 at src/codec/simpchinese.rs:126:36: 129:27
        StorageLive(_43);                // scope 5 at src/codec/simpchinese.rs:126:41: 129:26
        StorageLive(_44);                // scope 5 at src/codec/simpchinese.rs:127:35: 127:45
        StorageLive(_45);                // scope 5 at src/codec/simpchinese.rs:127:35: 127:36
        _45 = _21;                       // scope 5 at src/codec/simpchinese.rs:127:35: 127:36
        _44 = move _45 as isize (Misc);  // scope 5 at src/codec/simpchinese.rs:127:35: 127:45
        StorageDead(_45);                // scope 5 at src/codec/simpchinese.rs:127:44: 127:45
        StorageLive(_46);                // scope 5 at src/codec/simpchinese.rs:128:36: 128:83
        StorageLive(_47);                // scope 5 at src/codec/simpchinese.rs:128:36: 128:76
        StorageLive(_48);                // scope 5 at src/codec/simpchinese.rs:128:36: 128:76
        _48 = const "gbk doesn't support gb18030 extensions"; // scope 5 at src/codec/simpchinese.rs:128:36: 128:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 107, 32, 100, 111, 101, 115, 110, 39, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 103, 98, 49, 56, 48, 51, 48, 32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [274877906943], len: Size { raw: 38 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 38 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:128:36: 128:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 107, 32, 100, 111, 101, 115, 110, 39, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 103, 98, 49, 56, 48, 51, 48, 32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [274877906943], len: Size { raw: 38 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 38 }) }
        _47 = _48;                       // scope 5 at src/codec/simpchinese.rs:128:36: 128:76
        _46 = <&str as Into<Cow<str>>>::into(move _47) -> bb22; // scope 5 at src/codec/simpchinese.rs:128:36: 128:83
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:128:77: 128:81
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb22: {
        StorageDead(_47);                // scope 5 at src/codec/simpchinese.rs:128:82: 128:83
        (_43.0: isize) = move _44;       // scope 5 at src/codec/simpchinese.rs:126:41: 129:26
        (_43.1: std::borrow::Cow<str>) = move _46; // scope 5 at src/codec/simpchinese.rs:126:41: 129:26
        StorageDead(_46);                // scope 5 at src/codec/simpchinese.rs:129:25: 129:26
        StorageDead(_44);                // scope 5 at src/codec/simpchinese.rs:129:25: 129:26
        ((_42 as Some).0: encoding_types::CodecError) = move _43; // scope 5 at src/codec/simpchinese.rs:126:36: 129:27
        discriminant(_42) = 1;           // scope 5 at src/codec/simpchinese.rs:126:36: 129:27
        StorageDead(_43);                // scope 5 at src/codec/simpchinese.rs:129:26: 129:27
        (_0.0: usize) = move _41;        // scope 5 at src/codec/simpchinese.rs:126:32: 129:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _42; // scope 5 at src/codec/simpchinese.rs:126:32: 129:28
        StorageDead(_42);                // scope 5 at src/codec/simpchinese.rs:129:27: 129:28
        StorageDead(_41);                // scope 5 at src/codec/simpchinese.rs:129:27: 129:28
        StorageDead(_48);                // scope 5 at src/codec/simpchinese.rs:129:28: 129:29
        StorageDead(_40);                // scope 5 at src/codec/simpchinese.rs:130:21: 130:22
        StorageDead(_36);                // scope 4 at src/codec/simpchinese.rs:147:13: 147:14
        StorageDead(_30);                // scope 4 at src/codec/simpchinese.rs:147:13: 147:14
        StorageDead(_24);                // scope 4 at src/codec/simpchinese.rs:147:13: 147:14
        StorageDead(_23);                // scope 4 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_22);                // scope 2 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_21);                // scope 2 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_20);                // scope 2 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_13);                // scope 1 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_12);                // scope 0 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:117:46: 117:47
        goto -> bb41;                    // scope 0 at src/codec/simpchinese.rs:150:6: 150:6
    }

    bb23: {
        StorageDead(_40);                // scope 5 at src/codec/simpchinese.rs:130:21: 130:22
        StorageLive(_49);                // scope 5 at src/codec/simpchinese.rs:131:25: 131:28
        StorageLive(_50);                // scope 5 at src/codec/simpchinese.rs:131:63: 131:72
        StorageLive(_51);                // scope 5 at src/codec/simpchinese.rs:131:63: 131:65
        _51 = _22;                       // scope 5 at src/codec/simpchinese.rs:131:63: 131:65
        _50 = move _51 as u32 (Misc);    // scope 5 at src/codec/simpchinese.rs:131:63: 131:72
        StorageDead(_51);                // scope 5 at src/codec/simpchinese.rs:131:71: 131:72
        _49 = index_simpchinese::gb18030_ranges::backward(move _50) -> bb24; // scope 5 at src/codec/simpchinese.rs:131:31: 131:73
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:131:31: 131:62
                                         // + literal: Const { ty: fn(u32) -> u32 {index_simpchinese::gb18030_ranges::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_50);                // scope 5 at src/codec/simpchinese.rs:131:72: 131:73
        StorageLive(_52);                // scope 6 at src/codec/simpchinese.rs:132:21: 132:48
        StorageLive(_53);                // scope 6 at src/codec/simpchinese.rs:132:29: 132:46
        StorageLive(_54);                // scope 6 at src/codec/simpchinese.rs:132:29: 132:32
        _54 = _49;                       // scope 6 at src/codec/simpchinese.rs:132:29: 132:32
        _53 = Ne(move _54, const u32::MAX); // scope 6 at src/codec/simpchinese.rs:132:29: 132:46
        StorageDead(_54);                // scope 6 at src/codec/simpchinese.rs:132:45: 132:46
        _52 = Not(move _53);             // scope 6 at src/codec/simpchinese.rs:132:21: 132:48
        StorageDead(_53);                // scope 6 at src/codec/simpchinese.rs:132:47: 132:48
        switchInt(move _52) -> [false: bb26, otherwise: bb25]; // scope 6 at src/codec/simpchinese.rs:132:21: 132:48
    }

    bb25: {
        core::panicking::panic(const "assertion failed: ptr != 0xffffffff"); // scope 6 at src/codec/simpchinese.rs:132:21: 132:48
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:132:21: 132:48
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 112, 116, 114, 32, 33, 61, 32, 48, 120, 102, 102, 102, 102, 102, 102, 102, 102], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [34359738367], len: Size { raw: 35 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 35 })
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 112, 116, 114, 32, 33, 61, 32, 48, 120, 102, 102, 102, 102, 102, 102, 102, 102], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [34359738367], len: Size { raw: 35 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 35 }) }
    }

    bb26: {
        StorageDead(_52);                // scope 6 at src/codec/simpchinese.rs:132:47: 132:48
        StorageLive(_57);                // scope 6 at src/codec/simpchinese.rs:133:40: 133:60
        StorageLive(_58);                // scope 6 at src/codec/simpchinese.rs:133:41: 133:49
        StorageLive(_59);                // scope 6 at src/codec/simpchinese.rs:133:41: 133:44
        _59 = _49;                       // scope 6 at src/codec/simpchinese.rs:133:41: 133:44
        _58 = Div(move _59, const 10_u32); // scope 6 at src/codec/simpchinese.rs:133:41: 133:49
        StorageDead(_59);                // scope 6 at src/codec/simpchinese.rs:133:48: 133:49
        StorageLive(_60);                // scope 6 at src/codec/simpchinese.rs:133:51: 133:59
        StorageLive(_61);                // scope 6 at src/codec/simpchinese.rs:133:51: 133:54
        _61 = _49;                       // scope 6 at src/codec/simpchinese.rs:133:51: 133:54
        _60 = Rem(move _61, const 10_u32); // scope 6 at src/codec/simpchinese.rs:133:51: 133:59
        StorageDead(_61);                // scope 6 at src/codec/simpchinese.rs:133:58: 133:59
        (_57.0: u32) = move _58;         // scope 6 at src/codec/simpchinese.rs:133:40: 133:60
        (_57.1: u32) = move _60;         // scope 6 at src/codec/simpchinese.rs:133:40: 133:60
        StorageDead(_60);                // scope 6 at src/codec/simpchinese.rs:133:59: 133:60
        StorageDead(_58);                // scope 6 at src/codec/simpchinese.rs:133:59: 133:60
        StorageLive(_55);                // scope 6 at src/codec/simpchinese.rs:133:26: 133:29
        _55 = (_57.0: u32);              // scope 6 at src/codec/simpchinese.rs:133:26: 133:29
        StorageLive(_56);                // scope 6 at src/codec/simpchinese.rs:133:31: 133:36
        _56 = (_57.1: u32);              // scope 6 at src/codec/simpchinese.rs:133:31: 133:36
        StorageDead(_57);                // scope 6 at src/codec/simpchinese.rs:133:60: 133:61
        StorageLive(_64);                // scope 7 at src/codec/simpchinese.rs:134:40: 134:62
        StorageLive(_65);                // scope 7 at src/codec/simpchinese.rs:134:41: 134:50
        StorageLive(_66);                // scope 7 at src/codec/simpchinese.rs:134:41: 134:44
        _66 = _55;                       // scope 7 at src/codec/simpchinese.rs:134:41: 134:44
        _65 = Div(move _66, const 126_u32); // scope 7 at src/codec/simpchinese.rs:134:41: 134:50
        StorageDead(_66);                // scope 7 at src/codec/simpchinese.rs:134:49: 134:50
        StorageLive(_67);                // scope 7 at src/codec/simpchinese.rs:134:52: 134:61
        StorageLive(_68);                // scope 7 at src/codec/simpchinese.rs:134:52: 134:55
        _68 = _55;                       // scope 7 at src/codec/simpchinese.rs:134:52: 134:55
        _67 = Rem(move _68, const 126_u32); // scope 7 at src/codec/simpchinese.rs:134:52: 134:61
        StorageDead(_68);                // scope 7 at src/codec/simpchinese.rs:134:60: 134:61
        (_64.0: u32) = move _65;         // scope 7 at src/codec/simpchinese.rs:134:40: 134:62
        (_64.1: u32) = move _67;         // scope 7 at src/codec/simpchinese.rs:134:40: 134:62
        StorageDead(_67);                // scope 7 at src/codec/simpchinese.rs:134:61: 134:62
        StorageDead(_65);                // scope 7 at src/codec/simpchinese.rs:134:61: 134:62
        StorageLive(_62);                // scope 7 at src/codec/simpchinese.rs:134:26: 134:29
        _62 = (_64.0: u32);              // scope 7 at src/codec/simpchinese.rs:134:26: 134:29
        StorageLive(_63);                // scope 7 at src/codec/simpchinese.rs:134:31: 134:36
        _63 = (_64.1: u32);              // scope 7 at src/codec/simpchinese.rs:134:31: 134:36
        StorageDead(_64);                // scope 7 at src/codec/simpchinese.rs:134:62: 134:63
        StorageLive(_71);                // scope 8 at src/codec/simpchinese.rs:135:42: 135:62
        StorageLive(_72);                // scope 8 at src/codec/simpchinese.rs:135:43: 135:51
        StorageLive(_73);                // scope 8 at src/codec/simpchinese.rs:135:43: 135:46
        _73 = _62;                       // scope 8 at src/codec/simpchinese.rs:135:43: 135:46
        _72 = Div(move _73, const 10_u32); // scope 8 at src/codec/simpchinese.rs:135:43: 135:51
        StorageDead(_73);                // scope 8 at src/codec/simpchinese.rs:135:50: 135:51
        StorageLive(_74);                // scope 8 at src/codec/simpchinese.rs:135:53: 135:61
        StorageLive(_75);                // scope 8 at src/codec/simpchinese.rs:135:53: 135:56
        _75 = _62;                       // scope 8 at src/codec/simpchinese.rs:135:53: 135:56
        _74 = Rem(move _75, const 10_u32); // scope 8 at src/codec/simpchinese.rs:135:53: 135:61
        StorageDead(_75);                // scope 8 at src/codec/simpchinese.rs:135:60: 135:61
        (_71.0: u32) = move _72;         // scope 8 at src/codec/simpchinese.rs:135:42: 135:62
        (_71.1: u32) = move _74;         // scope 8 at src/codec/simpchinese.rs:135:42: 135:62
        StorageDead(_74);                // scope 8 at src/codec/simpchinese.rs:135:61: 135:62
        StorageDead(_72);                // scope 8 at src/codec/simpchinese.rs:135:61: 135:62
        StorageLive(_69);                // scope 8 at src/codec/simpchinese.rs:135:26: 135:31
        _69 = (_71.0: u32);              // scope 8 at src/codec/simpchinese.rs:135:26: 135:31
        StorageLive(_70);                // scope 8 at src/codec/simpchinese.rs:135:33: 135:38
        _70 = (_71.1: u32);              // scope 8 at src/codec/simpchinese.rs:135:33: 135:38
        StorageDead(_71);                // scope 8 at src/codec/simpchinese.rs:135:62: 135:63
        StorageLive(_76);                // scope 9 at src/codec/simpchinese.rs:136:21: 136:60
        StorageLive(_77);                // scope 9 at src/codec/simpchinese.rs:136:21: 136:27
        _77 = &mut (*_3);                // scope 9 at src/codec/simpchinese.rs:136:21: 136:27
        StorageLive(_78);                // scope 9 at src/codec/simpchinese.rs:136:39: 136:59
        StorageLive(_79);                // scope 9 at src/codec/simpchinese.rs:136:39: 136:53
        StorageLive(_80);                // scope 9 at src/codec/simpchinese.rs:136:40: 136:45
        _80 = _69;                       // scope 9 at src/codec/simpchinese.rs:136:40: 136:45
        _79 = Add(move _80, const 129_u32); // scope 9 at src/codec/simpchinese.rs:136:39: 136:53
        StorageDead(_80);                // scope 9 at src/codec/simpchinese.rs:136:52: 136:53
        _78 = move _79 as u8 (Misc);     // scope 9 at src/codec/simpchinese.rs:136:39: 136:59
        StorageDead(_79);                // scope 9 at src/codec/simpchinese.rs:136:58: 136:59
        _76 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _77, move _78) -> bb27; // scope 9 at src/codec/simpchinese.rs:136:21: 136:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:136:28: 136:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb27: {
        StorageDead(_78);                // scope 9 at src/codec/simpchinese.rs:136:59: 136:60
        StorageDead(_77);                // scope 9 at src/codec/simpchinese.rs:136:59: 136:60
        StorageDead(_76);                // scope 9 at src/codec/simpchinese.rs:136:60: 136:61
        StorageLive(_81);                // scope 9 at src/codec/simpchinese.rs:137:21: 137:60
        StorageLive(_82);                // scope 9 at src/codec/simpchinese.rs:137:21: 137:27
        _82 = &mut (*_3);                // scope 9 at src/codec/simpchinese.rs:137:21: 137:27
        StorageLive(_83);                // scope 9 at src/codec/simpchinese.rs:137:39: 137:59
        StorageLive(_84);                // scope 9 at src/codec/simpchinese.rs:137:39: 137:53
        StorageLive(_85);                // scope 9 at src/codec/simpchinese.rs:137:40: 137:45
        _85 = _70;                       // scope 9 at src/codec/simpchinese.rs:137:40: 137:45
        _84 = Add(move _85, const 48_u32); // scope 9 at src/codec/simpchinese.rs:137:39: 137:53
        StorageDead(_85);                // scope 9 at src/codec/simpchinese.rs:137:52: 137:53
        _83 = move _84 as u8 (Misc);     // scope 9 at src/codec/simpchinese.rs:137:39: 137:59
        StorageDead(_84);                // scope 9 at src/codec/simpchinese.rs:137:58: 137:59
        _81 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _82, move _83) -> bb28; // scope 9 at src/codec/simpchinese.rs:137:21: 137:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:137:28: 137:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb28: {
        StorageDead(_83);                // scope 9 at src/codec/simpchinese.rs:137:59: 137:60
        StorageDead(_82);                // scope 9 at src/codec/simpchinese.rs:137:59: 137:60
        StorageDead(_81);                // scope 9 at src/codec/simpchinese.rs:137:60: 137:61
        StorageLive(_86);                // scope 9 at src/codec/simpchinese.rs:138:21: 138:60
        StorageLive(_87);                // scope 9 at src/codec/simpchinese.rs:138:21: 138:27
        _87 = &mut (*_3);                // scope 9 at src/codec/simpchinese.rs:138:21: 138:27
        StorageLive(_88);                // scope 9 at src/codec/simpchinese.rs:138:39: 138:59
        StorageLive(_89);                // scope 9 at src/codec/simpchinese.rs:138:39: 138:53
        StorageLive(_90);                // scope 9 at src/codec/simpchinese.rs:138:40: 138:45
        _90 = _63;                       // scope 9 at src/codec/simpchinese.rs:138:40: 138:45
        _89 = Add(move _90, const 129_u32); // scope 9 at src/codec/simpchinese.rs:138:39: 138:53
        StorageDead(_90);                // scope 9 at src/codec/simpchinese.rs:138:52: 138:53
        _88 = move _89 as u8 (Misc);     // scope 9 at src/codec/simpchinese.rs:138:39: 138:59
        StorageDead(_89);                // scope 9 at src/codec/simpchinese.rs:138:58: 138:59
        _86 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _87, move _88) -> bb29; // scope 9 at src/codec/simpchinese.rs:138:21: 138:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:138:28: 138:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb29: {
        StorageDead(_88);                // scope 9 at src/codec/simpchinese.rs:138:59: 138:60
        StorageDead(_87);                // scope 9 at src/codec/simpchinese.rs:138:59: 138:60
        StorageDead(_86);                // scope 9 at src/codec/simpchinese.rs:138:60: 138:61
        StorageLive(_91);                // scope 9 at src/codec/simpchinese.rs:139:21: 139:60
        StorageLive(_92);                // scope 9 at src/codec/simpchinese.rs:139:21: 139:27
        _92 = &mut (*_3);                // scope 9 at src/codec/simpchinese.rs:139:21: 139:27
        StorageLive(_93);                // scope 9 at src/codec/simpchinese.rs:139:39: 139:59
        StorageLive(_94);                // scope 9 at src/codec/simpchinese.rs:139:39: 139:53
        StorageLive(_95);                // scope 9 at src/codec/simpchinese.rs:139:40: 139:45
        _95 = _56;                       // scope 9 at src/codec/simpchinese.rs:139:40: 139:45
        _94 = Add(move _95, const 48_u32); // scope 9 at src/codec/simpchinese.rs:139:39: 139:53
        StorageDead(_95);                // scope 9 at src/codec/simpchinese.rs:139:52: 139:53
        _93 = move _94 as u8 (Misc);     // scope 9 at src/codec/simpchinese.rs:139:39: 139:59
        StorageDead(_94);                // scope 9 at src/codec/simpchinese.rs:139:58: 139:59
        _91 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _92, move _93) -> bb30; // scope 9 at src/codec/simpchinese.rs:139:21: 139:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:139:28: 139:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb30: {
        StorageDead(_93);                // scope 9 at src/codec/simpchinese.rs:139:59: 139:60
        StorageDead(_92);                // scope 9 at src/codec/simpchinese.rs:139:59: 139:60
        StorageDead(_91);                // scope 9 at src/codec/simpchinese.rs:139:60: 139:61
        StorageDead(_70);                // scope 8 at src/codec/simpchinese.rs:140:17: 140:18
        StorageDead(_69);                // scope 8 at src/codec/simpchinese.rs:140:17: 140:18
        StorageDead(_63);                // scope 7 at src/codec/simpchinese.rs:140:17: 140:18
        StorageDead(_62);                // scope 7 at src/codec/simpchinese.rs:140:17: 140:18
        StorageDead(_56);                // scope 6 at src/codec/simpchinese.rs:140:17: 140:18
        StorageDead(_55);                // scope 6 at src/codec/simpchinese.rs:140:17: 140:18
        StorageDead(_49);                // scope 5 at src/codec/simpchinese.rs:140:17: 140:18
        goto -> bb37;                    // scope 5 at src/codec/simpchinese.rs:124:17: 146:18
    }

    bb31: {
        StorageDead(_39);                // scope 5 at src/codec/simpchinese.rs:124:20: 124:33
        StorageLive(_96);                // scope 5 at src/codec/simpchinese.rs:141:25: 141:29
        StorageLive(_97);                // scope 5 at src/codec/simpchinese.rs:141:32: 141:41
        StorageLive(_98);                // scope 5 at src/codec/simpchinese.rs:141:32: 141:35
        _98 = _36;                       // scope 5 at src/codec/simpchinese.rs:141:32: 141:35
        _97 = Div(move _98, const 190_u16); // scope 5 at src/codec/simpchinese.rs:141:32: 141:41
        StorageDead(_98);                // scope 5 at src/codec/simpchinese.rs:141:40: 141:41
        _96 = Add(move _97, const 129_u16); // scope 5 at src/codec/simpchinese.rs:141:32: 141:48
        StorageDead(_97);                // scope 5 at src/codec/simpchinese.rs:141:47: 141:48
        StorageLive(_99);                // scope 10 at src/codec/simpchinese.rs:142:25: 142:30
        StorageLive(_100);               // scope 10 at src/codec/simpchinese.rs:142:33: 142:36
        _100 = _36;                      // scope 10 at src/codec/simpchinese.rs:142:33: 142:36
        _99 = Rem(move _100, const 190_u16); // scope 10 at src/codec/simpchinese.rs:142:33: 142:42
        StorageDead(_100);               // scope 10 at src/codec/simpchinese.rs:142:41: 142:42
        StorageLive(_101);               // scope 11 at src/codec/simpchinese.rs:143:25: 143:36
        StorageLive(_102);               // scope 11 at src/codec/simpchinese.rs:143:42: 143:54
        StorageLive(_103);               // scope 11 at src/codec/simpchinese.rs:143:42: 143:47
        _103 = _99;                      // scope 11 at src/codec/simpchinese.rs:143:42: 143:47
        _102 = Lt(move _103, const 63_u16); // scope 11 at src/codec/simpchinese.rs:143:42: 143:54
        StorageDead(_103);               // scope 11 at src/codec/simpchinese.rs:143:53: 143:54
        switchInt(move _102) -> [false: bb33, otherwise: bb32]; // scope 11 at src/codec/simpchinese.rs:143:42: 143:54
    }

    bb32: {
        _101 = const 64_u16;             // scope 11 at src/codec/simpchinese.rs:143:56: 143:60
        goto -> bb34;                    // scope 11 at src/codec/simpchinese.rs:143:39: 143:73
    }

    bb33: {
        _101 = const 65_u16;             // scope 11 at src/codec/simpchinese.rs:143:68: 143:72
        goto -> bb34;                    // scope 11 at src/codec/simpchinese.rs:143:39: 143:73
    }

    bb34: {
        StorageDead(_102);               // scope 11 at src/codec/simpchinese.rs:143:72: 143:73
        StorageLive(_104);               // scope 12 at src/codec/simpchinese.rs:144:21: 144:50
        StorageLive(_105);               // scope 12 at src/codec/simpchinese.rs:144:21: 144:27
        _105 = &mut (*_3);               // scope 12 at src/codec/simpchinese.rs:144:21: 144:27
        StorageLive(_106);               // scope 12 at src/codec/simpchinese.rs:144:39: 144:49
        StorageLive(_107);               // scope 12 at src/codec/simpchinese.rs:144:39: 144:43
        _107 = _96;                      // scope 12 at src/codec/simpchinese.rs:144:39: 144:43
        _106 = move _107 as u8 (Misc);   // scope 12 at src/codec/simpchinese.rs:144:39: 144:49
        StorageDead(_107);               // scope 12 at src/codec/simpchinese.rs:144:48: 144:49
        _104 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _105, move _106) -> bb35; // scope 12 at src/codec/simpchinese.rs:144:21: 144:50
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:144:28: 144:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb35: {
        StorageDead(_106);               // scope 12 at src/codec/simpchinese.rs:144:49: 144:50
        StorageDead(_105);               // scope 12 at src/codec/simpchinese.rs:144:49: 144:50
        StorageDead(_104);               // scope 12 at src/codec/simpchinese.rs:144:50: 144:51
        StorageLive(_108);               // scope 12 at src/codec/simpchinese.rs:145:21: 145:67
        StorageLive(_109);               // scope 12 at src/codec/simpchinese.rs:145:21: 145:27
        _109 = &mut (*_3);               // scope 12 at src/codec/simpchinese.rs:145:21: 145:27
        StorageLive(_110);               // scope 12 at src/codec/simpchinese.rs:145:39: 145:66
        StorageLive(_111);               // scope 12 at src/codec/simpchinese.rs:145:39: 145:60
        StorageLive(_112);               // scope 12 at src/codec/simpchinese.rs:145:40: 145:45
        _112 = _99;                      // scope 12 at src/codec/simpchinese.rs:145:40: 145:45
        StorageLive(_113);               // scope 12 at src/codec/simpchinese.rs:145:48: 145:59
        _113 = _101;                     // scope 12 at src/codec/simpchinese.rs:145:48: 145:59
        _111 = Add(move _112, move _113); // scope 12 at src/codec/simpchinese.rs:145:39: 145:60
        StorageDead(_113);               // scope 12 at src/codec/simpchinese.rs:145:59: 145:60
        StorageDead(_112);               // scope 12 at src/codec/simpchinese.rs:145:59: 145:60
        _110 = move _111 as u8 (Misc);   // scope 12 at src/codec/simpchinese.rs:145:39: 145:66
        StorageDead(_111);               // scope 12 at src/codec/simpchinese.rs:145:65: 145:66
        _108 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _109, move _110) -> bb36; // scope 12 at src/codec/simpchinese.rs:145:21: 145:67
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:145:28: 145:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb36: {
        StorageDead(_110);               // scope 12 at src/codec/simpchinese.rs:145:66: 145:67
        StorageDead(_109);               // scope 12 at src/codec/simpchinese.rs:145:66: 145:67
        StorageDead(_108);               // scope 12 at src/codec/simpchinese.rs:145:67: 145:68
        StorageDead(_101);               // scope 11 at src/codec/simpchinese.rs:146:17: 146:18
        StorageDead(_99);                // scope 10 at src/codec/simpchinese.rs:146:17: 146:18
        StorageDead(_96);                // scope 5 at src/codec/simpchinese.rs:146:17: 146:18
        goto -> bb37;                    // scope 5 at src/codec/simpchinese.rs:124:17: 146:18
    }

    bb37: {
        StorageDead(_36);                // scope 4 at src/codec/simpchinese.rs:147:13: 147:14
        goto -> bb38;                    // scope 4 at src/codec/simpchinese.rs:120:20: 147:14
    }

    bb38: {
        StorageDead(_30);                // scope 4 at src/codec/simpchinese.rs:147:13: 147:14
        goto -> bb39;                    // scope 4 at src/codec/simpchinese.rs:118:13: 147:14
    }

    bb39: {
        StorageDead(_24);                // scope 4 at src/codec/simpchinese.rs:147:13: 147:14
        StorageDead(_23);                // scope 4 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_22);                // scope 2 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_21);                // scope 2 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_20);                // scope 2 at src/codec/simpchinese.rs:148:9: 148:10
        StorageDead(_13);                // scope 1 at src/codec/simpchinese.rs:148:9: 148:10
        goto -> bb5;                     // scope 1 at src/codec/simpchinese.rs:117:9: 148:10
    }

    bb40: {
        StorageDead(_115);               // scope 0 at src/codec/simpchinese.rs:149:20: 149:21
        StorageLive(_116);               // scope 0 at src/codec/simpchinese.rs:149:23: 149:27
        discriminant(_116) = 0;          // scope 0 at src/codec/simpchinese.rs:149:23: 149:27
        (_0.0: usize) = move _114;       // scope 0 at src/codec/simpchinese.rs:149:9: 149:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _116; // scope 0 at src/codec/simpchinese.rs:149:9: 149:28
        StorageDead(_116);               // scope 0 at src/codec/simpchinese.rs:149:27: 149:28
        StorageDead(_114);               // scope 0 at src/codec/simpchinese.rs:149:27: 149:28
        goto -> bb41;                    // scope 0 at src/codec/simpchinese.rs:150:6: 150:6
    }

    bb41: {
        return;                          // scope 0 at src/codec/simpchinese.rs:150:6: 150:6
    }
}

fn codec::error::<impl at src/codec/error.rs:53:1: 68:2>::from_self(_1: &ErrorDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:54:18: 54:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/error.rs:54:28: 54:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/error.rs:54:46: 54:65
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/error.rs:54:46: 54:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/error.rs:54:46: 54:65
        StorageLive(_3);                 // scope 0 at src/codec/error.rs:54:46: 54:65
        _3 = ErrorDecoder::new() -> bb1; // scope 0 at src/codec/error.rs:54:46: 54:65
                                         // mir::Constant
                                         // + span: src/codec/error.rs:54:46: 54:63
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::error::ErrorDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:54:46: 54:65
        StorageDead(_3);                 // scope 0 at src/codec/error.rs:54:64: 54:65
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:54:46: 54:65
        StorageDead(_2);                 // scope 0 at src/codec/error.rs:54:66: 54:67
        return;                          // scope 0 at src/codec/error.rs:54:67: 54:67
    }
}

fn korean::<impl at src/codec/korean.rs:42:1: 70:2>::from_self(_1: &Windows949Encoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:43:18: 43:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/korean.rs:43:28: 43:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/korean.rs:43:46: 43:70
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/korean.rs:43:46: 43:70

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:43:46: 43:70
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:43:46: 43:70
        _3 = Windows949Encoder::new() -> bb1; // scope 0 at src/codec/korean.rs:43:46: 43:70
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:43:46: 43:68
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::korean::Windows949Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:43:46: 43:70
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:43:69: 43:70
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:43:46: 43:70
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:43:71: 43:72
        return;                          // scope 0 at src/codec/korean.rs:43:72: 43:72
    }
}

const REPLACEMENT: &EncoderOnlyUTF8Encoding = {
    let mut _0: &codec::whatwg::EncoderOnlyUTF8Encoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const REPLACEMENT::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::whatwg::EncoderOnlyUTF8Encoding
                                         // + val: Unevaluated(REPLACEMENT, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::whatwg::EncoderOnlyUTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1290 ~ encoding[5d2c]::all::whatwg::REPLACEMENT), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in REPLACEMENT: &EncoderOnlyUTF8Encoding = {
    let mut _0: &codec::whatwg::EncoderOnlyUTF8Encoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::whatwg::EncoderOnlyUTF8Encoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:39:1: 67:2>::raw_finish(_1: &mut SingleByteEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:64:19: 64:28
    debug _output => _2;                 // in scope 0 at src/codec/singlebyte.rs:64:30: 64:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/singlebyte.rs:64:59: 64:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/singlebyte.rs:65:9: 65:13
        return;                          // scope 0 at src/codec/singlebyte.rs:66:6: 66:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:452:1: 457:2>::name(_1: &Windows31JEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:453:13: 453:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/japanese.rs:453:23: 453:35

    bb0: {
        _0 = const "windows-31j";        // scope 0 at src/codec/japanese.rs:453:38: 453:51
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 51, 49, 106], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:453:38: 453:51
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 51, 49, 106], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        return;                          // scope 0 at src/codec/japanese.rs:453:53: 453:53
    }
}

fn simpchinese::gb18030::<impl at src/util.rs:157:22: 157:31>::ne(_1: &simpchinese::gb18030::State, _2: &simpchinese::gb18030::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::simpchinese::gb18030::State, &codec::simpchinese::gb18030::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _24: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _26: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _27: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _28: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _29: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _36: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _37: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _38: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _39: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _40: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _41: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _42: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _43: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _44: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _45: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _54: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _55: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _56: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _57: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _58: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _59: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _60: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _61: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _62: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _63: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _64: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _65: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _66: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _67: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _22: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _23: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _30: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _31: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _32: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _33: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _34: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _35: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _46: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _47: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _48: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _49: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _50: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _51: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _52: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _53: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _20;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _21;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _22;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _23;  // in scope 3 at src/util.rs:164:32: 164:35
            }
            scope 4 {
                debug __self_0 => _30;   // in scope 4 at src/util.rs:164:25: 164:27
                debug __self_1 => _31;   // in scope 4 at src/util.rs:164:32: 164:35
                debug __self_2 => _32;   // in scope 4 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _33;  // in scope 4 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _34;  // in scope 4 at src/util.rs:164:32: 164:35
                debug __arg_1_2 => _35;  // in scope 4 at src/util.rs:164:32: 164:35
            }
            scope 5 {
                debug __self_0 => _46;   // in scope 5 at src/util.rs:164:25: 164:27
                debug __self_1 => _47;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __self_2 => _48;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __self_3 => _49;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _50;  // in scope 5 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _51;  // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_2 => _52;  // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_3 => _53;  // in scope 5 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb31, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::simpchinese::gb18030::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::simpchinese::gb18030::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _19 = discriminant((*(_13.0: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb6, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::simpchinese::gb18030::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb19, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 2 at src/util.rs:164:25: 164:27
        _22 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 2 at src/util.rs:164:32: 164:35
        _23 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_25);                // scope 3 at src/util.rs:164:25: 164:27
        _25 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_26);                // scope 3 at src/util.rs:164:25: 164:27
        _26 = _22;                       // scope 3 at src/util.rs:164:25: 164:27
        _24 = <() as PartialEq>::ne(move _25, move _26) -> bb10; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        _0 = const true;                 // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb9;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb8: {
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_28);                // scope 3 at src/util.rs:164:32: 164:35
        _28 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_29);                // scope 3 at src/util.rs:164:32: 164:35
        _29 = (*_23);                    // scope 3 at src/util.rs:164:32: 164:35
        _27 = Ne(move _28, move _29);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_29);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_28);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _27;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb9;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_24);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_23);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_22);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb10: {
        StorageDead(_26);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_25);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _24) -> [false: bb8, otherwise: bb7]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb11: {
        StorageLive(_30);                // scope 2 at src/util.rs:164:25: 164:27
        _30 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_31);                // scope 2 at src/util.rs:164:32: 164:35
        _31 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_32);                // scope 2 at src/util.rs:164:32: 164:35
        _32 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S2).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_33);                // scope 2 at src/util.rs:164:25: 164:27
        _33 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_34);                // scope 2 at src/util.rs:164:32: 164:35
        _34 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_35);                // scope 2 at src/util.rs:164:32: 164:35
        _35 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S2).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_36);                // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_37);                // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_38);                // scope 4 at src/util.rs:164:25: 164:27
        _38 = _30;                       // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_39);                // scope 4 at src/util.rs:164:25: 164:27
        _39 = _33;                       // scope 4 at src/util.rs:164:25: 164:27
        _37 = <() as PartialEq>::ne(move _38, move _39) -> bb18; // scope 4 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        _0 = const true;                 // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb13: {
        StorageLive(_43);                // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_44);                // scope 4 at src/util.rs:164:32: 164:35
        _44 = (*_32);                    // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_45);                // scope 4 at src/util.rs:164:32: 164:35
        _45 = (*_35);                    // scope 4 at src/util.rs:164:32: 164:35
        _43 = Ne(move _44, move _45);    // scope 4 at src/util.rs:164:32: 164:35
        StorageDead(_45);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_44);                // scope 4 at src/util.rs:164:34: 164:35
        _0 = move _43;                   // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb14: {
        StorageDead(_43);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_36);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_35);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_34);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_33);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_32);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_31);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb15: {
        _36 = const true;                // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb17;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb16: {
        StorageLive(_40);                // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_41);                // scope 4 at src/util.rs:164:32: 164:35
        _41 = (*_31);                    // scope 4 at src/util.rs:164:32: 164:35
        StorageLive(_42);                // scope 4 at src/util.rs:164:32: 164:35
        _42 = (*_34);                    // scope 4 at src/util.rs:164:32: 164:35
        _40 = Ne(move _41, move _42);    // scope 4 at src/util.rs:164:32: 164:35
        StorageDead(_42);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_41);                // scope 4 at src/util.rs:164:34: 164:35
        _36 = move _40;                  // scope 4 at src/util.rs:164:32: 164:35
        goto -> bb17;                    // scope 4 at src/util.rs:164:32: 164:35
    }

    bb17: {
        StorageDead(_40);                // scope 4 at src/util.rs:164:34: 164:35
        StorageDead(_37);                // scope 4 at src/util.rs:164:34: 164:35
        switchInt(move _36) -> [false: bb13, otherwise: bb12]; // scope 4 at src/util.rs:164:32: 164:35
    }

    bb18: {
        StorageDead(_39);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_38);                // scope 4 at src/util.rs:164:26: 164:27
        switchInt(move _37) -> [false: bb16, otherwise: bb15]; // scope 4 at src/util.rs:164:32: 164:35
    }

    bb19: {
        StorageLive(_46);                // scope 2 at src/util.rs:164:25: 164:27
        _46 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_47);                // scope 2 at src/util.rs:164:32: 164:35
        _47 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_48);                // scope 2 at src/util.rs:164:32: 164:35
        _48 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_49);                // scope 2 at src/util.rs:164:32: 164:35
        _49 = &(((*(_13.0: &codec::simpchinese::gb18030::State)) as S3).3: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_50);                // scope 2 at src/util.rs:164:25: 164:27
        _50 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_51);                // scope 2 at src/util.rs:164:32: 164:35
        _51 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_52);                // scope 2 at src/util.rs:164:32: 164:35
        _52 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).2: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_53);                // scope 2 at src/util.rs:164:32: 164:35
        _53 = &(((*(_13.1: &codec::simpchinese::gb18030::State)) as S3).3: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_54);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_55);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_56);                // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_57);                // scope 5 at src/util.rs:164:25: 164:27
        _57 = _46;                       // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_58);                // scope 5 at src/util.rs:164:25: 164:27
        _58 = _50;                       // scope 5 at src/util.rs:164:25: 164:27
        _56 = <() as PartialEq>::ne(move _57, move _58) -> bb29; // scope 5 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        _0 = const true;                 // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb22;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb21: {
        StorageLive(_65);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_66);                // scope 5 at src/util.rs:164:32: 164:35
        _66 = (*_49);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_67);                // scope 5 at src/util.rs:164:32: 164:35
        _67 = (*_53);                    // scope 5 at src/util.rs:164:32: 164:35
        _65 = Ne(move _66, move _67);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_67);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_66);                // scope 5 at src/util.rs:164:34: 164:35
        _0 = move _65;                   // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb22;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb22: {
        StorageDead(_65);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_54);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_53);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_52);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_51);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_50);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_49);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_48);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_47);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_46);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb30;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb23: {
        _54 = const true;                // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb25;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb24: {
        StorageLive(_62);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_63);                // scope 5 at src/util.rs:164:32: 164:35
        _63 = (*_48);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_64);                // scope 5 at src/util.rs:164:32: 164:35
        _64 = (*_52);                    // scope 5 at src/util.rs:164:32: 164:35
        _62 = Ne(move _63, move _64);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_64);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_63);                // scope 5 at src/util.rs:164:34: 164:35
        _54 = move _62;                  // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb25;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb25: {
        StorageDead(_62);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_55);                // scope 5 at src/util.rs:164:34: 164:35
        switchInt(move _54) -> [false: bb21, otherwise: bb20]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb26: {
        _55 = const true;                // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb28;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb27: {
        StorageLive(_59);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_60);                // scope 5 at src/util.rs:164:32: 164:35
        _60 = (*_47);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_61);                // scope 5 at src/util.rs:164:32: 164:35
        _61 = (*_51);                    // scope 5 at src/util.rs:164:32: 164:35
        _59 = Ne(move _60, move _61);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_61);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_60);                // scope 5 at src/util.rs:164:34: 164:35
        _55 = move _59;                  // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb28;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb28: {
        StorageDead(_59);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_56);                // scope 5 at src/util.rs:164:34: 164:35
        switchInt(move _55) -> [false: bb24, otherwise: bb23]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb29: {
        StorageDead(_58);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_57);                // scope 5 at src/util.rs:164:26: 164:27
        switchInt(move _56) -> [false: bb27, otherwise: bb26]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb30: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb32;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb31: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb32;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb32: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn utf_8::from_utf8(_1: &[u8]) -> Option<&str> {
    debug input => _1;                   // in scope 0 at src/codec/utf_8.rs:214:22: 214:27
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/utf_8.rs:214:42: 214:57
    let mut _2: std::slice::Iter<u8>;    // in scope 0 at src/codec/utf_8.rs:215:9: 215:17
    let mut _3: &[u8];                   // in scope 0 at src/codec/utf_8.rs:215:20: 215:25
    let mut _5: std::option::Option<&u8>; // in scope 0 at src/codec/utf_8.rs:222:15: 222:26
    let mut _6: &mut std::slice::Iter<u8>; // in scope 0 at src/codec/utf_8.rs:222:15: 222:19
    let mut _7: isize;                   // in scope 0 at src/codec/utf_8.rs:223:13: 223:22
    let mut _10: bool;                   // in scope 0 at src/codec/utf_8.rs:223:26: 223:35
    let mut _11: u8;                     // in scope 0 at src/codec/utf_8.rs:223:26: 223:28
    let mut _13: u8;                     // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _14: &[u8; 110];             // in scope 0 at src/codec/utf_8.rs:138:5: 138:22
    let _15: usize;                      // in scope 0 at src/codec/utf_8.rs:138:23: 138:70
    let mut _16: u8;                     // in scope 0 at src/codec/utf_8.rs:138:23: 138:61
    let mut _17: u8;                     // in scope 0 at src/codec/utf_8.rs:225:37: 225:50
    let mut _18: u8;                     // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _19: &[u8; 256];             // in scope 0 at src/codec/utf_8.rs:138:33: 138:46
    let _20: usize;                      // in scope 0 at src/codec/utf_8.rs:138:47: 138:59
    let mut _21: u8;                     // in scope 0 at src/codec/utf_8.rs:225:52: 225:54
    let mut _22: usize;                  // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _23: bool;                   // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _24: usize;                  // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _25: bool;                   // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _26: &str;                   // in scope 0 at src/codec/utf_8.rs:218:53: 218:83
    let mut _27: &[u8];                  // in scope 0 at src/codec/utf_8.rs:218:76: 218:81
    let mut _28: std::slice::Iter<u8>;   // in scope 0 at src/codec/utf_8.rs:232:16: 232:20
    let mut _29: std::slice::Iter<u8>;   // in scope 0 at src/codec/utf_8.rs:232:16: 232:20
    let mut _32: std::option::Option<&u8>; // in scope 0 at src/codec/utf_8.rs:232:16: 232:20
    let mut _33: &mut std::slice::Iter<u8>; // in scope 0 at src/codec/utf_8.rs:232:16: 232:20
    let mut _34: &mut std::slice::Iter<u8>; // in scope 0 at src/codec/utf_8.rs:232:16: 232:20
    let mut _35: isize;                  // in scope 0 at src/codec/utf_8.rs:232:9: 232:12
    let mut _37: &u8;                    // in scope 0 at src/codec/utf_8.rs:232:9: 232:12
    let mut _39: u8;                     // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _40: &[u8; 110];             // in scope 0 at src/codec/utf_8.rs:138:5: 138:22
    let _41: usize;                      // in scope 0 at src/codec/utf_8.rs:138:23: 138:70
    let mut _42: u8;                     // in scope 0 at src/codec/utf_8.rs:138:23: 138:61
    let mut _43: u8;                     // in scope 0 at src/codec/utf_8.rs:233:29: 233:34
    let mut _44: u8;                     // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _45: &[u8; 256];             // in scope 0 at src/codec/utf_8.rs:138:33: 138:46
    let _46: usize;                      // in scope 0 at src/codec/utf_8.rs:138:47: 138:59
    let mut _47: u8;                     // in scope 0 at src/codec/utf_8.rs:233:36: 233:38
    let mut _48: usize;                  // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _49: bool;                   // in scope 0 at src/codec/utf_8.rs:138:33: 138:60
    let mut _50: usize;                  // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _51: bool;                   // in scope 0 at src/codec/utf_8.rs:138:5: 138:71
    let mut _52: bool;                   // in scope 0 at src/codec/utf_8.rs:136:48: 136:82
    let mut _53: u8;                     // in scope 0 at src/codec/utf_8.rs:234:29: 234:34
    let mut _54: u8;                     // in scope 0 at src/codec/utf_8.rs:136:58: 136:82
    let mut _55: bool;                   // in scope 0 at src/codec/utf_8.rs:236:8: 236:29
    let mut _56: u8;                     // in scope 0 at src/codec/utf_8.rs:236:8: 236:13
    let mut _57: u8;                     // in scope 0 at src/codec/utf_8.rs:236:17: 236:29
    let mut _58: &str;                   // in scope 0 at src/codec/utf_8.rs:218:53: 218:83
    let mut _59: &[u8];                  // in scope 0 at src/codec/utf_8.rs:218:76: 218:81
    scope 1 {
        debug iter => _2;                // in scope 1 at src/codec/utf_8.rs:215:9: 215:17
        let mut _4: u8;                  // in scope 1 at src/codec/utf_8.rs:216:9: 216:18
        scope 2 {
            debug state => _4;           // in scope 2 at src/codec/utf_8.rs:216:9: 216:18
            let _8: u8;                  // in scope 2 at src/codec/utf_8.rs:223:19: 223:21
            let _9: &u8;                 // in scope 2 at src/codec/utf_8.rs:223:19: 223:21
            let _12: u8;                 // in scope 2 at src/codec/utf_8.rs:224:19: 224:21
            let mut _30: std::slice::Iter<u8>; // in scope 2 at src/codec/utf_8.rs:232:16: 232:20
            scope 3 {
                debug ch => _8;          // in scope 3 at src/codec/utf_8.rs:223:19: 223:21
                debug ch => _9;          // in scope 3 at src/codec/utf_8.rs:223:19: 223:21
            }
            scope 4 {
                debug ch => _12;         // in scope 4 at src/codec/utf_8.rs:224:19: 224:21
            }
            scope 5 {
            }
            scope 6 {
                debug iter => _30;       // in scope 6 at src/codec/utf_8.rs:232:16: 232:20
                let mut _31: &u8;        // in scope 6 at src/codec/utf_8.rs:232:16: 232:20
                scope 7 {
                    debug __next => _31; // in scope 7 at src/codec/utf_8.rs:232:16: 232:20
                    let _36: &u8;        // in scope 7 at src/codec/utf_8.rs:232:9: 232:12
                    let _38: u8;         // in scope 7 at src/codec/utf_8.rs:232:10: 232:12
                    scope 8 {
                        debug val => _36; // in scope 8 at src/codec/utf_8.rs:232:9: 232:12
                    }
                    scope 9 {
                        debug ch => _38; // in scope 9 at src/codec/utf_8.rs:232:10: 232:12
                    }
                }
            }
            scope 10 {
            }
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:215:9: 215:17
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:215:20: 215:25
        _3 = _1;                         // scope 0 at src/codec/utf_8.rs:215:20: 215:25
        _2 = core::slice::<impl [u8]>::iter(move _3) -> bb1; // scope 0 at src/codec/utf_8.rs:215:20: 215:32
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:215:26: 215:30
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> std::slice::Iter<'r, u8> {core::slice::<impl [u8]>::iter}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:215:31: 215:32
        StorageLive(_4);                 // scope 1 at src/codec/utf_8.rs:216:9: 216:18
        goto -> bb2;                     // scope 2 at src/codec/utf_8.rs:221:5: 230:6
    }

    bb2: {
        StorageLive(_5);                 // scope 2 at src/codec/utf_8.rs:222:15: 222:26
        StorageLive(_6);                 // scope 2 at src/codec/utf_8.rs:222:15: 222:19
        _6 = &mut _2;                    // scope 2 at src/codec/utf_8.rs:222:15: 222:19
        _5 = <std::slice::Iter<u8> as Iterator>::next(move _6) -> bb3; // scope 2 at src/codec/utf_8.rs:222:15: 222:26
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:222:20: 222:24
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::slice::Iter<u8>) -> std::option::Option<<std::slice::Iter<u8> as std::iter::Iterator>::Item> {<std::slice::Iter<u8> as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_6);                 // scope 2 at src/codec/utf_8.rs:222:25: 222:26
        _7 = discriminant(_5);           // scope 2 at src/codec/utf_8.rs:222:15: 222:26
        switchInt(move _7) -> [0_isize: bb4, 1_isize: bb6, otherwise: bb5]; // scope 2 at src/codec/utf_8.rs:222:9: 222:26
    }

    bb4: {
        StorageLive(_26);                // scope 2 at src/codec/utf_8.rs:218:53: 218:83
        StorageLive(_27);                // scope 5 at src/codec/utf_8.rs:218:76: 218:81
        _27 = _1;                        // scope 5 at src/codec/utf_8.rs:218:76: 218:81
        _26 = transmute::<&[u8], &str>(move _27) -> bb11; // scope 5 at src/codec/utf_8.rs:218:61: 218:82
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:218:61: 218:75
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(&[u8]) -> &str {std::intrinsics::transmute::<&[u8], &str>}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        unreachable;                     // scope 2 at src/codec/utf_8.rs:222:15: 222:26
    }

    bb6: {
        StorageLive(_9);                 // scope 2 at src/codec/utf_8.rs:223:19: 223:21
        _9 = ((_5 as Some).0: &u8);      // scope 2 at src/codec/utf_8.rs:223:19: 223:21
        StorageLive(_10);                // scope 2 at src/codec/utf_8.rs:223:26: 223:35
        StorageLive(_11);                // scope 2 at src/codec/utf_8.rs:223:26: 223:28
        _11 = (*_9);                     // scope 2 at src/codec/utf_8.rs:223:26: 223:28
        _10 = Lt(move _11, const 128_u8); // scope 2 at src/codec/utf_8.rs:223:26: 223:35
        switchInt(move _10) -> [false: bb8, otherwise: bb7]; // scope 2 at src/codec/utf_8.rs:223:26: 223:35
    }

    bb7: {
        StorageDead(_11);                // scope 2 at src/codec/utf_8.rs:223:34: 223:35
        StorageDead(_10);                // scope 2 at src/codec/utf_8.rs:223:34: 223:35
        StorageLive(_8);                 // scope 2 at src/codec/utf_8.rs:223:19: 223:21
        _8 = (*((_5 as Some).0: &u8));   // scope 2 at src/codec/utf_8.rs:223:19: 223:21
        StorageDead(_8);                 // scope 2 at src/codec/utf_8.rs:223:40: 223:41
        StorageDead(_9);                 // scope 2 at src/codec/utf_8.rs:223:40: 223:41
        StorageDead(_5);                 // scope 2 at src/codec/utf_8.rs:230:5: 230:6
        goto -> bb2;                     // scope 2 at src/codec/utf_8.rs:221:5: 230:6
    }

    bb8: {
        StorageDead(_11);                // scope 2 at src/codec/utf_8.rs:223:34: 223:35
        StorageDead(_10);                // scope 2 at src/codec/utf_8.rs:223:34: 223:35
        StorageDead(_9);                 // scope 2 at src/codec/utf_8.rs:223:40: 223:41
        StorageLive(_12);                // scope 2 at src/codec/utf_8.rs:224:19: 224:21
        _12 = (*((_5 as Some).0: &u8));  // scope 2 at src/codec/utf_8.rs:224:19: 224:21
        StorageLive(_13);                // scope 4 at src/codec/utf_8.rs:138:5: 138:71
        StorageLive(_14);                // scope 4 at src/codec/utf_8.rs:138:5: 138:22
        _14 = const <static(DefId(0:258 ~ encoding[5d2c]::codec::utf_8::STATE_TRANSITIONS))>; // scope 4 at src/codec/utf_8.rs:138:5: 138:22
                                         // ty::Const
                                         // + ty: &[u8; 110]
                                         // + val: Value(Scalar(alloc2))
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:138:5: 138:22
                                         // + literal: Const { ty: &[u8; 110], val: Value(Scalar(alloc2)) }
        StorageLive(_15);                // scope 4 at src/codec/utf_8.rs:138:23: 138:70
        StorageLive(_16);                // scope 4 at src/codec/utf_8.rs:138:23: 138:61
        StorageLive(_17);                // scope 4 at src/codec/utf_8.rs:225:37: 225:50
        _17 = const 0_u8;                // scope 4 at src/codec/utf_8.rs:225:37: 225:50
        StorageLive(_18);                // scope 4 at src/codec/utf_8.rs:138:33: 138:60
        StorageLive(_19);                // scope 4 at src/codec/utf_8.rs:138:33: 138:46
        _19 = const <static(DefId(0:256 ~ encoding[5d2c]::codec::utf_8::CHAR_CATEGORY))>; // scope 4 at src/codec/utf_8.rs:138:33: 138:46
                                         // ty::Const
                                         // + ty: &[u8; 256]
                                         // + val: Value(Scalar(alloc3))
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:138:33: 138:46
                                         // + literal: Const { ty: &[u8; 256], val: Value(Scalar(alloc3)) }
        StorageLive(_20);                // scope 4 at src/codec/utf_8.rs:138:47: 138:59
        StorageLive(_21);                // scope 4 at src/codec/utf_8.rs:225:52: 225:54
        _21 = _12;                       // scope 4 at src/codec/utf_8.rs:225:52: 225:54
        _20 = move _21 as usize (Misc);  // scope 4 at src/codec/utf_8.rs:138:47: 138:59
        StorageDead(_21);                // scope 4 at src/codec/utf_8.rs:138:58: 138:59
        _22 = const 256_usize;           // scope 4 at src/codec/utf_8.rs:138:33: 138:60
        _23 = Lt(_20, _22);              // scope 4 at src/codec/utf_8.rs:138:33: 138:60
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _20) -> bb9; // scope 4 at src/codec/utf_8.rs:138:33: 138:60
    }

    bb9: {
        _18 = (*_19)[_20];               // scope 4 at src/codec/utf_8.rs:138:33: 138:60
        _16 = Add(move _17, move _18);   // scope 4 at src/codec/utf_8.rs:138:23: 138:61
        StorageDead(_18);                // scope 4 at src/codec/utf_8.rs:138:60: 138:61
        StorageDead(_17);                // scope 4 at src/codec/utf_8.rs:138:60: 138:61
        _15 = move _16 as usize (Misc);  // scope 4 at src/codec/utf_8.rs:138:23: 138:70
        StorageDead(_16);                // scope 4 at src/codec/utf_8.rs:138:69: 138:70
        _24 = const 110_usize;           // scope 4 at src/codec/utf_8.rs:138:5: 138:71
        _25 = Lt(_15, _24);              // scope 4 at src/codec/utf_8.rs:138:5: 138:71
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _15) -> bb10; // scope 4 at src/codec/utf_8.rs:138:5: 138:71
    }

    bb10: {
        _13 = (*_14)[_15];               // scope 4 at src/codec/utf_8.rs:138:5: 138:71
        _4 = move _13;                   // scope 4 at src/codec/utf_8.rs:225:17: 225:55
        StorageDead(_13);                // scope 4 at src/codec/utf_8.rs:225:54: 225:55
        StorageDead(_20);                // scope 4 at src/codec/utf_8.rs:225:55: 225:56
        StorageDead(_19);                // scope 4 at src/codec/utf_8.rs:225:55: 225:56
        StorageDead(_15);                // scope 4 at src/codec/utf_8.rs:225:55: 225:56
        StorageDead(_14);                // scope 4 at src/codec/utf_8.rs:225:55: 225:56
        StorageDead(_12);                // scope 2 at src/codec/utf_8.rs:227:13: 227:14
        StorageDead(_5);                 // scope 2 at src/codec/utf_8.rs:230:5: 230:6
        StorageLive(_28);                // scope 2 at src/codec/utf_8.rs:232:16: 232:20
        StorageLive(_29);                // scope 2 at src/codec/utf_8.rs:232:16: 232:20
        _29 = move _2;                   // scope 2 at src/codec/utf_8.rs:232:16: 232:20
        _28 = <std::slice::Iter<u8> as IntoIterator>::into_iter(move _29) -> bb12; // scope 2 at src/codec/utf_8.rs:232:16: 232:20
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:232:16: 232:20
                                         // + literal: Const { ty: fn(std::slice::Iter<u8>) -> <std::slice::Iter<u8> as std::iter::IntoIterator>::IntoIter {<std::slice::Iter<u8> as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_27);                // scope 5 at src/codec/utf_8.rs:218:81: 218:82
        ((_0 as Some).0: &str) = move _26; // scope 2 at src/codec/utf_8.rs:218:48: 218:84
        discriminant(_0) = 1;            // scope 2 at src/codec/utf_8.rs:218:48: 218:84
        StorageDead(_26);                // scope 2 at src/codec/utf_8.rs:218:83: 218:84
        StorageDead(_5);                 // scope 2 at src/codec/utf_8.rs:230:5: 230:6
        goto -> bb25;                    // scope 2 at no-location
    }

    bb12: {
        StorageDead(_29);                // scope 2 at src/codec/utf_8.rs:232:19: 232:20
        StorageLive(_30);                // scope 2 at src/codec/utf_8.rs:232:16: 232:20
        _30 = move _28;                  // scope 2 at src/codec/utf_8.rs:232:16: 232:20
        goto -> bb13;                    // scope 6 at src/codec/utf_8.rs:232:5: 235:6
    }

    bb13: {
        StorageLive(_31);                // scope 6 at src/codec/utf_8.rs:232:16: 232:20
        StorageLive(_32);                // scope 7 at src/codec/utf_8.rs:232:16: 232:20
        StorageLive(_33);                // scope 7 at src/codec/utf_8.rs:232:16: 232:20
        StorageLive(_34);                // scope 7 at src/codec/utf_8.rs:232:16: 232:20
        _34 = &mut _30;                  // scope 7 at src/codec/utf_8.rs:232:16: 232:20
        _33 = &mut (*_34);               // scope 7 at src/codec/utf_8.rs:232:16: 232:20
        _32 = <std::slice::Iter<u8> as Iterator>::next(move _33) -> bb14; // scope 7 at src/codec/utf_8.rs:232:16: 232:20
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:232:16: 232:20
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::slice::Iter<u8>) -> std::option::Option<<std::slice::Iter<u8> as std::iter::Iterator>::Item> {<std::slice::Iter<u8> as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_33);                // scope 7 at src/codec/utf_8.rs:232:19: 232:20
        _35 = discriminant(_32);         // scope 7 at src/codec/utf_8.rs:232:16: 232:20
        switchInt(move _35) -> [0_isize: bb15, 1_isize: bb17, otherwise: bb16]; // scope 7 at src/codec/utf_8.rs:232:16: 232:20
    }

    bb15: {
        StorageDead(_34);                // scope 7 at src/codec/utf_8.rs:232:19: 232:20
        StorageDead(_32);                // scope 7 at src/codec/utf_8.rs:232:19: 232:20
        StorageDead(_31);                // scope 6 at src/codec/utf_8.rs:235:5: 235:6
        StorageDead(_30);                // scope 2 at src/codec/utf_8.rs:235:5: 235:6
        StorageDead(_28);                // scope 2 at src/codec/utf_8.rs:232:19: 232:20
        StorageLive(_55);                // scope 2 at src/codec/utf_8.rs:236:8: 236:29
        StorageLive(_56);                // scope 2 at src/codec/utf_8.rs:236:8: 236:13
        _56 = _4;                        // scope 2 at src/codec/utf_8.rs:236:8: 236:13
        StorageLive(_57);                // scope 2 at src/codec/utf_8.rs:236:17: 236:29
        _57 = const 0_u8;                // scope 2 at src/codec/utf_8.rs:236:17: 236:29
        _55 = Ne(move _56, move _57);    // scope 2 at src/codec/utf_8.rs:236:8: 236:29
        StorageDead(_57);                // scope 2 at src/codec/utf_8.rs:236:28: 236:29
        StorageDead(_56);                // scope 2 at src/codec/utf_8.rs:236:28: 236:29
        switchInt(move _55) -> [false: bb23, otherwise: bb22]; // scope 2 at src/codec/utf_8.rs:236:8: 236:29
    }

    bb16: {
        unreachable;                     // scope 7 at src/codec/utf_8.rs:232:16: 232:20
    }

    bb17: {
        StorageLive(_36);                // scope 7 at src/codec/utf_8.rs:232:9: 232:12
        _36 = ((_32 as Some).0: &u8);    // scope 7 at src/codec/utf_8.rs:232:9: 232:12
        StorageLive(_37);                // scope 8 at src/codec/utf_8.rs:232:9: 232:12
        _37 = _36;                       // scope 8 at src/codec/utf_8.rs:232:9: 232:12
        _31 = move _37;                  // scope 8 at src/codec/utf_8.rs:232:9: 232:12
        StorageDead(_37);                // scope 8 at src/codec/utf_8.rs:232:11: 232:12
        StorageDead(_36);                // scope 7 at src/codec/utf_8.rs:232:11: 232:12
        StorageDead(_34);                // scope 7 at src/codec/utf_8.rs:232:19: 232:20
        StorageDead(_32);                // scope 7 at src/codec/utf_8.rs:232:19: 232:20
        StorageLive(_38);                // scope 7 at src/codec/utf_8.rs:232:10: 232:12
        _38 = (*_31);                    // scope 7 at src/codec/utf_8.rs:232:10: 232:12
        StorageLive(_39);                // scope 9 at src/codec/utf_8.rs:138:5: 138:71
        StorageLive(_40);                // scope 9 at src/codec/utf_8.rs:138:5: 138:22
        _40 = const <static(DefId(0:258 ~ encoding[5d2c]::codec::utf_8::STATE_TRANSITIONS))>; // scope 9 at src/codec/utf_8.rs:138:5: 138:22
                                         // ty::Const
                                         // + ty: &[u8; 110]
                                         // + val: Value(Scalar(alloc2))
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:138:5: 138:22
                                         // + literal: Const { ty: &[u8; 110], val: Value(Scalar(alloc2)) }
        StorageLive(_41);                // scope 9 at src/codec/utf_8.rs:138:23: 138:70
        StorageLive(_42);                // scope 9 at src/codec/utf_8.rs:138:23: 138:61
        StorageLive(_43);                // scope 9 at src/codec/utf_8.rs:233:29: 233:34
        _43 = _4;                        // scope 9 at src/codec/utf_8.rs:233:29: 233:34
        StorageLive(_44);                // scope 9 at src/codec/utf_8.rs:138:33: 138:60
        StorageLive(_45);                // scope 9 at src/codec/utf_8.rs:138:33: 138:46
        _45 = const <static(DefId(0:256 ~ encoding[5d2c]::codec::utf_8::CHAR_CATEGORY))>; // scope 9 at src/codec/utf_8.rs:138:33: 138:46
                                         // ty::Const
                                         // + ty: &[u8; 256]
                                         // + val: Value(Scalar(alloc3))
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:138:33: 138:46
                                         // + literal: Const { ty: &[u8; 256], val: Value(Scalar(alloc3)) }
        StorageLive(_46);                // scope 9 at src/codec/utf_8.rs:138:47: 138:59
        StorageLive(_47);                // scope 9 at src/codec/utf_8.rs:233:36: 233:38
        _47 = _38;                       // scope 9 at src/codec/utf_8.rs:233:36: 233:38
        _46 = move _47 as usize (Misc);  // scope 9 at src/codec/utf_8.rs:138:47: 138:59
        StorageDead(_47);                // scope 9 at src/codec/utf_8.rs:138:58: 138:59
        _48 = const 256_usize;           // scope 9 at src/codec/utf_8.rs:138:33: 138:60
        _49 = Lt(_46, _48);              // scope 9 at src/codec/utf_8.rs:138:33: 138:60
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _46) -> bb18; // scope 9 at src/codec/utf_8.rs:138:33: 138:60
    }

    bb18: {
        _44 = (*_45)[_46];               // scope 9 at src/codec/utf_8.rs:138:33: 138:60
        _42 = Add(move _43, move _44);   // scope 9 at src/codec/utf_8.rs:138:23: 138:61
        StorageDead(_44);                // scope 9 at src/codec/utf_8.rs:138:60: 138:61
        StorageDead(_43);                // scope 9 at src/codec/utf_8.rs:138:60: 138:61
        _41 = move _42 as usize (Misc);  // scope 9 at src/codec/utf_8.rs:138:23: 138:70
        StorageDead(_42);                // scope 9 at src/codec/utf_8.rs:138:69: 138:70
        _50 = const 110_usize;           // scope 9 at src/codec/utf_8.rs:138:5: 138:71
        _51 = Lt(_41, _50);              // scope 9 at src/codec/utf_8.rs:138:5: 138:71
        assert(move _51, "index out of bounds: the length is {} but the index is {}", move _50, _41) -> bb19; // scope 9 at src/codec/utf_8.rs:138:5: 138:71
    }

    bb19: {
        _39 = (*_40)[_41];               // scope 9 at src/codec/utf_8.rs:138:5: 138:71
        _4 = move _39;                   // scope 9 at src/codec/utf_8.rs:233:9: 233:39
        StorageDead(_39);                // scope 9 at src/codec/utf_8.rs:233:38: 233:39
        StorageDead(_46);                // scope 9 at src/codec/utf_8.rs:233:39: 233:40
        StorageDead(_45);                // scope 9 at src/codec/utf_8.rs:233:39: 233:40
        StorageDead(_41);                // scope 9 at src/codec/utf_8.rs:233:39: 233:40
        StorageDead(_40);                // scope 9 at src/codec/utf_8.rs:233:39: 233:40
        StorageLive(_52);                // scope 9 at src/codec/utf_8.rs:136:48: 136:82
        StorageLive(_53);                // scope 9 at src/codec/utf_8.rs:234:29: 234:34
        _53 = _4;                        // scope 9 at src/codec/utf_8.rs:234:29: 234:34
        StorageLive(_54);                // scope 9 at src/codec/utf_8.rs:136:58: 136:82
        _54 = const 86_u8;               // scope 9 at src/codec/utf_8.rs:136:58: 136:82
        _52 = Ge(move _53, move _54);    // scope 9 at src/codec/utf_8.rs:136:48: 136:82
        StorageDead(_54);                // scope 9 at src/codec/utf_8.rs:136:81: 136:82
        StorageDead(_53);                // scope 9 at src/codec/utf_8.rs:136:81: 136:82
        switchInt(move _52) -> [false: bb21, otherwise: bb20]; // scope 9 at src/codec/utf_8.rs:136:48: 136:82
    }

    bb20: {
        discriminant(_0) = 0;            // scope 9 at src/codec/utf_8.rs:234:45: 234:49
        StorageDead(_52);                // scope 9 at src/codec/utf_8.rs:234:51: 234:52
        StorageDead(_38);                // scope 7 at src/codec/utf_8.rs:235:5: 235:6
        StorageDead(_31);                // scope 6 at src/codec/utf_8.rs:235:5: 235:6
        StorageDead(_30);                // scope 2 at src/codec/utf_8.rs:235:5: 235:6
        StorageDead(_28);                // scope 2 at src/codec/utf_8.rs:232:19: 232:20
        goto -> bb25;                    // scope 2 at no-location
    }

    bb21: {
        StorageDead(_52);                // scope 9 at src/codec/utf_8.rs:234:51: 234:52
        StorageDead(_38);                // scope 7 at src/codec/utf_8.rs:235:5: 235:6
        StorageDead(_31);                // scope 6 at src/codec/utf_8.rs:235:5: 235:6
        goto -> bb13;                    // scope 6 at src/codec/utf_8.rs:232:5: 235:6
    }

    bb22: {
        discriminant(_0) = 0;            // scope 2 at src/codec/utf_8.rs:236:39: 236:43
        StorageDead(_55);                // scope 2 at src/codec/utf_8.rs:236:45: 236:46
        goto -> bb25;                    // scope 2 at no-location
    }

    bb23: {
        StorageDead(_55);                // scope 2 at src/codec/utf_8.rs:236:45: 236:46
        StorageLive(_58);                // scope 2 at src/codec/utf_8.rs:218:53: 218:83
        StorageLive(_59);                // scope 10 at src/codec/utf_8.rs:218:76: 218:81
        _59 = _1;                        // scope 10 at src/codec/utf_8.rs:218:76: 218:81
        _58 = transmute::<&[u8], &str>(move _59) -> bb24; // scope 10 at src/codec/utf_8.rs:218:61: 218:82
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:218:61: 218:75
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(&[u8]) -> &str {std::intrinsics::transmute::<&[u8], &str>}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_59);                // scope 10 at src/codec/utf_8.rs:218:81: 218:82
        ((_0 as Some).0: &str) = move _58; // scope 2 at src/codec/utf_8.rs:218:48: 218:84
        discriminant(_0) = 1;            // scope 2 at src/codec/utf_8.rs:218:48: 218:84
        StorageDead(_58);                // scope 2 at src/codec/utf_8.rs:218:83: 218:84
        goto -> bb25;                    // scope 2 at src/codec/utf_8.rs:218:41: 218:84
    }

    bb25: {
        StorageDead(_4);                 // scope 1 at src/codec/utf_8.rs:238:1: 238:2
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:238:1: 238:2
        return;                          // scope 0 at src/codec/utf_8.rs:238:2: 238:2
    }
}

alloc3 (static: CHAR_CATEGORY, size: 256, align: 1) {
    0x000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x080  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................
    0x090  09 09 09 09 09 09 09 09 09 09 09 09 09 09 09 09  ................
    0x0a0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................
    0x0b0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................
    0x0c0  08 08 02 02 02 02 02 02 02 02 02 02 02 02 02 02  ................
    0x0d0  02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02  ................
    0x0e0  0a 03 03 03 03 03 03 03 03 03 03 03 03 04 03 03  ................
    0x0f0  0b 06 06 06 05 08 08 08 08 08 08 08 08 08 08 08  ................
}

alloc2 (static: STATE_TRANSITIONS, size: 110, align: 1) {
    0x00  00 62 0c 18 30 54 48 62 62 62 24 3c 56 00 56 56  .b..0THbbb$<V.VV
    0x10  56 56 56 00 56 00 56 56 56 0c 56 56 56 56 56 0c  VVV.V.VVV.VVVVV.
    0x20  56 0c 56 56 56 56 56 56 56 56 56 0c 56 56 56 56  V.VVVVVVVVV.VVVV
    0x30  56 0c 56 56 56 56 56 56 56 0c 56 56 56 56 56 56  V.VVVVVVV.VVVVVV
    0x40  56 56 56 18 56 18 56 56 56 18 56 56 56 56 56 18  VVV.V.VVV.VVVVV.
    0x50  56 18 56 56 56 18 56 56 56 56 56 56 56 56 56 56  V.VVV.VVVVVVVVVV
    0x60  56 56 62 62 62 62 62 62 62 62 62 62 62 62        VVbbbbbbbbbbbb
}

fn simpchinese::<impl at src/codec/simpchinese.rs:40:1: 45:2>::name(_1: &GB18030Encoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:41:13: 41:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/simpchinese.rs:41:23: 41:35

    bb0: {
        _0 = const "gb18030";            // scope 0 at src/codec/simpchinese.rs:41:38: 41:47
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 49, 56, 48, 51, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:41:38: 41:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 49, 56, 48, 51, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
        return;                          // scope 0 at src/codec/simpchinese.rs:41:49: 41:49
    }
}

fn eucjp::<impl at src/util.rs:168:13: 170:14>::default() -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:294:1: 302:2>::raw_feed::{closure#0}(_1: &[closure@src/codec/utf_16.rs:297:44: 297:93], _2: u16, _3: u8) -> u16 {
    debug lead => _2;                    // in scope 0 at src/codec/utf_16.rs:297:45: 297:49
    debug trail => _3;                   // in scope 0 at src/codec/utf_16.rs:297:56: 297:61
    let mut _0: u16;                     // return place in scope 0 at src/codec/utf_16.rs:297:67: 297:67
    let mut _4: u16;                     // in scope 0 at src/codec/utf_16.rs:297:67: 297:78
    let mut _5: u16;                     // in scope 0 at src/codec/utf_16.rs:297:68: 297:72
    let mut _6: u16;                     // in scope 0 at src/codec/utf_16.rs:297:81: 297:93
    let mut _7: u8;                      // in scope 0 at src/codec/utf_16.rs:297:81: 297:86

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:297:67: 297:78
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:297:68: 297:72
        _5 = _2;                         // scope 0 at src/codec/utf_16.rs:297:68: 297:72
        _4 = Shl(move _5, const 8_i32);  // scope 0 at src/codec/utf_16.rs:297:67: 297:78
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:297:77: 297:78
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:297:81: 297:93
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:297:81: 297:86
        _7 = _3;                         // scope 0 at src/codec/utf_16.rs:297:81: 297:86
        _6 = move _7 as u16 (Misc);      // scope 0 at src/codec/utf_16.rs:297:81: 297:93
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:297:92: 297:93
        _0 = BitOr(move _4, move _6);    // scope 0 at src/codec/utf_16.rs:297:67: 297:93
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:297:92: 297:93
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:297:92: 297:93
        return;                          // scope 0 at src/codec/utf_16.rs:297:93: 297:93
    }
}

fn eucjp::State::S4(_1: (), _2: u8) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S4).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S4).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 4;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn eucjp::State::S4(_1: (), _2: u8) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S4).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S4).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 4;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:69:1: 97:2>::raw_finish(_1: &mut ASCIIDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:94:19: 94:28
    debug _output => _2;                 // in scope 0 at src/codec/ascii.rs:94:30: 94:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/ascii.rs:94:61: 94:79

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/ascii.rs:95:9: 95:13
        return;                          // scope 0 at src/codec/ascii.rs:96:6: 96:6
    }
}

fn windows31j::<impl at src/util.rs:157:22: 157:31>::ne(_1: &windows31j::State, _2: &windows31j::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::japanese::windows31j::State, &codec::japanese::windows31j::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::japanese::windows31j::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _26: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _27: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _18: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _19: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _18;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _19;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _20;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _21;  // in scope 3 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb10, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::japanese::windows31j::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::japanese::windows31j::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _17 = discriminant((*(_13.0: &codec::japanese::windows31j::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [1_isize: bb3, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::japanese::windows31j::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb4, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        StorageLive(_18);                // scope 2 at src/util.rs:164:25: 164:27
        _18 = &(((*(_13.0: &codec::japanese::windows31j::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_19);                // scope 2 at src/util.rs:164:32: 164:35
        _19 = &(((*(_13.0: &codec::japanese::windows31j::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.1: &codec::japanese::windows31j::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.1: &codec::japanese::windows31j::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _18;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        _22 = <() as PartialEq>::ne(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        _0 = const true;                 // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb6: {
        StorageLive(_25);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_26);                // scope 3 at src/util.rs:164:32: 164:35
        _26 = (*_19);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        _27 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        _25 = Ne(move _26, move _27);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_26);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _25;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb7: {
        StorageDead(_25);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_22);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_19);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_18);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:30: 157:31
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _22) -> [false: bb6, otherwise: bb5]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:64:1: 78:2>::from_self(_1: &UTF8Encoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:65:18: 65:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_8.rs:65:28: 65:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_8.rs:65:46: 65:64
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_8.rs:65:46: 65:64

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:65:46: 65:64
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:65:46: 65:64
        _3 = UTF8Encoder::new() -> bb1;  // scope 0 at src/codec/utf_8.rs:65:46: 65:64
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:65:46: 65:62
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::utf_8::UTF8Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:65:46: 65:64
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:65:63: 65:64
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:65:46: 65:64
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:65:65: 65:66
        return;                          // scope 0 at src/codec/utf_8.rs:65:66: 65:66
    }
}

const WINDOWS_1256: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:65:68: 65:82
    let _5: &str;                        // in scope 0 at src/all.rs:65:68: 65:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1256::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1256, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1273 ~ encoding[5d2c]::all::WINDOWS_1256), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1256: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:65:68: 65:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:65:68: 65:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1256";       // scope 0 at src/all.rs:65:68: 65:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:65:68: 65:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:65:68: 65:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1256::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1256::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1256::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1256::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1256"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:65:68: 65:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:165:1: 180:2>::raw_finish(_1: &mut GB18030Decoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:175:19: 175:28
    debug output => _2;                  // in scope 0 at src/codec/simpchinese.rs:175:30: 175:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/simpchinese.rs:176:18: 176:21
    let _3: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:176:14: 176:16
    let mut _4: (codec::simpchinese::gb18030::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/simpchinese.rs:176:25: 176:66
    let mut _5: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:176:45: 176:52
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:176:54: 176:60
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:176:54: 176:60
    let mut _8: &();                     // in scope 0 at src/codec/simpchinese.rs:176:62: 176:65
    let _9: &();                         // in scope 0 at src/codec/simpchinese.rs:176:62: 176:65
    let mut _10: codec::simpchinese::gb18030::State; // in scope 0 at src/codec/simpchinese.rs:177:19: 177:21
    let mut _11: &();                    // in scope 0 at src/codec/simpchinese.rs:176:62: 176:65
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/simpchinese.rs:176:14: 176:16
        debug err => _0;                 // in scope 1 at src/codec/simpchinese.rs:176:18: 176:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:176:25: 176:66
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:176:45: 176:52
        _5 = ((*_1).0: codec::simpchinese::gb18030::State); // scope 0 at src/codec/simpchinese.rs:176:45: 176:52
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:176:54: 176:60
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:176:54: 176:60
        _7 = &mut (*_2);                 // scope 0 at src/codec/simpchinese.rs:176:54: 176:60
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:176:54: 176:60
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:176:59: 176:60
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
        StorageLive(_9);                 // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
        _11 = const <GB18030Decoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<GB18030Decoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:176:62: 176:65
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:493 ~ encoding[5d2c]::codec::simpchinese::{impl#8}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
        _8 = _9;                         // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
        _4 = simpchinese::gb18030::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/simpchinese.rs:176:25: 176:66
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:176:25: 176:44
                                         // + literal: Const { ty: for<'r, 's> fn(codec::simpchinese::gb18030::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::simpchinese::gb18030::State, std::option::Option<encoding_types::CodecError>) {codec::simpchinese::gb18030::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:176:65: 176:66
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:176:65: 176:66
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:176:65: 176:66
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:176:14: 176:16
        _3 = (_4.0: codec::simpchinese::gb18030::State); // scope 0 at src/codec/simpchinese.rs:176:14: 176:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/simpchinese.rs:176:18: 176:21
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:176:66: 176:67
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:176:66: 176:67
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:177:19: 177:21
        _10 = _3;                        // scope 1 at src/codec/simpchinese.rs:177:19: 177:21
        ((*_1).0: codec::simpchinese::gb18030::State) = move _10; // scope 1 at src/codec/simpchinese.rs:177:9: 177:21
        StorageDead(_10);                // scope 1 at src/codec/simpchinese.rs:177:20: 177:21
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:179:5: 179:6
        return;                          // scope 0 at src/codec/simpchinese.rs:179:6: 179:6
    }
}

promoted[0] in simpchinese::<impl at src/codec/simpchinese.rs:165:1: 180:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/simpchinese.rs:176:62: 176:65
    let mut _1: ();                      // in scope 0 at src/codec/simpchinese.rs:176:63: 176:65

    bb0: {
        nop;                             // scope 0 at src/codec/simpchinese.rs:176:63: 176:65
        _0 = &_1;                        // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
        return;                          // scope 0 at src/codec/simpchinese.rs:176:62: 176:65
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:38:10: 38:15>::clone(_1: &BigFive2003Encoder) -> BigFive2003Encoder {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:38:10: 38:15
    let mut _0: codec::tradchinese::BigFive2003Encoder; // return place in scope 0 at src/codec/tradchinese.rs:38:10: 38:15

    bb0: {
        return;                          // scope 0 at src/codec/tradchinese.rs:38:15: 38:15
    }
}

fn korean::<impl at src/codec/korean.rs:84:1: 99:2>::from_self(_1: &Windows949Decoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:85:18: 85:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/korean.rs:85:28: 85:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/korean.rs:85:46: 85:70
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/korean.rs:85:46: 85:70

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:85:46: 85:70
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:85:46: 85:70
        _3 = Windows949Decoder::new() -> bb1; // scope 0 at src/codec/korean.rs:85:46: 85:70
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:85:46: 85:68
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::korean::Windows949Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:85:46: 85:70
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:85:69: 85:70
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:85:46: 85:70
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:85:71: 85:72
        return;                          // scope 0 at src/codec/korean.rs:85:72: 85:72
    }
}

fn simpchinese::gb18030::internal::map_two_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/simpchinese.rs:185:35: 185:39
    debug trail => _2;                   // in scope 0 at src/codec/simpchinese.rs:185:45: 185:50
    let mut _0: u32;                     // return place in scope 0 at src/codec/simpchinese.rs:185:59: 185:62
    let _3: u16;                         // in scope 0 at src/codec/simpchinese.rs:188:13: 188:17
    let mut _4: u8;                      // in scope 0 at src/codec/simpchinese.rs:188:20: 188:24
    let mut _6: u8;                      // in scope 0 at src/codec/simpchinese.rs:189:21: 189:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/simpchinese.rs:190:27: 190:40
    let mut _9: u16;                     // in scope 0 at src/codec/simpchinese.rs:190:28: 190:32
    let mut _10: u16;                    // in scope 0 at src/codec/simpchinese.rs:190:34: 190:39
    let mut _11: bool;                   // in scope 0 at src/codec/simpchinese.rs:191:56: 191:67
    let mut _12: bool;                   // in scope 0 at src/codec/simpchinese.rs:191:56: 191:67
    let mut _13: bool;                   // in scope 0 at src/codec/simpchinese.rs:191:27: 191:38
    let mut _14: bool;                   // in scope 0 at src/codec/simpchinese.rs:191:27: 191:38
    let mut _15: bool;                   // in scope 0 at src/codec/simpchinese.rs:191:14: 191:25
    let mut _16: bool;                   // in scope 0 at src/codec/simpchinese.rs:191:14: 191:25
    let mut _18: bool;                   // in scope 0 at src/codec/simpchinese.rs:192:38: 192:50
    let mut _19: u16;                    // in scope 0 at src/codec/simpchinese.rs:192:38: 192:43
    let mut _20: u16;                    // in scope 0 at src/codec/simpchinese.rs:193:17: 193:44
    let mut _21: u16;                    // in scope 0 at src/codec/simpchinese.rs:193:17: 193:36
    let mut _22: u16;                    // in scope 0 at src/codec/simpchinese.rs:193:17: 193:30
    let mut _23: u16;                    // in scope 0 at src/codec/simpchinese.rs:193:18: 193:22
    let mut _24: u16;                    // in scope 0 at src/codec/simpchinese.rs:193:39: 193:44
    let mut _25: u16;                    // in scope 0 at src/codec/simpchinese.rs:193:47: 193:58
    let mut _26: u16;                    // in scope 0 at src/codec/simpchinese.rs:197:33: 197:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/simpchinese.rs:188:13: 188:17
        let _5: u16;                     // in scope 1 at src/codec/simpchinese.rs:189:13: 189:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/simpchinese.rs:189:13: 189:18
            let _7: u16;                 // in scope 2 at src/codec/simpchinese.rs:190:13: 190:18
            let _17: u16;                // in scope 2 at src/codec/simpchinese.rs:192:21: 192:32
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/simpchinese.rs:190:13: 190:18
            }
            scope 4 {
                debug trailoffset => _17; // in scope 4 at src/codec/simpchinese.rs:192:21: 192:32
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:188:13: 188:17
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:188:20: 188:24
        _4 = _1;                         // scope 0 at src/codec/simpchinese.rs:188:20: 188:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/simpchinese.rs:188:20: 188:31
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:188:30: 188:31
        StorageLive(_5);                 // scope 1 at src/codec/simpchinese.rs:189:13: 189:18
        StorageLive(_6);                 // scope 1 at src/codec/simpchinese.rs:189:21: 189:26
        _6 = _2;                         // scope 1 at src/codec/simpchinese.rs:189:21: 189:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/simpchinese.rs:189:21: 189:33
        StorageDead(_6);                 // scope 1 at src/codec/simpchinese.rs:189:32: 189:33
        StorageLive(_7);                 // scope 2 at src/codec/simpchinese.rs:190:13: 190:18
        StorageLive(_8);                 // scope 2 at src/codec/simpchinese.rs:190:27: 190:40
        StorageLive(_9);                 // scope 2 at src/codec/simpchinese.rs:190:28: 190:32
        _9 = _3;                         // scope 2 at src/codec/simpchinese.rs:190:28: 190:32
        StorageLive(_10);                // scope 2 at src/codec/simpchinese.rs:190:34: 190:39
        _10 = _5;                        // scope 2 at src/codec/simpchinese.rs:190:34: 190:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/simpchinese.rs:190:27: 190:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/simpchinese.rs:190:27: 190:40
        StorageDead(_10);                // scope 2 at src/codec/simpchinese.rs:190:39: 190:40
        StorageDead(_9);                 // scope 2 at src/codec/simpchinese.rs:190:39: 190:40
        _15 = Le(const 129_u16, (_8.0: u16)); // scope 2 at src/codec/simpchinese.rs:191:14: 191:25
        switchInt(move _15) -> [false: bb6, otherwise: bb1]; // scope 2 at src/codec/simpchinese.rs:191:14: 191:25
    }

    bb1: {
        _16 = Le((_8.0: u16), const 254_u16); // scope 2 at src/codec/simpchinese.rs:191:14: 191:25
        switchInt(move _16) -> [false: bb6, otherwise: bb2]; // scope 2 at src/codec/simpchinese.rs:191:14: 191:25
    }

    bb2: {
        _13 = Le(const 64_u16, (_8.1: u16)); // scope 2 at src/codec/simpchinese.rs:191:27: 191:38
        switchInt(move _13) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/simpchinese.rs:191:27: 191:38
    }

    bb3: {
        _14 = Le((_8.1: u16), const 126_u16); // scope 2 at src/codec/simpchinese.rs:191:27: 191:38
        switchInt(move _14) -> [false: bb4, otherwise: bb7]; // scope 2 at src/codec/simpchinese.rs:191:27: 191:38
    }

    bb4: {
        _11 = Le(const 128_u16, (_8.1: u16)); // scope 2 at src/codec/simpchinese.rs:191:56: 191:67
        switchInt(move _11) -> [false: bb6, otherwise: bb5]; // scope 2 at src/codec/simpchinese.rs:191:56: 191:67
    }

    bb5: {
        _12 = Le((_8.1: u16), const 254_u16); // scope 2 at src/codec/simpchinese.rs:191:56: 191:67
        switchInt(move _12) -> [false: bb6, otherwise: bb7]; // scope 2 at src/codec/simpchinese.rs:191:56: 191:67
    }

    bb6: {
        _7 = const u16::MAX;             // scope 2 at src/codec/simpchinese.rs:195:18: 195:24
        goto -> bb11;                    // scope 2 at src/codec/simpchinese.rs:195:18: 195:24
    }

    bb7: {
        StorageLive(_17);                // scope 2 at src/codec/simpchinese.rs:192:21: 192:32
        StorageLive(_18);                // scope 2 at src/codec/simpchinese.rs:192:38: 192:50
        StorageLive(_19);                // scope 2 at src/codec/simpchinese.rs:192:38: 192:43
        _19 = _5;                        // scope 2 at src/codec/simpchinese.rs:192:38: 192:43
        _18 = Lt(move _19, const 127_u16); // scope 2 at src/codec/simpchinese.rs:192:38: 192:50
        StorageDead(_19);                // scope 2 at src/codec/simpchinese.rs:192:49: 192:50
        switchInt(move _18) -> [false: bb9, otherwise: bb8]; // scope 2 at src/codec/simpchinese.rs:192:38: 192:50
    }

    bb8: {
        _17 = const 64_u16;              // scope 2 at src/codec/simpchinese.rs:192:52: 192:56
        goto -> bb10;                    // scope 2 at src/codec/simpchinese.rs:192:35: 192:69
    }

    bb9: {
        _17 = const 65_u16;              // scope 2 at src/codec/simpchinese.rs:192:64: 192:68
        goto -> bb10;                    // scope 2 at src/codec/simpchinese.rs:192:35: 192:69
    }

    bb10: {
        StorageDead(_18);                // scope 2 at src/codec/simpchinese.rs:192:68: 192:69
        StorageLive(_20);                // scope 4 at src/codec/simpchinese.rs:193:17: 193:44
        StorageLive(_21);                // scope 4 at src/codec/simpchinese.rs:193:17: 193:36
        StorageLive(_22);                // scope 4 at src/codec/simpchinese.rs:193:17: 193:30
        StorageLive(_23);                // scope 4 at src/codec/simpchinese.rs:193:18: 193:22
        _23 = _3;                        // scope 4 at src/codec/simpchinese.rs:193:18: 193:22
        _22 = Sub(move _23, const 129_u16); // scope 4 at src/codec/simpchinese.rs:193:17: 193:30
        StorageDead(_23);                // scope 4 at src/codec/simpchinese.rs:193:29: 193:30
        _21 = Mul(move _22, const 190_u16); // scope 4 at src/codec/simpchinese.rs:193:17: 193:36
        StorageDead(_22);                // scope 4 at src/codec/simpchinese.rs:193:35: 193:36
        StorageLive(_24);                // scope 4 at src/codec/simpchinese.rs:193:39: 193:44
        _24 = _5;                        // scope 4 at src/codec/simpchinese.rs:193:39: 193:44
        _20 = Add(move _21, move _24);   // scope 4 at src/codec/simpchinese.rs:193:17: 193:44
        StorageDead(_24);                // scope 4 at src/codec/simpchinese.rs:193:43: 193:44
        StorageDead(_21);                // scope 4 at src/codec/simpchinese.rs:193:43: 193:44
        StorageLive(_25);                // scope 4 at src/codec/simpchinese.rs:193:47: 193:58
        _25 = _17;                       // scope 4 at src/codec/simpchinese.rs:193:47: 193:58
        _7 = Sub(move _20, move _25);    // scope 4 at src/codec/simpchinese.rs:193:17: 193:58
        StorageDead(_25);                // scope 4 at src/codec/simpchinese.rs:193:57: 193:58
        StorageDead(_20);                // scope 4 at src/codec/simpchinese.rs:193:57: 193:58
        StorageDead(_17);                // scope 2 at src/codec/simpchinese.rs:194:13: 194:14
        goto -> bb11;                    // scope 2 at src/codec/simpchinese.rs:194:13: 194:14
    }

    bb11: {
        StorageDead(_8);                 // scope 2 at src/codec/simpchinese.rs:196:10: 196:11
        StorageLive(_26);                // scope 3 at src/codec/simpchinese.rs:197:33: 197:38
        _26 = _7;                        // scope 3 at src/codec/simpchinese.rs:197:33: 197:38
        _0 = index_simpchinese::gb18030::forward(move _26) -> bb12; // scope 3 at src/codec/simpchinese.rs:197:9: 197:39
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:197:9: 197:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_simpchinese::gb18030::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_26);                // scope 3 at src/codec/simpchinese.rs:197:38: 197:39
        StorageDead(_7);                 // scope 2 at src/codec/simpchinese.rs:198:5: 198:6
        StorageDead(_5);                 // scope 1 at src/codec/simpchinese.rs:198:5: 198:6
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:198:5: 198:6
        return;                          // scope 0 at src/codec/simpchinese.rs:198:6: 198:6
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:81:1: 111:2>::raw_finish(_1: &mut SingleByteDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:108:19: 108:28
    debug _output => _2;                 // in scope 0 at src/codec/singlebyte.rs:108:30: 108:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/singlebyte.rs:108:61: 108:79

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/singlebyte.rs:109:9: 109:13
        return;                          // scope 0 at src/codec/singlebyte.rs:110:6: 110:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:467:1: 506:2>::from_self(_1: &Windows31JEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:468:18: 468:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:468:28: 468:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:468:46: 468:70
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:468:46: 468:70

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:468:46: 468:70
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:468:46: 468:70
        _3 = Windows31JEncoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:468:46: 468:70
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:468:46: 468:68
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::japanese::Windows31JEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:468:46: 468:70
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:468:69: 468:70
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:468:46: 468:70
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:468:71: 468:72
        return;                          // scope 0 at src/codec/japanese.rs:468:72: 468:72
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:462:10: 462:15>::clone(_1: &HZEncoding) -> HZEncoding {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:462:10: 462:15
    let mut _0: codec::simpchinese::HZEncoding; // return place in scope 0 at src/codec/simpchinese.rs:462:10: 462:15

    bb0: {
        return;                          // scope 0 at src/codec/simpchinese.rs:462:15: 462:15
    }
}

const IBM866: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:41:56: 41:64
    let _5: &str;                        // in scope 0 at src/all.rs:41:56: 41:64
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const IBM866::promoted[0];  // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(IBM866, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1249 ~ encoding[5d2c]::all::IBM866), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in IBM866: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:41:56: 41:64
    let mut _4: &str;                    // in scope 0 at src/all.rs:41:56: 41:64
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "ibm866";             // scope 0 at src/all.rs:41:56: 41:64
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/all.rs:41:56: 41:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:41:56: 41:64
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::ibm866::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::ibm866::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::ibm866::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::ibm866::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "ibm866";   // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/all.rs:41:56: 41:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 98, 109, 56, 54, 54], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:55:1: 62:2>::from_self(_1: &GB18030Encoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:56:18: 56:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:56:28: 56:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:56:46: 56:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:56:46: 56:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:56:46: 56:67
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:56:46: 56:67
        _3 = GB18030Encoder::new() -> bb1; // scope 0 at src/codec/simpchinese.rs:56:46: 56:67
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:56:46: 56:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::simpchinese::GB18030Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:56:46: 56:67
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:56:66: 56:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:56:46: 56:67
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:56:68: 56:69
        return;                          // scope 0 at src/codec/simpchinese.rs:56:69: 56:69
    }
}

fn iso2022jp::raw_finish(_1: iso2022jp::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (iso2022jp::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::japanese::iso2022jp::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:914:18: 914:21
    let mut _20: &util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:923:18: 923:21
    let mut _22: &util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:931:18: 931:21
    let mut _24: &util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:939:18: 939:21
    let mut _26: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:949:18: 949:21
    let mut _28: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:958:18: 958:21
    let mut _30: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:967:18: 967:21
    let mut _32: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:975:18: 975:21
    let mut _35: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:986:18: 986:21
    let mut _38: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:997:18: 997:21
    let mut _39: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _40: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _41: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _42: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::japanese::iso2022jp::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:281:57: 281:63
        let _21: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:281:57: 281:63
        let _23: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:281:57: 281:63
        let _25: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _27: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _29: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _31: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _33: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _36: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug ctx => _19;            // in scope 4 at src/util.rs:281:57: 281:63
        }
        scope 5 {
            debug ctx => _21;            // in scope 5 at src/util.rs:281:57: 281:63
        }
        scope 6 {
            debug ctx => _23;            // in scope 6 at src/util.rs:281:57: 281:63
        }
        scope 7 {
            debug ctx => _25;            // in scope 7 at src/util.rs:284:53: 284:57
        }
        scope 8 {
            debug ctx => _27;            // in scope 8 at src/util.rs:284:53: 284:57
        }
        scope 9 {
            debug ctx => _29;            // in scope 9 at src/util.rs:284:53: 284:57
        }
        scope 10 {
            debug ctx => _31;            // in scope 10 at src/util.rs:284:53: 284:57
        }
        scope 11 {
            debug lead => _33;           // in scope 11 at src/util.rs:284:36: 284:40
            let _34: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 11 at src/util.rs:284:53: 284:57
            scope 12 {
                debug ctx => _34;        // in scope 12 at src/util.rs:284:53: 284:57
            }
        }
        scope 13 {
            debug lead => _36;           // in scope 13 at src/util.rs:284:36: 284:40
            let _37: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 13 at src/util.rs:284:53: 284:57
            scope 14 {
                debug ctx => _37;        // in scope 14 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _42 = const iso2022jp::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(iso2022jp::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:981 ~ encoding[5d2c]::codec::japanese::iso2022jp::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _42;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<iso2022jp::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<iso2022jp::State>(move _13, move _15) -> [return: bb2, unwind: bb27]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::japanese::iso2022jp::State, codec::japanese::iso2022jp::State) -> codec::japanese::iso2022jp::State {std::mem::replace::<codec::japanese::iso2022jp::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb7, 2_isize: bb9, 3_isize: bb11, 4_isize: bb13, 5_isize: bb15, 6_isize: bb17, 7_isize: bb19, 8_isize: bb21, 9_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_36);                // scope 1 at src/util.rs:284:36: 284:40
        _36 = ((_12 as Trail0212).1: u8); // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_37);                // scope 13 at src/util.rs:284:53: 284:57
        _37 = &mut _4;                   // scope 13 at src/util.rs:284:60: 284:68
        StorageLive(_38);                // scope 14 at src/codec/japanese.rs:997:18: 997:21
        _38 = &mut (*_37);               // scope 14 at src/codec/japanese.rs:997:18: 997:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _38, const "incomplete sequence") -> [return: bb23, unwind: bb27]; // scope 14 at src/codec/japanese.rs:997:18: 997:48
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:997:22: 997:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:997:26: 997:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/codec/japanese.rs:914:18: 914:21
        _18 = &(*_17);                   // scope 3 at src/codec/japanese.rs:914:18: 914:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::reset(move _18) -> [return: bb6, unwind: bb27]; // scope 3 at src/codec/japanese.rs:914:18: 914:29
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:914:22: 914:27
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/codec/japanese.rs:914:28: 914:29
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb24;                    // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageLive(_19);                // scope 1 at src/util.rs:281:57: 281:63
        _19 = &mut _4;                   // scope 1 at src/util.rs:281:66: 281:74
        StorageLive(_20);                // scope 4 at src/codec/japanese.rs:923:18: 923:21
        _20 = &(*_19);                   // scope 4 at src/codec/japanese.rs:923:18: 923:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::reset(move _20) -> [return: bb8, unwind: bb27]; // scope 4 at src/codec/japanese.rs:923:18: 923:29
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:923:22: 923:27
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_20);                // scope 4 at src/codec/japanese.rs:923:28: 923:29
        StorageDead(_19);                // scope 1 at src/util.rs:281:88: 281:89
        goto -> bb24;                    // scope 1 at src/util.rs:281:88: 281:89
    }

    bb9: {
        StorageLive(_21);                // scope 1 at src/util.rs:281:57: 281:63
        _21 = &mut _4;                   // scope 1 at src/util.rs:281:66: 281:74
        StorageLive(_22);                // scope 5 at src/codec/japanese.rs:931:18: 931:21
        _22 = &(*_21);                   // scope 5 at src/codec/japanese.rs:931:18: 931:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::reset(move _22) -> [return: bb10, unwind: bb27]; // scope 5 at src/codec/japanese.rs:931:18: 931:29
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:931:22: 931:27
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_22);                // scope 5 at src/codec/japanese.rs:931:28: 931:29
        StorageDead(_21);                // scope 1 at src/util.rs:281:88: 281:89
        goto -> bb24;                    // scope 1 at src/util.rs:281:88: 281:89
    }

    bb11: {
        StorageLive(_23);                // scope 1 at src/util.rs:281:57: 281:63
        _23 = &mut _4;                   // scope 1 at src/util.rs:281:66: 281:74
        StorageLive(_24);                // scope 6 at src/codec/japanese.rs:939:18: 939:21
        _24 = &(*_23);                   // scope 6 at src/codec/japanese.rs:939:18: 939:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::reset(move _24) -> [return: bb12, unwind: bb27]; // scope 6 at src/codec/japanese.rs:939:18: 939:29
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:939:22: 939:27
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_24);                // scope 6 at src/codec/japanese.rs:939:28: 939:29
        StorageDead(_23);                // scope 1 at src/util.rs:281:88: 281:89
        goto -> bb24;                    // scope 1 at src/util.rs:281:88: 281:89
    }

    bb13: {
        StorageLive(_25);                // scope 1 at src/util.rs:284:53: 284:57
        _25 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_26);                // scope 7 at src/codec/japanese.rs:949:18: 949:21
        _26 = &mut (*_25);               // scope 7 at src/codec/japanese.rs:949:18: 949:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _26, const "incomplete sequence") -> [return: bb14, unwind: bb27]; // scope 7 at src/codec/japanese.rs:949:18: 949:48
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:949:22: 949:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:949:26: 949:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb14: {
        StorageDead(_26);                // scope 7 at src/codec/japanese.rs:949:47: 949:48
        StorageDead(_25);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb24;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb15: {
        StorageLive(_27);                // scope 1 at src/util.rs:284:53: 284:57
        _27 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_28);                // scope 8 at src/codec/japanese.rs:958:18: 958:21
        _28 = &mut (*_27);               // scope 8 at src/codec/japanese.rs:958:18: 958:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _28, const "incomplete sequence") -> [return: bb16, unwind: bb27]; // scope 8 at src/codec/japanese.rs:958:18: 958:48
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:958:22: 958:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:958:26: 958:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb16: {
        StorageDead(_28);                // scope 8 at src/codec/japanese.rs:958:47: 958:48
        StorageDead(_27);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb24;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb17: {
        StorageLive(_29);                // scope 1 at src/util.rs:284:53: 284:57
        _29 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_30);                // scope 9 at src/codec/japanese.rs:967:18: 967:21
        _30 = &mut (*_29);               // scope 9 at src/codec/japanese.rs:967:18: 967:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _30, const "incomplete sequence") -> [return: bb18, unwind: bb27]; // scope 9 at src/codec/japanese.rs:967:18: 967:48
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:967:22: 967:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:967:26: 967:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb18: {
        StorageDead(_30);                // scope 9 at src/codec/japanese.rs:967:47: 967:48
        StorageDead(_29);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb24;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb19: {
        StorageLive(_31);                // scope 1 at src/util.rs:284:53: 284:57
        _31 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_32);                // scope 10 at src/codec/japanese.rs:975:18: 975:21
        _32 = &mut (*_31);               // scope 10 at src/codec/japanese.rs:975:18: 975:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::backup_and_err(move _32, const 1_usize, const "incomplete sequence") -> [return: bb20, unwind: bb27]; // scope 10 at src/codec/japanese.rs:975:18: 975:62
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:975:22: 975:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, usize, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:975:40: 975:61
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb20: {
        StorageDead(_32);                // scope 10 at src/codec/japanese.rs:975:61: 975:62
        StorageDead(_31);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb24;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb21: {
        StorageLive(_33);                // scope 1 at src/util.rs:284:36: 284:40
        _33 = ((_12 as Trail0208).1: u8); // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_34);                // scope 11 at src/util.rs:284:53: 284:57
        _34 = &mut _4;                   // scope 11 at src/util.rs:284:60: 284:68
        StorageLive(_35);                // scope 12 at src/codec/japanese.rs:986:18: 986:21
        _35 = &mut (*_34);               // scope 12 at src/codec/japanese.rs:986:18: 986:21
        _11 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _35, const "incomplete sequence") -> [return: bb22, unwind: bb27]; // scope 12 at src/codec/japanese.rs:986:18: 986:48
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:986:22: 986:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:986:26: 986:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb22: {
        StorageDead(_35);                // scope 12 at src/codec/japanese.rs:986:47: 986:48
        StorageDead(_34);                // scope 11 at src/util.rs:284:80: 284:81
        StorageDead(_33);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb24;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb23: {
        StorageDead(_38);                // scope 14 at src/codec/japanese.rs:997:47: 997:48
        StorageDead(_37);                // scope 13 at src/util.rs:284:80: 284:81
        StorageDead(_36);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb24;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb24: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_39);                // scope 2 at src/util.rs:287:18: 287:20
        _39 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_40);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_41);                // scope 2 at src/util.rs:287:22: 287:29
        _41 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _40 = Option::<encoding_types::CodecError>::take(move _41) -> [return: bb25, unwind: bb27]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb25: {
        StorageDead(_41);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::japanese::iso2022jp::State) = move _39; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _40; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_40);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_39);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb26;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb26: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb27 (cleanup): {
        drop(_4) -> bb28;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb28 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in iso2022jp::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn iso2022jp::State::EscapeFinal(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeFinal).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 7;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn iso2022jp::State::EscapeFinal(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeFinal).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 7;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn hz::State::A1(_1: ()) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as A1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 2;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn hz::State::A1(_1: ()) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as A1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 2;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn japanese::<impl at src/codec/japanese.rs:32:1: 37:2>::raw_encoder(_1: &EUCJPEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:35:20: 35:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:35:30: 35:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:35:48: 35:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:35:48: 35:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:35:48: 35:67
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:35:48: 35:67
        _3 = EUCJPEncoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:35:48: 35:67
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:35:48: 35:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::japanese::EUCJPEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:35:48: 35:67
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:35:66: 35:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:35:48: 35:67
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:35:68: 35:69
        return;                          // scope 0 at src/codec/japanese.rs:35:69: 35:69
    }
}

fn japanese::<impl at src/codec/japanese.rs:771:10: 771:15>::clone(_1: &ISO2022JPEncoding) -> ISO2022JPEncoding {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:771:10: 771:15
    let mut _0: codec::japanese::ISO2022JPEncoding; // return place in scope 0 at src/codec/japanese.rs:771:10: 771:15

    bb0: {
        return;                          // scope 0 at src/codec/japanese.rs:771:15: 771:15
    }
}

static CHAR_CATEGORY: [u8; 256] = {
    let mut _0: [u8; 256];               // return place in scope 0 at src/codec/utf_8.rs:94:23: 94:32

    bb0: {
        _0 = [const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 0_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 1_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 9_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 7_u8, const 8_u8, const 8_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 2_u8, const 10_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 3_u8, const 4_u8, const 3_u8, const 3_u8, const 11_u8, const 6_u8, const 6_u8, const 6_u8, const 5_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8, const 8_u8]; // scope 0 at src/codec/utf_8.rs:94:35: 116:2
        return;                          // scope 0 at src/codec/utf_8.rs:94:1: 116:3
    }
}

fn japanese::<impl at src/codec/japanese.rs:864:1: 879:2>::raw_feed(_1: &mut ISO2022JPDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:868:17: 868:26
    debug input => _2;                   // in scope 0 at src/codec/japanese.rs:868:28: 868:33
    debug output => _3;                  // in scope 0 at src/codec/japanese.rs:868:42: 868:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/japanese.rs:868:72: 868:99
    let _4: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:869:14: 869:16
    let _5: usize;                       // in scope 0 at src/codec/japanese.rs:869:18: 869:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:869:29: 869:32
    let mut _7: (codec::japanese::iso2022jp::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/japanese.rs:869:36: 869:84
    let mut _8: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:869:56: 869:63
    let mut _9: &[u8];                   // in scope 0 at src/codec/japanese.rs:869:65: 869:70
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:869:72: 869:78
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:869:72: 869:78
    let mut _12: &();                    // in scope 0 at src/codec/japanese.rs:869:80: 869:83
    let _13: &();                        // in scope 0 at src/codec/japanese.rs:869:80: 869:83
    let mut _14: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:870:19: 870:21
    let mut _15: usize;                  // in scope 0 at src/codec/japanese.rs:871:10: 871:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:871:21: 871:24
    let mut _17: &();                    // in scope 0 at src/codec/japanese.rs:869:80: 869:83
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/japanese.rs:869:14: 869:16
        debug processed => _5;           // in scope 1 at src/codec/japanese.rs:869:18: 869:27
        debug err => _6;                 // in scope 1 at src/codec/japanese.rs:869:29: 869:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:869:36: 869:84
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:869:56: 869:63
        _8 = ((*_1).0: codec::japanese::iso2022jp::State); // scope 0 at src/codec/japanese.rs:869:56: 869:63
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:869:65: 869:70
        _9 = _2;                         // scope 0 at src/codec/japanese.rs:869:65: 869:70
        StorageLive(_10);                // scope 0 at src/codec/japanese.rs:869:72: 869:78
        StorageLive(_11);                // scope 0 at src/codec/japanese.rs:869:72: 869:78
        _11 = &mut (*_3);                // scope 0 at src/codec/japanese.rs:869:72: 869:78
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:869:72: 869:78
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:869:77: 869:78
        StorageLive(_12);                // scope 0 at src/codec/japanese.rs:869:80: 869:83
        StorageLive(_13);                // scope 0 at src/codec/japanese.rs:869:80: 869:83
        _17 = const <ISO2022JPDecoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/japanese.rs:869:80: 869:83
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<ISO2022JPDecoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:869:80: 869:83
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:445 ~ encoding[5d2c]::codec::japanese::{impl#14}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/japanese.rs:869:80: 869:83
        _12 = _13;                       // scope 0 at src/codec/japanese.rs:869:80: 869:83
        _7 = iso2022jp::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/japanese.rs:869:36: 869:84
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:869:36: 869:55
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::japanese::iso2022jp::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::japanese::iso2022jp::State, usize, std::option::Option<encoding_types::CodecError>) {codec::japanese::iso2022jp::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/japanese.rs:869:83: 869:84
        StorageDead(_10);                // scope 0 at src/codec/japanese.rs:869:83: 869:84
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:869:83: 869:84
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:869:83: 869:84
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:869:14: 869:16
        _4 = (_7.0: codec::japanese::iso2022jp::State); // scope 0 at src/codec/japanese.rs:869:14: 869:16
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:869:18: 869:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/japanese.rs:869:18: 869:27
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:869:29: 869:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/japanese.rs:869:29: 869:32
        StorageDead(_13);                // scope 0 at src/codec/japanese.rs:869:84: 869:85
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:869:84: 869:85
        StorageLive(_14);                // scope 1 at src/codec/japanese.rs:870:19: 870:21
        _14 = _4;                        // scope 1 at src/codec/japanese.rs:870:19: 870:21
        ((*_1).0: codec::japanese::iso2022jp::State) = move _14; // scope 1 at src/codec/japanese.rs:870:9: 870:21
        StorageDead(_14);                // scope 1 at src/codec/japanese.rs:870:20: 870:21
        StorageLive(_15);                // scope 1 at src/codec/japanese.rs:871:10: 871:19
        _15 = _5;                        // scope 1 at src/codec/japanese.rs:871:10: 871:19
        StorageLive(_16);                // scope 1 at src/codec/japanese.rs:871:21: 871:24
        _16 = move _6;                   // scope 1 at src/codec/japanese.rs:871:21: 871:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/japanese.rs:871:9: 871:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/japanese.rs:871:9: 871:25
        StorageDead(_16);                // scope 1 at src/codec/japanese.rs:871:24: 871:25
        StorageDead(_15);                // scope 1 at src/codec/japanese.rs:871:24: 871:25
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:872:5: 872:6
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:872:5: 872:6
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:872:5: 872:6
        return;                          // scope 0 at src/codec/japanese.rs:872:6: 872:6
    }
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:864:1: 879:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/japanese.rs:869:80: 869:83
    let mut _1: ();                      // in scope 0 at src/codec/japanese.rs:869:81: 869:83

    bb0: {
        nop;                             // scope 0 at src/codec/japanese.rs:869:81: 869:83
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:869:80: 869:83
        return;                          // scope 0 at src/codec/japanese.rs:869:80: 869:83
    }
}

const WINDOWS_949: &Windows949Encoding = {
    let mut _0: &codec::korean::Windows949Encoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const WINDOWS_949::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::korean::Windows949Encoding
                                         // + val: Unevaluated(WINDOWS_949, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::korean::Windows949Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1280 ~ encoding[5d2c]::all::WINDOWS_949), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in WINDOWS_949: &Windows949Encoding = {
    let mut _0: &codec::korean::Windows949Encoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::korean::Windows949Encoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn eucjp::State::S1(_1: ()) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn eucjp::State::S1(_1: ()) -> eucjp::State {
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:478:1: 480:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:479:21: 479:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:479:39: 479:77
    let mut _2: std::boxed::Box<codec::simpchinese::HZEncoder>; // in scope 0 at src/codec/simpchinese.rs:479:39: 479:77
    let mut _3: codec::simpchinese::HZEncoder; // in scope 0 at src/codec/simpchinese.rs:479:48: 479:76

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/simpchinese.rs:479:39: 479:77
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:479:39: 479:77
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:479:48: 479:76
        (_3.0: bool) = const false;      // scope 0 at src/codec/simpchinese.rs:479:48: 479:76
        _2 = Box::<HZEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/simpchinese.rs:479:39: 479:77
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:479:39: 479:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::simpchinese::HZEncoder) -> std::boxed::Box<codec::simpchinese::HZEncoder> {std::boxed::Box::<codec::simpchinese::HZEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:479:39: 479:77
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:479:76: 479:77
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:479:76: 479:77
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:479:39: 479:77
        StorageDead(_1);                 // scope 0 at src/codec/simpchinese.rs:479:78: 479:79
        return;                          // scope 0 at src/codec/simpchinese.rs:479:79: 479:79
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:20:1: 24:2>::raw_decoder(_1: &ASCIIEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:23:20: 23:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/ascii.rs:23:30: 23:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/ascii.rs:23:48: 23:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/ascii.rs:23:48: 23:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/ascii.rs:23:48: 23:67
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:23:48: 23:67
        _3 = ASCIIDecoder::new() -> bb1; // scope 0 at src/codec/ascii.rs:23:48: 23:67
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:23:48: 23:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::ascii::ASCIIDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:23:48: 23:67
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:23:66: 23:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:23:48: 23:67
        StorageDead(_2);                 // scope 0 at src/codec/ascii.rs:23:68: 23:69
        return;                          // scope 0 at src/codec/ascii.rs:23:69: 23:69
    }
}

fn iso2022jp::State::Trail0212(_1: (), _2: u8) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as Trail0212).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as Trail0212).1: u8) = move _2; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 9;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn iso2022jp::State::Trail0212(_1: (), _2: u8) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as Trail0212).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as Trail0212).1: u8) = move _2; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 9;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn codec::whatwg::<impl at src/codec/whatwg.rs:15:1: 20:2>::whatwg_name(_1: &EncoderOnlyUTF8Encoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/whatwg.rs:17:20: 17:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/whatwg.rs:17:30: 17:50
    let mut _2: &str;                    // in scope 0 at src/codec/whatwg.rs:17:58: 17:71
    let _3: &str;                        // in scope 0 at src/codec/whatwg.rs:17:58: 17:71

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/whatwg.rs:17:58: 17:71
        StorageLive(_3);                 // scope 0 at src/codec/whatwg.rs:17:58: 17:71
        _3 = const "replacement";        // scope 0 at src/codec/whatwg.rs:17:58: 17:71
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [114, 101, 112, 108, 97, 99, 101, 109, 101, 110, 116], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/codec/whatwg.rs:17:58: 17:71
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [114, 101, 112, 108, 97, 99, 101, 109, 101, 110, 116], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _2 = _3;                         // scope 0 at src/codec/whatwg.rs:17:58: 17:71
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/whatwg.rs:17:53: 17:72
        discriminant(_0) = 1;            // scope 0 at src/codec/whatwg.rs:17:53: 17:72
        StorageDead(_2);                 // scope 0 at src/codec/whatwg.rs:17:71: 17:72
        StorageDead(_3);                 // scope 0 at src/codec/whatwg.rs:17:73: 17:74
        return;                          // scope 0 at src/codec/whatwg.rs:17:74: 17:74
    }
}

const ISO_8859_7: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:48:64: 48:76
    let _5: &str;                        // in scope 0 at src/all.rs:48:64: 48:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_7::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_7, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1256 ~ encoding[5d2c]::all::ISO_8859_7), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_7: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:48:64: 48:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:48:64: 48:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-7";         // scope 0 at src/all.rs:48:64: 48:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:48:64: 48:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:48:64: 48:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_7::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_7::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_7::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_7::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-7"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:48:64: 48:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:520:1: 535:2>::from_self(_1: &Windows31JDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:521:18: 521:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:521:28: 521:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:521:46: 521:70
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:521:46: 521:70

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:521:46: 521:70
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:521:46: 521:70
        _3 = Windows31JDecoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:521:46: 521:70
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:521:46: 521:68
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::japanese::Windows31JDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:521:46: 521:70
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:521:69: 521:70
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:521:46: 521:70
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:521:71: 521:72
        return;                          // scope 0 at src/codec/japanese.rs:521:72: 521:72
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::new(_1: &[u8], _2: &mut dyn encoding_types::StringWriter, _3: &Data) -> StatefulDecoderHelper<St, Data> {
    debug buf => _1;                     // in scope 0 at src/util.rs:72:16: 72:19
    debug output => _2;                  // in scope 0 at src/util.rs:72:31: 72:37
    debug data => _3;                    // in scope 0 at src/util.rs:73:16: 73:20
    let mut _0: util::StatefulDecoderHelper<St, Data>; // return place in scope 0 at src/util.rs:73:35: 73:70
    let mut _4: &[u8];                   // in scope 0 at src/util.rs:74:38: 74:41
    let mut _5: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:74:59: 74:65
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:74:59: 74:65
    let mut _7: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:74:72: 74:76
    let mut _8: &Data;                   // in scope 0 at src/util.rs:75:39: 75:43

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:74:38: 74:41
        _4 = _1;                         // scope 0 at src/util.rs:74:38: 74:41
        StorageLive(_5);                 // scope 0 at src/util.rs:74:59: 74:65
        StorageLive(_6);                 // scope 0 at src/util.rs:74:59: 74:65
        _6 = &mut (*_2);                 // scope 0 at src/util.rs:74:59: 74:65
        _5 = move _6 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:74:59: 74:65
        StorageDead(_6);                 // scope 0 at src/util.rs:74:64: 74:65
        StorageLive(_7);                 // scope 0 at src/util.rs:74:72: 74:76
        discriminant(_7) = 0;            // scope 0 at src/util.rs:74:72: 74:76
        StorageLive(_8);                 // scope 0 at src/util.rs:75:39: 75:43
        _8 = _3;                         // scope 0 at src/util.rs:75:39: 75:43
        (_0.0: &[u8]) = move _4;         // scope 0 at src/util.rs:74:9: 75:67
        (_0.1: usize) = const 0_usize;   // scope 0 at src/util.rs:74:9: 75:67
        (_0.2: &mut dyn encoding_types::StringWriter) = move _5; // scope 0 at src/util.rs:74:9: 75:67
        (_0.3: std::option::Option<encoding_types::CodecError>) = move _7; // scope 0 at src/util.rs:74:9: 75:67
        (_0.4: &Data) = move _8;         // scope 0 at src/util.rs:74:9: 75:67
        StorageDead(_8);                 // scope 0 at src/util.rs:75:66: 75:67
        StorageDead(_7);                 // scope 0 at src/util.rs:75:66: 75:67
        StorageDead(_5);                 // scope 0 at src/util.rs:75:66: 75:67
        StorageDead(_4);                 // scope 0 at src/util.rs:75:66: 75:67
        return;                          // scope 0 at src/util.rs:76:6: 76:6
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:22:1: 27:2>::raw_encoder(_1: &UTF16LEEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:25:20: 25:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_16.rs:25:30: 25:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:25:48: 25:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:25:48: 25:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:25:48: 25:69
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:25:48: 25:69
        _3 = UTF16LEEncoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:25:48: 25:69
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:25:48: 25:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::utf_16::UTF16LEEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:25:48: 25:69
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:25:68: 25:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:25:48: 25:69
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:25:70: 25:71
        return;                          // scope 0 at src/codec/utf_16.rs:25:71: 25:71
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:84:1: 89:2>::raw_encoder(_1: &GBKEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:87:20: 87:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:87:30: 87:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:87:48: 87:65
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:87:48: 87:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:87:48: 87:65
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:87:48: 87:65
        _3 = GBKEncoder::new() -> bb1;   // scope 0 at src/codec/simpchinese.rs:87:48: 87:65
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:87:48: 87:63
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::simpchinese::GBKEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:87:48: 87:65
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:87:64: 87:65
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:87:48: 87:65
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:87:66: 87:67
        return;                          // scope 0 at src/codec/simpchinese.rs:87:67: 87:67
    }
}

fn codec::error::<impl at src/codec/error.rs:14:1: 18:2>::raw_decoder(_1: &ErrorEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:17:20: 17:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/error.rs:17:30: 17:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/error.rs:17:48: 17:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/error.rs:17:48: 17:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/error.rs:17:48: 17:67
        StorageLive(_3);                 // scope 0 at src/codec/error.rs:17:48: 17:67
        _3 = ErrorDecoder::new() -> bb1; // scope 0 at src/codec/error.rs:17:48: 17:67
                                         // mir::Constant
                                         // + span: src/codec/error.rs:17:48: 17:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::error::ErrorDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:17:48: 17:67
        StorageDead(_3);                 // scope 0 at src/codec/error.rs:17:66: 17:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:17:48: 17:67
        StorageDead(_2);                 // scope 0 at src/codec/error.rs:17:68: 17:69
        return;                          // scope 0 at src/codec/error.rs:17:69: 17:69
    }
}

fn simpchinese::gb18030::State::S1(_1: (), _2: u8) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn simpchinese::gb18030::State::S1(_1: (), _2: u8) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:30:1: 35:2>::whatwg_name(_1: &BigFive2003Encoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:32:20: 32:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/tradchinese.rs:32:30: 32:50
    let mut _2: &str;                    // in scope 0 at src/codec/tradchinese.rs:32:58: 32:64
    let _3: &str;                        // in scope 0 at src/codec/tradchinese.rs:32:58: 32:64

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:32:58: 32:64
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:32:58: 32:64
        _3 = const "big5";               // scope 0 at src/codec/tradchinese.rs:32:58: 32:64
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:32:58: 32:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [98, 105, 103, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
        _2 = _3;                         // scope 0 at src/codec/tradchinese.rs:32:58: 32:64
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/tradchinese.rs:32:53: 32:65
        discriminant(_0) = 1;            // scope 0 at src/codec/tradchinese.rs:32:53: 32:65
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:32:64: 32:65
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:32:66: 32:67
        return;                          // scope 0 at src/codec/tradchinese.rs:32:67: 32:67
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:20:1: 25:2>::name(_1: &SingleByteEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:21:13: 21:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/singlebyte.rs:21:23: 21:35

    bb0: {
        _0 = ((*_1).0: &str);            // scope 0 at src/codec/singlebyte.rs:21:38: 21:47
        return;                          // scope 0 at src/codec/singlebyte.rs:21:49: 21:49
    }
}

fn japanese::<impl at src/codec/japanese.rs:47:1: 84:2>::raw_feed(_1: &mut EUCJPEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:51:17: 51:26
    debug input => _2;                   // in scope 0 at src/codec/japanese.rs:51:28: 51:33
    debug output => _3;                  // in scope 0 at src/codec/japanese.rs:51:41: 51:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/japanese.rs:51:69: 51:96
    let _4: ();                          // in scope 0 at src/codec/japanese.rs:52:9: 52:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:52:9: 52:15
    let mut _6: usize;                   // in scope 0 at src/codec/japanese.rs:52:28: 52:39
    let mut _7: &str;                    // in scope 0 at src/codec/japanese.rs:52:28: 52:33
    let mut _8: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:54:28: 54:46
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:54:28: 54:46
    let mut _10: &&str;                  // in scope 0 at src/codec/japanese.rs:54:28: 54:33
    let mut _11: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:54:28: 54:46
    let mut _13: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/japanese.rs:54:28: 54:46
    let mut _14: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:54:28: 54:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:54:28: 54:46
    let mut _16: isize;                  // in scope 0 at src/codec/japanese.rs:54:13: 54:24
    let mut _18: ((usize, usize), char); // in scope 0 at src/codec/japanese.rs:54:13: 54:24
    let mut _22: bool;                   // in scope 0 at src/codec/japanese.rs:59:17: 59:40
    let mut _23: bool;                   // in scope 0 at src/codec/japanese.rs:59:17: 59:40
    let mut _24: bool;                   // in scope 0 at src/codec/japanese.rs:56:17: 56:35
    let mut _25: bool;                   // in scope 0 at src/codec/japanese.rs:56:17: 56:35
    let _26: ();                         // in scope 0 at src/codec/japanese.rs:56:41: 56:68
    let mut _27: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:56:41: 56:47
    let mut _28: u8;                     // in scope 0 at src/codec/japanese.rs:56:59: 56:67
    let mut _29: char;                   // in scope 0 at src/codec/japanese.rs:56:59: 56:61
    let _30: ();                         // in scope 0 at src/codec/japanese.rs:57:31: 57:54
    let mut _31: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:57:31: 57:37
    let _32: ();                         // in scope 0 at src/codec/japanese.rs:58:33: 58:56
    let mut _33: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:58:33: 58:39
    let _34: ();                         // in scope 0 at src/codec/japanese.rs:60:21: 60:44
    let mut _35: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:60:21: 60:27
    let _36: ();                         // in scope 0 at src/codec/japanese.rs:61:21: 61:75
    let mut _37: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:61:21: 61:27
    let mut _38: u8;                     // in scope 0 at src/codec/japanese.rs:61:39: 61:74
    let mut _39: usize;                  // in scope 0 at src/codec/japanese.rs:61:39: 61:68
    let mut _40: usize;                  // in scope 0 at src/codec/japanese.rs:61:40: 61:60
    let mut _41: usize;                  // in scope 0 at src/codec/japanese.rs:61:40: 61:51
    let mut _42: char;                   // in scope 0 at src/codec/japanese.rs:61:40: 61:42
    let mut _44: u32;                    // in scope 0 at src/codec/japanese.rs:64:56: 64:65
    let mut _45: char;                   // in scope 0 at src/codec/japanese.rs:64:56: 64:58
    let mut _46: u16;                    // in scope 0 at src/codec/japanese.rs:65:24: 65:27
    let mut _47: usize;                  // in scope 0 at src/codec/japanese.rs:66:33: 66:34
    let mut _48: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:66:36: 68:27
    let mut _49: encoding_types::CodecError; // in scope 0 at src/codec/japanese.rs:66:41: 68:26
    let mut _50: isize;                  // in scope 0 at src/codec/japanese.rs:67:35: 67:45
    let mut _51: usize;                  // in scope 0 at src/codec/japanese.rs:67:35: 67:36
    let mut _52: std::borrow::Cow<str>;  // in scope 0 at src/codec/japanese.rs:67:54: 67:88
    let mut _53: &str;                   // in scope 0 at src/codec/japanese.rs:67:54: 67:81
    let _54: &str;                       // in scope 0 at src/codec/japanese.rs:67:54: 67:81
    let mut _56: u16;                    // in scope 0 at src/codec/japanese.rs:70:36: 70:44
    let mut _57: u16;                    // in scope 0 at src/codec/japanese.rs:70:36: 70:39
    let mut _59: u16;                    // in scope 0 at src/codec/japanese.rs:71:37: 71:45
    let mut _60: u16;                    // in scope 0 at src/codec/japanese.rs:71:37: 71:40
    let _61: ();                         // in scope 0 at src/codec/japanese.rs:72:25: 72:54
    let mut _62: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:72:25: 72:31
    let mut _63: u8;                     // in scope 0 at src/codec/japanese.rs:72:43: 72:53
    let mut _64: u16;                    // in scope 0 at src/codec/japanese.rs:72:43: 72:47
    let _65: ();                         // in scope 0 at src/codec/japanese.rs:73:25: 73:55
    let mut _66: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:73:25: 73:31
    let mut _67: u8;                     // in scope 0 at src/codec/japanese.rs:73:43: 73:54
    let mut _68: u16;                    // in scope 0 at src/codec/japanese.rs:73:43: 73:48
    let mut _69: usize;                  // in scope 0 at src/codec/japanese.rs:78:10: 78:21
    let mut _70: &str;                   // in scope 0 at src/codec/japanese.rs:78:10: 78:15
    let mut _71: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:78:23: 78:27
    scope 1 {
        debug iter => _11;               // in scope 1 at src/codec/japanese.rs:54:28: 54:46
        let mut _12: ((usize, usize), char); // in scope 1 at src/codec/japanese.rs:54:28: 54:46
        scope 2 {
            debug __next => _12;         // in scope 2 at src/codec/japanese.rs:54:28: 54:46
            let _17: ((usize, usize), char); // in scope 2 at src/codec/japanese.rs:54:13: 54:24
            let _19: usize;              // in scope 2 at src/codec/japanese.rs:54:15: 54:16
            let _20: usize;              // in scope 2 at src/codec/japanese.rs:54:17: 54:18
            let _21: char;               // in scope 2 at src/codec/japanese.rs:54:21: 54:23
            scope 3 {
                debug val => _17;        // in scope 3 at src/codec/japanese.rs:54:13: 54:24
            }
            scope 4 {
                debug i => _19;          // in scope 4 at src/codec/japanese.rs:54:15: 54:16
                debug j => _20;          // in scope 4 at src/codec/japanese.rs:54:17: 54:18
                debug ch => _21;         // in scope 4 at src/codec/japanese.rs:54:21: 54:23
                let _43: u16;            // in scope 4 at src/codec/japanese.rs:64:25: 64:28
                scope 5 {
                    debug ptr => _43;    // in scope 5 at src/codec/japanese.rs:64:25: 64:28
                    let _55: u16;        // in scope 5 at src/codec/japanese.rs:70:29: 70:33
                    scope 6 {
                        debug lead => _55; // in scope 6 at src/codec/japanese.rs:70:29: 70:33
                        let _58: u16;    // in scope 6 at src/codec/japanese.rs:71:29: 71:34
                        scope 7 {
                            debug trail => _58; // in scope 7 at src/codec/japanese.rs:71:29: 71:34
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:52:9: 52:40
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:52:9: 52:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/japanese.rs:52:9: 52:15
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:52:28: 52:39
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:52:28: 52:33
        _7 = _2;                         // scope 0 at src/codec/japanese.rs:52:28: 52:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/japanese.rs:52:28: 52:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:52:34: 52:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:52:38: 52:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/japanese.rs:52:9: 52:40
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:52:16: 52:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:52:39: 52:40
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:52:39: 52:40
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:52:40: 52:41
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:54:28: 54:46
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:54:28: 54:46
        StorageLive(_10);                // scope 0 at src/codec/japanese.rs:54:28: 54:33
        _10 = &_2;                       // scope 0 at src/codec/japanese.rs:54:28: 54:33
        _9 = <&str as StrCharIndex>::index_iter(move _10) -> bb3; // scope 0 at src/codec/japanese.rs:54:28: 54:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:54:34: 54:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_10);                // scope 0 at src/codec/japanese.rs:54:45: 54:46
        _8 = <StrCharIndexIterator as IntoIterator>::into_iter(move _9) -> bb4; // scope 0 at src/codec/japanese.rs:54:28: 54:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:54:28: 54:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:54:45: 54:46
        StorageLive(_11);                // scope 0 at src/codec/japanese.rs:54:28: 54:46
        _11 = move _8;                   // scope 0 at src/codec/japanese.rs:54:28: 54:46
        goto -> bb5;                     // scope 1 at src/codec/japanese.rs:54:9: 77:10
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/japanese.rs:54:28: 54:46
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:54:28: 54:46
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:54:28: 54:46
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:54:28: 54:46
        _15 = &mut _11;                  // scope 2 at src/codec/japanese.rs:54:28: 54:46
        _14 = &mut (*_15);               // scope 2 at src/codec/japanese.rs:54:28: 54:46
        _13 = <StrCharIndexIterator as Iterator>::next(move _14) -> bb6; // scope 2 at src/codec/japanese.rs:54:28: 54:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:54:28: 54:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:54:45: 54:46
        _16 = discriminant(_13);         // scope 2 at src/codec/japanese.rs:54:28: 54:46
        switchInt(move _16) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/japanese.rs:54:28: 54:46
    }

    bb7: {
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:54:45: 54:46
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:54:45: 54:46
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:54:45: 54:46
        StorageLive(_69);                // scope 0 at src/codec/japanese.rs:78:10: 78:21
        StorageLive(_70);                // scope 0 at src/codec/japanese.rs:78:10: 78:15
        _70 = _2;                        // scope 0 at src/codec/japanese.rs:78:10: 78:15
        _69 = core::str::<impl str>::len(move _70) -> bb31; // scope 0 at src/codec/japanese.rs:78:10: 78:21
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:78:16: 78:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/japanese.rs:54:28: 54:46
    }

    bb9: {
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:54:13: 54:24
        _17 = ((_13 as Some).0: ((usize, usize), char)); // scope 2 at src/codec/japanese.rs:54:13: 54:24
        StorageLive(_18);                // scope 3 at src/codec/japanese.rs:54:13: 54:24
        _18 = _17;                       // scope 3 at src/codec/japanese.rs:54:13: 54:24
        _12 = move _18;                  // scope 3 at src/codec/japanese.rs:54:13: 54:24
        StorageDead(_18);                // scope 3 at src/codec/japanese.rs:54:23: 54:24
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:54:23: 54:24
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:54:45: 54:46
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:54:45: 54:46
        StorageLive(_19);                // scope 2 at src/codec/japanese.rs:54:15: 54:16
        _19 = ((_12.0: (usize, usize)).0: usize); // scope 2 at src/codec/japanese.rs:54:15: 54:16
        StorageLive(_20);                // scope 2 at src/codec/japanese.rs:54:17: 54:18
        _20 = ((_12.0: (usize, usize)).1: usize); // scope 2 at src/codec/japanese.rs:54:17: 54:18
        StorageLive(_21);                // scope 2 at src/codec/japanese.rs:54:21: 54:23
        _21 = (_12.1: char);             // scope 2 at src/codec/japanese.rs:54:21: 54:23
        _24 = Le(const '\u{0}', _21);    // scope 4 at src/codec/japanese.rs:56:17: 56:35
        switchInt(move _24) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/japanese.rs:56:17: 56:35
    }

    bb10: {
        _25 = Le(_21, const '\u{7f}');   // scope 4 at src/codec/japanese.rs:56:17: 56:35
        switchInt(move _25) -> [false: bb11, otherwise: bb15]; // scope 4 at src/codec/japanese.rs:56:17: 56:35
    }

    bb11: {
        switchInt(_21) -> ['': bb17, '': bb19, otherwise: bb12]; // scope 4 at src/codec/japanese.rs:55:13: 55:21
    }

    bb12: {
        _22 = Le(const '', _21);        // scope 4 at src/codec/japanese.rs:59:17: 59:40
        switchInt(move _22) -> [false: bb14, otherwise: bb13]; // scope 4 at src/codec/japanese.rs:59:17: 59:40
    }

    bb13: {
        _23 = Le(_21, const '\u{ff9f}'); // scope 4 at src/codec/japanese.rs:59:17: 59:40
        switchInt(move _23) -> [false: bb14, otherwise: bb21]; // scope 4 at src/codec/japanese.rs:59:17: 59:40
    }

    bb14: {
        StorageLive(_43);                // scope 4 at src/codec/japanese.rs:64:25: 64:28
        StorageLive(_44);                // scope 4 at src/codec/japanese.rs:64:56: 64:65
        StorageLive(_45);                // scope 4 at src/codec/japanese.rs:64:56: 64:58
        _45 = _21;                       // scope 4 at src/codec/japanese.rs:64:56: 64:58
        _44 = move _45 as u32 (Misc);    // scope 4 at src/codec/japanese.rs:64:56: 64:65
        StorageDead(_45);                // scope 4 at src/codec/japanese.rs:64:64: 64:65
        _43 = index_japanese::jis0208::backward(move _44) -> bb24; // scope 4 at src/codec/japanese.rs:64:31: 64:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:64:31: 64:55
                                         // + literal: Const { ty: fn(u32) -> u16 {index_japanese::jis0208::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageLive(_26);                // scope 4 at src/codec/japanese.rs:56:41: 56:68
        StorageLive(_27);                // scope 4 at src/codec/japanese.rs:56:41: 56:47
        _27 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:56:41: 56:47
        StorageLive(_28);                // scope 4 at src/codec/japanese.rs:56:59: 56:67
        StorageLive(_29);                // scope 4 at src/codec/japanese.rs:56:59: 56:61
        _29 = _21;                       // scope 4 at src/codec/japanese.rs:56:59: 56:61
        _28 = move _29 as u8 (Misc);     // scope 4 at src/codec/japanese.rs:56:59: 56:67
        StorageDead(_29);                // scope 4 at src/codec/japanese.rs:56:66: 56:67
        _26 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _27, move _28) -> bb16; // scope 4 at src/codec/japanese.rs:56:41: 56:68
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:56:48: 56:58
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_28);                // scope 4 at src/codec/japanese.rs:56:67: 56:68
        StorageDead(_27);                // scope 4 at src/codec/japanese.rs:56:67: 56:68
        StorageDead(_26);                // scope 4 at src/codec/japanese.rs:56:68: 56:69
        goto -> bb30;                    // scope 4 at src/codec/japanese.rs:56:39: 56:71
    }

    bb17: {
        StorageLive(_30);                // scope 4 at src/codec/japanese.rs:57:31: 57:54
        StorageLive(_31);                // scope 4 at src/codec/japanese.rs:57:31: 57:37
        _31 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:57:31: 57:37
        _30 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _31, const 92_u8) -> bb18; // scope 4 at src/codec/japanese.rs:57:31: 57:54
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:57:38: 57:48
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb18: {
        StorageDead(_31);                // scope 4 at src/codec/japanese.rs:57:53: 57:54
        StorageDead(_30);                // scope 4 at src/codec/japanese.rs:57:54: 57:55
        goto -> bb30;                    // scope 4 at src/codec/japanese.rs:57:29: 57:57
    }

    bb19: {
        StorageLive(_32);                // scope 4 at src/codec/japanese.rs:58:33: 58:56
        StorageLive(_33);                // scope 4 at src/codec/japanese.rs:58:33: 58:39
        _33 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:58:33: 58:39
        _32 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _33, const 126_u8) -> bb20; // scope 4 at src/codec/japanese.rs:58:33: 58:56
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:58:40: 58:50
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_33);                // scope 4 at src/codec/japanese.rs:58:55: 58:56
        StorageDead(_32);                // scope 4 at src/codec/japanese.rs:58:56: 58:57
        goto -> bb30;                    // scope 4 at src/codec/japanese.rs:58:31: 58:59
    }

    bb21: {
        StorageLive(_34);                // scope 4 at src/codec/japanese.rs:60:21: 60:44
        StorageLive(_35);                // scope 4 at src/codec/japanese.rs:60:21: 60:27
        _35 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:60:21: 60:27
        _34 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _35, const 142_u8) -> bb22; // scope 4 at src/codec/japanese.rs:60:21: 60:44
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:60:28: 60:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb22: {
        StorageDead(_35);                // scope 4 at src/codec/japanese.rs:60:43: 60:44
        StorageDead(_34);                // scope 4 at src/codec/japanese.rs:60:44: 60:45
        StorageLive(_36);                // scope 4 at src/codec/japanese.rs:61:21: 61:75
        StorageLive(_37);                // scope 4 at src/codec/japanese.rs:61:21: 61:27
        _37 = &mut (*_3);                // scope 4 at src/codec/japanese.rs:61:21: 61:27
        StorageLive(_38);                // scope 4 at src/codec/japanese.rs:61:39: 61:74
        StorageLive(_39);                // scope 4 at src/codec/japanese.rs:61:39: 61:68
        StorageLive(_40);                // scope 4 at src/codec/japanese.rs:61:40: 61:60
        StorageLive(_41);                // scope 4 at src/codec/japanese.rs:61:40: 61:51
        StorageLive(_42);                // scope 4 at src/codec/japanese.rs:61:40: 61:42
        _42 = _21;                       // scope 4 at src/codec/japanese.rs:61:40: 61:42
        _41 = move _42 as usize (Misc);  // scope 4 at src/codec/japanese.rs:61:40: 61:51
        StorageDead(_42);                // scope 4 at src/codec/japanese.rs:61:50: 61:51
        _40 = Sub(move _41, const 65377_usize); // scope 4 at src/codec/japanese.rs:61:40: 61:60
        StorageDead(_41);                // scope 4 at src/codec/japanese.rs:61:59: 61:60
        _39 = Add(move _40, const 161_usize); // scope 4 at src/codec/japanese.rs:61:39: 61:68
        StorageDead(_40);                // scope 4 at src/codec/japanese.rs:61:67: 61:68
        _38 = move _39 as u8 (Misc);     // scope 4 at src/codec/japanese.rs:61:39: 61:74
        StorageDead(_39);                // scope 4 at src/codec/japanese.rs:61:73: 61:74
        _36 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _37, move _38) -> bb23; // scope 4 at src/codec/japanese.rs:61:21: 61:75
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:61:28: 61:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb23: {
        StorageDead(_38);                // scope 4 at src/codec/japanese.rs:61:74: 61:75
        StorageDead(_37);                // scope 4 at src/codec/japanese.rs:61:74: 61:75
        StorageDead(_36);                // scope 4 at src/codec/japanese.rs:61:75: 61:76
        goto -> bb30;                    // scope 4 at src/codec/japanese.rs:59:44: 62:18
    }

    bb24: {
        StorageDead(_44);                // scope 4 at src/codec/japanese.rs:64:65: 64:66
        StorageLive(_46);                // scope 5 at src/codec/japanese.rs:65:24: 65:27
        _46 = _43;                       // scope 5 at src/codec/japanese.rs:65:24: 65:27
        switchInt(move _46) -> [u16::MAX: bb25, otherwise: bb27]; // scope 5 at src/codec/japanese.rs:65:24: 65:37
    }

    bb25: {
        StorageDead(_46);                // scope 5 at src/codec/japanese.rs:65:24: 65:37
        StorageLive(_47);                // scope 5 at src/codec/japanese.rs:66:33: 66:34
        _47 = _19;                       // scope 5 at src/codec/japanese.rs:66:33: 66:34
        StorageLive(_48);                // scope 5 at src/codec/japanese.rs:66:36: 68:27
        StorageLive(_49);                // scope 5 at src/codec/japanese.rs:66:41: 68:26
        StorageLive(_50);                // scope 5 at src/codec/japanese.rs:67:35: 67:45
        StorageLive(_51);                // scope 5 at src/codec/japanese.rs:67:35: 67:36
        _51 = _20;                       // scope 5 at src/codec/japanese.rs:67:35: 67:36
        _50 = move _51 as isize (Misc);  // scope 5 at src/codec/japanese.rs:67:35: 67:45
        StorageDead(_51);                // scope 5 at src/codec/japanese.rs:67:44: 67:45
        StorageLive(_52);                // scope 5 at src/codec/japanese.rs:67:54: 67:88
        StorageLive(_53);                // scope 5 at src/codec/japanese.rs:67:54: 67:81
        StorageLive(_54);                // scope 5 at src/codec/japanese.rs:67:54: 67:81
        _54 = const "unrepresentable character"; // scope 5 at src/codec/japanese.rs:67:54: 67:81
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:67:54: 67:81
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _53 = _54;                       // scope 5 at src/codec/japanese.rs:67:54: 67:81
        _52 = <&str as Into<Cow<str>>>::into(move _53) -> bb26; // scope 5 at src/codec/japanese.rs:67:54: 67:88
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:67:82: 67:86
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb26: {
        StorageDead(_53);                // scope 5 at src/codec/japanese.rs:67:87: 67:88
        (_49.0: isize) = move _50;       // scope 5 at src/codec/japanese.rs:66:41: 68:26
        (_49.1: std::borrow::Cow<str>) = move _52; // scope 5 at src/codec/japanese.rs:66:41: 68:26
        StorageDead(_52);                // scope 5 at src/codec/japanese.rs:68:25: 68:26
        StorageDead(_50);                // scope 5 at src/codec/japanese.rs:68:25: 68:26
        ((_48 as Some).0: encoding_types::CodecError) = move _49; // scope 5 at src/codec/japanese.rs:66:36: 68:27
        discriminant(_48) = 1;           // scope 5 at src/codec/japanese.rs:66:36: 68:27
        StorageDead(_49);                // scope 5 at src/codec/japanese.rs:68:26: 68:27
        (_0.0: usize) = move _47;        // scope 5 at src/codec/japanese.rs:66:32: 68:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _48; // scope 5 at src/codec/japanese.rs:66:32: 68:28
        StorageDead(_48);                // scope 5 at src/codec/japanese.rs:68:27: 68:28
        StorageDead(_47);                // scope 5 at src/codec/japanese.rs:68:27: 68:28
        StorageDead(_54);                // scope 5 at src/codec/japanese.rs:68:28: 68:29
        StorageDead(_43);                // scope 4 at src/codec/japanese.rs:75:17: 75:18
        StorageDead(_21);                // scope 2 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_20);                // scope 2 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:54:45: 54:46
        goto -> bb32;                    // scope 0 at src/codec/japanese.rs:79:6: 79:6
    }

    bb27: {
        StorageDead(_46);                // scope 5 at src/codec/japanese.rs:65:24: 65:37
        StorageLive(_55);                // scope 5 at src/codec/japanese.rs:70:29: 70:33
        StorageLive(_56);                // scope 5 at src/codec/japanese.rs:70:36: 70:44
        StorageLive(_57);                // scope 5 at src/codec/japanese.rs:70:36: 70:39
        _57 = _43;                       // scope 5 at src/codec/japanese.rs:70:36: 70:39
        _56 = Div(move _57, const 94_u16); // scope 5 at src/codec/japanese.rs:70:36: 70:44
        StorageDead(_57);                // scope 5 at src/codec/japanese.rs:70:43: 70:44
        _55 = Add(move _56, const 161_u16); // scope 5 at src/codec/japanese.rs:70:36: 70:51
        StorageDead(_56);                // scope 5 at src/codec/japanese.rs:70:50: 70:51
        StorageLive(_58);                // scope 6 at src/codec/japanese.rs:71:29: 71:34
        StorageLive(_59);                // scope 6 at src/codec/japanese.rs:71:37: 71:45
        StorageLive(_60);                // scope 6 at src/codec/japanese.rs:71:37: 71:40
        _60 = _43;                       // scope 6 at src/codec/japanese.rs:71:37: 71:40
        _59 = Rem(move _60, const 94_u16); // scope 6 at src/codec/japanese.rs:71:37: 71:45
        StorageDead(_60);                // scope 6 at src/codec/japanese.rs:71:44: 71:45
        _58 = Add(move _59, const 161_u16); // scope 6 at src/codec/japanese.rs:71:37: 71:52
        StorageDead(_59);                // scope 6 at src/codec/japanese.rs:71:51: 71:52
        StorageLive(_61);                // scope 7 at src/codec/japanese.rs:72:25: 72:54
        StorageLive(_62);                // scope 7 at src/codec/japanese.rs:72:25: 72:31
        _62 = &mut (*_3);                // scope 7 at src/codec/japanese.rs:72:25: 72:31
        StorageLive(_63);                // scope 7 at src/codec/japanese.rs:72:43: 72:53
        StorageLive(_64);                // scope 7 at src/codec/japanese.rs:72:43: 72:47
        _64 = _55;                       // scope 7 at src/codec/japanese.rs:72:43: 72:47
        _63 = move _64 as u8 (Misc);     // scope 7 at src/codec/japanese.rs:72:43: 72:53
        StorageDead(_64);                // scope 7 at src/codec/japanese.rs:72:52: 72:53
        _61 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _62, move _63) -> bb28; // scope 7 at src/codec/japanese.rs:72:25: 72:54
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:72:32: 72:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb28: {
        StorageDead(_63);                // scope 7 at src/codec/japanese.rs:72:53: 72:54
        StorageDead(_62);                // scope 7 at src/codec/japanese.rs:72:53: 72:54
        StorageDead(_61);                // scope 7 at src/codec/japanese.rs:72:54: 72:55
        StorageLive(_65);                // scope 7 at src/codec/japanese.rs:73:25: 73:55
        StorageLive(_66);                // scope 7 at src/codec/japanese.rs:73:25: 73:31
        _66 = &mut (*_3);                // scope 7 at src/codec/japanese.rs:73:25: 73:31
        StorageLive(_67);                // scope 7 at src/codec/japanese.rs:73:43: 73:54
        StorageLive(_68);                // scope 7 at src/codec/japanese.rs:73:43: 73:48
        _68 = _58;                       // scope 7 at src/codec/japanese.rs:73:43: 73:48
        _67 = move _68 as u8 (Misc);     // scope 7 at src/codec/japanese.rs:73:43: 73:54
        StorageDead(_68);                // scope 7 at src/codec/japanese.rs:73:53: 73:54
        _65 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _66, move _67) -> bb29; // scope 7 at src/codec/japanese.rs:73:25: 73:55
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:73:32: 73:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb29: {
        StorageDead(_67);                // scope 7 at src/codec/japanese.rs:73:54: 73:55
        StorageDead(_66);                // scope 7 at src/codec/japanese.rs:73:54: 73:55
        StorageDead(_65);                // scope 7 at src/codec/japanese.rs:73:55: 73:56
        StorageDead(_58);                // scope 6 at src/codec/japanese.rs:74:21: 74:22
        StorageDead(_55);                // scope 5 at src/codec/japanese.rs:74:21: 74:22
        StorageDead(_43);                // scope 4 at src/codec/japanese.rs:75:17: 75:18
        goto -> bb30;                    // scope 4 at src/codec/japanese.rs:75:17: 75:18
    }

    bb30: {
        StorageDead(_21);                // scope 2 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_20);                // scope 2 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:77:9: 77:10
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:77:9: 77:10
        goto -> bb5;                     // scope 1 at src/codec/japanese.rs:54:9: 77:10
    }

    bb31: {
        StorageDead(_70);                // scope 0 at src/codec/japanese.rs:78:20: 78:21
        StorageLive(_71);                // scope 0 at src/codec/japanese.rs:78:23: 78:27
        discriminant(_71) = 0;           // scope 0 at src/codec/japanese.rs:78:23: 78:27
        (_0.0: usize) = move _69;        // scope 0 at src/codec/japanese.rs:78:9: 78:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _71; // scope 0 at src/codec/japanese.rs:78:9: 78:28
        StorageDead(_71);                // scope 0 at src/codec/japanese.rs:78:27: 78:28
        StorageDead(_69);                // scope 0 at src/codec/japanese.rs:78:27: 78:28
        goto -> bb32;                    // scope 0 at src/codec/japanese.rs:79:6: 79:6
    }

    bb32: {
        return;                          // scope 0 at src/codec/japanese.rs:79:6: 79:6
    }
}

fn bigfive2003::State::S1(_1: (), _2: u8) -> bigfive2003::State {
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn bigfive2003::State::S1(_1: (), _2: u8) -> bigfive2003::State {
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

static REJECT_STATE_WITH_BACKUP: u8 = {
    let mut _0: u8;                      // return place in scope 0 at src/codec/utf_8.rs:134:34: 134:36

    bb0: {
        _0 = const 86_u8;                // scope 0 at src/codec/utf_8.rs:134:39: 134:41
        return;                          // scope 0 at src/codec/utf_8.rs:134:1: 134:42
    }
}

fn japanese::<impl at src/codec/japanese.rs:40:10: 40:15>::clone(_1: &EUCJPEncoder) -> EUCJPEncoder {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:40:10: 40:15
    let mut _0: codec::japanese::EUCJPEncoder; // return place in scope 0 at src/codec/japanese.rs:40:10: 40:15

    bb0: {
        return;                          // scope 0 at src/codec/japanese.rs:40:15: 40:15
    }
}

fn hz::transient::A1(_1: &mut StatefulDecoderHelper<hz::State, T>) -> hz::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:601:25: 601:28
    let mut _7: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:602:25: 602:28
    let _8: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:603:22: 603:36
    let mut _9: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:603:22: 603:25
    let mut _10: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:603:41: 603:44
    let mut _11: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:604:25: 604:28
    let mut _12: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:605:19: 605:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<hz::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_5) -> [123_u8: bb6, 125_u8: bb8, 126_u8: bb10, 10_u8: bb13, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 2;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb17;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/simpchinese.rs:605:19: 605:22
        _12 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:605:19: 605:22
        _0 = StatefulDecoderHelper::<hz::State, T>::backup_and_err(move _12, const 1_usize, const "invalid sequence") -> bb15; // scope 1 at src/codec/simpchinese.rs:605:19: 605:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:605:23: 605:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, usize, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:605:41: 605:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/simpchinese.rs:601:25: 601:28
        _6 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:601:25: 601:28
        _0 = hz::transient::B0::<T>(move _6) -> bb7; // scope 1 at src/codec/simpchinese.rs:601:22: 601:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:601:22: 601:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/simpchinese.rs:601:28: 601:29
        goto -> bb16;                    // scope 1 at src/codec/simpchinese.rs:601:28: 601:29
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/simpchinese.rs:602:25: 602:28
        _7 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:602:25: 602:28
        _0 = hz::transient::A0::<T>(move _7) -> bb9; // scope 1 at src/codec/simpchinese.rs:602:22: 602:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:602:22: 602:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/simpchinese.rs:602:28: 602:29
        goto -> bb16;                    // scope 1 at src/codec/simpchinese.rs:602:28: 602:29
    }

    bb10: {
        StorageLive(_8);                 // scope 1 at src/codec/simpchinese.rs:603:22: 603:36
        StorageLive(_9);                 // scope 1 at src/codec/simpchinese.rs:603:22: 603:25
        _9 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:603:22: 603:25
        _8 = StatefulDecoderHelper::<hz::State, T>::emit(move _9, const 126_u32) -> bb11; // scope 1 at src/codec/simpchinese.rs:603:22: 603:36
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:603:26: 603:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, u32) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_9);                 // scope 1 at src/codec/simpchinese.rs:603:35: 603:36
        StorageDead(_8);                 // scope 1 at src/util.rs:226:72: 226:73
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:603:41: 603:44
        _10 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:603:41: 603:44
        _0 = hz::transient::A0::<T>(move _10) -> bb12; // scope 1 at src/codec/simpchinese.rs:603:38: 603:45
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:603:38: 603:40
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_10);                // scope 1 at src/codec/simpchinese.rs:603:44: 603:45
        goto -> bb16;                    // scope 1 at src/codec/simpchinese.rs:603:44: 603:45
    }

    bb13: {
        StorageLive(_11);                // scope 1 at src/codec/simpchinese.rs:604:25: 604:28
        _11 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:604:25: 604:28
        _0 = hz::transient::A0::<T>(move _11) -> bb14; // scope 1 at src/codec/simpchinese.rs:604:22: 604:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:604:22: 604:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::A0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_11);                // scope 1 at src/codec/simpchinese.rs:604:28: 604:29
        goto -> bb16;                    // scope 1 at src/codec/simpchinese.rs:604:28: 604:29
    }

    bb15: {
        StorageDead(_12);                // scope 1 at src/codec/simpchinese.rs:605:59: 605:60
        goto -> bb16;                    // scope 1 at src/codec/simpchinese.rs:605:59: 605:60
    }

    bb16: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb17;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb17: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

const BIG5_2003: &BigFive2003Encoding = {
    let mut _0: &codec::tradchinese::BigFive2003Encoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const BIG5_2003::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::tradchinese::BigFive2003Encoding
                                         // + val: Unevaluated(BIG5_2003, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::tradchinese::BigFive2003Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1287 ~ encoding[5d2c]::all::BIG5_2003), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in BIG5_2003: &BigFive2003Encoding = {
    let mut _0: &codec::tradchinese::BigFive2003Encoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:482:1: 533:2>::raw_finish(_1: &mut HZEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:530:19: 530:28
    debug _output => _2;                 // in scope 0 at src/codec/simpchinese.rs:530:30: 530:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/simpchinese.rs:530:59: 530:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/simpchinese.rs:531:9: 531:13
        return;                          // scope 0 at src/codec/simpchinese.rs:532:6: 532:6
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:34:1: 59:2>::raw_feed::{closure#0}(_1: &mut [closure@src/codec/ascii.rs:41:48: 41:64], _2: &u8) -> bool {
    let mut _0: bool;                    // return place in scope 0 at src/codec/ascii.rs:41:54: 41:54
    let _3: u8;                          // in scope 0 at src/codec/ascii.rs:41:50: 41:52
    let mut _4: u8;                      // in scope 0 at src/codec/ascii.rs:41:54: 41:56
    scope 1 {
        debug ch => _3;                  // in scope 1 at src/codec/ascii.rs:41:50: 41:52
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:41:50: 41:52
        _3 = (*_2);                      // scope 0 at src/codec/ascii.rs:41:50: 41:52
        StorageLive(_4);                 // scope 1 at src/codec/ascii.rs:41:54: 41:56
        _4 = _3;                         // scope 1 at src/codec/ascii.rs:41:54: 41:56
        _0 = Ge(move _4, const 128_u8);  // scope 1 at src/codec/ascii.rs:41:54: 41:64
        StorageDead(_4);                 // scope 1 at src/codec/ascii.rs:41:63: 41:64
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:41:63: 41:64
        return;                          // scope 0 at src/codec/ascii.rs:41:64: 41:64
    }
}

fn windows949::raw_finish(_1: windows949::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (windows949::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::korean::windows949::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::korean::windows949::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::korean::windows949::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::korean::windows949::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::korean::windows949::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:311:26: 311:33
    let mut _21: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _22: codec::korean::windows949::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _23: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _24: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _25: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::korean::windows949::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug lead => _19;           // in scope 4 at src/util.rs:284:36: 284:40
            let _20: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 4 at src/util.rs:284:53: 284:57
            scope 5 {
                debug ctx => _20;        // in scope 5 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _25 = const windows949::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(windows949::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:751 ~ encoding[5d2c]::codec::korean::windows949::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _25;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<windows949::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::korean::windows949::State, T> {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<windows949::State>(move _13, move _15) -> [return: bb2, unwind: bb11]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::korean::windows949::State, codec::korean::windows949::State) -> codec::korean::windows949::State {std::mem::replace::<codec::korean::windows949::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_19);                // scope 1 at src/util.rs:284:36: 284:40
        _19 = ((_12 as S1).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_20);                // scope 4 at src/util.rs:284:53: 284:57
        _20 = &mut _4;                   // scope 4 at src/util.rs:284:60: 284:68
        StorageLive(_21);                // scope 5 at src/util.rs:317:26: 317:30
        _21 = &mut (*_20);               // scope 5 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<windows949::State, T>::err(move _21, const "incomplete sequence") -> [return: bb7, unwind: bb11]; // scope 5 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>, &'static str) -> codec::korean::windows949::State {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/util.rs:311:26: 311:33
        _18 = &(*_17);                   // scope 3 at src/util.rs:311:26: 311:33
        _11 = StatefulDecoderHelper::<windows949::State, T>::reset(move _18) -> [return: bb6, unwind: bb11]; // scope 3 at src/util.rs:311:26: 311:41
                                         // mir::Constant
                                         // + span: src/util.rs:311:34: 311:39
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::korean::windows949::State, T>) -> codec::korean::windows949::State {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/util.rs:311:40: 311:41
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb8;                     // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageDead(_21);                // scope 5 at src/util.rs:317:56: 317:57
        StorageDead(_20);                // scope 4 at src/util.rs:284:80: 284:81
        StorageDead(_19);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb8;                     // scope 1 at src/util.rs:284:80: 284:81
    }

    bb8: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_22);                // scope 2 at src/util.rs:287:18: 287:20
        _22 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_23);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_24);                // scope 2 at src/util.rs:287:22: 287:29
        _24 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _23 = Option::<encoding_types::CodecError>::take(move _24) -> [return: bb9, unwind: bb11]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_24);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::korean::windows949::State) = move _22; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _23; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_23);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_22);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb10;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb10: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb11 (cleanup): {
        drop(_4) -> bb12;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb12 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in windows949::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn japanese::<impl at src/codec/japanese.rs:774:1: 779:2>::raw_encoder(_1: &ISO2022JPEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:777:20: 777:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:777:30: 777:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:777:48: 777:71
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:777:48: 777:71

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:777:48: 777:71
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:777:48: 777:71
        _3 = ISO2022JPEncoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:777:48: 777:71
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:777:48: 777:69
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::japanese::ISO2022JPEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:777:48: 777:71
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:777:70: 777:71
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:777:48: 777:71
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:777:72: 777:73
        return;                          // scope 0 at src/codec/japanese.rs:777:73: 777:73
    }
}

const KOI8_R: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:55:56: 55:64
    let _5: &str;                        // in scope 0 at src/all.rs:55:56: 55:64
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const KOI8_R::promoted[0];  // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_R, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1263 ~ encoding[5d2c]::all::KOI8_R), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in KOI8_R: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:55:56: 55:64
    let mut _4: &str;                    // in scope 0 at src/all.rs:55:56: 55:64
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "koi8-r";             // scope 0 at src/all.rs:55:56: 55:64
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/all.rs:55:56: 55:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:55:56: 55:64
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::koi8_r::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::koi8_r::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::koi8_r::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::koi8_r::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "koi8-r";   // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/all.rs:55:56: 55:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:99:1: 106:2>::raw_feed(_1: &mut GBKEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:102:17: 102:26
    debug input => _2;                   // in scope 0 at src/codec/simpchinese.rs:102:28: 102:33
    debug output => _3;                  // in scope 0 at src/codec/simpchinese.rs:102:41: 102:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/simpchinese.rs:102:69: 102:96
    let mut _4: &mut codec::simpchinese::GBEncoder; // in scope 0 at src/codec/simpchinese.rs:103:9: 103:18
    let mut _5: codec::simpchinese::GBEncoder; // in scope 0 at src/codec/simpchinese.rs:103:9: 103:18
    let mut _6: &str;                    // in scope 0 at src/codec/simpchinese.rs:103:28: 103:33
    let mut _7: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:103:35: 103:41
    let mut _8: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:103:35: 103:41

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:103:9: 103:18
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:103:9: 103:18
        _4 = &mut _5;                    // scope 0 at src/codec/simpchinese.rs:103:9: 103:18
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:103:28: 103:33
        _6 = _2;                         // scope 0 at src/codec/simpchinese.rs:103:28: 103:33
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:103:35: 103:41
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:103:35: 103:41
        _8 = &mut (*_3);                 // scope 0 at src/codec/simpchinese.rs:103:35: 103:41
        _7 = move _8 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:103:35: 103:41
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:103:40: 103:41
        _0 = GBEncoder::raw_feed(move _4, move _6, move _7, const true) -> bb1; // scope 0 at src/codec/simpchinese.rs:103:9: 103:48
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:103:19: 103:27
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut codec::simpchinese::GBEncoder, &'s str, &'t0 mut (dyn encoding_types::ByteWriter + 't0), bool) -> (usize, std::option::Option<encoding_types::CodecError>) {codec::simpchinese::GBEncoder::raw_feed}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:103:47: 103:48
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:103:47: 103:48
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:103:47: 103:48
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:104:5: 104:6
        return;                          // scope 0 at src/codec/simpchinese.rs:104:6: 104:6
    }
}

fn hz::<impl at src/util.rs:157:33: 157:38>::clone(_1: &hz::State) -> hz::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 5 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn windows31j::<impl at src/util.rs:168:13: 170:14>::default() -> windows31j::State {
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:45:1: 76:2>::is_ascii_compatible(_1: &BigFive2003Encoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:47:28: 47:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/tradchinese.rs:47:38: 47:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/tradchinese.rs:47:45: 47:49
        return;                          // scope 0 at src/codec/tradchinese.rs:47:51: 47:51
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:39:1: 67:2>::from_self(_1: &SingleByteEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:40:18: 40:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/singlebyte.rs:40:28: 40:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/singlebyte.rs:40:46: 40:89
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/singlebyte.rs:40:46: 40:89
    let mut _4: fn(u32) -> u8;           // in scope 0 at src/codec/singlebyte.rs:40:69: 40:88

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:40:46: 40:89
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:40:46: 40:89
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:40:69: 40:88
        _4 = ((*_1).0: fn(u32) -> u8);   // scope 0 at src/codec/singlebyte.rs:40:69: 40:88
        _3 = SingleByteEncoder::new(move _4) -> bb1; // scope 0 at src/codec/singlebyte.rs:40:46: 40:89
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:40:46: 40:68
                                         // + literal: Const { ty: fn(fn(u32) -> u8) -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::singlebyte::SingleByteEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:40:46: 40:89
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:40:88: 40:89
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:40:88: 40:89
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:40:46: 40:89
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:40:90: 40:91
        return;                          // scope 0 at src/codec/singlebyte.rs:40:91: 40:91
    }
}

fn japanese::<impl at src/codec/japanese.rs:98:1: 113:2>::raw_feed(_1: &mut EUCJP0212Decoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:102:17: 102:26
    debug input => _2;                   // in scope 0 at src/codec/japanese.rs:102:28: 102:33
    debug output => _3;                  // in scope 0 at src/codec/japanese.rs:102:42: 102:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/japanese.rs:102:72: 102:99
    let _4: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:103:14: 103:16
    let _5: usize;                       // in scope 0 at src/codec/japanese.rs:103:18: 103:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:103:29: 103:32
    let mut _7: (codec::japanese::eucjp::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/japanese.rs:103:36: 103:80
    let mut _8: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:103:52: 103:59
    let mut _9: &[u8];                   // in scope 0 at src/codec/japanese.rs:103:61: 103:66
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:103:68: 103:74
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:103:68: 103:74
    let mut _12: &();                    // in scope 0 at src/codec/japanese.rs:103:76: 103:79
    let _13: &();                        // in scope 0 at src/codec/japanese.rs:103:76: 103:79
    let mut _14: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:104:19: 104:21
    let mut _15: usize;                  // in scope 0 at src/codec/japanese.rs:105:10: 105:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:105:21: 105:24
    let mut _17: &();                    // in scope 0 at src/codec/japanese.rs:103:76: 103:79
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/japanese.rs:103:14: 103:16
        debug processed => _5;           // in scope 1 at src/codec/japanese.rs:103:18: 103:27
        debug err => _6;                 // in scope 1 at src/codec/japanese.rs:103:29: 103:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:103:36: 103:80
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:103:52: 103:59
        _8 = ((*_1).0: codec::japanese::eucjp::State); // scope 0 at src/codec/japanese.rs:103:52: 103:59
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:103:61: 103:66
        _9 = _2;                         // scope 0 at src/codec/japanese.rs:103:61: 103:66
        StorageLive(_10);                // scope 0 at src/codec/japanese.rs:103:68: 103:74
        StorageLive(_11);                // scope 0 at src/codec/japanese.rs:103:68: 103:74
        _11 = &mut (*_3);                // scope 0 at src/codec/japanese.rs:103:68: 103:74
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:103:68: 103:74
        StorageDead(_11);                // scope 0 at src/codec/japanese.rs:103:73: 103:74
        StorageLive(_12);                // scope 0 at src/codec/japanese.rs:103:76: 103:79
        StorageLive(_13);                // scope 0 at src/codec/japanese.rs:103:76: 103:79
        _17 = const <EUCJP0212Decoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/japanese.rs:103:76: 103:79
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<EUCJP0212Decoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:103:76: 103:79
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:404 ~ encoding[5d2c]::codec::japanese::{impl#4}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/japanese.rs:103:76: 103:79
        _12 = _13;                       // scope 0 at src/codec/japanese.rs:103:76: 103:79
        _7 = eucjp::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/japanese.rs:103:36: 103:80
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:103:36: 103:51
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::japanese::eucjp::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::japanese::eucjp::State, usize, std::option::Option<encoding_types::CodecError>) {codec::japanese::eucjp::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/japanese.rs:103:79: 103:80
        StorageDead(_10);                // scope 0 at src/codec/japanese.rs:103:79: 103:80
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:103:79: 103:80
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:103:79: 103:80
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:103:14: 103:16
        _4 = (_7.0: codec::japanese::eucjp::State); // scope 0 at src/codec/japanese.rs:103:14: 103:16
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:103:18: 103:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/japanese.rs:103:18: 103:27
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:103:29: 103:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/japanese.rs:103:29: 103:32
        StorageDead(_13);                // scope 0 at src/codec/japanese.rs:103:80: 103:81
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:103:80: 103:81
        StorageLive(_14);                // scope 1 at src/codec/japanese.rs:104:19: 104:21
        _14 = _4;                        // scope 1 at src/codec/japanese.rs:104:19: 104:21
        ((*_1).0: codec::japanese::eucjp::State) = move _14; // scope 1 at src/codec/japanese.rs:104:9: 104:21
        StorageDead(_14);                // scope 1 at src/codec/japanese.rs:104:20: 104:21
        StorageLive(_15);                // scope 1 at src/codec/japanese.rs:105:10: 105:19
        _15 = _5;                        // scope 1 at src/codec/japanese.rs:105:10: 105:19
        StorageLive(_16);                // scope 1 at src/codec/japanese.rs:105:21: 105:24
        _16 = move _6;                   // scope 1 at src/codec/japanese.rs:105:21: 105:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/japanese.rs:105:9: 105:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/japanese.rs:105:9: 105:25
        StorageDead(_16);                // scope 1 at src/codec/japanese.rs:105:24: 105:25
        StorageDead(_15);                // scope 1 at src/codec/japanese.rs:105:24: 105:25
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:106:5: 106:6
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:106:5: 106:6
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:106:5: 106:6
        return;                          // scope 0 at src/codec/japanese.rs:106:6: 106:6
    }
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:98:1: 113:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/japanese.rs:103:76: 103:79
    let mut _1: ();                      // in scope 0 at src/codec/japanese.rs:103:77: 103:79

    bb0: {
        nop;                             // scope 0 at src/codec/japanese.rs:103:77: 103:79
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:103:76: 103:79
        return;                          // scope 0 at src/codec/japanese.rs:103:76: 103:79
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:154:10: 154:15>::clone(_1: &GB18030Decoder) -> GB18030Decoder {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:154:10: 154:15
    let mut _0: codec::simpchinese::GB18030Decoder; // return place in scope 0 at src/codec/simpchinese.rs:154:10: 154:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/simpchinese.rs:154:10: 154:15
        return;                          // scope 0 at src/codec/simpchinese.rs:154:15: 154:15
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:141:1: 209:2>::raw_feed::write_bytes(_1: &mut dyn encoding_types::StringWriter, _2: &[u8]) -> () {
    debug output => _1;                  // in scope 0 at src/codec/utf_8.rs:148:24: 148:30
    debug bytes => _2;                   // in scope 0 at src/codec/utf_8.rs:148:51: 148:56
    let mut _0: ();                      // return place in scope 0 at src/codec/utf_8.rs:148:65: 148:65
    let _3: ();                          // in scope 0 at src/codec/utf_8.rs:149:13: 149:61
    let mut _4: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_8.rs:149:13: 149:19
    let mut _5: &str;                    // in scope 0 at src/codec/utf_8.rs:149:30: 149:60
    let mut _6: &[u8];                   // in scope 0 at src/codec/utf_8.rs:149:53: 149:58
    scope 1 {
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:149:13: 149:61
        StorageLive(_4);                 // scope 0 at src/codec/utf_8.rs:149:13: 149:19
        _4 = &mut (*_1);                 // scope 0 at src/codec/utf_8.rs:149:13: 149:19
        StorageLive(_5);                 // scope 0 at src/codec/utf_8.rs:149:30: 149:60
        StorageLive(_6);                 // scope 1 at src/codec/utf_8.rs:149:53: 149:58
        _6 = _2;                         // scope 1 at src/codec/utf_8.rs:149:53: 149:58
        _5 = transmute::<&[u8], &str>(move _6) -> bb1; // scope 1 at src/codec/utf_8.rs:149:38: 149:59
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:149:38: 149:52
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(&[u8]) -> &str {std::intrinsics::transmute::<&[u8], &str>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 1 at src/codec/utf_8.rs:149:58: 149:59
        _3 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_str(move _4, move _5) -> bb2; // scope 0 at src/codec/utf_8.rs:149:13: 149:61
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:149:20: 149:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::StringWriter, &'s str) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_str}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_5);                 // scope 0 at src/codec/utf_8.rs:149:60: 149:61
        StorageDead(_4);                 // scope 0 at src/codec/utf_8.rs:149:60: 149:61
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:149:61: 149:62
        return;                          // scope 0 at src/codec/utf_8.rs:150:10: 150:10
    }
}

fn iso2022jp::transient::EscapeMiddle28(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: &util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:964:28: 964:31
    let mut _7: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:965:31: 965:34
    let mut _8: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:966:19: 966:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_5) -> [66_u8: bb6, 74_u8: bb6, 73_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 6;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb12;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:966:19: 966:22
        _8 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:966:19: 966:22
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::backup_and_err(move _8, const 2_usize, const "invalid sequence") -> bb10; // scope 1 at src/codec/japanese.rs:966:19: 966:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:966:23: 966:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, usize, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:966:41: 966:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:964:28: 964:31
        _6 = &(*_1);                     // scope 1 at src/codec/japanese.rs:964:28: 964:31
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::reset(move _6) -> bb7; // scope 1 at src/codec/japanese.rs:964:28: 964:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:964:32: 964:37
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:964:38: 964:39
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:964:38: 964:39
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:965:31: 965:34
        _7 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:965:31: 965:34
        _0 = iso2022jp::transient::Katakana::<T>(move _7) -> bb9; // scope 1 at src/codec/japanese.rs:965:22: 965:35
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:965:22: 965:30
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Katakana::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:965:34: 965:35
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:965:34: 965:35
    }

    bb10: {
        StorageDead(_8);                 // scope 1 at src/codec/japanese.rs:966:59: 966:60
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:966:59: 966:60
    }

    bb11: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb12;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb12: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:547:1: 562:2>::raw_finish(_1: &mut HZDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:557:19: 557:28
    debug output => _2;                  // in scope 0 at src/codec/simpchinese.rs:557:30: 557:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/simpchinese.rs:558:18: 558:21
    let _3: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:558:14: 558:16
    let mut _4: (codec::simpchinese::hz::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/simpchinese.rs:558:25: 558:61
    let mut _5: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:558:40: 558:47
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:558:49: 558:55
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/simpchinese.rs:558:49: 558:55
    let mut _8: &();                     // in scope 0 at src/codec/simpchinese.rs:558:57: 558:60
    let _9: &();                         // in scope 0 at src/codec/simpchinese.rs:558:57: 558:60
    let mut _10: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:559:19: 559:21
    let mut _11: &();                    // in scope 0 at src/codec/simpchinese.rs:558:57: 558:60
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/simpchinese.rs:558:14: 558:16
        debug err => _0;                 // in scope 1 at src/codec/simpchinese.rs:558:18: 558:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:558:25: 558:61
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:558:40: 558:47
        _5 = ((*_1).0: codec::simpchinese::hz::State); // scope 0 at src/codec/simpchinese.rs:558:40: 558:47
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:558:49: 558:55
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:558:49: 558:55
        _7 = &mut (*_2);                 // scope 0 at src/codec/simpchinese.rs:558:49: 558:55
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:558:49: 558:55
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:558:54: 558:55
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
        StorageLive(_9);                 // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
        _11 = const <HZDecoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<HZDecoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:558:57: 558:60
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:514 ~ encoding[5d2c]::codec::simpchinese::{impl#13}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
        _8 = _9;                         // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
        _4 = hz::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/simpchinese.rs:558:25: 558:61
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:558:25: 558:39
                                         // + literal: Const { ty: for<'r, 's> fn(codec::simpchinese::hz::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::simpchinese::hz::State, std::option::Option<encoding_types::CodecError>) {codec::simpchinese::hz::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:558:60: 558:61
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:558:60: 558:61
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:558:60: 558:61
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:558:14: 558:16
        _3 = (_4.0: codec::simpchinese::hz::State); // scope 0 at src/codec/simpchinese.rs:558:14: 558:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/simpchinese.rs:558:18: 558:21
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:558:61: 558:62
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:558:61: 558:62
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:559:19: 559:21
        _10 = _3;                        // scope 1 at src/codec/simpchinese.rs:559:19: 559:21
        ((*_1).0: codec::simpchinese::hz::State) = move _10; // scope 1 at src/codec/simpchinese.rs:559:9: 559:21
        StorageDead(_10);                // scope 1 at src/codec/simpchinese.rs:559:20: 559:21
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:561:5: 561:6
        return;                          // scope 0 at src/codec/simpchinese.rs:561:6: 561:6
    }
}

promoted[0] in simpchinese::<impl at src/codec/simpchinese.rs:547:1: 562:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/simpchinese.rs:558:57: 558:60
    let mut _1: ();                      // in scope 0 at src/codec/simpchinese.rs:558:58: 558:60

    bb0: {
        nop;                             // scope 0 at src/codec/simpchinese.rs:558:58: 558:60
        _0 = &_1;                        // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
        return;                          // scope 0 at src/codec/simpchinese.rs:558:57: 558:60
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:69:1: 97:2>::raw_feed(_1: &mut ASCIIDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:73:17: 73:26
    debug input => _2;                   // in scope 0 at src/codec/ascii.rs:73:28: 73:33
    debug output => _3;                  // in scope 0 at src/codec/ascii.rs:73:42: 73:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/ascii.rs:73:72: 73:99
    let _4: ();                          // in scope 0 at src/codec/ascii.rs:74:9: 74:40
    let mut _5: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/ascii.rs:74:9: 74:15
    let mut _6: usize;                   // in scope 0 at src/codec/ascii.rs:74:28: 74:39
    let mut _7: &[u8];                   // in scope 0 at src/codec/ascii.rs:74:28: 74:33
    let mut _8: std::option::Option<usize>; // in scope 0 at src/codec/ascii.rs:80:15: 80:54
    let mut _9: &mut std::slice::Iter<u8>; // in scope 0 at src/codec/ascii.rs:80:15: 80:27
    let mut _10: std::slice::Iter<u8>;   // in scope 0 at src/codec/ascii.rs:80:15: 80:27
    let mut _11: &[u8];                  // in scope 0 at src/codec/ascii.rs:80:15: 80:20
    let mut _12: [closure@src/codec/ascii.rs:80:37: 80:53]; // in scope 0 at src/codec/ascii.rs:80:37: 80:53
    let mut _13: isize;                  // in scope 0 at src/codec/ascii.rs:81:13: 81:30
    let _14: usize;                      // in scope 0 at src/codec/ascii.rs:81:18: 81:29
    let _15: ();                         // in scope 0 at src/codec/ascii.rs:82:17: 82:65
    let mut _16: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/ascii.rs:82:35: 82:41
    let mut _17: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/ascii.rs:82:35: 82:41
    let mut _18: &[u8];                  // in scope 0 at src/codec/ascii.rs:82:43: 82:64
    let _19: &[u8];                      // in scope 0 at src/codec/ascii.rs:82:43: 82:64
    let _20: &[u8];                      // in scope 0 at src/codec/ascii.rs:82:44: 82:64
    let mut _21: &[u8];                  // in scope 0 at src/codec/ascii.rs:82:44: 82:49
    let mut _22: std::ops::RangeTo<usize>; // in scope 0 at src/codec/ascii.rs:82:50: 82:63
    let mut _23: usize;                  // in scope 0 at src/codec/ascii.rs:82:52: 82:63
    let mut _24: usize;                  // in scope 0 at src/codec/ascii.rs:83:18: 83:29
    let mut _25: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/ascii.rs:83:31: 85:19
    let mut _26: encoding_types::CodecError; // in scope 0 at src/codec/ascii.rs:83:36: 85:18
    let mut _27: isize;                  // in scope 0 at src/codec/ascii.rs:84:27: 84:51
    let mut _28: isize;                  // in scope 0 at src/codec/ascii.rs:84:27: 84:47
    let mut _29: usize;                  // in scope 0 at src/codec/ascii.rs:84:27: 84:38
    let mut _30: std::borrow::Cow<str>;  // in scope 0 at src/codec/ascii.rs:84:60: 84:85
    let mut _31: &str;                   // in scope 0 at src/codec/ascii.rs:84:60: 84:78
    let _32: &str;                       // in scope 0 at src/codec/ascii.rs:84:60: 84:78
    let _33: ();                         // in scope 0 at src/codec/ascii.rs:88:17: 88:49
    let mut _34: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/ascii.rs:88:35: 88:41
    let mut _35: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/ascii.rs:88:35: 88:41
    let mut _36: &[u8];                  // in scope 0 at src/codec/ascii.rs:88:43: 88:48
    let mut _37: usize;                  // in scope 0 at src/codec/ascii.rs:89:18: 89:29
    let mut _38: &[u8];                  // in scope 0 at src/codec/ascii.rs:89:18: 89:23
    let mut _39: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/ascii.rs:89:31: 89:35
    scope 1 {
        debug first_error => _14;        // in scope 1 at src/codec/ascii.rs:81:18: 81:29
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/ascii.rs:74:9: 74:40
        StorageLive(_5);                 // scope 0 at src/codec/ascii.rs:74:9: 74:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/ascii.rs:74:9: 74:15
        StorageLive(_6);                 // scope 0 at src/codec/ascii.rs:74:28: 74:39
        StorageLive(_7);                 // scope 0 at src/codec/ascii.rs:74:28: 74:33
        _7 = _2;                         // scope 0 at src/codec/ascii.rs:74:28: 74:33
        _6 = Len((*_7));                 // scope 0 at src/codec/ascii.rs:74:28: 74:39
        StorageDead(_7);                 // scope 0 at src/codec/ascii.rs:74:38: 74:39
        _4 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _5, move _6) -> bb1; // scope 0 at src/codec/ascii.rs:74:9: 74:40
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:74:16: 74:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 0 at src/codec/ascii.rs:74:39: 74:40
        StorageDead(_5);                 // scope 0 at src/codec/ascii.rs:74:39: 74:40
        StorageDead(_4);                 // scope 0 at src/codec/ascii.rs:74:40: 74:41
        StorageLive(_8);                 // scope 0 at src/codec/ascii.rs:80:15: 80:54
        StorageLive(_9);                 // scope 0 at src/codec/ascii.rs:80:15: 80:27
        StorageLive(_10);                // scope 0 at src/codec/ascii.rs:80:15: 80:27
        StorageLive(_11);                // scope 0 at src/codec/ascii.rs:80:15: 80:20
        _11 = _2;                        // scope 0 at src/codec/ascii.rs:80:15: 80:20
        _10 = core::slice::<impl [u8]>::iter(move _11) -> bb2; // scope 0 at src/codec/ascii.rs:80:15: 80:27
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:80:21: 80:25
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> std::slice::Iter<'r, u8> {core::slice::<impl [u8]>::iter}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _9 = &mut _10;                   // scope 0 at src/codec/ascii.rs:80:15: 80:27
        StorageDead(_11);                // scope 0 at src/codec/ascii.rs:80:26: 80:27
        StorageLive(_12);                // scope 0 at src/codec/ascii.rs:80:37: 80:53
        _8 = <std::slice::Iter<u8> as Iterator>::position::<[closure@src/codec/ascii.rs:80:37: 80:53]>(move _9, move _12) -> bb3; // scope 0 at src/codec/ascii.rs:80:15: 80:54
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:80:28: 80:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::slice::Iter<u8>, [closure@src/codec/ascii.rs:80:37: 80:53]) -> std::option::Option<usize> {<std::slice::Iter<u8> as std::iter::Iterator>::position::<[closure@src/codec/ascii.rs:80:37: 80:53]>}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_12);                // scope 0 at src/codec/ascii.rs:80:53: 80:54
        StorageDead(_9);                 // scope 0 at src/codec/ascii.rs:80:53: 80:54
        _13 = discriminant(_8);          // scope 0 at src/codec/ascii.rs:80:15: 80:54
        switchInt(move _13) -> [0_isize: bb4, 1_isize: bb6, otherwise: bb5]; // scope 0 at src/codec/ascii.rs:80:9: 80:54
    }

    bb4: {
        StorageLive(_33);                // scope 0 at src/codec/ascii.rs:88:17: 88:49
        StorageLive(_34);                // scope 0 at src/codec/ascii.rs:88:35: 88:41
        StorageLive(_35);                // scope 0 at src/codec/ascii.rs:88:35: 88:41
        _35 = &mut (*_3);                // scope 0 at src/codec/ascii.rs:88:35: 88:41
        _34 = move _35 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:88:35: 88:41
        StorageDead(_35);                // scope 0 at src/codec/ascii.rs:88:40: 88:41
        StorageLive(_36);                // scope 0 at src/codec/ascii.rs:88:43: 88:48
        _36 = _2;                        // scope 0 at src/codec/ascii.rs:88:43: 88:48
        _33 = write_ascii_bytes(move _34, move _36) -> bb10; // scope 0 at src/codec/ascii.rs:88:17: 88:49
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:88:17: 88:34
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut (dyn encoding_types::StringWriter + 'r), &'s [u8]) {<codec::ascii::ASCIIDecoder as encoding_types::RawDecoder>::raw_feed::write_ascii_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        unreachable;                     // scope 0 at src/codec/ascii.rs:80:15: 80:54
    }

    bb6: {
        StorageLive(_14);                // scope 0 at src/codec/ascii.rs:81:18: 81:29
        _14 = ((_8 as Some).0: usize);   // scope 0 at src/codec/ascii.rs:81:18: 81:29
        StorageLive(_15);                // scope 1 at src/codec/ascii.rs:82:17: 82:65
        StorageLive(_16);                // scope 1 at src/codec/ascii.rs:82:35: 82:41
        StorageLive(_17);                // scope 1 at src/codec/ascii.rs:82:35: 82:41
        _17 = &mut (*_3);                // scope 1 at src/codec/ascii.rs:82:35: 82:41
        _16 = move _17 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 1 at src/codec/ascii.rs:82:35: 82:41
        StorageDead(_17);                // scope 1 at src/codec/ascii.rs:82:40: 82:41
        StorageLive(_18);                // scope 1 at src/codec/ascii.rs:82:43: 82:64
        StorageLive(_19);                // scope 1 at src/codec/ascii.rs:82:43: 82:64
        StorageLive(_20);                // scope 1 at src/codec/ascii.rs:82:44: 82:64
        StorageLive(_21);                // scope 1 at src/codec/ascii.rs:82:44: 82:49
        _21 = _2;                        // scope 1 at src/codec/ascii.rs:82:44: 82:49
        StorageLive(_22);                // scope 1 at src/codec/ascii.rs:82:50: 82:63
        StorageLive(_23);                // scope 1 at src/codec/ascii.rs:82:52: 82:63
        _23 = _14;                       // scope 1 at src/codec/ascii.rs:82:52: 82:63
        (_22.0: usize) = move _23;       // scope 1 at src/codec/ascii.rs:82:50: 82:63
        StorageDead(_23);                // scope 1 at src/codec/ascii.rs:82:62: 82:63
        _20 = <[u8] as Index<RangeTo<usize>>>::index(move _21, move _22) -> bb7; // scope 1 at src/codec/ascii.rs:82:44: 82:64
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:82:44: 82:64
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], std::ops::RangeTo<usize>) -> &'r <[u8] as std::ops::Index<std::ops::RangeTo<usize>>>::Output {<[u8] as std::ops::Index<std::ops::RangeTo<usize>>>::index}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_22);                // scope 1 at src/codec/ascii.rs:82:63: 82:64
        StorageDead(_21);                // scope 1 at src/codec/ascii.rs:82:63: 82:64
        _19 = _20;                       // scope 1 at src/codec/ascii.rs:82:43: 82:64
        _18 = _19;                       // scope 1 at src/codec/ascii.rs:82:43: 82:64
        _15 = write_ascii_bytes(move _16, move _18) -> bb8; // scope 1 at src/codec/ascii.rs:82:17: 82:65
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:82:17: 82:34
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut (dyn encoding_types::StringWriter + 'r), &'s [u8]) {<codec::ascii::ASCIIDecoder as encoding_types::RawDecoder>::raw_feed::write_ascii_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_18);                // scope 1 at src/codec/ascii.rs:82:64: 82:65
        StorageDead(_16);                // scope 1 at src/codec/ascii.rs:82:64: 82:65
        StorageDead(_20);                // scope 1 at src/codec/ascii.rs:82:65: 82:66
        StorageDead(_19);                // scope 1 at src/codec/ascii.rs:82:65: 82:66
        StorageDead(_15);                // scope 1 at src/codec/ascii.rs:82:65: 82:66
        StorageLive(_24);                // scope 1 at src/codec/ascii.rs:83:18: 83:29
        _24 = _14;                       // scope 1 at src/codec/ascii.rs:83:18: 83:29
        StorageLive(_25);                // scope 1 at src/codec/ascii.rs:83:31: 85:19
        StorageLive(_26);                // scope 1 at src/codec/ascii.rs:83:36: 85:18
        StorageLive(_27);                // scope 1 at src/codec/ascii.rs:84:27: 84:51
        StorageLive(_28);                // scope 1 at src/codec/ascii.rs:84:27: 84:47
        StorageLive(_29);                // scope 1 at src/codec/ascii.rs:84:27: 84:38
        _29 = _14;                       // scope 1 at src/codec/ascii.rs:84:27: 84:38
        _28 = move _29 as isize (Misc);  // scope 1 at src/codec/ascii.rs:84:27: 84:47
        StorageDead(_29);                // scope 1 at src/codec/ascii.rs:84:46: 84:47
        _27 = Add(move _28, const 1_isize); // scope 1 at src/codec/ascii.rs:84:27: 84:51
        StorageDead(_28);                // scope 1 at src/codec/ascii.rs:84:50: 84:51
        StorageLive(_30);                // scope 1 at src/codec/ascii.rs:84:60: 84:85
        StorageLive(_31);                // scope 1 at src/codec/ascii.rs:84:60: 84:78
        StorageLive(_32);                // scope 1 at src/codec/ascii.rs:84:60: 84:78
        _32 = const "invalid sequence";  // scope 1 at src/codec/ascii.rs:84:60: 84:78
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:84:60: 84:78
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _31 = _32;                       // scope 1 at src/codec/ascii.rs:84:60: 84:78
        _30 = <&str as Into<Cow<str>>>::into(move _31) -> bb9; // scope 1 at src/codec/ascii.rs:84:60: 84:85
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:84:79: 84:83
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_31);                // scope 1 at src/codec/ascii.rs:84:84: 84:85
        (_26.0: isize) = move _27;       // scope 1 at src/codec/ascii.rs:83:36: 85:18
        (_26.1: std::borrow::Cow<str>) = move _30; // scope 1 at src/codec/ascii.rs:83:36: 85:18
        StorageDead(_30);                // scope 1 at src/codec/ascii.rs:85:17: 85:18
        StorageDead(_27);                // scope 1 at src/codec/ascii.rs:85:17: 85:18
        ((_25 as Some).0: encoding_types::CodecError) = move _26; // scope 1 at src/codec/ascii.rs:83:31: 85:19
        discriminant(_25) = 1;           // scope 1 at src/codec/ascii.rs:83:31: 85:19
        StorageDead(_26);                // scope 1 at src/codec/ascii.rs:85:18: 85:19
        (_0.0: usize) = move _24;        // scope 1 at src/codec/ascii.rs:83:17: 85:20
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _25; // scope 1 at src/codec/ascii.rs:83:17: 85:20
        StorageDead(_25);                // scope 1 at src/codec/ascii.rs:85:19: 85:20
        StorageDead(_24);                // scope 1 at src/codec/ascii.rs:85:19: 85:20
        StorageDead(_32);                // scope 1 at src/codec/ascii.rs:86:13: 86:14
        StorageDead(_14);                // scope 0 at src/codec/ascii.rs:86:13: 86:14
        goto -> bb11;                    // scope 0 at src/codec/ascii.rs:86:13: 86:14
    }

    bb10: {
        StorageDead(_36);                // scope 0 at src/codec/ascii.rs:88:48: 88:49
        StorageDead(_34);                // scope 0 at src/codec/ascii.rs:88:48: 88:49
        StorageDead(_33);                // scope 0 at src/codec/ascii.rs:88:49: 88:50
        StorageLive(_37);                // scope 0 at src/codec/ascii.rs:89:18: 89:29
        StorageLive(_38);                // scope 0 at src/codec/ascii.rs:89:18: 89:23
        _38 = _2;                        // scope 0 at src/codec/ascii.rs:89:18: 89:23
        _37 = Len((*_38));               // scope 0 at src/codec/ascii.rs:89:18: 89:29
        StorageDead(_38);                // scope 0 at src/codec/ascii.rs:89:28: 89:29
        StorageLive(_39);                // scope 0 at src/codec/ascii.rs:89:31: 89:35
        discriminant(_39) = 0;           // scope 0 at src/codec/ascii.rs:89:31: 89:35
        (_0.0: usize) = move _37;        // scope 0 at src/codec/ascii.rs:89:17: 89:36
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _39; // scope 0 at src/codec/ascii.rs:89:17: 89:36
        StorageDead(_39);                // scope 0 at src/codec/ascii.rs:89:35: 89:36
        StorageDead(_37);                // scope 0 at src/codec/ascii.rs:89:35: 89:36
        goto -> bb11;                    // scope 0 at src/codec/ascii.rs:89:35: 89:36
    }

    bb11: {
        StorageDead(_10);                // scope 0 at src/codec/ascii.rs:92:5: 92:6
        StorageDead(_8);                 // scope 0 at src/codec/ascii.rs:92:5: 92:6
        return;                          // scope 0 at src/codec/ascii.rs:92:6: 92:6
    }
}

fn bigfive2003::start::S0(_1: &mut StatefulDecoderHelper<bigfive2003::State, T>) -> bigfive2003::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/tradchinese.rs:129:18: 129:29
    let mut _7: bool;                    // in scope 0 at src/codec/tradchinese.rs:129:18: 129:29
    let mut _8: bool;                    // in scope 0 at src/codec/tradchinese.rs:128:18: 128:29
    let mut _9: bool;                    // in scope 0 at src/codec/tradchinese.rs:128:18: 128:29
    let mut _11: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:128:33: 128:36
    let mut _12: u32;                    // in scope 0 at src/codec/tradchinese.rs:128:42: 128:50
    let mut _13: u8;                     // in scope 0 at src/codec/tradchinese.rs:128:42: 128:43
    let mut _15: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:129:36: 129:39
    let mut _16: u8;                     // in scope 0 at src/codec/tradchinese.rs:129:41: 129:42
    let mut _17: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:130:19: 130:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _10: u8;                     // in scope 1 at src/codec/tradchinese.rs:128:14: 128:29
        let _14: u8;                     // in scope 1 at src/codec/tradchinese.rs:129:14: 129:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/tradchinese.rs:128:14: 128:29
        }
        scope 3 {
            debug b => _14;              // in scope 3 at src/codec/tradchinese.rs:129:14: 129:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<bigfive2003::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        _8 = Le(const 0_u8, _5);         // scope 1 at src/codec/tradchinese.rs:128:18: 128:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/tradchinese.rs:128:18: 128:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb15;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _9 = Le(_5, const 127_u8);       // scope 1 at src/codec/tradchinese.rs:128:18: 128:29
        switchInt(move _9) -> [false: bb6, otherwise: bb9]; // scope 1 at src/codec/tradchinese.rs:128:18: 128:29
    }

    bb6: {
        _6 = Le(const 129_u8, _5);       // scope 1 at src/codec/tradchinese.rs:129:18: 129:29
        switchInt(move _6) -> [false: bb8, otherwise: bb7]; // scope 1 at src/codec/tradchinese.rs:129:18: 129:29
    }

    bb7: {
        _7 = Le(_5, const 254_u8);       // scope 1 at src/codec/tradchinese.rs:129:18: 129:29
        switchInt(move _7) -> [false: bb8, otherwise: bb11]; // scope 1 at src/codec/tradchinese.rs:129:18: 129:29
    }

    bb8: {
        StorageLive(_17);                // scope 1 at src/codec/tradchinese.rs:130:19: 130:22
        _17 = &mut (*_1);                // scope 1 at src/codec/tradchinese.rs:130:19: 130:22
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::err(move _17, const "invalid sequence") -> bb13; // scope 1 at src/codec/tradchinese.rs:130:19: 130:46
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:130:23: 130:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, &'static str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:130:27: 130:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb9: {
        StorageLive(_10);                // scope 1 at src/codec/tradchinese.rs:128:14: 128:29
        _10 = _5;                        // scope 1 at src/codec/tradchinese.rs:128:14: 128:29
        StorageLive(_11);                // scope 2 at src/codec/tradchinese.rs:128:33: 128:36
        _11 = &mut (*_1);                // scope 2 at src/codec/tradchinese.rs:128:33: 128:36
        StorageLive(_12);                // scope 2 at src/codec/tradchinese.rs:128:42: 128:50
        StorageLive(_13);                // scope 2 at src/codec/tradchinese.rs:128:42: 128:43
        _13 = _10;                       // scope 2 at src/codec/tradchinese.rs:128:42: 128:43
        _12 = move _13 as u32 (Misc);    // scope 2 at src/codec/tradchinese.rs:128:42: 128:50
        StorageDead(_13);                // scope 2 at src/codec/tradchinese.rs:128:49: 128:50
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::emit(move _11, move _12) -> bb10; // scope 2 at src/codec/tradchinese.rs:128:33: 128:51
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:128:37: 128:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, u32) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_12);                // scope 2 at src/codec/tradchinese.rs:128:50: 128:51
        StorageDead(_11);                // scope 2 at src/codec/tradchinese.rs:128:50: 128:51
        StorageDead(_10);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb14;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb11: {
        StorageLive(_14);                // scope 1 at src/codec/tradchinese.rs:129:14: 129:29
        _14 = _5;                        // scope 1 at src/codec/tradchinese.rs:129:14: 129:29
        StorageLive(_15);                // scope 3 at src/codec/tradchinese.rs:129:36: 129:39
        _15 = &mut (*_1);                // scope 3 at src/codec/tradchinese.rs:129:36: 129:39
        StorageLive(_16);                // scope 3 at src/codec/tradchinese.rs:129:41: 129:42
        _16 = _14;                       // scope 3 at src/codec/tradchinese.rs:129:41: 129:42
        _0 = bigfive2003::transient::S1::<T>(move _15, move _16) -> bb12; // scope 3 at src/codec/tradchinese.rs:129:33: 129:43
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:129:33: 129:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::tradchinese::bigfive2003::State, T>, u8) -> codec::tradchinese::bigfive2003::State {codec::tradchinese::bigfive2003::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_16);                // scope 3 at src/codec/tradchinese.rs:129:42: 129:43
        StorageDead(_15);                // scope 3 at src/codec/tradchinese.rs:129:42: 129:43
        StorageDead(_14);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb14;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb13: {
        StorageDead(_17);                // scope 1 at src/codec/tradchinese.rs:130:45: 130:46
        goto -> bb14;                    // scope 1 at src/codec/tradchinese.rs:130:45: 130:46
    }

    bb14: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb15;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb15: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

fn simpchinese::gb18030::transient::S3(_1: &mut StatefulDecoderHelper<simpchinese::gb18030::State, T>, _2: u8, _3: u8, _4: u8) -> simpchinese::gb18030::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug first => _2;                   // in scope 0 at src/util.rs:223:61: 223:65
    debug second => _3;                  // in scope 0 at src/util.rs:223:61: 223:65
    debug third => _4;                   // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _5: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _6: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _7: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _8: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let mut _9: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let mut _10: u8;                     // in scope 0 at src/util.rs:225:55: 225:59
    let _11: u8;                         // in scope 0 at src/util.rs:226:34: 226:35
    let mut _12: bool;                   // in scope 0 at src/codec/simpchinese.rs:236:18: 236:29
    let mut _13: bool;                   // in scope 0 at src/codec/simpchinese.rs:236:18: 236:29
    let mut _15: u32;                    // in scope 0 at src/codec/simpchinese.rs:236:39: 236:78
    let mut _16: u8;                     // in scope 0 at src/codec/simpchinese.rs:236:54: 236:59
    let mut _17: u8;                     // in scope 0 at src/codec/simpchinese.rs:236:61: 236:67
    let mut _18: u8;                     // in scope 0 at src/codec/simpchinese.rs:236:69: 236:74
    let mut _19: u8;                     // in scope 0 at src/codec/simpchinese.rs:236:76: 236:77
    let mut _20: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:237:27: 237:30
    let mut _22: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:238:19: 238:22
    let mut _23: u32;                    // in scope 0 at src/codec/simpchinese.rs:238:28: 238:30
    let mut _24: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/codec/simpchinese.rs:240:19: 240:22
    scope 1 {
        debug c => _11;                  // in scope 1 at src/util.rs:226:34: 226:35
        let _14: u8;                     // in scope 1 at src/codec/simpchinese.rs:236:14: 236:29
        scope 2 {
            debug b => _14;              // in scope 2 at src/codec/simpchinese.rs:236:14: 236:29
            let _21: u32;                // in scope 2 at src/codec/simpchinese.rs:238:13: 238:15
            scope 3 {
                debug ch => _21;         // in scope 3 at src/codec/simpchinese.rs:238:13: 238:15
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_6);                 // scope 0 at src/util.rs:224:31: 224:38
        _6 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _5 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::read(move _6) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 0 at src/util.rs:224:44: 224:45
        _7 = discriminant(_5);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _7) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_11);                // scope 0 at src/util.rs:226:34: 226:35
        _11 = ((_5 as Some).0: u8);      // scope 0 at src/util.rs:226:34: 226:35
        _12 = Le(const 48_u8, _11);      // scope 1 at src/codec/simpchinese.rs:236:18: 236:29
        switchInt(move _12) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/simpchinese.rs:236:18: 236:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_8);                 // scope 0 at src/util.rs:225:55: 225:59
        _8 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        StorageLive(_9);                 // scope 0 at src/util.rs:225:55: 225:59
        _9 = _3;                         // scope 0 at src/util.rs:225:55: 225:59
        StorageLive(_10);                // scope 0 at src/util.rs:225:55: 225:59
        _10 = _4;                        // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S3).1: u8) = move _8;    // scope 0 at src/util.rs:225:44: 225:62
        ((_0 as S3).2: u8) = move _9;    // scope 0 at src/util.rs:225:44: 225:62
        ((_0 as S3).3: u8) = move _10;   // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 3;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_10);                // scope 0 at src/util.rs:225:61: 225:62
        StorageDead(_9);                 // scope 0 at src/util.rs:225:61: 225:62
        StorageDead(_8);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb16;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _13 = Le(_11, const 57_u8);      // scope 1 at src/codec/simpchinese.rs:236:18: 236:29
        switchInt(move _13) -> [false: bb6, otherwise: bb7]; // scope 1 at src/codec/simpchinese.rs:236:18: 236:29
    }

    bb6: {
        StorageLive(_24);                // scope 1 at src/codec/simpchinese.rs:240:19: 240:22
        _24 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:240:19: 240:22
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::backup_and_err(move _24, const 3_usize, const "invalid sequence") -> bb14; // scope 1 at src/codec/simpchinese.rs:240:19: 240:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:240:23: 240:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, usize, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:240:41: 240:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb7: {
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:236:14: 236:29
        _14 = _11;                       // scope 1 at src/codec/simpchinese.rs:236:14: 236:29
        StorageLive(_15);                // scope 2 at src/codec/simpchinese.rs:236:39: 236:78
        StorageLive(_16);                // scope 2 at src/codec/simpchinese.rs:236:54: 236:59
        _16 = _2;                        // scope 2 at src/codec/simpchinese.rs:236:54: 236:59
        StorageLive(_17);                // scope 2 at src/codec/simpchinese.rs:236:61: 236:67
        _17 = _3;                        // scope 2 at src/codec/simpchinese.rs:236:61: 236:67
        StorageLive(_18);                // scope 2 at src/codec/simpchinese.rs:236:69: 236:74
        _18 = _4;                        // scope 2 at src/codec/simpchinese.rs:236:69: 236:74
        StorageLive(_19);                // scope 2 at src/codec/simpchinese.rs:236:76: 236:77
        _19 = _14;                       // scope 2 at src/codec/simpchinese.rs:236:76: 236:77
        _15 = simpchinese::gb18030::internal::map_four_bytes(move _16, move _17, move _18, move _19) -> bb8; // scope 2 at src/codec/simpchinese.rs:236:39: 236:78
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:236:39: 236:53
                                         // + literal: Const { ty: fn(u8, u8, u8, u8) -> u32 {codec::simpchinese::gb18030::internal::map_four_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_19);                // scope 2 at src/codec/simpchinese.rs:236:77: 236:78
        StorageDead(_18);                // scope 2 at src/codec/simpchinese.rs:236:77: 236:78
        StorageDead(_17);                // scope 2 at src/codec/simpchinese.rs:236:77: 236:78
        StorageDead(_16);                // scope 2 at src/codec/simpchinese.rs:236:77: 236:78
        switchInt(_15) -> [u32::MAX: bb10, otherwise: bb9]; // scope 2 at src/codec/simpchinese.rs:236:33: 236:78
    }

    bb9: {
        StorageLive(_21);                // scope 2 at src/codec/simpchinese.rs:238:13: 238:15
        _21 = _15;                       // scope 2 at src/codec/simpchinese.rs:238:13: 238:15
        StorageLive(_22);                // scope 3 at src/codec/simpchinese.rs:238:19: 238:22
        _22 = &mut (*_1);                // scope 3 at src/codec/simpchinese.rs:238:19: 238:22
        StorageLive(_23);                // scope 3 at src/codec/simpchinese.rs:238:28: 238:30
        _23 = _21;                       // scope 3 at src/codec/simpchinese.rs:238:28: 238:30
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::emit(move _22, move _23) -> bb12; // scope 3 at src/codec/simpchinese.rs:238:19: 238:31
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:238:23: 238:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, u32) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageLive(_20);                // scope 2 at src/codec/simpchinese.rs:237:27: 237:30
        _20 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:237:27: 237:30
        _0 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::backup_and_err(move _20, const 3_usize, const "invalid sequence") -> bb11; // scope 2 at src/codec/simpchinese.rs:237:27: 237:68
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:237:31: 237:45
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, usize, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:237:49: 237:67
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb11: {
        StorageDead(_20);                // scope 2 at src/codec/simpchinese.rs:237:67: 237:68
        goto -> bb13;                    // scope 2 at src/codec/simpchinese.rs:237:67: 237:68
    }

    bb12: {
        StorageDead(_23);                // scope 3 at src/codec/simpchinese.rs:238:30: 238:31
        StorageDead(_22);                // scope 3 at src/codec/simpchinese.rs:238:30: 238:31
        StorageDead(_21);                // scope 2 at src/codec/simpchinese.rs:238:30: 238:31
        goto -> bb13;                    // scope 2 at src/codec/simpchinese.rs:238:30: 238:31
    }

    bb13: {
        StorageDead(_15);                // scope 2 at src/util.rs:226:77: 226:78
        StorageDead(_14);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb15;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb14: {
        StorageDead(_24);                // scope 1 at src/codec/simpchinese.rs:240:59: 240:60
        goto -> bb15;                    // scope 1 at src/codec/simpchinese.rs:240:59: 240:60
    }

    bb15: {
        StorageDead(_11);                // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb16;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb16: {
        StorageDead(_5);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

const WINDOWS_1253: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:62:68: 62:82
    let _5: &str;                        // in scope 0 at src/all.rs:62:68: 62:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1253::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1253, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1270 ~ encoding[5d2c]::all::WINDOWS_1253), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1253: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:62:68: 62:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:62:68: 62:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1253";       // scope 0 at src/all.rs:62:68: 62:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:62:68: 62:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:62:68: 62:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1253::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1253::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1253::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1253::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1253"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:62:68: 62:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 51], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_feed(_1: &mut ISO2022JPEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:802:17: 802:26
    debug input => _2;                   // in scope 0 at src/codec/japanese.rs:802:28: 802:33
    debug output => _3;                  // in scope 0 at src/codec/japanese.rs:802:41: 802:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/japanese.rs:802:69: 802:96
    let _4: ();                          // in scope 0 at src/codec/japanese.rs:803:9: 803:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:803:9: 803:15
    let mut _6: usize;                   // in scope 0 at src/codec/japanese.rs:803:28: 803:39
    let mut _7: &str;                    // in scope 0 at src/codec/japanese.rs:803:28: 803:33
    let mut _8: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:805:13: 805:19
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:816:28: 816:46
    let mut _10: util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:816:28: 816:46
    let mut _11: &&str;                  // in scope 0 at src/codec/japanese.rs:816:28: 816:33
    let mut _14: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/japanese.rs:816:28: 816:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:816:28: 816:46
    let mut _16: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/japanese.rs:816:28: 816:46
    let mut _17: isize;                  // in scope 0 at src/codec/japanese.rs:816:13: 816:24
    let mut _19: ((usize, usize), char); // in scope 0 at src/codec/japanese.rs:816:13: 816:24
    let mut _23: bool;                   // in scope 0 at src/codec/japanese.rs:821:17: 821:40
    let mut _24: bool;                   // in scope 0 at src/codec/japanese.rs:821:17: 821:40
    let mut _25: bool;                   // in scope 0 at src/codec/japanese.rs:818:17: 818:35
    let mut _26: bool;                   // in scope 0 at src/codec/japanese.rs:818:17: 818:35
    let mut _27: bool;                   // in scope 0 at src/codec/japanese.rs:807:23: 807:34
    let mut _28: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:23: 807:25
    let mut _29: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:29: 807:34
    let _30: ();                         // in scope 0 at src/codec/japanese.rs:807:37: 807:66
    let mut _31: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:807:37: 807:43
    let mut _32: &[u8];                  // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let mut _33: &[u8; 3];               // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let _34: &[u8; 3];                   // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let mut _35: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:73: 807:78
    let _36: ();                         // in scope 0 at src/codec/japanese.rs:818:58: 818:85
    let mut _37: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:818:58: 818:64
    let mut _38: u8;                     // in scope 0 at src/codec/japanese.rs:818:76: 818:84
    let mut _39: char;                   // in scope 0 at src/codec/japanese.rs:818:76: 818:78
    let mut _40: bool;                   // in scope 0 at src/codec/japanese.rs:807:23: 807:34
    let mut _41: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:23: 807:25
    let mut _42: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:29: 807:34
    let _43: ();                         // in scope 0 at src/codec/japanese.rs:807:37: 807:66
    let mut _44: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:807:37: 807:43
    let mut _45: &[u8];                  // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let mut _46: &[u8; 3];               // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let _47: &[u8; 3];                   // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let mut _48: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:73: 807:78
    let _49: ();                         // in scope 0 at src/codec/japanese.rs:819:48: 819:71
    let mut _50: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:819:48: 819:54
    let mut _51: bool;                   // in scope 0 at src/codec/japanese.rs:807:23: 807:34
    let mut _52: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:23: 807:25
    let mut _53: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:29: 807:34
    let _54: ();                         // in scope 0 at src/codec/japanese.rs:807:37: 807:66
    let mut _55: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:807:37: 807:43
    let mut _56: &[u8];                  // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let mut _57: &[u8; 3];               // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let _58: &[u8; 3];                   // in scope 0 at src/codec/japanese.rs:807:56: 807:65
    let mut _59: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:73: 807:78
    let _60: ();                         // in scope 0 at src/codec/japanese.rs:820:50: 820:73
    let mut _61: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:820:50: 820:56
    let mut _62: bool;                   // in scope 0 at src/codec/japanese.rs:810:23: 810:37
    let mut _63: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:810:23: 810:25
    let mut _64: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:810:29: 810:37
    let _65: ();                         // in scope 0 at src/codec/japanese.rs:810:40: 810:69
    let mut _66: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:810:40: 810:46
    let mut _67: &[u8];                  // in scope 0 at src/codec/japanese.rs:810:59: 810:68
    let mut _68: &[u8; 3];               // in scope 0 at src/codec/japanese.rs:810:59: 810:68
    let _69: &[u8; 3];                   // in scope 0 at src/codec/japanese.rs:810:59: 810:68
    let mut _70: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:810:76: 810:84
    let _71: ();                         // in scope 0 at src/codec/japanese.rs:823:21: 823:75
    let mut _72: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:823:21: 823:27
    let mut _73: u8;                     // in scope 0 at src/codec/japanese.rs:823:39: 823:74
    let mut _74: usize;                  // in scope 0 at src/codec/japanese.rs:823:39: 823:68
    let mut _75: usize;                  // in scope 0 at src/codec/japanese.rs:823:40: 823:60
    let mut _76: usize;                  // in scope 0 at src/codec/japanese.rs:823:40: 823:51
    let mut _77: char;                   // in scope 0 at src/codec/japanese.rs:823:40: 823:42
    let mut _79: u32;                    // in scope 0 at src/codec/japanese.rs:826:56: 826:65
    let mut _80: char;                   // in scope 0 at src/codec/japanese.rs:826:56: 826:58
    let mut _81: u16;                    // in scope 0 at src/codec/japanese.rs:827:24: 827:27
    let mut _82: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:828:35: 828:37
    let mut _83: usize;                  // in scope 0 at src/codec/japanese.rs:829:33: 829:34
    let mut _84: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:829:36: 831:27
    let mut _85: encoding_types::CodecError; // in scope 0 at src/codec/japanese.rs:829:41: 831:26
    let mut _86: isize;                  // in scope 0 at src/codec/japanese.rs:830:35: 830:45
    let mut _87: usize;                  // in scope 0 at src/codec/japanese.rs:830:35: 830:36
    let mut _88: std::borrow::Cow<str>;  // in scope 0 at src/codec/japanese.rs:830:54: 830:88
    let mut _89: &str;                   // in scope 0 at src/codec/japanese.rs:830:54: 830:81
    let _90: &str;                       // in scope 0 at src/codec/japanese.rs:830:54: 830:81
    let mut _91: bool;                   // in scope 0 at src/codec/japanese.rs:813:23: 813:33
    let mut _92: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:813:23: 813:25
    let mut _93: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:813:29: 813:33
    let _94: ();                         // in scope 0 at src/codec/japanese.rs:813:36: 813:65
    let mut _95: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:813:36: 813:42
    let mut _96: &[u8];                  // in scope 0 at src/codec/japanese.rs:813:55: 813:64
    let mut _97: &[u8; 3];               // in scope 0 at src/codec/japanese.rs:813:55: 813:64
    let _98: &[u8; 3];                   // in scope 0 at src/codec/japanese.rs:813:55: 813:64
    let mut _99: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:813:72: 813:76
    let mut _101: u16;                   // in scope 0 at src/codec/japanese.rs:834:36: 834:44
    let mut _102: u16;                   // in scope 0 at src/codec/japanese.rs:834:36: 834:39
    let mut _104: u16;                   // in scope 0 at src/codec/japanese.rs:835:37: 835:45
    let mut _105: u16;                   // in scope 0 at src/codec/japanese.rs:835:37: 835:40
    let _106: ();                        // in scope 0 at src/codec/japanese.rs:836:25: 836:54
    let mut _107: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:836:25: 836:31
    let mut _108: u8;                    // in scope 0 at src/codec/japanese.rs:836:43: 836:53
    let mut _109: u16;                   // in scope 0 at src/codec/japanese.rs:836:43: 836:47
    let _110: ();                        // in scope 0 at src/codec/japanese.rs:837:25: 837:55
    let mut _111: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/japanese.rs:837:25: 837:31
    let mut _112: u8;                    // in scope 0 at src/codec/japanese.rs:837:43: 837:54
    let mut _113: u16;                   // in scope 0 at src/codec/japanese.rs:837:43: 837:48
    let mut _114: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:843:19: 843:21
    let mut _115: usize;                 // in scope 0 at src/codec/japanese.rs:844:10: 844:21
    let mut _116: &str;                  // in scope 0 at src/codec/japanese.rs:844:10: 844:15
    let mut _117: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/japanese.rs:844:23: 844:27
    scope 1 {
        debug st => _8;                  // in scope 1 at src/codec/japanese.rs:805:13: 805:19
        let mut _12: util::StrCharIndexIterator; // in scope 1 at src/codec/japanese.rs:816:28: 816:46
        scope 2 {
            debug iter => _12;           // in scope 2 at src/codec/japanese.rs:816:28: 816:46
            let mut _13: ((usize, usize), char); // in scope 2 at src/codec/japanese.rs:816:28: 816:46
            scope 3 {
                debug __next => _13;     // in scope 3 at src/codec/japanese.rs:816:28: 816:46
                let _18: ((usize, usize), char); // in scope 3 at src/codec/japanese.rs:816:13: 816:24
                let _20: usize;          // in scope 3 at src/codec/japanese.rs:816:15: 816:16
                let _21: usize;          // in scope 3 at src/codec/japanese.rs:816:17: 816:18
                let _22: char;           // in scope 3 at src/codec/japanese.rs:816:21: 816:23
                scope 4 {
                    debug val => _18;    // in scope 4 at src/codec/japanese.rs:816:13: 816:24
                }
                scope 5 {
                    debug i => _20;      // in scope 5 at src/codec/japanese.rs:816:15: 816:16
                    debug j => _21;      // in scope 5 at src/codec/japanese.rs:816:17: 816:18
                    debug ch => _22;     // in scope 5 at src/codec/japanese.rs:816:21: 816:23
                    let _78: u16;        // in scope 5 at src/codec/japanese.rs:826:25: 826:28
                    let mut _118: &codec::japanese::ISO2022JPState; // in scope 5 at src/codec/japanese.rs:807:29: 807:34
                    let mut _119: &codec::japanese::ISO2022JPState; // in scope 5 at src/codec/japanese.rs:807:29: 807:34
                    let mut _120: &codec::japanese::ISO2022JPState; // in scope 5 at src/codec/japanese.rs:810:29: 810:37
                    let mut _122: &codec::japanese::ISO2022JPState; // in scope 5 at src/codec/japanese.rs:807:29: 807:34
                    scope 6 {
                        debug ptr => _78; // in scope 6 at src/codec/japanese.rs:826:25: 826:28
                        let _100: u16;   // in scope 6 at src/codec/japanese.rs:834:29: 834:33
                        let mut _121: &codec::japanese::ISO2022JPState; // in scope 6 at src/codec/japanese.rs:813:29: 813:33
                        scope 7 {
                            debug lead => _100; // in scope 7 at src/codec/japanese.rs:834:29: 834:33
                            let _103: u16; // in scope 7 at src/codec/japanese.rs:835:29: 835:34
                            scope 8 {
                                debug trail => _103; // in scope 8 at src/codec/japanese.rs:835:29: 835:34
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:803:9: 803:40
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:803:9: 803:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/japanese.rs:803:9: 803:15
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:803:28: 803:39
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:803:28: 803:33
        _7 = _2;                         // scope 0 at src/codec/japanese.rs:803:28: 803:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/japanese.rs:803:28: 803:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:803:34: 803:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:803:38: 803:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/japanese.rs:803:9: 803:40
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:803:16: 803:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:803:39: 803:40
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:803:39: 803:40
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:803:40: 803:41
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:805:13: 805:19
        _8 = ((*_1).0: codec::japanese::ISO2022JPState); // scope 0 at src/codec/japanese.rs:805:22: 805:29
        StorageLive(_9);                 // scope 1 at src/codec/japanese.rs:816:28: 816:46
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:816:28: 816:46
        StorageLive(_11);                // scope 1 at src/codec/japanese.rs:816:28: 816:33
        _11 = &_2;                       // scope 1 at src/codec/japanese.rs:816:28: 816:33
        _10 = <&str as StrCharIndex>::index_iter(move _11) -> bb3; // scope 1 at src/codec/japanese.rs:816:28: 816:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:816:34: 816:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_11);                // scope 1 at src/codec/japanese.rs:816:45: 816:46
        _9 = <StrCharIndexIterator as IntoIterator>::into_iter(move _10) -> bb4; // scope 1 at src/codec/japanese.rs:816:28: 816:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:816:28: 816:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_10);                // scope 1 at src/codec/japanese.rs:816:45: 816:46
        StorageLive(_12);                // scope 1 at src/codec/japanese.rs:816:28: 816:46
        _12 = move _9;                   // scope 1 at src/codec/japanese.rs:816:28: 816:46
        goto -> bb5;                     // scope 2 at src/codec/japanese.rs:816:9: 841:10
    }

    bb5: {
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:816:28: 816:46
        StorageLive(_14);                // scope 3 at src/codec/japanese.rs:816:28: 816:46
        StorageLive(_15);                // scope 3 at src/codec/japanese.rs:816:28: 816:46
        StorageLive(_16);                // scope 3 at src/codec/japanese.rs:816:28: 816:46
        _16 = &mut _12;                  // scope 3 at src/codec/japanese.rs:816:28: 816:46
        _15 = &mut (*_16);               // scope 3 at src/codec/japanese.rs:816:28: 816:46
        _14 = <StrCharIndexIterator as Iterator>::next(move _15) -> bb6; // scope 3 at src/codec/japanese.rs:816:28: 816:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:816:28: 816:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_15);                // scope 3 at src/codec/japanese.rs:816:45: 816:46
        _17 = discriminant(_14);         // scope 3 at src/codec/japanese.rs:816:28: 816:46
        switchInt(move _17) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 3 at src/codec/japanese.rs:816:28: 816:46
    }

    bb7: {
        StorageDead(_16);                // scope 3 at src/codec/japanese.rs:816:45: 816:46
        StorageDead(_14);                // scope 3 at src/codec/japanese.rs:816:45: 816:46
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_9);                 // scope 1 at src/codec/japanese.rs:816:45: 816:46
        StorageLive(_114);               // scope 1 at src/codec/japanese.rs:843:19: 843:21
        _114 = _8;                       // scope 1 at src/codec/japanese.rs:843:19: 843:21
        ((*_1).0: codec::japanese::ISO2022JPState) = move _114; // scope 1 at src/codec/japanese.rs:843:9: 843:21
        StorageDead(_114);               // scope 1 at src/codec/japanese.rs:843:20: 843:21
        StorageLive(_115);               // scope 1 at src/codec/japanese.rs:844:10: 844:21
        StorageLive(_116);               // scope 1 at src/codec/japanese.rs:844:10: 844:15
        _116 = _2;                       // scope 1 at src/codec/japanese.rs:844:10: 844:15
        _115 = core::str::<impl str>::len(move _116) -> bb50; // scope 1 at src/codec/japanese.rs:844:10: 844:21
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:844:16: 844:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 3 at src/codec/japanese.rs:816:28: 816:46
    }

    bb9: {
        StorageLive(_18);                // scope 3 at src/codec/japanese.rs:816:13: 816:24
        _18 = ((_14 as Some).0: ((usize, usize), char)); // scope 3 at src/codec/japanese.rs:816:13: 816:24
        StorageLive(_19);                // scope 4 at src/codec/japanese.rs:816:13: 816:24
        _19 = _18;                       // scope 4 at src/codec/japanese.rs:816:13: 816:24
        _13 = move _19;                  // scope 4 at src/codec/japanese.rs:816:13: 816:24
        StorageDead(_19);                // scope 4 at src/codec/japanese.rs:816:23: 816:24
        StorageDead(_18);                // scope 3 at src/codec/japanese.rs:816:23: 816:24
        StorageDead(_16);                // scope 3 at src/codec/japanese.rs:816:45: 816:46
        StorageDead(_14);                // scope 3 at src/codec/japanese.rs:816:45: 816:46
        StorageLive(_20);                // scope 3 at src/codec/japanese.rs:816:15: 816:16
        _20 = ((_13.0: (usize, usize)).0: usize); // scope 3 at src/codec/japanese.rs:816:15: 816:16
        StorageLive(_21);                // scope 3 at src/codec/japanese.rs:816:17: 816:18
        _21 = ((_13.0: (usize, usize)).1: usize); // scope 3 at src/codec/japanese.rs:816:17: 816:18
        StorageLive(_22);                // scope 3 at src/codec/japanese.rs:816:21: 816:23
        _22 = (_13.1: char);             // scope 3 at src/codec/japanese.rs:816:21: 816:23
        _25 = Le(const '\u{0}', _22);    // scope 5 at src/codec/japanese.rs:818:17: 818:35
        switchInt(move _25) -> [false: bb11, otherwise: bb10]; // scope 5 at src/codec/japanese.rs:818:17: 818:35
    }

    bb10: {
        _26 = Le(_22, const '\u{7f}');   // scope 5 at src/codec/japanese.rs:818:17: 818:35
        switchInt(move _26) -> [false: bb11, otherwise: bb15]; // scope 5 at src/codec/japanese.rs:818:17: 818:35
    }

    bb11: {
        switchInt(_22) -> ['': bb21, '': bb27, otherwise: bb12]; // scope 5 at src/codec/japanese.rs:817:13: 817:21
    }

    bb12: {
        _23 = Le(const '', _22);        // scope 5 at src/codec/japanese.rs:821:17: 821:40
        switchInt(move _23) -> [false: bb14, otherwise: bb13]; // scope 5 at src/codec/japanese.rs:821:17: 821:40
    }

    bb13: {
        _24 = Le(_22, const '\u{ff9f}'); // scope 5 at src/codec/japanese.rs:821:17: 821:40
        switchInt(move _24) -> [false: bb14, otherwise: bb33]; // scope 5 at src/codec/japanese.rs:821:17: 821:40
    }

    bb14: {
        StorageLive(_78);                // scope 5 at src/codec/japanese.rs:826:25: 826:28
        StorageLive(_79);                // scope 5 at src/codec/japanese.rs:826:56: 826:65
        StorageLive(_80);                // scope 5 at src/codec/japanese.rs:826:56: 826:58
        _80 = _22;                       // scope 5 at src/codec/japanese.rs:826:56: 826:58
        _79 = move _80 as u32 (Misc);    // scope 5 at src/codec/japanese.rs:826:56: 826:65
        StorageDead(_80);                // scope 5 at src/codec/japanese.rs:826:64: 826:65
        _78 = index_japanese::jis0208::backward(move _79) -> bb39; // scope 5 at src/codec/japanese.rs:826:31: 826:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:826:31: 826:55
                                         // + literal: Const { ty: fn(u32) -> u16 {index_japanese::jis0208::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageLive(_27);                // scope 5 at src/codec/japanese.rs:807:23: 807:34
        StorageLive(_28);                // scope 5 at src/codec/japanese.rs:807:23: 807:25
        _28 = &_8;                       // scope 5 at src/codec/japanese.rs:807:23: 807:25
        StorageLive(_29);                // scope 5 at src/codec/japanese.rs:807:29: 807:34
        _122 = const <ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed::promoted[4]; // scope 5 at src/codec/japanese.rs:807:29: 807:34
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPState
                                         // + val: Unevaluated(<ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed, [], Some(promoted[4]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:29: 807:34
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPState, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:435 ~ encoding[5d2c]::codec::japanese::{impl#12}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[4]) }) }
        _29 = _122;                      // scope 5 at src/codec/japanese.rs:807:29: 807:34
        _27 = <ISO2022JPState as PartialEq>::ne(move _28, move _29) -> bb16; // scope 5 at src/codec/japanese.rs:807:23: 807:34
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:23: 807:34
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::japanese::ISO2022JPState, &'s codec::japanese::ISO2022JPState) -> bool {<codec::japanese::ISO2022JPState as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_29);                // scope 5 at src/codec/japanese.rs:807:33: 807:34
        StorageDead(_28);                // scope 5 at src/codec/japanese.rs:807:33: 807:34
        switchInt(move _27) -> [false: bb19, otherwise: bb17]; // scope 5 at src/codec/japanese.rs:807:23: 807:34
    }

    bb17: {
        StorageLive(_30);                // scope 5 at src/codec/japanese.rs:807:37: 807:66
        StorageLive(_31);                // scope 5 at src/codec/japanese.rs:807:37: 807:43
        _31 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:807:37: 807:43
        StorageLive(_32);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageLive(_33);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageLive(_34);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        _34 = const b"\x1b(B";           // scope 5 at src/codec/japanese.rs:807:56: 807:65
                                         // ty::Const
                                         // + ty: &[u8; 3]
                                         // + val: Value(Scalar(alloc7))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:56: 807:65
                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc7)) }
        _33 = _34;                       // scope 5 at src/codec/japanese.rs:807:56: 807:65
        _32 = move _33 as &[u8] (Pointer(Unsize)); // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageDead(_33);                // scope 5 at src/codec/japanese.rs:807:64: 807:65
        _30 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _31, move _32) -> bb18; // scope 5 at src/codec/japanese.rs:807:37: 807:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:44: 807:55
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb18: {
        StorageDead(_32);                // scope 5 at src/codec/japanese.rs:807:65: 807:66
        StorageDead(_31);                // scope 5 at src/codec/japanese.rs:807:65: 807:66
        StorageDead(_34);                // scope 5 at src/codec/japanese.rs:807:66: 807:67
        StorageDead(_30);                // scope 5 at src/codec/japanese.rs:807:66: 807:67
        StorageLive(_35);                // scope 5 at src/codec/japanese.rs:807:73: 807:78
        discriminant(_35) = 0;           // scope 5 at src/codec/japanese.rs:807:73: 807:78
        _8 = move _35;                   // scope 5 at src/codec/japanese.rs:807:68: 807:78
        StorageDead(_35);                // scope 5 at src/codec/japanese.rs:807:77: 807:78
        goto -> bb19;                    // scope 5 at src/codec/japanese.rs:807:20: 807:81
    }

    bb19: {
        StorageDead(_27);                // scope 5 at src/codec/japanese.rs:807:80: 807:81
        StorageLive(_36);                // scope 5 at src/codec/japanese.rs:818:58: 818:85
        StorageLive(_37);                // scope 5 at src/codec/japanese.rs:818:58: 818:64
        _37 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:818:58: 818:64
        StorageLive(_38);                // scope 5 at src/codec/japanese.rs:818:76: 818:84
        StorageLive(_39);                // scope 5 at src/codec/japanese.rs:818:76: 818:78
        _39 = _22;                       // scope 5 at src/codec/japanese.rs:818:76: 818:78
        _38 = move _39 as u8 (Misc);     // scope 5 at src/codec/japanese.rs:818:76: 818:84
        StorageDead(_39);                // scope 5 at src/codec/japanese.rs:818:83: 818:84
        _36 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _37, move _38) -> bb20; // scope 5 at src/codec/japanese.rs:818:58: 818:85
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:818:65: 818:75
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_38);                // scope 5 at src/codec/japanese.rs:818:84: 818:85
        StorageDead(_37);                // scope 5 at src/codec/japanese.rs:818:84: 818:85
        StorageDead(_36);                // scope 5 at src/codec/japanese.rs:818:85: 818:86
        goto -> bb49;                    // scope 5 at src/codec/japanese.rs:818:39: 818:88
    }

    bb21: {
        StorageLive(_40);                // scope 5 at src/codec/japanese.rs:807:23: 807:34
        StorageLive(_41);                // scope 5 at src/codec/japanese.rs:807:23: 807:25
        _41 = &_8;                       // scope 5 at src/codec/japanese.rs:807:23: 807:25
        StorageLive(_42);                // scope 5 at src/codec/japanese.rs:807:29: 807:34
        _118 = const <ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed::promoted[0]; // scope 5 at src/codec/japanese.rs:807:29: 807:34
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPState
                                         // + val: Unevaluated(<ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:29: 807:34
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPState, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:435 ~ encoding[5d2c]::codec::japanese::{impl#12}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _42 = _118;                      // scope 5 at src/codec/japanese.rs:807:29: 807:34
        _40 = <ISO2022JPState as PartialEq>::ne(move _41, move _42) -> bb22; // scope 5 at src/codec/japanese.rs:807:23: 807:34
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:23: 807:34
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::japanese::ISO2022JPState, &'s codec::japanese::ISO2022JPState) -> bool {<codec::japanese::ISO2022JPState as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb22: {
        StorageDead(_42);                // scope 5 at src/codec/japanese.rs:807:33: 807:34
        StorageDead(_41);                // scope 5 at src/codec/japanese.rs:807:33: 807:34
        switchInt(move _40) -> [false: bb25, otherwise: bb23]; // scope 5 at src/codec/japanese.rs:807:23: 807:34
    }

    bb23: {
        StorageLive(_43);                // scope 5 at src/codec/japanese.rs:807:37: 807:66
        StorageLive(_44);                // scope 5 at src/codec/japanese.rs:807:37: 807:43
        _44 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:807:37: 807:43
        StorageLive(_45);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageLive(_46);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageLive(_47);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        _47 = const b"\x1b(B";           // scope 5 at src/codec/japanese.rs:807:56: 807:65
                                         // ty::Const
                                         // + ty: &[u8; 3]
                                         // + val: Value(Scalar(alloc7))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:56: 807:65
                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc7)) }
        _46 = _47;                       // scope 5 at src/codec/japanese.rs:807:56: 807:65
        _45 = move _46 as &[u8] (Pointer(Unsize)); // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageDead(_46);                // scope 5 at src/codec/japanese.rs:807:64: 807:65
        _43 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _44, move _45) -> bb24; // scope 5 at src/codec/japanese.rs:807:37: 807:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:44: 807:55
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_45);                // scope 5 at src/codec/japanese.rs:807:65: 807:66
        StorageDead(_44);                // scope 5 at src/codec/japanese.rs:807:65: 807:66
        StorageDead(_47);                // scope 5 at src/codec/japanese.rs:807:66: 807:67
        StorageDead(_43);                // scope 5 at src/codec/japanese.rs:807:66: 807:67
        StorageLive(_48);                // scope 5 at src/codec/japanese.rs:807:73: 807:78
        discriminant(_48) = 0;           // scope 5 at src/codec/japanese.rs:807:73: 807:78
        _8 = move _48;                   // scope 5 at src/codec/japanese.rs:807:68: 807:78
        StorageDead(_48);                // scope 5 at src/codec/japanese.rs:807:77: 807:78
        goto -> bb25;                    // scope 5 at src/codec/japanese.rs:807:20: 807:81
    }

    bb25: {
        StorageDead(_40);                // scope 5 at src/codec/japanese.rs:807:80: 807:81
        StorageLive(_49);                // scope 5 at src/codec/japanese.rs:819:48: 819:71
        StorageLive(_50);                // scope 5 at src/codec/japanese.rs:819:48: 819:54
        _50 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:819:48: 819:54
        _49 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _50, const 92_u8) -> bb26; // scope 5 at src/codec/japanese.rs:819:48: 819:71
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:819:55: 819:65
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb26: {
        StorageDead(_50);                // scope 5 at src/codec/japanese.rs:819:70: 819:71
        StorageDead(_49);                // scope 5 at src/codec/japanese.rs:819:71: 819:72
        goto -> bb49;                    // scope 5 at src/codec/japanese.rs:819:29: 819:74
    }

    bb27: {
        StorageLive(_51);                // scope 5 at src/codec/japanese.rs:807:23: 807:34
        StorageLive(_52);                // scope 5 at src/codec/japanese.rs:807:23: 807:25
        _52 = &_8;                       // scope 5 at src/codec/japanese.rs:807:23: 807:25
        StorageLive(_53);                // scope 5 at src/codec/japanese.rs:807:29: 807:34
        _119 = const <ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed::promoted[1]; // scope 5 at src/codec/japanese.rs:807:29: 807:34
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPState
                                         // + val: Unevaluated(<ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed, [], Some(promoted[1]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:29: 807:34
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPState, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:435 ~ encoding[5d2c]::codec::japanese::{impl#12}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[1]) }) }
        _53 = _119;                      // scope 5 at src/codec/japanese.rs:807:29: 807:34
        _51 = <ISO2022JPState as PartialEq>::ne(move _52, move _53) -> bb28; // scope 5 at src/codec/japanese.rs:807:23: 807:34
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:23: 807:34
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::japanese::ISO2022JPState, &'s codec::japanese::ISO2022JPState) -> bool {<codec::japanese::ISO2022JPState as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb28: {
        StorageDead(_53);                // scope 5 at src/codec/japanese.rs:807:33: 807:34
        StorageDead(_52);                // scope 5 at src/codec/japanese.rs:807:33: 807:34
        switchInt(move _51) -> [false: bb31, otherwise: bb29]; // scope 5 at src/codec/japanese.rs:807:23: 807:34
    }

    bb29: {
        StorageLive(_54);                // scope 5 at src/codec/japanese.rs:807:37: 807:66
        StorageLive(_55);                // scope 5 at src/codec/japanese.rs:807:37: 807:43
        _55 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:807:37: 807:43
        StorageLive(_56);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageLive(_57);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageLive(_58);                // scope 5 at src/codec/japanese.rs:807:56: 807:65
        _58 = const b"\x1b(B";           // scope 5 at src/codec/japanese.rs:807:56: 807:65
                                         // ty::Const
                                         // + ty: &[u8; 3]
                                         // + val: Value(Scalar(alloc7))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:56: 807:65
                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc7)) }
        _57 = _58;                       // scope 5 at src/codec/japanese.rs:807:56: 807:65
        _56 = move _57 as &[u8] (Pointer(Unsize)); // scope 5 at src/codec/japanese.rs:807:56: 807:65
        StorageDead(_57);                // scope 5 at src/codec/japanese.rs:807:64: 807:65
        _54 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _55, move _56) -> bb30; // scope 5 at src/codec/japanese.rs:807:37: 807:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:807:44: 807:55
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb30: {
        StorageDead(_56);                // scope 5 at src/codec/japanese.rs:807:65: 807:66
        StorageDead(_55);                // scope 5 at src/codec/japanese.rs:807:65: 807:66
        StorageDead(_58);                // scope 5 at src/codec/japanese.rs:807:66: 807:67
        StorageDead(_54);                // scope 5 at src/codec/japanese.rs:807:66: 807:67
        StorageLive(_59);                // scope 5 at src/codec/japanese.rs:807:73: 807:78
        discriminant(_59) = 0;           // scope 5 at src/codec/japanese.rs:807:73: 807:78
        _8 = move _59;                   // scope 5 at src/codec/japanese.rs:807:68: 807:78
        StorageDead(_59);                // scope 5 at src/codec/japanese.rs:807:77: 807:78
        goto -> bb31;                    // scope 5 at src/codec/japanese.rs:807:20: 807:81
    }

    bb31: {
        StorageDead(_51);                // scope 5 at src/codec/japanese.rs:807:80: 807:81
        StorageLive(_60);                // scope 5 at src/codec/japanese.rs:820:50: 820:73
        StorageLive(_61);                // scope 5 at src/codec/japanese.rs:820:50: 820:56
        _61 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:820:50: 820:56
        _60 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _61, const 126_u8) -> bb32; // scope 5 at src/codec/japanese.rs:820:50: 820:73
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:820:57: 820:67
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb32: {
        StorageDead(_61);                // scope 5 at src/codec/japanese.rs:820:72: 820:73
        StorageDead(_60);                // scope 5 at src/codec/japanese.rs:820:73: 820:74
        goto -> bb49;                    // scope 5 at src/codec/japanese.rs:820:31: 820:76
    }

    bb33: {
        StorageLive(_62);                // scope 5 at src/codec/japanese.rs:810:23: 810:37
        StorageLive(_63);                // scope 5 at src/codec/japanese.rs:810:23: 810:25
        _63 = &_8;                       // scope 5 at src/codec/japanese.rs:810:23: 810:25
        StorageLive(_64);                // scope 5 at src/codec/japanese.rs:810:29: 810:37
        _120 = const <ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed::promoted[2]; // scope 5 at src/codec/japanese.rs:810:29: 810:37
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPState
                                         // + val: Unevaluated(<ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed, [], Some(promoted[2]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:810:29: 810:37
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPState, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:435 ~ encoding[5d2c]::codec::japanese::{impl#12}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[2]) }) }
        _64 = _120;                      // scope 5 at src/codec/japanese.rs:810:29: 810:37
        _62 = <ISO2022JPState as PartialEq>::ne(move _63, move _64) -> bb34; // scope 5 at src/codec/japanese.rs:810:23: 810:37
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:810:23: 810:37
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::japanese::ISO2022JPState, &'s codec::japanese::ISO2022JPState) -> bool {<codec::japanese::ISO2022JPState as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb34: {
        StorageDead(_64);                // scope 5 at src/codec/japanese.rs:810:36: 810:37
        StorageDead(_63);                // scope 5 at src/codec/japanese.rs:810:36: 810:37
        switchInt(move _62) -> [false: bb37, otherwise: bb35]; // scope 5 at src/codec/japanese.rs:810:23: 810:37
    }

    bb35: {
        StorageLive(_65);                // scope 5 at src/codec/japanese.rs:810:40: 810:69
        StorageLive(_66);                // scope 5 at src/codec/japanese.rs:810:40: 810:46
        _66 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:810:40: 810:46
        StorageLive(_67);                // scope 5 at src/codec/japanese.rs:810:59: 810:68
        StorageLive(_68);                // scope 5 at src/codec/japanese.rs:810:59: 810:68
        StorageLive(_69);                // scope 5 at src/codec/japanese.rs:810:59: 810:68
        _69 = const b"\x1b(I";           // scope 5 at src/codec/japanese.rs:810:59: 810:68
                                         // ty::Const
                                         // + ty: &[u8; 3]
                                         // + val: Value(Scalar(alloc8))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:810:59: 810:68
                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc8)) }
        _68 = _69;                       // scope 5 at src/codec/japanese.rs:810:59: 810:68
        _67 = move _68 as &[u8] (Pointer(Unsize)); // scope 5 at src/codec/japanese.rs:810:59: 810:68
        StorageDead(_68);                // scope 5 at src/codec/japanese.rs:810:67: 810:68
        _65 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _66, move _67) -> bb36; // scope 5 at src/codec/japanese.rs:810:40: 810:69
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:810:47: 810:58
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb36: {
        StorageDead(_67);                // scope 5 at src/codec/japanese.rs:810:68: 810:69
        StorageDead(_66);                // scope 5 at src/codec/japanese.rs:810:68: 810:69
        StorageDead(_69);                // scope 5 at src/codec/japanese.rs:810:69: 810:70
        StorageDead(_65);                // scope 5 at src/codec/japanese.rs:810:69: 810:70
        StorageLive(_70);                // scope 5 at src/codec/japanese.rs:810:76: 810:84
        discriminant(_70) = 1;           // scope 5 at src/codec/japanese.rs:810:76: 810:84
        _8 = move _70;                   // scope 5 at src/codec/japanese.rs:810:71: 810:84
        StorageDead(_70);                // scope 5 at src/codec/japanese.rs:810:83: 810:84
        goto -> bb37;                    // scope 5 at src/codec/japanese.rs:810:20: 810:87
    }

    bb37: {
        StorageDead(_62);                // scope 5 at src/codec/japanese.rs:810:86: 810:87
        StorageLive(_71);                // scope 5 at src/codec/japanese.rs:823:21: 823:75
        StorageLive(_72);                // scope 5 at src/codec/japanese.rs:823:21: 823:27
        _72 = &mut (*_3);                // scope 5 at src/codec/japanese.rs:823:21: 823:27
        StorageLive(_73);                // scope 5 at src/codec/japanese.rs:823:39: 823:74
        StorageLive(_74);                // scope 5 at src/codec/japanese.rs:823:39: 823:68
        StorageLive(_75);                // scope 5 at src/codec/japanese.rs:823:40: 823:60
        StorageLive(_76);                // scope 5 at src/codec/japanese.rs:823:40: 823:51
        StorageLive(_77);                // scope 5 at src/codec/japanese.rs:823:40: 823:42
        _77 = _22;                       // scope 5 at src/codec/japanese.rs:823:40: 823:42
        _76 = move _77 as usize (Misc);  // scope 5 at src/codec/japanese.rs:823:40: 823:51
        StorageDead(_77);                // scope 5 at src/codec/japanese.rs:823:50: 823:51
        _75 = Sub(move _76, const 65377_usize); // scope 5 at src/codec/japanese.rs:823:40: 823:60
        StorageDead(_76);                // scope 5 at src/codec/japanese.rs:823:59: 823:60
        _74 = Add(move _75, const 33_usize); // scope 5 at src/codec/japanese.rs:823:39: 823:68
        StorageDead(_75);                // scope 5 at src/codec/japanese.rs:823:67: 823:68
        _73 = move _74 as u8 (Misc);     // scope 5 at src/codec/japanese.rs:823:39: 823:74
        StorageDead(_74);                // scope 5 at src/codec/japanese.rs:823:73: 823:74
        _71 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _72, move _73) -> bb38; // scope 5 at src/codec/japanese.rs:823:21: 823:75
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:823:28: 823:38
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb38: {
        StorageDead(_73);                // scope 5 at src/codec/japanese.rs:823:74: 823:75
        StorageDead(_72);                // scope 5 at src/codec/japanese.rs:823:74: 823:75
        StorageDead(_71);                // scope 5 at src/codec/japanese.rs:823:75: 823:76
        goto -> bb49;                    // scope 5 at src/codec/japanese.rs:821:44: 824:18
    }

    bb39: {
        StorageDead(_79);                // scope 5 at src/codec/japanese.rs:826:65: 826:66
        StorageLive(_81);                // scope 6 at src/codec/japanese.rs:827:24: 827:27
        _81 = _78;                       // scope 6 at src/codec/japanese.rs:827:24: 827:27
        switchInt(move _81) -> [u16::MAX: bb40, otherwise: bb42]; // scope 6 at src/codec/japanese.rs:827:24: 827:37
    }

    bb40: {
        StorageDead(_81);                // scope 6 at src/codec/japanese.rs:827:24: 827:37
        StorageLive(_82);                // scope 6 at src/codec/japanese.rs:828:35: 828:37
        _82 = _8;                        // scope 6 at src/codec/japanese.rs:828:35: 828:37
        ((*_1).0: codec::japanese::ISO2022JPState) = move _82; // scope 6 at src/codec/japanese.rs:828:25: 828:37
        StorageDead(_82);                // scope 6 at src/codec/japanese.rs:828:36: 828:37
        StorageLive(_83);                // scope 6 at src/codec/japanese.rs:829:33: 829:34
        _83 = _20;                       // scope 6 at src/codec/japanese.rs:829:33: 829:34
        StorageLive(_84);                // scope 6 at src/codec/japanese.rs:829:36: 831:27
        StorageLive(_85);                // scope 6 at src/codec/japanese.rs:829:41: 831:26
        StorageLive(_86);                // scope 6 at src/codec/japanese.rs:830:35: 830:45
        StorageLive(_87);                // scope 6 at src/codec/japanese.rs:830:35: 830:36
        _87 = _21;                       // scope 6 at src/codec/japanese.rs:830:35: 830:36
        _86 = move _87 as isize (Misc);  // scope 6 at src/codec/japanese.rs:830:35: 830:45
        StorageDead(_87);                // scope 6 at src/codec/japanese.rs:830:44: 830:45
        StorageLive(_88);                // scope 6 at src/codec/japanese.rs:830:54: 830:88
        StorageLive(_89);                // scope 6 at src/codec/japanese.rs:830:54: 830:81
        StorageLive(_90);                // scope 6 at src/codec/japanese.rs:830:54: 830:81
        _90 = const "unrepresentable character"; // scope 6 at src/codec/japanese.rs:830:54: 830:81
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:830:54: 830:81
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _89 = _90;                       // scope 6 at src/codec/japanese.rs:830:54: 830:81
        _88 = <&str as Into<Cow<str>>>::into(move _89) -> bb41; // scope 6 at src/codec/japanese.rs:830:54: 830:88
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:830:82: 830:86
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb41: {
        StorageDead(_89);                // scope 6 at src/codec/japanese.rs:830:87: 830:88
        (_85.0: isize) = move _86;       // scope 6 at src/codec/japanese.rs:829:41: 831:26
        (_85.1: std::borrow::Cow<str>) = move _88; // scope 6 at src/codec/japanese.rs:829:41: 831:26
        StorageDead(_88);                // scope 6 at src/codec/japanese.rs:831:25: 831:26
        StorageDead(_86);                // scope 6 at src/codec/japanese.rs:831:25: 831:26
        ((_84 as Some).0: encoding_types::CodecError) = move _85; // scope 6 at src/codec/japanese.rs:829:36: 831:27
        discriminant(_84) = 1;           // scope 6 at src/codec/japanese.rs:829:36: 831:27
        StorageDead(_85);                // scope 6 at src/codec/japanese.rs:831:26: 831:27
        (_0.0: usize) = move _83;        // scope 6 at src/codec/japanese.rs:829:32: 831:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _84; // scope 6 at src/codec/japanese.rs:829:32: 831:28
        StorageDead(_84);                // scope 6 at src/codec/japanese.rs:831:27: 831:28
        StorageDead(_83);                // scope 6 at src/codec/japanese.rs:831:27: 831:28
        StorageDead(_90);                // scope 6 at src/codec/japanese.rs:831:28: 831:29
        StorageDead(_78);                // scope 5 at src/codec/japanese.rs:839:17: 839:18
        StorageDead(_22);                // scope 3 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_21);                // scope 3 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_12);                // scope 1 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_9);                 // scope 1 at src/codec/japanese.rs:816:45: 816:46
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:845:5: 845:6
        goto -> bb51;                    // scope 0 at src/codec/japanese.rs:845:6: 845:6
    }

    bb42: {
        StorageDead(_81);                // scope 6 at src/codec/japanese.rs:827:24: 827:37
        StorageLive(_91);                // scope 6 at src/codec/japanese.rs:813:23: 813:33
        StorageLive(_92);                // scope 6 at src/codec/japanese.rs:813:23: 813:25
        _92 = &_8;                       // scope 6 at src/codec/japanese.rs:813:23: 813:25
        StorageLive(_93);                // scope 6 at src/codec/japanese.rs:813:29: 813:33
        _121 = const <ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed::promoted[3]; // scope 6 at src/codec/japanese.rs:813:29: 813:33
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPState
                                         // + val: Unevaluated(<ISO2022JPEncoder as encoding_types::RawEncoder>::raw_feed, [], Some(promoted[3]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:813:29: 813:33
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPState, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:435 ~ encoding[5d2c]::codec::japanese::{impl#12}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[3]) }) }
        _93 = _121;                      // scope 6 at src/codec/japanese.rs:813:29: 813:33
        _91 = <ISO2022JPState as PartialEq>::ne(move _92, move _93) -> bb43; // scope 6 at src/codec/japanese.rs:813:23: 813:33
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:813:23: 813:33
                                         // + literal: Const { ty: for<'r, 's> fn(&'r codec::japanese::ISO2022JPState, &'s codec::japanese::ISO2022JPState) -> bool {<codec::japanese::ISO2022JPState as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb43: {
        StorageDead(_93);                // scope 6 at src/codec/japanese.rs:813:32: 813:33
        StorageDead(_92);                // scope 6 at src/codec/japanese.rs:813:32: 813:33
        switchInt(move _91) -> [false: bb46, otherwise: bb44]; // scope 6 at src/codec/japanese.rs:813:23: 813:33
    }

    bb44: {
        StorageLive(_94);                // scope 6 at src/codec/japanese.rs:813:36: 813:65
        StorageLive(_95);                // scope 6 at src/codec/japanese.rs:813:36: 813:42
        _95 = &mut (*_3);                // scope 6 at src/codec/japanese.rs:813:36: 813:42
        StorageLive(_96);                // scope 6 at src/codec/japanese.rs:813:55: 813:64
        StorageLive(_97);                // scope 6 at src/codec/japanese.rs:813:55: 813:64
        StorageLive(_98);                // scope 6 at src/codec/japanese.rs:813:55: 813:64
        _98 = const b"\x1b$B";           // scope 6 at src/codec/japanese.rs:813:55: 813:64
                                         // ty::Const
                                         // + ty: &[u8; 3]
                                         // + val: Value(Scalar(alloc9))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:813:55: 813:64
                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc9)) }
        _97 = _98;                       // scope 6 at src/codec/japanese.rs:813:55: 813:64
        _96 = move _97 as &[u8] (Pointer(Unsize)); // scope 6 at src/codec/japanese.rs:813:55: 813:64
        StorageDead(_97);                // scope 6 at src/codec/japanese.rs:813:63: 813:64
        _94 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _95, move _96) -> bb45; // scope 6 at src/codec/japanese.rs:813:36: 813:65
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:813:43: 813:54
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb45: {
        StorageDead(_96);                // scope 6 at src/codec/japanese.rs:813:64: 813:65
        StorageDead(_95);                // scope 6 at src/codec/japanese.rs:813:64: 813:65
        StorageDead(_98);                // scope 6 at src/codec/japanese.rs:813:65: 813:66
        StorageDead(_94);                // scope 6 at src/codec/japanese.rs:813:65: 813:66
        StorageLive(_99);                // scope 6 at src/codec/japanese.rs:813:72: 813:76
        discriminant(_99) = 2;           // scope 6 at src/codec/japanese.rs:813:72: 813:76
        _8 = move _99;                   // scope 6 at src/codec/japanese.rs:813:67: 813:76
        StorageDead(_99);                // scope 6 at src/codec/japanese.rs:813:75: 813:76
        goto -> bb46;                    // scope 6 at src/codec/japanese.rs:813:20: 813:79
    }

    bb46: {
        StorageDead(_91);                // scope 6 at src/codec/japanese.rs:813:78: 813:79
        StorageLive(_100);               // scope 6 at src/codec/japanese.rs:834:29: 834:33
        StorageLive(_101);               // scope 6 at src/codec/japanese.rs:834:36: 834:44
        StorageLive(_102);               // scope 6 at src/codec/japanese.rs:834:36: 834:39
        _102 = _78;                      // scope 6 at src/codec/japanese.rs:834:36: 834:39
        _101 = Div(move _102, const 94_u16); // scope 6 at src/codec/japanese.rs:834:36: 834:44
        StorageDead(_102);               // scope 6 at src/codec/japanese.rs:834:43: 834:44
        _100 = Add(move _101, const 33_u16); // scope 6 at src/codec/japanese.rs:834:36: 834:51
        StorageDead(_101);               // scope 6 at src/codec/japanese.rs:834:50: 834:51
        StorageLive(_103);               // scope 7 at src/codec/japanese.rs:835:29: 835:34
        StorageLive(_104);               // scope 7 at src/codec/japanese.rs:835:37: 835:45
        StorageLive(_105);               // scope 7 at src/codec/japanese.rs:835:37: 835:40
        _105 = _78;                      // scope 7 at src/codec/japanese.rs:835:37: 835:40
        _104 = Rem(move _105, const 94_u16); // scope 7 at src/codec/japanese.rs:835:37: 835:45
        StorageDead(_105);               // scope 7 at src/codec/japanese.rs:835:44: 835:45
        _103 = Add(move _104, const 33_u16); // scope 7 at src/codec/japanese.rs:835:37: 835:52
        StorageDead(_104);               // scope 7 at src/codec/japanese.rs:835:51: 835:52
        StorageLive(_106);               // scope 8 at src/codec/japanese.rs:836:25: 836:54
        StorageLive(_107);               // scope 8 at src/codec/japanese.rs:836:25: 836:31
        _107 = &mut (*_3);               // scope 8 at src/codec/japanese.rs:836:25: 836:31
        StorageLive(_108);               // scope 8 at src/codec/japanese.rs:836:43: 836:53
        StorageLive(_109);               // scope 8 at src/codec/japanese.rs:836:43: 836:47
        _109 = _100;                     // scope 8 at src/codec/japanese.rs:836:43: 836:47
        _108 = move _109 as u8 (Misc);   // scope 8 at src/codec/japanese.rs:836:43: 836:53
        StorageDead(_109);               // scope 8 at src/codec/japanese.rs:836:52: 836:53
        _106 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _107, move _108) -> bb47; // scope 8 at src/codec/japanese.rs:836:25: 836:54
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:836:32: 836:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb47: {
        StorageDead(_108);               // scope 8 at src/codec/japanese.rs:836:53: 836:54
        StorageDead(_107);               // scope 8 at src/codec/japanese.rs:836:53: 836:54
        StorageDead(_106);               // scope 8 at src/codec/japanese.rs:836:54: 836:55
        StorageLive(_110);               // scope 8 at src/codec/japanese.rs:837:25: 837:55
        StorageLive(_111);               // scope 8 at src/codec/japanese.rs:837:25: 837:31
        _111 = &mut (*_3);               // scope 8 at src/codec/japanese.rs:837:25: 837:31
        StorageLive(_112);               // scope 8 at src/codec/japanese.rs:837:43: 837:54
        StorageLive(_113);               // scope 8 at src/codec/japanese.rs:837:43: 837:48
        _113 = _103;                     // scope 8 at src/codec/japanese.rs:837:43: 837:48
        _112 = move _113 as u8 (Misc);   // scope 8 at src/codec/japanese.rs:837:43: 837:54
        StorageDead(_113);               // scope 8 at src/codec/japanese.rs:837:53: 837:54
        _110 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _111, move _112) -> bb48; // scope 8 at src/codec/japanese.rs:837:25: 837:55
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:837:32: 837:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb48: {
        StorageDead(_112);               // scope 8 at src/codec/japanese.rs:837:54: 837:55
        StorageDead(_111);               // scope 8 at src/codec/japanese.rs:837:54: 837:55
        StorageDead(_110);               // scope 8 at src/codec/japanese.rs:837:55: 837:56
        StorageDead(_103);               // scope 7 at src/codec/japanese.rs:838:21: 838:22
        StorageDead(_100);               // scope 6 at src/codec/japanese.rs:838:21: 838:22
        StorageDead(_78);                // scope 5 at src/codec/japanese.rs:839:17: 839:18
        goto -> bb49;                    // scope 5 at src/codec/japanese.rs:839:17: 839:18
    }

    bb49: {
        StorageDead(_22);                // scope 3 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_21);                // scope 3 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:841:9: 841:10
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:841:9: 841:10
        goto -> bb5;                     // scope 2 at src/codec/japanese.rs:816:9: 841:10
    }

    bb50: {
        StorageDead(_116);               // scope 1 at src/codec/japanese.rs:844:20: 844:21
        StorageLive(_117);               // scope 1 at src/codec/japanese.rs:844:23: 844:27
        discriminant(_117) = 0;          // scope 1 at src/codec/japanese.rs:844:23: 844:27
        (_0.0: usize) = move _115;       // scope 1 at src/codec/japanese.rs:844:9: 844:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _117; // scope 1 at src/codec/japanese.rs:844:9: 844:28
        StorageDead(_117);               // scope 1 at src/codec/japanese.rs:844:27: 844:28
        StorageDead(_115);               // scope 1 at src/codec/japanese.rs:844:27: 844:28
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:845:5: 845:6
        goto -> bb51;                    // scope 0 at src/codec/japanese.rs:845:6: 845:6
    }

    bb51: {
        return;                          // scope 0 at src/codec/japanese.rs:845:6: 845:6
    }
}

alloc9 (size: 3, align: 1) {
    1b 24 42                                         .$B
}

alloc8 (size: 3, align: 1) {
    1b 28 49                                         .(I
}

alloc7 (size: 3, align: 1) {
    1b 28 42                                         .(B
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_feed: &ISO2022JPState = {
    let mut _0: &codec::japanese::ISO2022JPState; // return place in scope 0 at src/codec/japanese.rs:807:29: 807:34
    let mut _1: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:29: 807:34

    bb0: {
        discriminant(_1) = 0;            // scope 0 at src/codec/japanese.rs:807:29: 807:34
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:807:29: 807:34
        return;                          // scope 0 at src/codec/japanese.rs:807:29: 807:34
    }
}

promoted[1] in japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_feed: &ISO2022JPState = {
    let mut _0: &codec::japanese::ISO2022JPState; // return place in scope 0 at src/codec/japanese.rs:807:29: 807:34
    let mut _1: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:29: 807:34

    bb0: {
        discriminant(_1) = 0;            // scope 0 at src/codec/japanese.rs:807:29: 807:34
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:807:29: 807:34
        return;                          // scope 0 at src/codec/japanese.rs:807:29: 807:34
    }
}

promoted[2] in japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_feed: &ISO2022JPState = {
    let mut _0: &codec::japanese::ISO2022JPState; // return place in scope 0 at src/codec/japanese.rs:810:29: 810:37
    let mut _1: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:810:29: 810:37

    bb0: {
        discriminant(_1) = 1;            // scope 0 at src/codec/japanese.rs:810:29: 810:37
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:810:29: 810:37
        return;                          // scope 0 at src/codec/japanese.rs:810:29: 810:37
    }
}

promoted[3] in japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_feed: &ISO2022JPState = {
    let mut _0: &codec::japanese::ISO2022JPState; // return place in scope 0 at src/codec/japanese.rs:813:29: 813:33
    let mut _1: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:813:29: 813:33

    bb0: {
        discriminant(_1) = 2;            // scope 0 at src/codec/japanese.rs:813:29: 813:33
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:813:29: 813:33
        return;                          // scope 0 at src/codec/japanese.rs:813:29: 813:33
    }
}

promoted[4] in japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_feed: &ISO2022JPState = {
    let mut _0: &codec::japanese::ISO2022JPState; // return place in scope 0 at src/codec/japanese.rs:807:29: 807:34
    let mut _1: codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:807:29: 807:34

    bb0: {
        discriminant(_1) = 0;            // scope 0 at src/codec/japanese.rs:807:29: 807:34
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:807:29: 807:34
        return;                          // scope 0 at src/codec/japanese.rs:807:29: 807:34
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:85:1: 94:2>::raw_feed(_1: &mut UTF16LEEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:87:17: 87:26
    debug input => _2;                   // in scope 0 at src/codec/utf_16.rs:87:28: 87:33
    debug output => _3;                  // in scope 0 at src/codec/utf_16.rs:87:41: 87:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_16.rs:87:69: 87:96
    let mut _4: &mut codec::utf_16::UTF16Encoder; // in scope 0 at src/codec/utf_16.rs:88:9: 88:21
    let mut _5: codec::utf_16::UTF16Encoder; // in scope 0 at src/codec/utf_16.rs:88:9: 88:21
    let mut _6: &str;                    // in scope 0 at src/codec/utf_16.rs:88:31: 88:36
    let mut _7: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:88:38: 88:44
    let mut _8: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:88:38: 88:44
    let mut _9: [closure@src/codec/utf_16.rs:88:46: 91:10]; // in scope 0 at src/codec/utf_16.rs:88:46: 91:10

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:88:9: 88:21
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:88:9: 88:21
        _4 = &mut _5;                    // scope 0 at src/codec/utf_16.rs:88:9: 88:21
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:88:31: 88:36
        _6 = _2;                         // scope 0 at src/codec/utf_16.rs:88:31: 88:36
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:88:38: 88:44
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:88:38: 88:44
        _8 = &mut (*_3);                 // scope 0 at src/codec/utf_16.rs:88:38: 88:44
        _7 = move _8 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:88:38: 88:44
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:88:43: 88:44
        StorageLive(_9);                 // scope 0 at src/codec/utf_16.rs:88:46: 91:10
        _0 = UTF16Encoder::raw_feed::<[closure@src/codec/utf_16.rs:88:46: 91:10]>(move _4, move _6, move _7, move _9) -> bb1; // scope 0 at src/codec/utf_16.rs:88:9: 91:11
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:88:22: 88:30
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut codec::utf_16::UTF16Encoder, &'s str, &'t0 mut (dyn encoding_types::ByteWriter + 't0), [closure@src/codec/utf_16.rs:88:46: 91:10]) -> (usize, std::option::Option<encoding_types::CodecError>) {codec::utf_16::UTF16Encoder::raw_feed::<[closure@src/codec/utf_16.rs:88:46: 91:10]>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_9);                 // scope 0 at src/codec/utf_16.rs:91:10: 91:11
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:91:10: 91:11
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:91:10: 91:11
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:91:10: 91:11
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:92:5: 92:6
        return;                          // scope 0 at src/codec/utf_16.rs:92:6: 92:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:165:1: 180:2>::from_self(_1: &GB18030Decoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:166:18: 166:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:166:28: 166:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:166:46: 166:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:166:46: 166:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:166:46: 166:67
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:166:46: 166:67
        _3 = GB18030Decoder::new() -> bb1; // scope 0 at src/codec/simpchinese.rs:166:46: 166:67
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:166:46: 166:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::simpchinese::GB18030Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:166:46: 166:67
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:166:66: 166:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:166:46: 166:67
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:166:68: 166:69
        return;                          // scope 0 at src/codec/simpchinese.rs:166:69: 166:69
    }
}

fn eucjp::transient::S4(_1: &mut StatefulDecoderHelper<eucjp::State, T>, _2: u8) -> eucjp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _8: bool;                    // in scope 0 at src/codec/japanese.rs:181:18: 181:29
    let mut _9: bool;                    // in scope 0 at src/codec/japanese.rs:181:18: 181:29
    let mut _11: u32;                    // in scope 0 at src/codec/japanese.rs:181:39: 181:66
    let mut _12: u8;                     // in scope 0 at src/codec/japanese.rs:181:58: 181:62
    let mut _13: u8;                     // in scope 0 at src/codec/japanese.rs:181:64: 181:65
    let mut _14: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:183:23: 183:26
    let mut _16: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:184:19: 184:22
    let mut _17: u32;                    // in scope 0 at src/codec/japanese.rs:184:28: 184:37
    let mut _18: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:186:19: 186:22
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _10: u8;                     // in scope 1 at src/codec/japanese.rs:181:14: 181:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/japanese.rs:181:14: 181:29
            let _15: u32;                // in scope 2 at src/codec/japanese.rs:184:13: 184:15
            scope 3 {
                debug ch => _15;         // in scope 3 at src/codec/japanese.rs:184:13: 184:15
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<eucjp::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        _8 = Le(const 161_u8, _7);       // scope 1 at src/codec/japanese.rs:181:18: 181:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/japanese.rs:181:18: 181:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S4).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 4;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb16;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _9 = Le(_7, const 254_u8);       // scope 1 at src/codec/japanese.rs:181:18: 181:29
        switchInt(move _9) -> [false: bb6, otherwise: bb7]; // scope 1 at src/codec/japanese.rs:181:18: 181:29
    }

    bb6: {
        StorageLive(_18);                // scope 1 at src/codec/japanese.rs:186:19: 186:22
        _18 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:186:19: 186:22
        _0 = StatefulDecoderHelper::<eucjp::State, T>::backup_and_err(move _18, const 1_usize, const "invalid sequence") -> bb14; // scope 1 at src/codec/japanese.rs:186:19: 186:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:186:23: 186:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, usize, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:186:41: 186:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb7: {
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:181:14: 181:29
        _10 = _7;                        // scope 1 at src/codec/japanese.rs:181:14: 181:29
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:181:39: 181:66
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:181:58: 181:62
        _12 = _2;                        // scope 2 at src/codec/japanese.rs:181:58: 181:62
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:181:64: 181:65
        _13 = _10;                       // scope 2 at src/codec/japanese.rs:181:64: 181:65
        _11 = eucjp::internal::map_two_0212_bytes(move _12, move _13) -> bb8; // scope 2 at src/codec/japanese.rs:181:39: 181:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:181:39: 181:57
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::japanese::eucjp::internal::map_two_0212_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:181:65: 181:66
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:181:65: 181:66
        switchInt(_11) -> [65535_u32: bb10, otherwise: bb9]; // scope 2 at src/codec/japanese.rs:181:33: 181:66
    }

    bb9: {
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:184:13: 184:15
        _15 = _11;                       // scope 2 at src/codec/japanese.rs:184:13: 184:15
        StorageLive(_16);                // scope 3 at src/codec/japanese.rs:184:19: 184:22
        _16 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:184:19: 184:22
        StorageLive(_17);                // scope 3 at src/codec/japanese.rs:184:28: 184:37
        _17 = _15;                       // scope 3 at src/codec/japanese.rs:184:28: 184:30
        _0 = StatefulDecoderHelper::<eucjp::State, T>::emit(move _16, move _17) -> bb12; // scope 3 at src/codec/japanese.rs:184:19: 184:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:184:23: 184:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, u32) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:183:23: 183:26
        _14 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:183:23: 183:26
        _0 = StatefulDecoderHelper::<eucjp::State, T>::err(move _14, const "invalid sequence") -> bb11; // scope 2 at src/codec/japanese.rs:183:23: 183:50
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:183:27: 183:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:183:31: 183:49
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb11: {
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:183:49: 183:50
        goto -> bb13;                    // scope 2 at src/codec/japanese.rs:183:49: 183:50
    }

    bb12: {
        StorageDead(_17);                // scope 3 at src/codec/japanese.rs:184:37: 184:38
        StorageDead(_16);                // scope 3 at src/codec/japanese.rs:184:37: 184:38
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:184:37: 184:38
        goto -> bb13;                    // scope 2 at src/codec/japanese.rs:184:37: 184:38
    }

    bb13: {
        StorageDead(_11);                // scope 2 at src/util.rs:226:77: 226:78
        StorageDead(_10);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb15;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb14: {
        StorageDead(_18);                // scope 1 at src/codec/japanese.rs:186:59: 186:60
        goto -> bb15;                    // scope 1 at src/codec/japanese.rs:186:59: 186:60
    }

    bb15: {
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb16;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb16: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn iso2022jp::State::EscapeMiddle28(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeMiddle28).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 6;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn iso2022jp::State::EscapeMiddle28(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeMiddle28).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 6;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:90:1: 105:2>::is_ascii_compatible(_1: &BigFive2003HKSCS2008Decoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:92:28: 92:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/tradchinese.rs:92:38: 92:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/tradchinese.rs:92:45: 92:49
        return;                          // scope 0 at src/codec/tradchinese.rs:92:51: 92:51
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:81:1: 111:2>::from_self(_1: &SingleByteDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:82:18: 82:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/singlebyte.rs:82:28: 82:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/singlebyte.rs:82:46: 82:88
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/singlebyte.rs:82:46: 82:88
    let mut _4: fn(u8) -> u16;           // in scope 0 at src/codec/singlebyte.rs:82:69: 82:87

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:82:46: 82:88
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:82:46: 82:88
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:82:69: 82:87
        _4 = ((*_1).0: fn(u8) -> u16);   // scope 0 at src/codec/singlebyte.rs:82:69: 82:87
        _3 = SingleByteDecoder::new(move _4) -> bb1; // scope 0 at src/codec/singlebyte.rs:82:46: 82:88
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:82:46: 82:68
                                         // + literal: Const { ty: fn(fn(u8) -> u16) -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::singlebyte::SingleByteDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:82:46: 82:88
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:82:87: 82:88
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:82:87: 82:88
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:82:46: 82:88
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:82:89: 82:90
        return;                          // scope 0 at src/codec/singlebyte.rs:82:90: 82:90
    }
}

fn windows949::internal::map_two_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/korean.rs:104:35: 104:39
    debug trail => _2;                   // in scope 0 at src/codec/korean.rs:104:45: 104:50
    let mut _0: u32;                     // return place in scope 0 at src/codec/korean.rs:104:59: 104:62
    let _3: u16;                         // in scope 0 at src/codec/korean.rs:107:13: 107:17
    let mut _4: u8;                      // in scope 0 at src/codec/korean.rs:107:20: 107:24
    let mut _6: u8;                      // in scope 0 at src/codec/korean.rs:108:21: 108:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/korean.rs:109:27: 109:40
    let mut _9: u16;                     // in scope 0 at src/codec/korean.rs:109:28: 109:32
    let mut _10: u16;                    // in scope 0 at src/codec/korean.rs:109:34: 109:39
    let mut _11: bool;                   // in scope 0 at src/codec/korean.rs:110:27: 110:38
    let mut _12: bool;                   // in scope 0 at src/codec/korean.rs:110:27: 110:38
    let mut _13: bool;                   // in scope 0 at src/codec/korean.rs:110:14: 110:25
    let mut _14: bool;                   // in scope 0 at src/codec/korean.rs:110:14: 110:25
    let mut _15: u16;                    // in scope 0 at src/codec/korean.rs:110:43: 110:62
    let mut _16: u16;                    // in scope 0 at src/codec/korean.rs:110:43: 110:56
    let mut _17: u16;                    // in scope 0 at src/codec/korean.rs:110:44: 110:48
    let mut _18: u16;                    // in scope 0 at src/codec/korean.rs:110:65: 110:79
    let mut _19: u16;                    // in scope 0 at src/codec/korean.rs:110:66: 110:71
    let mut _20: u16;                    // in scope 0 at src/codec/korean.rs:113:32: 113:37
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/korean.rs:107:13: 107:17
        let _5: u16;                     // in scope 1 at src/codec/korean.rs:108:13: 108:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/korean.rs:108:13: 108:18
            let _7: u16;                 // in scope 2 at src/codec/korean.rs:109:13: 109:18
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/korean.rs:109:13: 109:18
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:107:13: 107:17
        StorageLive(_4);                 // scope 0 at src/codec/korean.rs:107:20: 107:24
        _4 = _1;                         // scope 0 at src/codec/korean.rs:107:20: 107:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/korean.rs:107:20: 107:31
        StorageDead(_4);                 // scope 0 at src/codec/korean.rs:107:30: 107:31
        StorageLive(_5);                 // scope 1 at src/codec/korean.rs:108:13: 108:18
        StorageLive(_6);                 // scope 1 at src/codec/korean.rs:108:21: 108:26
        _6 = _2;                         // scope 1 at src/codec/korean.rs:108:21: 108:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/korean.rs:108:21: 108:33
        StorageDead(_6);                 // scope 1 at src/codec/korean.rs:108:32: 108:33
        StorageLive(_7);                 // scope 2 at src/codec/korean.rs:109:13: 109:18
        StorageLive(_8);                 // scope 2 at src/codec/korean.rs:109:27: 109:40
        StorageLive(_9);                 // scope 2 at src/codec/korean.rs:109:28: 109:32
        _9 = _3;                         // scope 2 at src/codec/korean.rs:109:28: 109:32
        StorageLive(_10);                // scope 2 at src/codec/korean.rs:109:34: 109:39
        _10 = _5;                        // scope 2 at src/codec/korean.rs:109:34: 109:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/korean.rs:109:27: 109:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/korean.rs:109:27: 109:40
        StorageDead(_10);                // scope 2 at src/codec/korean.rs:109:39: 109:40
        StorageDead(_9);                 // scope 2 at src/codec/korean.rs:109:39: 109:40
        _13 = Le(const 129_u16, (_8.0: u16)); // scope 2 at src/codec/korean.rs:110:14: 110:25
        switchInt(move _13) -> [false: bb4, otherwise: bb1]; // scope 2 at src/codec/korean.rs:110:14: 110:25
    }

    bb1: {
        _14 = Le((_8.0: u16), const 254_u16); // scope 2 at src/codec/korean.rs:110:14: 110:25
        switchInt(move _14) -> [false: bb4, otherwise: bb2]; // scope 2 at src/codec/korean.rs:110:14: 110:25
    }

    bb2: {
        _11 = Le(const 65_u16, (_8.1: u16)); // scope 2 at src/codec/korean.rs:110:27: 110:38
        switchInt(move _11) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/korean.rs:110:27: 110:38
    }

    bb3: {
        _12 = Le((_8.1: u16), const 254_u16); // scope 2 at src/codec/korean.rs:110:27: 110:38
        switchInt(move _12) -> [false: bb4, otherwise: bb5]; // scope 2 at src/codec/korean.rs:110:27: 110:38
    }

    bb4: {
        _7 = const u16::MAX;             // scope 2 at src/codec/korean.rs:111:23: 111:29
        goto -> bb6;                     // scope 2 at src/codec/korean.rs:111:23: 111:29
    }

    bb5: {
        StorageLive(_15);                // scope 2 at src/codec/korean.rs:110:43: 110:62
        StorageLive(_16);                // scope 2 at src/codec/korean.rs:110:43: 110:56
        StorageLive(_17);                // scope 2 at src/codec/korean.rs:110:44: 110:48
        _17 = _3;                        // scope 2 at src/codec/korean.rs:110:44: 110:48
        _16 = Sub(move _17, const 129_u16); // scope 2 at src/codec/korean.rs:110:43: 110:56
        StorageDead(_17);                // scope 2 at src/codec/korean.rs:110:55: 110:56
        _15 = Mul(move _16, const 190_u16); // scope 2 at src/codec/korean.rs:110:43: 110:62
        StorageDead(_16);                // scope 2 at src/codec/korean.rs:110:61: 110:62
        StorageLive(_18);                // scope 2 at src/codec/korean.rs:110:65: 110:79
        StorageLive(_19);                // scope 2 at src/codec/korean.rs:110:66: 110:71
        _19 = _5;                        // scope 2 at src/codec/korean.rs:110:66: 110:71
        _18 = Sub(move _19, const 65_u16); // scope 2 at src/codec/korean.rs:110:65: 110:79
        StorageDead(_19);                // scope 2 at src/codec/korean.rs:110:78: 110:79
        _7 = Add(move _15, move _18);    // scope 2 at src/codec/korean.rs:110:43: 110:79
        StorageDead(_18);                // scope 2 at src/codec/korean.rs:110:78: 110:79
        StorageDead(_15);                // scope 2 at src/codec/korean.rs:110:78: 110:79
        goto -> bb6;                     // scope 2 at src/codec/korean.rs:110:78: 110:79
    }

    bb6: {
        StorageDead(_8);                 // scope 2 at src/codec/korean.rs:112:10: 112:11
        StorageLive(_20);                // scope 3 at src/codec/korean.rs:113:32: 113:37
        _20 = _7;                        // scope 3 at src/codec/korean.rs:113:32: 113:37
        _0 = index_korean::euc_kr::forward(move _20) -> bb7; // scope 3 at src/codec/korean.rs:113:9: 113:38
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:113:9: 113:31
                                         // + literal: Const { ty: fn(u16) -> u32 {index_korean::euc_kr::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 3 at src/codec/korean.rs:113:37: 113:38
        StorageDead(_7);                 // scope 2 at src/codec/korean.rs:114:5: 114:6
        StorageDead(_5);                 // scope 1 at src/codec/korean.rs:114:5: 114:6
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:114:5: 114:6
        return;                          // scope 0 at src/codec/korean.rs:114:6: 114:6
    }
}

fn hz::State::B0(_1: ()) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as B0).0: ()) = move _1;    // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 1;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

// MIR FOR CTFE
fn hz::State::B0(_1: ()) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:161:21: 161:42

    bb0: {
        ((_0 as B0).0: ()) = move _1;    // scope 0 at src/util.rs:161:21: 161:42
        discriminant(_0) = 1;            // scope 0 at src/util.rs:161:21: 161:42
        return;                          // scope 0 at src/util.rs:161:21: 161:42
    }
}

fn bigfive2003::transient::S1(_1: &mut StatefulDecoderHelper<bigfive2003::State, T>, _2: u8) -> bigfive2003::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _9: u32;                     // in scope 0 at src/codec/tradchinese.rs:136:25: 136:47
    let mut _10: u8;                     // in scope 0 at src/codec/tradchinese.rs:136:39: 136:43
    let mut _11: u8;                     // in scope 0 at src/codec/tradchinese.rs:136:45: 136:46
    let mut _13: bool;                   // in scope 0 at src/codec/tradchinese.rs:138:33: 138:41
    let mut _14: u8;                     // in scope 0 at src/codec/tradchinese.rs:138:33: 138:34
    let mut _15: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:139:17: 139:20
    let mut _16: usize;                  // in scope 0 at src/codec/tradchinese.rs:139:36: 139:42
    let mut _17: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:141:33: 141:36
    let mut _18: &str;                   // in scope 0 at src/codec/tradchinese.rs:141:46: 141:61
    let _19: &str;                       // in scope 0 at src/codec/tradchinese.rs:141:46: 141:61
    let mut _20: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:142:33: 142:36
    let mut _21: &str;                   // in scope 0 at src/codec/tradchinese.rs:142:46: 142:61
    let _22: &str;                       // in scope 0 at src/codec/tradchinese.rs:142:46: 142:61
    let mut _23: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:143:33: 143:36
    let mut _24: &str;                   // in scope 0 at src/codec/tradchinese.rs:143:46: 143:61
    let _25: &str;                       // in scope 0 at src/codec/tradchinese.rs:143:46: 143:61
    let mut _26: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:144:33: 144:36
    let mut _27: &str;                   // in scope 0 at src/codec/tradchinese.rs:144:46: 144:61
    let _28: &str;                       // in scope 0 at src/codec/tradchinese.rs:144:46: 144:61
    let mut _30: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/codec/tradchinese.rs:145:19: 145:22
    let mut _31: u32;                    // in scope 0 at src/codec/tradchinese.rs:145:28: 145:30
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _8: u8;                      // in scope 1 at src/codec/tradchinese.rs:136:14: 136:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/tradchinese.rs:136:14: 136:15
            let _12: usize;              // in scope 2 at src/codec/tradchinese.rs:138:21: 138:27
            let _29: u32;                // in scope 2 at src/codec/tradchinese.rs:145:13: 145:15
            scope 3 {
                debug backup => _12;     // in scope 3 at src/codec/tradchinese.rs:138:21: 138:27
            }
            scope 4 {
                debug ch => _29;         // in scope 4 at src/codec/tradchinese.rs:145:13: 145:15
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<bigfive2003::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        StorageLive(_8);                 // scope 1 at src/codec/tradchinese.rs:136:14: 136:15
        _8 = _7;                         // scope 1 at src/codec/tradchinese.rs:136:14: 136:15
        StorageLive(_9);                 // scope 2 at src/codec/tradchinese.rs:136:25: 136:47
        StorageLive(_10);                // scope 2 at src/codec/tradchinese.rs:136:39: 136:43
        _10 = _2;                        // scope 2 at src/codec/tradchinese.rs:136:39: 136:43
        StorageLive(_11);                // scope 2 at src/codec/tradchinese.rs:136:45: 136:46
        _11 = _8;                        // scope 2 at src/codec/tradchinese.rs:136:45: 136:46
        _9 = bigfive2003::internal::map_two_bytes(move _10, move _11) -> bb5; // scope 2 at src/codec/tradchinese.rs:136:25: 136:47
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:136:25: 136:38
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::tradchinese::bigfive2003::internal::map_two_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S1).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 1;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb22;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageDead(_11);                // scope 2 at src/codec/tradchinese.rs:136:46: 136:47
        StorageDead(_10);                // scope 2 at src/codec/tradchinese.rs:136:46: 136:47
        switchInt(_9) -> [65535_u32: bb7, 0_u32: bb12, 1_u32: bb14, 2_u32: bb16, 3_u32: bb18, otherwise: bb6]; // scope 2 at src/codec/tradchinese.rs:136:19: 136:47
    }

    bb6: {
        StorageLive(_29);                // scope 2 at src/codec/tradchinese.rs:145:13: 145:15
        _29 = _9;                        // scope 2 at src/codec/tradchinese.rs:145:13: 145:15
        StorageLive(_30);                // scope 4 at src/codec/tradchinese.rs:145:19: 145:22
        _30 = &mut (*_1);                // scope 4 at src/codec/tradchinese.rs:145:19: 145:22
        StorageLive(_31);                // scope 4 at src/codec/tradchinese.rs:145:28: 145:30
        _31 = _29;                       // scope 4 at src/codec/tradchinese.rs:145:28: 145:30
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::emit(move _30, move _31) -> bb20; // scope 4 at src/codec/tradchinese.rs:145:19: 145:31
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:145:23: 145:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, u32) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageLive(_12);                // scope 2 at src/codec/tradchinese.rs:138:21: 138:27
        StorageLive(_13);                // scope 2 at src/codec/tradchinese.rs:138:33: 138:41
        StorageLive(_14);                // scope 2 at src/codec/tradchinese.rs:138:33: 138:34
        _14 = _8;                        // scope 2 at src/codec/tradchinese.rs:138:33: 138:34
        _13 = Lt(move _14, const 128_u8); // scope 2 at src/codec/tradchinese.rs:138:33: 138:41
        StorageDead(_14);                // scope 2 at src/codec/tradchinese.rs:138:40: 138:41
        switchInt(move _13) -> [false: bb9, otherwise: bb8]; // scope 2 at src/codec/tradchinese.rs:138:33: 138:41
    }

    bb8: {
        _12 = const 1_usize;             // scope 2 at src/codec/tradchinese.rs:138:43: 138:44
        goto -> bb10;                    // scope 2 at src/codec/tradchinese.rs:138:30: 138:54
    }

    bb9: {
        _12 = const 0_usize;             // scope 2 at src/codec/tradchinese.rs:138:52: 138:53
        goto -> bb10;                    // scope 2 at src/codec/tradchinese.rs:138:30: 138:54
    }

    bb10: {
        StorageDead(_13);                // scope 2 at src/codec/tradchinese.rs:138:53: 138:54
        StorageLive(_15);                // scope 3 at src/codec/tradchinese.rs:139:17: 139:20
        _15 = &mut (*_1);                // scope 3 at src/codec/tradchinese.rs:139:17: 139:20
        StorageLive(_16);                // scope 3 at src/codec/tradchinese.rs:139:36: 139:42
        _16 = _12;                       // scope 3 at src/codec/tradchinese.rs:139:36: 139:42
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::backup_and_err(move _15, move _16, const "invalid sequence") -> bb11; // scope 3 at src/codec/tradchinese.rs:139:17: 139:63
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:139:21: 139:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, usize, &'static str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:139:44: 139:62
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb11: {
        StorageDead(_16);                // scope 3 at src/codec/tradchinese.rs:139:62: 139:63
        StorageDead(_15);                // scope 3 at src/codec/tradchinese.rs:139:62: 139:63
        StorageDead(_12);                // scope 2 at src/codec/tradchinese.rs:140:13: 140:14
        goto -> bb21;                    // scope 2 at src/codec/tradchinese.rs:140:13: 140:14
    }

    bb12: {
        StorageLive(_17);                // scope 2 at src/codec/tradchinese.rs:141:33: 141:36
        _17 = &mut (*_1);                // scope 2 at src/codec/tradchinese.rs:141:33: 141:36
        StorageLive(_18);                // scope 2 at src/codec/tradchinese.rs:141:46: 141:61
        StorageLive(_19);                // scope 2 at src/codec/tradchinese.rs:141:46: 141:61
        _19 = const "\u{304}";          // scope 2 at src/codec/tradchinese.rs:141:46: 141:61
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [195, 138, 204, 132], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:141:46: 141:61
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [195, 138, 204, 132], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
        _18 = _19;                       // scope 2 at src/codec/tradchinese.rs:141:46: 141:61
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::emit_str(move _17, move _18) -> bb13; // scope 2 at src/codec/tradchinese.rs:141:33: 141:62
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:141:37: 141:45
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, &'s str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::emit_str}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_19);                // scope 2 at src/codec/tradchinese.rs:141:61: 141:62
        StorageDead(_18);                // scope 2 at src/codec/tradchinese.rs:141:61: 141:62
        StorageDead(_17);                // scope 2 at src/codec/tradchinese.rs:141:61: 141:62
        goto -> bb21;                    // scope 2 at src/codec/tradchinese.rs:141:61: 141:62
    }

    bb14: {
        StorageLive(_20);                // scope 2 at src/codec/tradchinese.rs:142:33: 142:36
        _20 = &mut (*_1);                // scope 2 at src/codec/tradchinese.rs:142:33: 142:36
        StorageLive(_21);                // scope 2 at src/codec/tradchinese.rs:142:46: 142:61
        StorageLive(_22);                // scope 2 at src/codec/tradchinese.rs:142:46: 142:61
        _22 = const "\u{30c}";          // scope 2 at src/codec/tradchinese.rs:142:46: 142:61
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [195, 138, 204, 140], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:142:46: 142:61
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [195, 138, 204, 140], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
        _21 = _22;                       // scope 2 at src/codec/tradchinese.rs:142:46: 142:61
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::emit_str(move _20, move _21) -> bb15; // scope 2 at src/codec/tradchinese.rs:142:33: 142:62
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:142:37: 142:45
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, &'s str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::emit_str}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_22);                // scope 2 at src/codec/tradchinese.rs:142:61: 142:62
        StorageDead(_21);                // scope 2 at src/codec/tradchinese.rs:142:61: 142:62
        StorageDead(_20);                // scope 2 at src/codec/tradchinese.rs:142:61: 142:62
        goto -> bb21;                    // scope 2 at src/codec/tradchinese.rs:142:61: 142:62
    }

    bb16: {
        StorageLive(_23);                // scope 2 at src/codec/tradchinese.rs:143:33: 143:36
        _23 = &mut (*_1);                // scope 2 at src/codec/tradchinese.rs:143:33: 143:36
        StorageLive(_24);                // scope 2 at src/codec/tradchinese.rs:143:46: 143:61
        StorageLive(_25);                // scope 2 at src/codec/tradchinese.rs:143:46: 143:61
        _25 = const "\u{304}";          // scope 2 at src/codec/tradchinese.rs:143:46: 143:61
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [195, 170, 204, 132], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:143:46: 143:61
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [195, 170, 204, 132], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
        _24 = _25;                       // scope 2 at src/codec/tradchinese.rs:143:46: 143:61
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::emit_str(move _23, move _24) -> bb17; // scope 2 at src/codec/tradchinese.rs:143:33: 143:62
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:143:37: 143:45
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, &'s str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::emit_str}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_25);                // scope 2 at src/codec/tradchinese.rs:143:61: 143:62
        StorageDead(_24);                // scope 2 at src/codec/tradchinese.rs:143:61: 143:62
        StorageDead(_23);                // scope 2 at src/codec/tradchinese.rs:143:61: 143:62
        goto -> bb21;                    // scope 2 at src/codec/tradchinese.rs:143:61: 143:62
    }

    bb18: {
        StorageLive(_26);                // scope 2 at src/codec/tradchinese.rs:144:33: 144:36
        _26 = &mut (*_1);                // scope 2 at src/codec/tradchinese.rs:144:33: 144:36
        StorageLive(_27);                // scope 2 at src/codec/tradchinese.rs:144:46: 144:61
        StorageLive(_28);                // scope 2 at src/codec/tradchinese.rs:144:46: 144:61
        _28 = const "\u{30c}";          // scope 2 at src/codec/tradchinese.rs:144:46: 144:61
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [195, 170, 204, 140], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:144:46: 144:61
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [195, 170, 204, 140], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [15], len: Size { raw: 4 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 4 }) }
        _27 = _28;                       // scope 2 at src/codec/tradchinese.rs:144:46: 144:61
        _0 = StatefulDecoderHelper::<bigfive2003::State, T>::emit_str(move _26, move _27) -> bb19; // scope 2 at src/codec/tradchinese.rs:144:33: 144:62
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:144:37: 144:45
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, &'s str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::emit_str}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_28);                // scope 2 at src/codec/tradchinese.rs:144:61: 144:62
        StorageDead(_27);                // scope 2 at src/codec/tradchinese.rs:144:61: 144:62
        StorageDead(_26);                // scope 2 at src/codec/tradchinese.rs:144:61: 144:62
        goto -> bb21;                    // scope 2 at src/codec/tradchinese.rs:144:61: 144:62
    }

    bb20: {
        StorageDead(_31);                // scope 4 at src/codec/tradchinese.rs:145:30: 145:31
        StorageDead(_30);                // scope 4 at src/codec/tradchinese.rs:145:30: 145:31
        StorageDead(_29);                // scope 2 at src/codec/tradchinese.rs:145:30: 145:31
        goto -> bb21;                    // scope 2 at src/codec/tradchinese.rs:145:30: 145:31
    }

    bb21: {
        StorageDead(_9);                 // scope 2 at src/util.rs:226:77: 226:78
        StorageDead(_8);                 // scope 1 at src/util.rs:226:77: 226:78
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb22;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb22: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn windows949::<impl at src/util.rs:157:33: 157:38>::clone(_1: &windows949::State) -> windows949::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 2 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn iso2022jp::start::Katakana(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:193:37: 193:43
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:193:85: 193:97
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:196:31: 196:44
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:196:31: 196:37
    let mut _4: isize;                   // in scope 0 at src/util.rs:197:29: 197:33
    let _5: u8;                          // in scope 0 at src/util.rs:198:34: 198:35
    let mut _6: bool;                    // in scope 0 at src/codec/japanese.rs:937:18: 937:29
    let mut _7: bool;                    // in scope 0 at src/codec/japanese.rs:937:18: 937:29
    let mut _8: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:936:34: 936:37
    let _10: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:937:33: 937:67
    let mut _11: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:937:33: 937:36
    let mut _12: u32;                    // in scope 0 at src/codec/japanese.rs:937:42: 937:66
    let mut _13: u32;                    // in scope 0 at src/codec/japanese.rs:937:42: 937:59
    let mut _14: u32;                    // in scope 0 at src/codec/japanese.rs:937:51: 937:59
    let mut _15: u8;                     // in scope 0 at src/codec/japanese.rs:937:51: 937:52
    let mut _16: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:937:78: 937:81
    let _17: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:938:19: 938:46
    let mut _18: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:938:19: 938:22
    let mut _19: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:938:57: 938:60
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:198:34: 198:35
        let _9: u8;                      // in scope 1 at src/codec/japanese.rs:937:14: 937:29
        scope 2 {
            debug b => _9;               // in scope 2 at src/codec/japanese.rs:937:14: 937:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:196:31: 196:44
        StorageLive(_3);                 // scope 0 at src/util.rs:196:31: 196:37
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:196:31: 196:37
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:196:31: 196:44
                                         // mir::Constant
                                         // + span: src/util.rs:196:38: 196:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:196:43: 196:44
        _4 = discriminant(_2);           // scope 0 at src/util.rs:196:31: 196:44
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:196:25: 196:44
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:198:34: 198:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:198:34: 198:35
        switchInt(_5) -> [27_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:198:40: 198:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:196:31: 196:44
    }

    bb4: {
        discriminant(_0) = 3;            // scope 0 at src/util.rs:197:44: 197:66
        goto -> bb16;                    // scope 0 at src/util.rs:197:65: 197:66
    }

    bb5: {
        _6 = Le(const 33_u8, _5);        // scope 1 at src/codec/japanese.rs:937:18: 937:29
        switchInt(move _6) -> [false: bb7, otherwise: bb6]; // scope 1 at src/codec/japanese.rs:937:18: 937:29
    }

    bb6: {
        _7 = Le(_5, const 95_u8);        // scope 1 at src/codec/japanese.rs:937:18: 937:29
        switchInt(move _7) -> [false: bb7, otherwise: bb10]; // scope 1 at src/codec/japanese.rs:937:18: 937:29
    }

    bb7: {
        StorageLive(_17);                // scope 1 at src/codec/japanese.rs:938:19: 938:46
        StorageLive(_18);                // scope 1 at src/codec/japanese.rs:938:19: 938:22
        _18 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:938:19: 938:22
        _17 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _18, const "invalid sequence") -> bb13; // scope 1 at src/codec/japanese.rs:938:19: 938:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:938:23: 938:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:938:27: 938:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb8: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:936:34: 936:37
        _8 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:936:34: 936:37
        _0 = iso2022jp::transient::EscapeStart::<T>(move _8) -> bb9; // scope 1 at src/codec/japanese.rs:936:22: 936:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:936:22: 936:33
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeStart::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_8);                 // scope 1 at src/codec/japanese.rs:936:37: 936:38
        goto -> bb15;                    // scope 1 at src/codec/japanese.rs:936:37: 936:38
    }

    bb10: {
        StorageLive(_9);                 // scope 1 at src/codec/japanese.rs:937:14: 937:29
        _9 = _5;                         // scope 1 at src/codec/japanese.rs:937:14: 937:29
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:937:33: 937:67
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:937:33: 937:36
        _11 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:937:33: 937:36
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:937:42: 937:66
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:937:42: 937:59
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:937:51: 937:59
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:937:51: 937:52
        _15 = _9;                        // scope 2 at src/codec/japanese.rs:937:51: 937:52
        _14 = move _15 as u32 (Misc);    // scope 2 at src/codec/japanese.rs:937:51: 937:59
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:937:58: 937:59
        _13 = Add(const 65377_u32, move _14); // scope 2 at src/codec/japanese.rs:937:42: 937:59
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:937:58: 937:59
        _12 = Sub(move _13, const 33_u32); // scope 2 at src/codec/japanese.rs:937:42: 937:66
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:937:65: 937:66
        _10 = StatefulDecoderHelper::<iso2022jp::State, T>::emit(move _11, move _12) -> bb11; // scope 2 at src/codec/japanese.rs:937:33: 937:67
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:937:37: 937:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, u32) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:937:66: 937:67
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:937:66: 937:67
        StorageDead(_10);                // scope 2 at src/util.rs:198:76: 198:77
        StorageLive(_16);                // scope 2 at src/codec/japanese.rs:937:78: 937:81
        _16 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:937:78: 937:81
        _0 = iso2022jp::transient::Katakana::<T>(move _16) -> bb12; // scope 2 at src/codec/japanese.rs:937:69: 937:82
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:937:69: 937:77
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Katakana::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_16);                // scope 2 at src/codec/japanese.rs:937:81: 937:82
        StorageDead(_9);                 // scope 1 at src/util.rs:198:81: 198:82
        goto -> bb15;                    // scope 1 at src/util.rs:198:81: 198:82
    }

    bb13: {
        StorageDead(_18);                // scope 1 at src/codec/japanese.rs:938:45: 938:46
        StorageDead(_17);                // scope 1 at src/util.rs:198:76: 198:77
        StorageLive(_19);                // scope 1 at src/codec/japanese.rs:938:57: 938:60
        _19 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:938:57: 938:60
        _0 = iso2022jp::transient::Katakana::<T>(move _19) -> bb14; // scope 1 at src/codec/japanese.rs:938:48: 938:61
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:938:48: 938:56
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Katakana::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_19);                // scope 1 at src/codec/japanese.rs:938:60: 938:61
        goto -> bb15;                    // scope 1 at src/codec/japanese.rs:938:60: 938:61
    }

    bb15: {
        StorageDead(_5);                 // scope 0 at src/util.rs:198:85: 198:86
        goto -> bb16;                    // scope 0 at src/util.rs:198:85: 198:86
    }

    bb16: {
        StorageDead(_2);                 // scope 0 at src/util.rs:200:21: 200:22
        return;                          // scope 0 at src/util.rs:200:22: 200:22
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:62:10: 62:15>::clone(_1: &ASCIIDecoder) -> ASCIIDecoder {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:62:10: 62:15
    let mut _0: codec::ascii::ASCIIDecoder; // return place in scope 0 at src/codec/ascii.rs:62:10: 62:15

    bb0: {
        return;                          // scope 0 at src/codec/ascii.rs:62:15: 62:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:104:1: 113:2>::raw_feed(_1: &mut UTF16BEEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:106:17: 106:26
    debug input => _2;                   // in scope 0 at src/codec/utf_16.rs:106:28: 106:33
    debug output => _3;                  // in scope 0 at src/codec/utf_16.rs:106:41: 106:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_16.rs:106:69: 106:96
    let mut _4: &mut codec::utf_16::UTF16Encoder; // in scope 0 at src/codec/utf_16.rs:107:9: 107:21
    let mut _5: codec::utf_16::UTF16Encoder; // in scope 0 at src/codec/utf_16.rs:107:9: 107:21
    let mut _6: &str;                    // in scope 0 at src/codec/utf_16.rs:107:31: 107:36
    let mut _7: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:107:38: 107:44
    let mut _8: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:107:38: 107:44
    let mut _9: [closure@src/codec/utf_16.rs:107:46: 110:10]; // in scope 0 at src/codec/utf_16.rs:107:46: 110:10

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:107:9: 107:21
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:107:9: 107:21
        _4 = &mut _5;                    // scope 0 at src/codec/utf_16.rs:107:9: 107:21
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:107:31: 107:36
        _6 = _2;                         // scope 0 at src/codec/utf_16.rs:107:31: 107:36
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:107:38: 107:44
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:107:38: 107:44
        _8 = &mut (*_3);                 // scope 0 at src/codec/utf_16.rs:107:38: 107:44
        _7 = move _8 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:107:38: 107:44
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:107:43: 107:44
        StorageLive(_9);                 // scope 0 at src/codec/utf_16.rs:107:46: 110:10
        _0 = UTF16Encoder::raw_feed::<[closure@src/codec/utf_16.rs:107:46: 110:10]>(move _4, move _6, move _7, move _9) -> bb1; // scope 0 at src/codec/utf_16.rs:107:9: 110:11
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:107:22: 107:30
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut codec::utf_16::UTF16Encoder, &'s str, &'t0 mut (dyn encoding_types::ByteWriter + 't0), [closure@src/codec/utf_16.rs:107:46: 110:10]) -> (usize, std::option::Option<encoding_types::CodecError>) {codec::utf_16::UTF16Encoder::raw_feed::<[closure@src/codec/utf_16.rs:107:46: 110:10]>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_9);                 // scope 0 at src/codec/utf_16.rs:110:10: 110:11
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:110:10: 110:11
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:110:10: 110:11
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:110:10: 110:11
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:111:5: 111:6
        return;                          // scope 0 at src/codec/utf_16.rs:111:6: 111:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:465:1: 470:2>::raw_encoder(_1: &HZEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:468:20: 468:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:468:30: 468:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:468:48: 468:64
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:468:48: 468:64

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:468:48: 468:64
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:468:48: 468:64
        _3 = HZEncoder::new() -> bb1;    // scope 0 at src/codec/simpchinese.rs:468:48: 468:64
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:468:48: 468:62
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::simpchinese::HZEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:468:48: 468:64
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:468:63: 468:64
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:468:48: 468:64
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:468:65: 468:66
        return;                          // scope 0 at src/codec/simpchinese.rs:468:66: 468:66
    }
}

const UTF_8: &UTF8Encoding = {
    let mut _0: &codec::utf_8::UTF8Encoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::utf_8::UTF8Encoding;  // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const UTF_8::promoted[0];   // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(UTF_8, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1277 ~ encoding[5d2c]::all::UTF_8), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in UTF_8: &UTF8Encoding = {
    let mut _0: &codec::utf_8::UTF8Encoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::utf_8::UTF8Encoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn simpchinese::gb18030::internal::map_four_bytes(_1: u8, _2: u8, _3: u8, _4: u8) -> u32 {
    debug b1 => _1;                      // in scope 0 at src/codec/simpchinese.rs:200:36: 200:38
    debug b2 => _2;                      // in scope 0 at src/codec/simpchinese.rs:200:44: 200:46
    debug b3 => _3;                      // in scope 0 at src/codec/simpchinese.rs:200:52: 200:54
    debug b4 => _4;                      // in scope 0 at src/codec/simpchinese.rs:200:60: 200:62
    let mut _0: u32;                     // return place in scope 0 at src/codec/simpchinese.rs:200:71: 200:74
    let _5: u32;                         // in scope 0 at src/codec/simpchinese.rs:204:13: 204:18
    let mut _6: u32;                     // in scope 0 at src/codec/simpchinese.rs:204:21: 205:44
    let mut _7: u32;                     // in scope 0 at src/codec/simpchinese.rs:204:21: 204:75
    let mut _8: u32;                     // in scope 0 at src/codec/simpchinese.rs:204:21: 204:47
    let mut _9: u32;                     // in scope 0 at src/codec/simpchinese.rs:204:21: 204:39
    let mut _10: u32;                    // in scope 0 at src/codec/simpchinese.rs:204:22: 204:31
    let mut _11: u8;                     // in scope 0 at src/codec/simpchinese.rs:204:22: 204:24
    let mut _12: u32;                    // in scope 0 at src/codec/simpchinese.rs:204:50: 204:75
    let mut _13: u32;                    // in scope 0 at src/codec/simpchinese.rs:204:50: 204:68
    let mut _14: u32;                    // in scope 0 at src/codec/simpchinese.rs:204:51: 204:60
    let mut _15: u8;                     // in scope 0 at src/codec/simpchinese.rs:204:51: 204:53
    let mut _16: u32;                    // in scope 0 at src/codec/simpchinese.rs:205:21: 205:44
    let mut _17: u32;                    // in scope 0 at src/codec/simpchinese.rs:205:21: 205:39
    let mut _18: u32;                    // in scope 0 at src/codec/simpchinese.rs:205:22: 205:31
    let mut _19: u8;                     // in scope 0 at src/codec/simpchinese.rs:205:22: 205:24
    let mut _20: u32;                    // in scope 0 at src/codec/simpchinese.rs:205:47: 205:65
    let mut _21: u32;                    // in scope 0 at src/codec/simpchinese.rs:205:48: 205:57
    let mut _22: u8;                     // in scope 0 at src/codec/simpchinese.rs:205:48: 205:50
    let mut _23: u32;                    // in scope 0 at src/codec/simpchinese.rs:206:40: 206:45
    scope 1 {
        debug index => _5;               // in scope 1 at src/codec/simpchinese.rs:204:13: 204:18
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:204:13: 204:18
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:204:21: 205:44
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:204:21: 204:75
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:204:21: 204:47
        StorageLive(_9);                 // scope 0 at src/codec/simpchinese.rs:204:21: 204:39
        StorageLive(_10);                // scope 0 at src/codec/simpchinese.rs:204:22: 204:31
        StorageLive(_11);                // scope 0 at src/codec/simpchinese.rs:204:22: 204:24
        _11 = _1;                        // scope 0 at src/codec/simpchinese.rs:204:22: 204:24
        _10 = move _11 as u32 (Misc);    // scope 0 at src/codec/simpchinese.rs:204:22: 204:31
        StorageDead(_11);                // scope 0 at src/codec/simpchinese.rs:204:30: 204:31
        _9 = Sub(move _10, const 129_u32); // scope 0 at src/codec/simpchinese.rs:204:21: 204:39
        StorageDead(_10);                // scope 0 at src/codec/simpchinese.rs:204:38: 204:39
        _8 = Mul(move _9, const 12600_u32); // scope 0 at src/codec/simpchinese.rs:204:21: 204:47
        StorageDead(_9);                 // scope 0 at src/codec/simpchinese.rs:204:46: 204:47
        StorageLive(_12);                // scope 0 at src/codec/simpchinese.rs:204:50: 204:75
        StorageLive(_13);                // scope 0 at src/codec/simpchinese.rs:204:50: 204:68
        StorageLive(_14);                // scope 0 at src/codec/simpchinese.rs:204:51: 204:60
        StorageLive(_15);                // scope 0 at src/codec/simpchinese.rs:204:51: 204:53
        _15 = _2;                        // scope 0 at src/codec/simpchinese.rs:204:51: 204:53
        _14 = move _15 as u32 (Misc);    // scope 0 at src/codec/simpchinese.rs:204:51: 204:60
        StorageDead(_15);                // scope 0 at src/codec/simpchinese.rs:204:59: 204:60
        _13 = Sub(move _14, const 48_u32); // scope 0 at src/codec/simpchinese.rs:204:50: 204:68
        StorageDead(_14);                // scope 0 at src/codec/simpchinese.rs:204:67: 204:68
        _12 = Mul(move _13, const 1260_u32); // scope 0 at src/codec/simpchinese.rs:204:50: 204:75
        StorageDead(_13);                // scope 0 at src/codec/simpchinese.rs:204:74: 204:75
        _7 = Add(move _8, move _12);     // scope 0 at src/codec/simpchinese.rs:204:21: 204:75
        StorageDead(_12);                // scope 0 at src/codec/simpchinese.rs:204:74: 204:75
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:204:74: 204:75
        StorageLive(_16);                // scope 0 at src/codec/simpchinese.rs:205:21: 205:44
        StorageLive(_17);                // scope 0 at src/codec/simpchinese.rs:205:21: 205:39
        StorageLive(_18);                // scope 0 at src/codec/simpchinese.rs:205:22: 205:31
        StorageLive(_19);                // scope 0 at src/codec/simpchinese.rs:205:22: 205:24
        _19 = _3;                        // scope 0 at src/codec/simpchinese.rs:205:22: 205:24
        _18 = move _19 as u32 (Misc);    // scope 0 at src/codec/simpchinese.rs:205:22: 205:31
        StorageDead(_19);                // scope 0 at src/codec/simpchinese.rs:205:30: 205:31
        _17 = Sub(move _18, const 129_u32); // scope 0 at src/codec/simpchinese.rs:205:21: 205:39
        StorageDead(_18);                // scope 0 at src/codec/simpchinese.rs:205:38: 205:39
        _16 = Mul(move _17, const 10_u32); // scope 0 at src/codec/simpchinese.rs:205:21: 205:44
        StorageDead(_17);                // scope 0 at src/codec/simpchinese.rs:205:43: 205:44
        _6 = Add(move _7, move _16);     // scope 0 at src/codec/simpchinese.rs:204:21: 205:44
        StorageDead(_16);                // scope 0 at src/codec/simpchinese.rs:205:43: 205:44
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:205:43: 205:44
        StorageLive(_20);                // scope 0 at src/codec/simpchinese.rs:205:47: 205:65
        StorageLive(_21);                // scope 0 at src/codec/simpchinese.rs:205:48: 205:57
        StorageLive(_22);                // scope 0 at src/codec/simpchinese.rs:205:48: 205:50
        _22 = _4;                        // scope 0 at src/codec/simpchinese.rs:205:48: 205:50
        _21 = move _22 as u32 (Misc);    // scope 0 at src/codec/simpchinese.rs:205:48: 205:57
        StorageDead(_22);                // scope 0 at src/codec/simpchinese.rs:205:56: 205:57
        _20 = Sub(move _21, const 48_u32); // scope 0 at src/codec/simpchinese.rs:205:47: 205:65
        StorageDead(_21);                // scope 0 at src/codec/simpchinese.rs:205:64: 205:65
        _5 = Add(move _6, move _20);     // scope 0 at src/codec/simpchinese.rs:204:21: 205:65
        StorageDead(_20);                // scope 0 at src/codec/simpchinese.rs:205:64: 205:65
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:205:64: 205:65
        StorageLive(_23);                // scope 1 at src/codec/simpchinese.rs:206:40: 206:45
        _23 = _5;                        // scope 1 at src/codec/simpchinese.rs:206:40: 206:45
        _0 = index_simpchinese::gb18030_ranges::forward(move _23) -> bb1; // scope 1 at src/codec/simpchinese.rs:206:9: 206:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:206:9: 206:39
                                         // + literal: Const { ty: fn(u32) -> u32 {index_simpchinese::gb18030_ranges::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_23);                // scope 1 at src/codec/simpchinese.rs:206:45: 206:46
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:207:5: 207:6
        return;                          // scope 0 at src/codec/simpchinese.rs:207:6: 207:6
    }
}

const ISO_8859_4: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:45:64: 45:76
    let _5: &str;                        // in scope 0 at src/all.rs:45:64: 45:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_4::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_4, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1253 ~ encoding[5d2c]::all::ISO_8859_4), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_4: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:45:64: 45:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:45:64: 45:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-4";         // scope 0 at src/all.rs:45:64: 45:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:45:64: 45:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:45:64: 45:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_4::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_4::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_4::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_4::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-4"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:45:64: 45:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn iso2022jp::<impl at src/util.rs:168:13: 170:14>::default() -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn japanese::<impl at src/codec/japanese.rs:460:10: 460:15>::clone(_1: &Windows31JEncoder) -> Windows31JEncoder {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:460:10: 460:15
    let mut _0: codec::japanese::Windows31JEncoder; // return place in scope 0 at src/codec/japanese.rs:460:10: 460:15

    bb0: {
        return;                          // scope 0 at src/codec/japanese.rs:460:15: 460:15
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:92:10: 92:15>::clone(_1: &GBKEncoder) -> GBKEncoder {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:92:10: 92:15
    let mut _0: codec::simpchinese::GBKEncoder; // return place in scope 0 at src/codec/simpchinese.rs:92:10: 92:15

    bb0: {
        return;                          // scope 0 at src/codec/simpchinese.rs:92:15: 92:15
    }
}

fn simpchinese::gb18030::State::S2(_1: (), _2: u8, _3: u8) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S2).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S2).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S2).2: u8) = move _3;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 2;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn simpchinese::gb18030::State::S2(_1: (), _2: u8, _3: u8) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S2).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S2).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S2).2: u8) = move _3;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 2;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

static INITIAL_STATE: u8 = {
    let mut _0: u8;                      // return place in scope 0 at src/codec/utf_8.rs:131:23: 131:25

    bb0: {
        _0 = const 0_u8;                 // scope 0 at src/codec/utf_8.rs:131:28: 131:29
        return;                          // scope 0 at src/codec/utf_8.rs:131:1: 131:30
    }
}

fn iso2022jp::transient::Lead0208(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:216:80: 216:92

    bb0: {
        discriminant(_0) = 1;            // scope 0 at src/util.rs:217:25: 217:54
        return;                          // scope 0 at src/util.rs:218:22: 218:22
    }
}

const GBK: &GBKEncoding = {
    let mut _0: &codec::simpchinese::GBKEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const GBK::promoted[0];     // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GBKEncoding
                                         // + val: Unevaluated(GBK, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::simpchinese::GBKEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1284 ~ encoding[5d2c]::all::GBK), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in GBK: &GBKEncoding = {
    let mut _0: &codec::simpchinese::GBKEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::simpchinese::GBKEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:122:1: 258:2>::raw_finish(_1: &mut UTF16Decoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:247:19: 247:28
    debug _output => _2;                 // in scope 0 at src/codec/utf_16.rs:247:30: 247:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_16.rs:247:61: 247:79
    let _3: u16;                         // in scope 0 at src/codec/utf_16.rs:248:13: 248:21
    let mut _5: bool;                    // in scope 0 at src/codec/utf_16.rs:252:12: 252:57
    let mut _6: u16;                     // in scope 0 at src/codec/utf_16.rs:252:12: 252:20
    let mut _7: bool;                    // in scope 0 at src/codec/utf_16.rs:252:34: 252:57
    let mut _8: u16;                     // in scope 0 at src/codec/utf_16.rs:252:34: 252:47
    let mut _9: encoding_types::CodecError; // in scope 0 at src/codec/utf_16.rs:253:18: 253:77
    let mut _10: std::borrow::Cow<str>;  // in scope 0 at src/codec/utf_16.rs:253:47: 253:75
    let mut _11: &str;                   // in scope 0 at src/codec/utf_16.rs:253:47: 253:68
    let _12: &str;                       // in scope 0 at src/codec/utf_16.rs:253:47: 253:68
    scope 1 {
        debug leadbyte => _3;            // in scope 1 at src/codec/utf_16.rs:248:13: 248:21
        let _4: u16;                     // in scope 1 at src/codec/utf_16.rs:249:13: 249:26
        scope 2 {
            debug leadsurrogate => _4;   // in scope 2 at src/codec/utf_16.rs:249:13: 249:26
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:248:13: 248:21
        _3 = ((*_1).0: u16);             // scope 0 at src/codec/utf_16.rs:248:24: 248:37
        StorageLive(_4);                 // scope 1 at src/codec/utf_16.rs:249:13: 249:26
        _4 = ((*_1).1: u16);             // scope 1 at src/codec/utf_16.rs:249:29: 249:47
        ((*_1).0: u16) = const u16::MAX; // scope 2 at src/codec/utf_16.rs:250:9: 250:31
        ((*_1).1: u16) = const u16::MAX; // scope 2 at src/codec/utf_16.rs:251:9: 251:36
        StorageLive(_5);                 // scope 2 at src/codec/utf_16.rs:252:12: 252:57
        StorageLive(_6);                 // scope 2 at src/codec/utf_16.rs:252:12: 252:20
        _6 = _3;                         // scope 2 at src/codec/utf_16.rs:252:12: 252:20
        switchInt(move _6) -> [u16::MAX: bb2, otherwise: bb1]; // scope 2 at src/codec/utf_16.rs:252:12: 252:57
    }

    bb1: {
        StorageDead(_6);                 // scope 2 at src/codec/utf_16.rs:252:12: 252:57
        _5 = const true;                 // scope 2 at src/codec/utf_16.rs:252:12: 252:57
        goto -> bb3;                     // scope 2 at src/codec/utf_16.rs:252:12: 252:57
    }

    bb2: {
        StorageDead(_6);                 // scope 2 at src/codec/utf_16.rs:252:12: 252:57
        StorageLive(_7);                 // scope 2 at src/codec/utf_16.rs:252:34: 252:57
        StorageLive(_8);                 // scope 2 at src/codec/utf_16.rs:252:34: 252:47
        _8 = _4;                         // scope 2 at src/codec/utf_16.rs:252:34: 252:47
        _7 = Ne(move _8, const u16::MAX); // scope 2 at src/codec/utf_16.rs:252:34: 252:57
        StorageDead(_8);                 // scope 2 at src/codec/utf_16.rs:252:56: 252:57
        _5 = move _7;                    // scope 2 at src/codec/utf_16.rs:252:12: 252:57
        goto -> bb3;                     // scope 2 at src/codec/utf_16.rs:252:12: 252:57
    }

    bb3: {
        StorageDead(_7);                 // scope 2 at src/codec/utf_16.rs:252:56: 252:57
        switchInt(move _5) -> [false: bb6, otherwise: bb4]; // scope 2 at src/codec/utf_16.rs:252:12: 252:57
    }

    bb4: {
        StorageLive(_9);                 // scope 2 at src/codec/utf_16.rs:253:18: 253:77
        StorageLive(_10);                // scope 2 at src/codec/utf_16.rs:253:47: 253:75
        StorageLive(_11);                // scope 2 at src/codec/utf_16.rs:253:47: 253:68
        StorageLive(_12);                // scope 2 at src/codec/utf_16.rs:253:47: 253:68
        _12 = const "incomplete sequence"; // scope 2 at src/codec/utf_16.rs:253:47: 253:68
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:253:47: 253:68
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
        _11 = _12;                       // scope 2 at src/codec/utf_16.rs:253:47: 253:68
        _10 = <&str as Into<Cow<str>>>::into(move _11) -> bb5; // scope 2 at src/codec/utf_16.rs:253:47: 253:75
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:253:69: 253:73
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        StorageDead(_11);                // scope 2 at src/codec/utf_16.rs:253:74: 253:75
        (_9.0: isize) = const 0_isize;   // scope 2 at src/codec/utf_16.rs:253:18: 253:77
        (_9.1: std::borrow::Cow<str>) = move _10; // scope 2 at src/codec/utf_16.rs:253:18: 253:77
        StorageDead(_10);                // scope 2 at src/codec/utf_16.rs:253:76: 253:77
        ((_0 as Some).0: encoding_types::CodecError) = move _9; // scope 2 at src/codec/utf_16.rs:253:13: 253:78
        discriminant(_0) = 1;            // scope 2 at src/codec/utf_16.rs:253:13: 253:78
        StorageDead(_9);                 // scope 2 at src/codec/utf_16.rs:253:77: 253:78
        StorageDead(_12);                // scope 2 at src/codec/utf_16.rs:254:9: 254:10
        goto -> bb7;                     // scope 2 at src/codec/utf_16.rs:252:9: 256:10
    }

    bb6: {
        discriminant(_0) = 0;            // scope 2 at src/codec/utf_16.rs:255:13: 255:17
        goto -> bb7;                     // scope 2 at src/codec/utf_16.rs:252:9: 256:10
    }

    bb7: {
        StorageDead(_5);                 // scope 2 at src/codec/utf_16.rs:256:9: 256:10
        StorageDead(_4);                 // scope 1 at src/codec/utf_16.rs:257:5: 257:6
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:257:5: 257:6
        return;                          // scope 0 at src/codec/utf_16.rs:257:6: 257:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:482:1: 533:2>::raw_feed(_1: &mut HZEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:486:17: 486:26
    debug input => _2;                   // in scope 0 at src/codec/simpchinese.rs:486:28: 486:33
    debug output => _3;                  // in scope 0 at src/codec/simpchinese.rs:486:41: 486:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/simpchinese.rs:486:69: 486:96
    let _4: ();                          // in scope 0 at src/codec/simpchinese.rs:487:9: 487:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:487:9: 487:15
    let mut _6: usize;                   // in scope 0 at src/codec/simpchinese.rs:487:28: 487:39
    let mut _7: &str;                    // in scope 0 at src/codec/simpchinese.rs:487:28: 487:33
    let mut _8: bool;                    // in scope 0 at src/codec/simpchinese.rs:489:13: 489:24
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:497:28: 497:46
    let mut _10: util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:497:28: 497:46
    let mut _11: &&str;                  // in scope 0 at src/codec/simpchinese.rs:497:28: 497:33
    let mut _14: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/simpchinese.rs:497:28: 497:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:497:28: 497:46
    let mut _16: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/simpchinese.rs:497:28: 497:46
    let mut _17: isize;                  // in scope 0 at src/codec/simpchinese.rs:497:13: 497:24
    let mut _19: ((usize, usize), char); // in scope 0 at src/codec/simpchinese.rs:497:13: 497:24
    let mut _23: bool;                   // in scope 0 at src/codec/simpchinese.rs:498:16: 498:29
    let mut _24: char;                   // in scope 0 at src/codec/simpchinese.rs:498:16: 498:18
    let mut _25: bool;                   // in scope 0 at src/codec/simpchinese.rs:494:23: 494:30
    let _26: ();                         // in scope 0 at src/codec/simpchinese.rs:494:33: 494:58
    let mut _27: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:494:33: 494:39
    let mut _28: &[u8];                  // in scope 0 at src/codec/simpchinese.rs:494:52: 494:57
    let mut _29: &[u8; 2];               // in scope 0 at src/codec/simpchinese.rs:494:52: 494:57
    let _30: &[u8; 2];                   // in scope 0 at src/codec/simpchinese.rs:494:52: 494:57
    let _31: ();                         // in scope 0 at src/codec/simpchinese.rs:500:17: 500:44
    let mut _32: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:500:17: 500:23
    let mut _33: u8;                     // in scope 0 at src/codec/simpchinese.rs:500:35: 500:43
    let mut _34: char;                   // in scope 0 at src/codec/simpchinese.rs:500:35: 500:37
    let mut _35: char;                   // in scope 0 at src/codec/simpchinese.rs:501:20: 501:22
    let _36: ();                         // in scope 0 at src/codec/simpchinese.rs:501:32: 501:60
    let mut _37: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:501:32: 501:38
    let mut _38: u8;                     // in scope 0 at src/codec/simpchinese.rs:501:50: 501:59
    let mut _40: u32;                    // in scope 0 at src/codec/simpchinese.rs:503:52: 503:61
    let mut _41: char;                   // in scope 0 at src/codec/simpchinese.rs:503:52: 503:54
    let mut _42: u16;                    // in scope 0 at src/codec/simpchinese.rs:504:20: 504:23
    let mut _43: bool;                   // in scope 0 at src/codec/simpchinese.rs:505:36: 505:43
    let mut _44: usize;                  // in scope 0 at src/codec/simpchinese.rs:506:29: 506:30
    let mut _45: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:506:32: 508:23
    let mut _46: encoding_types::CodecError; // in scope 0 at src/codec/simpchinese.rs:506:37: 508:22
    let mut _47: isize;                  // in scope 0 at src/codec/simpchinese.rs:507:31: 507:41
    let mut _48: usize;                  // in scope 0 at src/codec/simpchinese.rs:507:31: 507:32
    let mut _49: std::borrow::Cow<str>;  // in scope 0 at src/codec/simpchinese.rs:507:50: 507:84
    let mut _50: &str;                   // in scope 0 at src/codec/simpchinese.rs:507:50: 507:77
    let _51: &str;                       // in scope 0 at src/codec/simpchinese.rs:507:50: 507:77
    let mut _53: u16;                    // in scope 0 at src/codec/simpchinese.rs:510:32: 510:35
    let mut _55: u16;                    // in scope 0 at src/codec/simpchinese.rs:511:33: 511:36
    let mut _56: bool;                   // in scope 0 at src/codec/simpchinese.rs:512:24: 512:62
    let mut _57: bool;                   // in scope 0 at src/codec/simpchinese.rs:512:24: 512:39
    let mut _58: u16;                    // in scope 0 at src/codec/simpchinese.rs:512:24: 512:28
    let mut _59: u16;                    // in scope 0 at src/codec/simpchinese.rs:512:31: 512:39
    let mut _60: bool;                   // in scope 0 at src/codec/simpchinese.rs:512:43: 512:62
    let mut _61: u16;                    // in scope 0 at src/codec/simpchinese.rs:512:43: 512:48
    let mut _62: u16;                    // in scope 0 at src/codec/simpchinese.rs:512:51: 512:62
    let mut _63: bool;                   // in scope 0 at src/codec/simpchinese.rs:513:40: 513:47
    let mut _64: usize;                  // in scope 0 at src/codec/simpchinese.rs:514:33: 514:34
    let mut _65: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:514:36: 516:27
    let mut _66: encoding_types::CodecError; // in scope 0 at src/codec/simpchinese.rs:514:41: 516:26
    let mut _67: isize;                  // in scope 0 at src/codec/simpchinese.rs:515:35: 515:45
    let mut _68: usize;                  // in scope 0 at src/codec/simpchinese.rs:515:35: 515:36
    let mut _69: std::borrow::Cow<str>;  // in scope 0 at src/codec/simpchinese.rs:515:54: 515:88
    let mut _70: &str;                   // in scope 0 at src/codec/simpchinese.rs:515:54: 515:81
    let _71: &str;                       // in scope 0 at src/codec/simpchinese.rs:515:54: 515:81
    let mut _72: bool;                   // in scope 0 at src/codec/simpchinese.rs:491:23: 491:31
    let mut _73: bool;                   // in scope 0 at src/codec/simpchinese.rs:491:24: 491:31
    let _74: ();                         // in scope 0 at src/codec/simpchinese.rs:491:34: 491:59
    let mut _75: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:491:34: 491:40
    let mut _76: &[u8];                  // in scope 0 at src/codec/simpchinese.rs:491:53: 491:58
    let mut _77: &[u8; 2];               // in scope 0 at src/codec/simpchinese.rs:491:53: 491:58
    let _78: &[u8; 2];                   // in scope 0 at src/codec/simpchinese.rs:491:53: 491:58
    let _79: ();                         // in scope 0 at src/codec/simpchinese.rs:519:25: 519:60
    let mut _80: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:519:25: 519:31
    let mut _81: u8;                     // in scope 0 at src/codec/simpchinese.rs:519:43: 519:59
    let mut _82: u16;                    // in scope 0 at src/codec/simpchinese.rs:519:43: 519:53
    let mut _83: u16;                    // in scope 0 at src/codec/simpchinese.rs:519:44: 519:48
    let _84: ();                         // in scope 0 at src/codec/simpchinese.rs:520:25: 520:64
    let mut _85: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/simpchinese.rs:520:25: 520:31
    let mut _86: u8;                     // in scope 0 at src/codec/simpchinese.rs:520:43: 520:63
    let mut _87: u16;                    // in scope 0 at src/codec/simpchinese.rs:520:43: 520:57
    let mut _88: u16;                    // in scope 0 at src/codec/simpchinese.rs:520:44: 520:49
    let mut _89: bool;                   // in scope 0 at src/codec/simpchinese.rs:526:24: 526:31
    let mut _90: usize;                  // in scope 0 at src/codec/simpchinese.rs:527:10: 527:21
    let mut _91: &str;                   // in scope 0 at src/codec/simpchinese.rs:527:10: 527:15
    let mut _92: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/simpchinese.rs:527:23: 527:27
    scope 1 {
        debug escaped => _8;             // in scope 1 at src/codec/simpchinese.rs:489:13: 489:24
        let mut _12: util::StrCharIndexIterator; // in scope 1 at src/codec/simpchinese.rs:497:28: 497:46
        scope 2 {
            debug iter => _12;           // in scope 2 at src/codec/simpchinese.rs:497:28: 497:46
            let mut _13: ((usize, usize), char); // in scope 2 at src/codec/simpchinese.rs:497:28: 497:46
            scope 3 {
                debug __next => _13;     // in scope 3 at src/codec/simpchinese.rs:497:28: 497:46
                let _18: ((usize, usize), char); // in scope 3 at src/codec/simpchinese.rs:497:13: 497:24
                let _20: usize;          // in scope 3 at src/codec/simpchinese.rs:497:15: 497:16
                let _21: usize;          // in scope 3 at src/codec/simpchinese.rs:497:17: 497:18
                let _22: char;           // in scope 3 at src/codec/simpchinese.rs:497:21: 497:23
                scope 4 {
                    debug val => _18;    // in scope 4 at src/codec/simpchinese.rs:497:13: 497:24
                }
                scope 5 {
                    debug i => _20;      // in scope 5 at src/codec/simpchinese.rs:497:15: 497:16
                    debug j => _21;      // in scope 5 at src/codec/simpchinese.rs:497:17: 497:18
                    debug ch => _22;     // in scope 5 at src/codec/simpchinese.rs:497:21: 497:23
                    let _39: u16;        // in scope 5 at src/codec/simpchinese.rs:503:21: 503:24
                    scope 6 {
                        debug ptr => _39; // in scope 6 at src/codec/simpchinese.rs:503:21: 503:24
                        let _52: u16;    // in scope 6 at src/codec/simpchinese.rs:510:25: 510:29
                        scope 7 {
                            debug lead => _52; // in scope 7 at src/codec/simpchinese.rs:510:25: 510:29
                            let _54: u16; // in scope 7 at src/codec/simpchinese.rs:511:25: 511:30
                            scope 8 {
                                debug trail => _54; // in scope 8 at src/codec/simpchinese.rs:511:25: 511:30
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/simpchinese.rs:487:9: 487:40
        StorageLive(_5);                 // scope 0 at src/codec/simpchinese.rs:487:9: 487:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/simpchinese.rs:487:9: 487:15
        StorageLive(_6);                 // scope 0 at src/codec/simpchinese.rs:487:28: 487:39
        StorageLive(_7);                 // scope 0 at src/codec/simpchinese.rs:487:28: 487:33
        _7 = _2;                         // scope 0 at src/codec/simpchinese.rs:487:28: 487:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/simpchinese.rs:487:28: 487:39
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:487:34: 487:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/simpchinese.rs:487:38: 487:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/simpchinese.rs:487:9: 487:40
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:487:16: 487:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/simpchinese.rs:487:39: 487:40
        StorageDead(_5);                 // scope 0 at src/codec/simpchinese.rs:487:39: 487:40
        StorageDead(_4);                 // scope 0 at src/codec/simpchinese.rs:487:40: 487:41
        StorageLive(_8);                 // scope 0 at src/codec/simpchinese.rs:489:13: 489:24
        _8 = ((*_1).0: bool);            // scope 0 at src/codec/simpchinese.rs:489:27: 489:39
        StorageLive(_9);                 // scope 1 at src/codec/simpchinese.rs:497:28: 497:46
        StorageLive(_10);                // scope 1 at src/codec/simpchinese.rs:497:28: 497:46
        StorageLive(_11);                // scope 1 at src/codec/simpchinese.rs:497:28: 497:33
        _11 = &_2;                       // scope 1 at src/codec/simpchinese.rs:497:28: 497:33
        _10 = <&str as StrCharIndex>::index_iter(move _11) -> bb3; // scope 1 at src/codec/simpchinese.rs:497:28: 497:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:497:34: 497:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_11);                // scope 1 at src/codec/simpchinese.rs:497:45: 497:46
        _9 = <StrCharIndexIterator as IntoIterator>::into_iter(move _10) -> bb4; // scope 1 at src/codec/simpchinese.rs:497:28: 497:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:497:28: 497:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_10);                // scope 1 at src/codec/simpchinese.rs:497:45: 497:46
        StorageLive(_12);                // scope 1 at src/codec/simpchinese.rs:497:28: 497:46
        _12 = move _9;                   // scope 1 at src/codec/simpchinese.rs:497:28: 497:46
        goto -> bb5;                     // scope 2 at src/codec/simpchinese.rs:497:9: 524:10
    }

    bb5: {
        StorageLive(_13);                // scope 2 at src/codec/simpchinese.rs:497:28: 497:46
        StorageLive(_14);                // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
        StorageLive(_15);                // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
        StorageLive(_16);                // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
        _16 = &mut _12;                  // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
        _15 = &mut (*_16);               // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
        _14 = <StrCharIndexIterator as Iterator>::next(move _15) -> bb6; // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:497:28: 497:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_15);                // scope 3 at src/codec/simpchinese.rs:497:45: 497:46
        _17 = discriminant(_14);         // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
        switchInt(move _17) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
    }

    bb7: {
        StorageDead(_16);                // scope 3 at src/codec/simpchinese.rs:497:45: 497:46
        StorageDead(_14);                // scope 3 at src/codec/simpchinese.rs:497:45: 497:46
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_12);                // scope 1 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_9);                 // scope 1 at src/codec/simpchinese.rs:497:45: 497:46
        StorageLive(_89);                // scope 1 at src/codec/simpchinese.rs:526:24: 526:31
        _89 = _8;                        // scope 1 at src/codec/simpchinese.rs:526:24: 526:31
        ((*_1).0: bool) = move _89;      // scope 1 at src/codec/simpchinese.rs:526:9: 526:31
        StorageDead(_89);                // scope 1 at src/codec/simpchinese.rs:526:30: 526:31
        StorageLive(_90);                // scope 1 at src/codec/simpchinese.rs:527:10: 527:21
        StorageLive(_91);                // scope 1 at src/codec/simpchinese.rs:527:10: 527:15
        _91 = _2;                        // scope 1 at src/codec/simpchinese.rs:527:10: 527:15
        _90 = core::str::<impl str>::len(move _91) -> bb36; // scope 1 at src/codec/simpchinese.rs:527:10: 527:21
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:527:16: 527:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 3 at src/codec/simpchinese.rs:497:28: 497:46
    }

    bb9: {
        StorageLive(_18);                // scope 3 at src/codec/simpchinese.rs:497:13: 497:24
        _18 = ((_14 as Some).0: ((usize, usize), char)); // scope 3 at src/codec/simpchinese.rs:497:13: 497:24
        StorageLive(_19);                // scope 4 at src/codec/simpchinese.rs:497:13: 497:24
        _19 = _18;                       // scope 4 at src/codec/simpchinese.rs:497:13: 497:24
        _13 = move _19;                  // scope 4 at src/codec/simpchinese.rs:497:13: 497:24
        StorageDead(_19);                // scope 4 at src/codec/simpchinese.rs:497:23: 497:24
        StorageDead(_18);                // scope 3 at src/codec/simpchinese.rs:497:23: 497:24
        StorageDead(_16);                // scope 3 at src/codec/simpchinese.rs:497:45: 497:46
        StorageDead(_14);                // scope 3 at src/codec/simpchinese.rs:497:45: 497:46
        StorageLive(_20);                // scope 3 at src/codec/simpchinese.rs:497:15: 497:16
        _20 = ((_13.0: (usize, usize)).0: usize); // scope 3 at src/codec/simpchinese.rs:497:15: 497:16
        StorageLive(_21);                // scope 3 at src/codec/simpchinese.rs:497:17: 497:18
        _21 = ((_13.0: (usize, usize)).1: usize); // scope 3 at src/codec/simpchinese.rs:497:17: 497:18
        StorageLive(_22);                // scope 3 at src/codec/simpchinese.rs:497:21: 497:23
        _22 = (_13.1: char);             // scope 3 at src/codec/simpchinese.rs:497:21: 497:23
        StorageLive(_23);                // scope 5 at src/codec/simpchinese.rs:498:16: 498:29
        StorageLive(_24);                // scope 5 at src/codec/simpchinese.rs:498:16: 498:18
        _24 = _22;                       // scope 5 at src/codec/simpchinese.rs:498:16: 498:18
        _23 = Lt(move _24, const '\u{80}'); // scope 5 at src/codec/simpchinese.rs:498:16: 498:29
        StorageDead(_24);                // scope 5 at src/codec/simpchinese.rs:498:28: 498:29
        switchInt(move _23) -> [false: bb11, otherwise: bb10]; // scope 5 at src/codec/simpchinese.rs:498:16: 498:29
    }

    bb10: {
        StorageLive(_25);                // scope 5 at src/codec/simpchinese.rs:494:23: 494:30
        _25 = _8;                        // scope 5 at src/codec/simpchinese.rs:494:23: 494:30
        switchInt(move _25) -> [false: bb14, otherwise: bb12]; // scope 5 at src/codec/simpchinese.rs:494:23: 494:30
    }

    bb11: {
        StorageLive(_39);                // scope 5 at src/codec/simpchinese.rs:503:21: 503:24
        StorageLive(_40);                // scope 5 at src/codec/simpchinese.rs:503:52: 503:61
        StorageLive(_41);                // scope 5 at src/codec/simpchinese.rs:503:52: 503:54
        _41 = _22;                       // scope 5 at src/codec/simpchinese.rs:503:52: 503:54
        _40 = move _41 as u32 (Misc);    // scope 5 at src/codec/simpchinese.rs:503:52: 503:61
        StorageDead(_41);                // scope 5 at src/codec/simpchinese.rs:503:60: 503:61
        _39 = index_simpchinese::gb18030::backward(move _40) -> bb20; // scope 5 at src/codec/simpchinese.rs:503:27: 503:62
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:503:27: 503:51
                                         // + literal: Const { ty: fn(u32) -> u16 {index_simpchinese::gb18030::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageLive(_26);                // scope 5 at src/codec/simpchinese.rs:494:33: 494:58
        StorageLive(_27);                // scope 5 at src/codec/simpchinese.rs:494:33: 494:39
        _27 = &mut (*_3);                // scope 5 at src/codec/simpchinese.rs:494:33: 494:39
        StorageLive(_28);                // scope 5 at src/codec/simpchinese.rs:494:52: 494:57
        StorageLive(_29);                // scope 5 at src/codec/simpchinese.rs:494:52: 494:57
        StorageLive(_30);                // scope 5 at src/codec/simpchinese.rs:494:52: 494:57
        _30 = const b"~}";               // scope 5 at src/codec/simpchinese.rs:494:52: 494:57
                                         // ty::Const
                                         // + ty: &[u8; 2]
                                         // + val: Value(Scalar(alloc10))
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:494:52: 494:57
                                         // + literal: Const { ty: &[u8; 2], val: Value(Scalar(alloc10)) }
        _29 = _30;                       // scope 5 at src/codec/simpchinese.rs:494:52: 494:57
        _28 = move _29 as &[u8] (Pointer(Unsize)); // scope 5 at src/codec/simpchinese.rs:494:52: 494:57
        StorageDead(_29);                // scope 5 at src/codec/simpchinese.rs:494:56: 494:57
        _26 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _27, move _28) -> bb13; // scope 5 at src/codec/simpchinese.rs:494:33: 494:58
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:494:40: 494:51
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_28);                // scope 5 at src/codec/simpchinese.rs:494:57: 494:58
        StorageDead(_27);                // scope 5 at src/codec/simpchinese.rs:494:57: 494:58
        StorageDead(_30);                // scope 5 at src/codec/simpchinese.rs:494:58: 494:59
        StorageDead(_26);                // scope 5 at src/codec/simpchinese.rs:494:58: 494:59
        _8 = const false;                // scope 5 at src/codec/simpchinese.rs:494:60: 494:75
        goto -> bb14;                    // scope 5 at src/codec/simpchinese.rs:494:20: 494:78
    }

    bb14: {
        StorageDead(_25);                // scope 5 at src/codec/simpchinese.rs:494:77: 494:78
        StorageLive(_31);                // scope 5 at src/codec/simpchinese.rs:500:17: 500:44
        StorageLive(_32);                // scope 5 at src/codec/simpchinese.rs:500:17: 500:23
        _32 = &mut (*_3);                // scope 5 at src/codec/simpchinese.rs:500:17: 500:23
        StorageLive(_33);                // scope 5 at src/codec/simpchinese.rs:500:35: 500:43
        StorageLive(_34);                // scope 5 at src/codec/simpchinese.rs:500:35: 500:37
        _34 = _22;                       // scope 5 at src/codec/simpchinese.rs:500:35: 500:37
        _33 = move _34 as u8 (Misc);     // scope 5 at src/codec/simpchinese.rs:500:35: 500:43
        StorageDead(_34);                // scope 5 at src/codec/simpchinese.rs:500:42: 500:43
        _31 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _32, move _33) -> bb15; // scope 5 at src/codec/simpchinese.rs:500:17: 500:44
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:500:24: 500:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_33);                // scope 5 at src/codec/simpchinese.rs:500:43: 500:44
        StorageDead(_32);                // scope 5 at src/codec/simpchinese.rs:500:43: 500:44
        StorageDead(_31);                // scope 5 at src/codec/simpchinese.rs:500:44: 500:45
        StorageLive(_35);                // scope 5 at src/codec/simpchinese.rs:501:20: 501:22
        _35 = _22;                       // scope 5 at src/codec/simpchinese.rs:501:20: 501:22
        switchInt(move _35) -> ['~': bb16, otherwise: bb18]; // scope 5 at src/codec/simpchinese.rs:501:20: 501:29
    }

    bb16: {
        StorageDead(_35);                // scope 5 at src/codec/simpchinese.rs:501:20: 501:29
        StorageLive(_36);                // scope 5 at src/codec/simpchinese.rs:501:32: 501:60
        StorageLive(_37);                // scope 5 at src/codec/simpchinese.rs:501:32: 501:38
        _37 = &mut (*_3);                // scope 5 at src/codec/simpchinese.rs:501:32: 501:38
        StorageLive(_38);                // scope 5 at src/codec/simpchinese.rs:501:50: 501:59
        _38 = const 126_u8;              // scope 5 at src/codec/simpchinese.rs:501:50: 501:59
        _36 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _37, move _38) -> bb17; // scope 5 at src/codec/simpchinese.rs:501:32: 501:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:501:39: 501:49
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_38);                // scope 5 at src/codec/simpchinese.rs:501:59: 501:60
        StorageDead(_37);                // scope 5 at src/codec/simpchinese.rs:501:59: 501:60
        StorageDead(_36);                // scope 5 at src/codec/simpchinese.rs:501:60: 501:61
        goto -> bb19;                    // scope 5 at src/codec/simpchinese.rs:501:17: 501:63
    }

    bb18: {
        StorageDead(_35);                // scope 5 at src/codec/simpchinese.rs:501:20: 501:29
        goto -> bb19;                    // scope 5 at src/codec/simpchinese.rs:501:17: 501:63
    }

    bb19: {
        goto -> bb35;                    // scope 5 at src/codec/simpchinese.rs:498:13: 523:14
    }

    bb20: {
        StorageDead(_40);                // scope 5 at src/codec/simpchinese.rs:503:61: 503:62
        StorageLive(_42);                // scope 6 at src/codec/simpchinese.rs:504:20: 504:23
        _42 = _39;                       // scope 6 at src/codec/simpchinese.rs:504:20: 504:23
        switchInt(move _42) -> [u16::MAX: bb21, otherwise: bb23]; // scope 6 at src/codec/simpchinese.rs:504:20: 504:33
    }

    bb21: {
        StorageDead(_42);                // scope 6 at src/codec/simpchinese.rs:504:20: 504:33
        StorageLive(_43);                // scope 6 at src/codec/simpchinese.rs:505:36: 505:43
        _43 = _8;                        // scope 6 at src/codec/simpchinese.rs:505:36: 505:43
        ((*_1).0: bool) = move _43;      // scope 6 at src/codec/simpchinese.rs:505:21: 505:43
        StorageDead(_43);                // scope 6 at src/codec/simpchinese.rs:505:42: 505:43
        StorageLive(_44);                // scope 6 at src/codec/simpchinese.rs:506:29: 506:30
        _44 = _20;                       // scope 6 at src/codec/simpchinese.rs:506:29: 506:30
        StorageLive(_45);                // scope 6 at src/codec/simpchinese.rs:506:32: 508:23
        StorageLive(_46);                // scope 6 at src/codec/simpchinese.rs:506:37: 508:22
        StorageLive(_47);                // scope 6 at src/codec/simpchinese.rs:507:31: 507:41
        StorageLive(_48);                // scope 6 at src/codec/simpchinese.rs:507:31: 507:32
        _48 = _21;                       // scope 6 at src/codec/simpchinese.rs:507:31: 507:32
        _47 = move _48 as isize (Misc);  // scope 6 at src/codec/simpchinese.rs:507:31: 507:41
        StorageDead(_48);                // scope 6 at src/codec/simpchinese.rs:507:40: 507:41
        StorageLive(_49);                // scope 6 at src/codec/simpchinese.rs:507:50: 507:84
        StorageLive(_50);                // scope 6 at src/codec/simpchinese.rs:507:50: 507:77
        StorageLive(_51);                // scope 6 at src/codec/simpchinese.rs:507:50: 507:77
        _51 = const "unrepresentable character"; // scope 6 at src/codec/simpchinese.rs:507:50: 507:77
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:507:50: 507:77
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _50 = _51;                       // scope 6 at src/codec/simpchinese.rs:507:50: 507:77
        _49 = <&str as Into<Cow<str>>>::into(move _50) -> bb22; // scope 6 at src/codec/simpchinese.rs:507:50: 507:84
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:507:78: 507:82
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb22: {
        StorageDead(_50);                // scope 6 at src/codec/simpchinese.rs:507:83: 507:84
        (_46.0: isize) = move _47;       // scope 6 at src/codec/simpchinese.rs:506:37: 508:22
        (_46.1: std::borrow::Cow<str>) = move _49; // scope 6 at src/codec/simpchinese.rs:506:37: 508:22
        StorageDead(_49);                // scope 6 at src/codec/simpchinese.rs:508:21: 508:22
        StorageDead(_47);                // scope 6 at src/codec/simpchinese.rs:508:21: 508:22
        ((_45 as Some).0: encoding_types::CodecError) = move _46; // scope 6 at src/codec/simpchinese.rs:506:32: 508:23
        discriminant(_45) = 1;           // scope 6 at src/codec/simpchinese.rs:506:32: 508:23
        StorageDead(_46);                // scope 6 at src/codec/simpchinese.rs:508:22: 508:23
        (_0.0: usize) = move _44;        // scope 6 at src/codec/simpchinese.rs:506:28: 508:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _45; // scope 6 at src/codec/simpchinese.rs:506:28: 508:24
        StorageDead(_45);                // scope 6 at src/codec/simpchinese.rs:508:23: 508:24
        StorageDead(_44);                // scope 6 at src/codec/simpchinese.rs:508:23: 508:24
        StorageDead(_51);                // scope 6 at src/codec/simpchinese.rs:508:24: 508:25
        goto -> bb37;                    // scope 6 at no-location
    }

    bb23: {
        StorageDead(_42);                // scope 6 at src/codec/simpchinese.rs:504:20: 504:33
        StorageLive(_52);                // scope 6 at src/codec/simpchinese.rs:510:25: 510:29
        StorageLive(_53);                // scope 6 at src/codec/simpchinese.rs:510:32: 510:35
        _53 = _39;                       // scope 6 at src/codec/simpchinese.rs:510:32: 510:35
        _52 = Div(move _53, const 190_u16); // scope 6 at src/codec/simpchinese.rs:510:32: 510:41
        StorageDead(_53);                // scope 6 at src/codec/simpchinese.rs:510:40: 510:41
        StorageLive(_54);                // scope 7 at src/codec/simpchinese.rs:511:25: 511:30
        StorageLive(_55);                // scope 7 at src/codec/simpchinese.rs:511:33: 511:36
        _55 = _39;                       // scope 7 at src/codec/simpchinese.rs:511:33: 511:36
        _54 = Rem(move _55, const 190_u16); // scope 7 at src/codec/simpchinese.rs:511:33: 511:42
        StorageDead(_55);                // scope 7 at src/codec/simpchinese.rs:511:41: 511:42
        StorageLive(_56);                // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
        StorageLive(_57);                // scope 8 at src/codec/simpchinese.rs:512:24: 512:39
        StorageLive(_58);                // scope 8 at src/codec/simpchinese.rs:512:24: 512:28
        _58 = _52;                       // scope 8 at src/codec/simpchinese.rs:512:24: 512:28
        StorageLive(_59);                // scope 8 at src/codec/simpchinese.rs:512:31: 512:39
        _59 = const 32_u16;              // scope 8 at src/codec/simpchinese.rs:512:31: 512:39
        _57 = Lt(move _58, move _59);    // scope 8 at src/codec/simpchinese.rs:512:24: 512:39
        StorageDead(_59);                // scope 8 at src/codec/simpchinese.rs:512:38: 512:39
        StorageDead(_58);                // scope 8 at src/codec/simpchinese.rs:512:38: 512:39
        switchInt(move _57) -> [false: bb25, otherwise: bb24]; // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
    }

    bb24: {
        _56 = const true;                // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
        goto -> bb26;                    // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
    }

    bb25: {
        StorageLive(_60);                // scope 8 at src/codec/simpchinese.rs:512:43: 512:62
        StorageLive(_61);                // scope 8 at src/codec/simpchinese.rs:512:43: 512:48
        _61 = _54;                       // scope 8 at src/codec/simpchinese.rs:512:43: 512:48
        StorageLive(_62);                // scope 8 at src/codec/simpchinese.rs:512:51: 512:62
        _62 = const 96_u16;              // scope 8 at src/codec/simpchinese.rs:512:51: 512:62
        _60 = Lt(move _61, move _62);    // scope 8 at src/codec/simpchinese.rs:512:43: 512:62
        StorageDead(_62);                // scope 8 at src/codec/simpchinese.rs:512:61: 512:62
        StorageDead(_61);                // scope 8 at src/codec/simpchinese.rs:512:61: 512:62
        _56 = move _60;                  // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
        goto -> bb26;                    // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
    }

    bb26: {
        StorageDead(_60);                // scope 8 at src/codec/simpchinese.rs:512:61: 512:62
        StorageDead(_57);                // scope 8 at src/codec/simpchinese.rs:512:61: 512:62
        switchInt(move _56) -> [false: bb29, otherwise: bb27]; // scope 8 at src/codec/simpchinese.rs:512:24: 512:62
    }

    bb27: {
        StorageLive(_63);                // scope 8 at src/codec/simpchinese.rs:513:40: 513:47
        _63 = _8;                        // scope 8 at src/codec/simpchinese.rs:513:40: 513:47
        ((*_1).0: bool) = move _63;      // scope 8 at src/codec/simpchinese.rs:513:25: 513:47
        StorageDead(_63);                // scope 8 at src/codec/simpchinese.rs:513:46: 513:47
        StorageLive(_64);                // scope 8 at src/codec/simpchinese.rs:514:33: 514:34
        _64 = _20;                       // scope 8 at src/codec/simpchinese.rs:514:33: 514:34
        StorageLive(_65);                // scope 8 at src/codec/simpchinese.rs:514:36: 516:27
        StorageLive(_66);                // scope 8 at src/codec/simpchinese.rs:514:41: 516:26
        StorageLive(_67);                // scope 8 at src/codec/simpchinese.rs:515:35: 515:45
        StorageLive(_68);                // scope 8 at src/codec/simpchinese.rs:515:35: 515:36
        _68 = _21;                       // scope 8 at src/codec/simpchinese.rs:515:35: 515:36
        _67 = move _68 as isize (Misc);  // scope 8 at src/codec/simpchinese.rs:515:35: 515:45
        StorageDead(_68);                // scope 8 at src/codec/simpchinese.rs:515:44: 515:45
        StorageLive(_69);                // scope 8 at src/codec/simpchinese.rs:515:54: 515:88
        StorageLive(_70);                // scope 8 at src/codec/simpchinese.rs:515:54: 515:81
        StorageLive(_71);                // scope 8 at src/codec/simpchinese.rs:515:54: 515:81
        _71 = const "unrepresentable character"; // scope 8 at src/codec/simpchinese.rs:515:54: 515:81
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:515:54: 515:81
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _70 = _71;                       // scope 8 at src/codec/simpchinese.rs:515:54: 515:81
        _69 = <&str as Into<Cow<str>>>::into(move _70) -> bb28; // scope 8 at src/codec/simpchinese.rs:515:54: 515:88
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:515:82: 515:86
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb28: {
        StorageDead(_70);                // scope 8 at src/codec/simpchinese.rs:515:87: 515:88
        (_66.0: isize) = move _67;       // scope 8 at src/codec/simpchinese.rs:514:41: 516:26
        (_66.1: std::borrow::Cow<str>) = move _69; // scope 8 at src/codec/simpchinese.rs:514:41: 516:26
        StorageDead(_69);                // scope 8 at src/codec/simpchinese.rs:516:25: 516:26
        StorageDead(_67);                // scope 8 at src/codec/simpchinese.rs:516:25: 516:26
        ((_65 as Some).0: encoding_types::CodecError) = move _66; // scope 8 at src/codec/simpchinese.rs:514:36: 516:27
        discriminant(_65) = 1;           // scope 8 at src/codec/simpchinese.rs:514:36: 516:27
        StorageDead(_66);                // scope 8 at src/codec/simpchinese.rs:516:26: 516:27
        (_0.0: usize) = move _64;        // scope 8 at src/codec/simpchinese.rs:514:32: 516:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _65; // scope 8 at src/codec/simpchinese.rs:514:32: 516:28
        StorageDead(_65);                // scope 8 at src/codec/simpchinese.rs:516:27: 516:28
        StorageDead(_64);                // scope 8 at src/codec/simpchinese.rs:516:27: 516:28
        StorageDead(_71);                // scope 8 at src/codec/simpchinese.rs:516:28: 516:29
        StorageDead(_56);                // scope 8 at src/codec/simpchinese.rs:521:21: 521:22
        StorageDead(_54);                // scope 7 at src/codec/simpchinese.rs:522:17: 522:18
        StorageDead(_52);                // scope 6 at src/codec/simpchinese.rs:522:17: 522:18
        goto -> bb37;                    // scope 6 at no-location
    }

    bb29: {
        StorageLive(_72);                // scope 8 at src/codec/simpchinese.rs:491:23: 491:31
        StorageLive(_73);                // scope 8 at src/codec/simpchinese.rs:491:24: 491:31
        _73 = _8;                        // scope 8 at src/codec/simpchinese.rs:491:24: 491:31
        _72 = Not(move _73);             // scope 8 at src/codec/simpchinese.rs:491:23: 491:31
        StorageDead(_73);                // scope 8 at src/codec/simpchinese.rs:491:30: 491:31
        switchInt(move _72) -> [false: bb32, otherwise: bb30]; // scope 8 at src/codec/simpchinese.rs:491:23: 491:31
    }

    bb30: {
        StorageLive(_74);                // scope 8 at src/codec/simpchinese.rs:491:34: 491:59
        StorageLive(_75);                // scope 8 at src/codec/simpchinese.rs:491:34: 491:40
        _75 = &mut (*_3);                // scope 8 at src/codec/simpchinese.rs:491:34: 491:40
        StorageLive(_76);                // scope 8 at src/codec/simpchinese.rs:491:53: 491:58
        StorageLive(_77);                // scope 8 at src/codec/simpchinese.rs:491:53: 491:58
        StorageLive(_78);                // scope 8 at src/codec/simpchinese.rs:491:53: 491:58
        _78 = const b"~{";               // scope 8 at src/codec/simpchinese.rs:491:53: 491:58
                                         // ty::Const
                                         // + ty: &[u8; 2]
                                         // + val: Value(Scalar(alloc11))
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:491:53: 491:58
                                         // + literal: Const { ty: &[u8; 2], val: Value(Scalar(alloc11)) }
        _77 = _78;                       // scope 8 at src/codec/simpchinese.rs:491:53: 491:58
        _76 = move _77 as &[u8] (Pointer(Unsize)); // scope 8 at src/codec/simpchinese.rs:491:53: 491:58
        StorageDead(_77);                // scope 8 at src/codec/simpchinese.rs:491:57: 491:58
        _74 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes(move _75, move _76) -> bb31; // scope 8 at src/codec/simpchinese.rs:491:34: 491:59
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:491:41: 491:52
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::ByteWriter, &'s [u8]) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb31: {
        StorageDead(_76);                // scope 8 at src/codec/simpchinese.rs:491:58: 491:59
        StorageDead(_75);                // scope 8 at src/codec/simpchinese.rs:491:58: 491:59
        StorageDead(_78);                // scope 8 at src/codec/simpchinese.rs:491:59: 491:60
        StorageDead(_74);                // scope 8 at src/codec/simpchinese.rs:491:59: 491:60
        _8 = const true;                 // scope 8 at src/codec/simpchinese.rs:491:61: 491:75
        goto -> bb32;                    // scope 8 at src/codec/simpchinese.rs:491:20: 491:78
    }

    bb32: {
        StorageDead(_72);                // scope 8 at src/codec/simpchinese.rs:491:77: 491:78
        StorageLive(_79);                // scope 8 at src/codec/simpchinese.rs:519:25: 519:60
        StorageLive(_80);                // scope 8 at src/codec/simpchinese.rs:519:25: 519:31
        _80 = &mut (*_3);                // scope 8 at src/codec/simpchinese.rs:519:25: 519:31
        StorageLive(_81);                // scope 8 at src/codec/simpchinese.rs:519:43: 519:59
        StorageLive(_82);                // scope 8 at src/codec/simpchinese.rs:519:43: 519:53
        StorageLive(_83);                // scope 8 at src/codec/simpchinese.rs:519:44: 519:48
        _83 = _52;                       // scope 8 at src/codec/simpchinese.rs:519:44: 519:48
        _82 = Add(move _83, const 1_u16); // scope 8 at src/codec/simpchinese.rs:519:43: 519:53
        StorageDead(_83);                // scope 8 at src/codec/simpchinese.rs:519:52: 519:53
        _81 = move _82 as u8 (Misc);     // scope 8 at src/codec/simpchinese.rs:519:43: 519:59
        StorageDead(_82);                // scope 8 at src/codec/simpchinese.rs:519:58: 519:59
        _79 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _80, move _81) -> bb33; // scope 8 at src/codec/simpchinese.rs:519:25: 519:60
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:519:32: 519:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb33: {
        StorageDead(_81);                // scope 8 at src/codec/simpchinese.rs:519:59: 519:60
        StorageDead(_80);                // scope 8 at src/codec/simpchinese.rs:519:59: 519:60
        StorageDead(_79);                // scope 8 at src/codec/simpchinese.rs:519:60: 519:61
        StorageLive(_84);                // scope 8 at src/codec/simpchinese.rs:520:25: 520:64
        StorageLive(_85);                // scope 8 at src/codec/simpchinese.rs:520:25: 520:31
        _85 = &mut (*_3);                // scope 8 at src/codec/simpchinese.rs:520:25: 520:31
        StorageLive(_86);                // scope 8 at src/codec/simpchinese.rs:520:43: 520:63
        StorageLive(_87);                // scope 8 at src/codec/simpchinese.rs:520:43: 520:57
        StorageLive(_88);                // scope 8 at src/codec/simpchinese.rs:520:44: 520:49
        _88 = _54;                       // scope 8 at src/codec/simpchinese.rs:520:44: 520:49
        _87 = Sub(move _88, const 63_u16); // scope 8 at src/codec/simpchinese.rs:520:43: 520:57
        StorageDead(_88);                // scope 8 at src/codec/simpchinese.rs:520:56: 520:57
        _86 = move _87 as u8 (Misc);     // scope 8 at src/codec/simpchinese.rs:520:43: 520:63
        StorageDead(_87);                // scope 8 at src/codec/simpchinese.rs:520:62: 520:63
        _84 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _85, move _86) -> bb34; // scope 8 at src/codec/simpchinese.rs:520:25: 520:64
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:520:32: 520:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb34: {
        StorageDead(_86);                // scope 8 at src/codec/simpchinese.rs:520:63: 520:64
        StorageDead(_85);                // scope 8 at src/codec/simpchinese.rs:520:63: 520:64
        StorageDead(_84);                // scope 8 at src/codec/simpchinese.rs:520:64: 520:65
        StorageDead(_56);                // scope 8 at src/codec/simpchinese.rs:521:21: 521:22
        StorageDead(_54);                // scope 7 at src/codec/simpchinese.rs:522:17: 522:18
        StorageDead(_52);                // scope 6 at src/codec/simpchinese.rs:522:17: 522:18
        StorageDead(_39);                // scope 5 at src/codec/simpchinese.rs:523:13: 523:14
        goto -> bb35;                    // scope 5 at src/codec/simpchinese.rs:498:13: 523:14
    }

    bb35: {
        StorageDead(_23);                // scope 5 at src/codec/simpchinese.rs:523:13: 523:14
        StorageDead(_22);                // scope 3 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_21);                // scope 3 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_20);                // scope 3 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:524:9: 524:10
        goto -> bb5;                     // scope 2 at src/codec/simpchinese.rs:497:9: 524:10
    }

    bb36: {
        StorageDead(_91);                // scope 1 at src/codec/simpchinese.rs:527:20: 527:21
        StorageLive(_92);                // scope 1 at src/codec/simpchinese.rs:527:23: 527:27
        discriminant(_92) = 0;           // scope 1 at src/codec/simpchinese.rs:527:23: 527:27
        (_0.0: usize) = move _90;        // scope 1 at src/codec/simpchinese.rs:527:9: 527:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _92; // scope 1 at src/codec/simpchinese.rs:527:9: 527:28
        StorageDead(_92);                // scope 1 at src/codec/simpchinese.rs:527:27: 527:28
        StorageDead(_90);                // scope 1 at src/codec/simpchinese.rs:527:27: 527:28
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:528:5: 528:6
        goto -> bb38;                    // scope 0 at src/codec/simpchinese.rs:528:6: 528:6
    }

    bb37: {
        StorageDead(_39);                // scope 5 at src/codec/simpchinese.rs:523:13: 523:14
        StorageDead(_23);                // scope 5 at src/codec/simpchinese.rs:523:13: 523:14
        StorageDead(_22);                // scope 3 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_21);                // scope 3 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_20);                // scope 3 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_12);                // scope 1 at src/codec/simpchinese.rs:524:9: 524:10
        StorageDead(_9);                 // scope 1 at src/codec/simpchinese.rs:497:45: 497:46
        StorageDead(_8);                 // scope 0 at src/codec/simpchinese.rs:528:5: 528:6
        goto -> bb38;                    // scope 0 at src/codec/simpchinese.rs:528:6: 528:6
    }

    bb38: {
        return;                          // scope 0 at src/codec/simpchinese.rs:528:6: 528:6
    }
}

alloc11 (size: 2, align: 1) {
    7e 7b                                            ~{
}

alloc10 (size: 2, align: 1) {
    7e 7d                                            ~}
}

fn codec::ascii::<impl at src/codec/ascii.rs:34:1: 59:2>::from_self(_1: &ASCIIEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:35:18: 35:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/ascii.rs:35:28: 35:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/ascii.rs:35:46: 35:65
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/ascii.rs:35:46: 35:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/ascii.rs:35:46: 35:65
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:35:46: 35:65
        _3 = ASCIIEncoder::new() -> bb1; // scope 0 at src/codec/ascii.rs:35:46: 35:65
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:35:46: 35:63
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::ascii::ASCIIEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:35:46: 35:65
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:35:64: 35:65
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/ascii.rs:35:46: 35:65
        StorageDead(_2);                 // scope 0 at src/codec/ascii.rs:35:66: 35:67
        return;                          // scope 0 at src/codec/ascii.rs:35:67: 35:67
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:97:10: 97:15>::clone(_1: &UTF16BEEncoder) -> UTF16BEEncoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:97:10: 97:15
    let mut _0: codec::utf_16::UTF16BEEncoder; // return place in scope 0 at src/codec/utf_16.rs:97:10: 97:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_16.rs:97:15: 97:15
    }
}

fn x_user_defined::forward(_1: u8) -> u16 {
    debug code => _1;                    // in scope 0 at src/codec/whatwg.rs:25:20: 25:24
    let mut _0: u16;                     // return place in scope 0 at src/codec/whatwg.rs:25:33: 25:36
    let mut _2: u16;                     // in scope 0 at src/codec/whatwg.rs:26:18: 26:31
    let mut _3: u8;                      // in scope 0 at src/codec/whatwg.rs:26:19: 26:23

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/whatwg.rs:26:18: 26:31
        StorageLive(_3);                 // scope 0 at src/codec/whatwg.rs:26:19: 26:23
        _3 = _1;                         // scope 0 at src/codec/whatwg.rs:26:19: 26:23
        _2 = move _3 as u16 (Misc);      // scope 0 at src/codec/whatwg.rs:26:18: 26:31
        StorageDead(_3);                 // scope 0 at src/codec/whatwg.rs:26:30: 26:31
        _0 = BitOr(const 63232_u16, move _2); // scope 0 at src/codec/whatwg.rs:26:9: 26:31
        StorageDead(_2);                 // scope 0 at src/codec/whatwg.rs:26:30: 26:31
        return;                          // scope 0 at src/codec/whatwg.rs:27:6: 27:6
    }
}

const ISO_8859_14: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:52:66: 52:79
    let _5: &str;                        // in scope 0 at src/all.rs:52:66: 52:79
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_14::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_14, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1260 ~ encoding[5d2c]::all::ISO_8859_14), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_14: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:52:66: 52:79
    let mut _4: &str;                    // in scope 0 at src/all.rs:52:66: 52:79
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-14";        // scope 0 at src/all.rs:52:66: 52:79
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:52:66: 52:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:52:66: 52:79
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_14::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_14::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_14::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_14::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-14"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/all.rs:52:66: 52:79
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::emit_str(_1: &mut StatefulDecoderHelper<St, Data>, _2: &str) -> St {
    debug self => _1;                    // in scope 0 at src/util.rs:106:21: 106:30
    debug s => _2;                       // in scope 0 at src/util.rs:106:32: 106:33
    let mut _0: St;                      // return place in scope 0 at src/util.rs:106:44: 106:46
    let _3: ();                          // in scope 0 at src/util.rs:107:9: 107:33
    let mut _4: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:107:9: 107:20
    let mut _5: &str;                    // in scope 0 at src/util.rs:107:31: 107:32

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:107:9: 107:33
        StorageLive(_4);                 // scope 0 at src/util.rs:107:9: 107:20
        _4 = &mut (*((*_1).2: &mut dyn encoding_types::StringWriter)); // scope 0 at src/util.rs:107:9: 107:20
        StorageLive(_5);                 // scope 0 at src/util.rs:107:31: 107:32
        _5 = _2;                         // scope 0 at src/util.rs:107:31: 107:32
        _3 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_str(move _4, move _5) -> bb1; // scope 0 at src/util.rs:107:9: 107:33
                                         // mir::Constant
                                         // + span: src/util.rs:107:21: 107:30
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::StringWriter, &'s str) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_str}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_5);                 // scope 0 at src/util.rs:107:32: 107:33
        StorageDead(_4);                 // scope 0 at src/util.rs:107:32: 107:33
        StorageDead(_3);                 // scope 0 at src/util.rs:107:33: 107:34
        _0 = <St as Default>::default() -> bb2; // scope 0 at src/util.rs:108:9: 108:27
                                         // mir::Constant
                                         // + span: src/util.rs:108:9: 108:25
                                         // + literal: Const { ty: fn() -> St {<St as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        return;                          // scope 0 at src/util.rs:109:6: 109:6
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:40:1: 45:2>::whatwg_name(_1: &UTF16BEEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:42:20: 42:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/utf_16.rs:42:30: 42:50
    let mut _2: &str;                    // in scope 0 at src/codec/utf_16.rs:42:58: 42:68
    let _3: &str;                        // in scope 0 at src/codec/utf_16.rs:42:58: 42:68

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:42:58: 42:68
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:42:58: 42:68
        _3 = const "utf-16be";           // scope 0 at src/codec/utf_16.rs:42:58: 42:68
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 98, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:42:58: 42:68
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 98, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
        _2 = _3;                         // scope 0 at src/codec/utf_16.rs:42:58: 42:68
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/utf_16.rs:42:53: 42:69
        discriminant(_0) = 1;            // scope 0 at src/codec/utf_16.rs:42:53: 42:69
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:42:68: 42:69
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:42:70: 42:71
        return;                          // scope 0 at src/codec/utf_16.rs:42:71: 42:71
    }
}

fn codec::error::<impl at src/codec/error.rs:28:1: 43:2>::from_self(_1: &ErrorEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:29:18: 29:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/error.rs:29:28: 29:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/error.rs:29:46: 29:65
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/error.rs:29:46: 29:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/error.rs:29:46: 29:65
        StorageLive(_3);                 // scope 0 at src/codec/error.rs:29:46: 29:65
        _3 = ErrorEncoder::new() -> bb1; // scope 0 at src/codec/error.rs:29:46: 29:65
                                         // mir::Constant
                                         // + span: src/codec/error.rs:29:46: 29:63
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::error::ErrorEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:29:46: 29:65
        StorageDead(_3);                 // scope 0 at src/codec/error.rs:29:64: 29:65
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:29:46: 29:65
        StorageDead(_2);                 // scope 0 at src/codec/error.rs:29:66: 29:67
        return;                          // scope 0 at src/codec/error.rs:29:67: 29:67
    }
}

fn korean::<impl at src/codec/korean.rs:27:1: 32:2>::whatwg_name(_1: &Windows949Encoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:29:20: 29:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/korean.rs:29:30: 29:50
    let mut _2: &str;                    // in scope 0 at src/codec/korean.rs:29:58: 29:66
    let _3: &str;                        // in scope 0 at src/codec/korean.rs:29:58: 29:66

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:29:58: 29:66
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:29:58: 29:66
        _3 = const "euc-kr";             // scope 0 at src/codec/korean.rs:29:58: 29:66
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:29:58: 29:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 107, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        _2 = _3;                         // scope 0 at src/codec/korean.rs:29:58: 29:66
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/korean.rs:29:53: 29:67
        discriminant(_0) = 1;            // scope 0 at src/codec/korean.rs:29:53: 29:67
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:29:66: 29:67
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:29:68: 29:69
        return;                          // scope 0 at src/codec/korean.rs:29:69: 29:69
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:41:1: 43:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/tradchinese.rs:42:21: 42:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/tradchinese.rs:42:39: 42:67
    let mut _2: std::boxed::Box<codec::tradchinese::BigFive2003Encoder>; // in scope 0 at src/codec/tradchinese.rs:42:39: 42:67
    let mut _3: codec::tradchinese::BigFive2003Encoder; // in scope 0 at src/codec/tradchinese.rs:42:48: 42:66

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/tradchinese.rs:42:39: 42:67
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:42:39: 42:67
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:42:48: 42:66
        _2 = Box::<BigFive2003Encoder>::new(move _3) -> bb1; // scope 0 at src/codec/tradchinese.rs:42:39: 42:67
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:42:39: 42:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::tradchinese::BigFive2003Encoder) -> std::boxed::Box<codec::tradchinese::BigFive2003Encoder> {std::boxed::Box::<codec::tradchinese::BigFive2003Encoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:42:39: 42:67
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:42:66: 42:67
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:42:66: 42:67
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:42:39: 42:67
        StorageDead(_1);                 // scope 0 at src/codec/tradchinese.rs:42:68: 42:69
        return;                          // scope 0 at src/codec/tradchinese.rs:42:69: 42:69
    }
}

fn korean::<impl at src/codec/korean.rs:73:10: 73:15>::clone(_1: &Windows949Decoder) -> Windows949Decoder {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:73:10: 73:15
    let mut _0: codec::korean::Windows949Decoder; // return place in scope 0 at src/codec/korean.rs:73:10: 73:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/korean.rs:73:10: 73:15
        return;                          // scope 0 at src/codec/korean.rs:73:15: 73:15
    }
}

fn japanese::<impl at src/codec/japanese.rs:781:10: 781:19>::eq(_1: &ISO2022JPState, _2: &ISO2022JPState) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    debug other => _2;                   // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let _3: isize;                       // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _4: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let _5: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _7: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let _8: &codec::japanese::ISO2022JPState; // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _9: bool;                    // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _10: bool;                   // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _11: isize;                  // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    let mut _12: isize;                  // in scope 0 at src/codec/japanese.rs:781:10: 781:19
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/codec/japanese.rs:781:10: 781:19
        let _6: isize;                   // in scope 1 at src/codec/japanese.rs:781:10: 781:19
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/codec/japanese.rs:781:10: 781:19
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:781:10: 781:19
        _5 = _1;                         // scope 0 at src/codec/japanese.rs:781:10: 781:19
        _4 = _5;                         // scope 0 at src/codec/japanese.rs:781:10: 781:19
        _3 = discriminant((*_4));        // scope 0 at src/codec/japanese.rs:781:10: 781:19
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:781:18: 781:19
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:781:18: 781:19
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:781:10: 781:19
        _8 = _2;                         // scope 1 at src/codec/japanese.rs:781:10: 781:19
        _7 = _8;                         // scope 1 at src/codec/japanese.rs:781:10: 781:19
        _6 = discriminant((*_7));        // scope 1 at src/codec/japanese.rs:781:10: 781:19
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:781:18: 781:19
        StorageDead(_8);                 // scope 1 at src/codec/japanese.rs:781:18: 781:19
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:781:10: 781:19
        _11 = _3;                        // scope 2 at src/codec/japanese.rs:781:10: 781:19
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:781:10: 781:19
        _12 = _6;                        // scope 2 at src/codec/japanese.rs:781:10: 781:19
        _10 = Eq(move _11, move _12);    // scope 2 at src/codec/japanese.rs:781:10: 781:19
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:781:18: 781:19
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:781:18: 781:19
        _9 = move _10;                   // scope 2 at src/codec/japanese.rs:781:10: 781:19
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:781:18: 781:19
        switchInt(move _9) -> [false: bb2, otherwise: bb1]; // scope 2 at src/codec/japanese.rs:781:10: 781:19
    }

    bb1: {
        _0 = const true;                 // scope 2 at src/codec/japanese.rs:781:10: 781:19
        goto -> bb3;                     // scope 2 at src/codec/japanese.rs:781:10: 781:19
    }

    bb2: {
        _0 = const false;                // scope 2 at src/codec/japanese.rs:781:10: 781:19
        goto -> bb3;                     // scope 2 at src/codec/japanese.rs:781:10: 781:19
    }

    bb3: {
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:781:18: 781:19
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:781:18: 781:19
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:781:18: 781:19
        return;                          // scope 0 at src/codec/japanese.rs:781:19: 781:19
    }
}

fn encoding_from_whatwg_label::{closure#0}(_1: &mut [closure@src/label.rs:15:27: 15:86], _2: char) -> char {
    debug c => _2;                       // in scope 0 at src/label.rs:15:28: 15:29
    let mut _0: char;                    // return place in scope 0 at src/label.rs:15:31: 15:31
    let mut _3: bool;                    // in scope 0 at src/label.rs:15:41: 15:50
    let mut _4: bool;                    // in scope 0 at src/label.rs:15:41: 15:50
    let mut _5: u8;                      // in scope 0 at src/label.rs:15:54: 15:68
    let mut _6: u8;                      // in scope 0 at src/label.rs:15:55: 15:62
    let mut _7: char;                    // in scope 0 at src/label.rs:15:55: 15:56

    bb0: {
        _3 = Le(const 'A', _2);          // scope 0 at src/label.rs:15:41: 15:50
        switchInt(move _3) -> [false: bb2, otherwise: bb1]; // scope 0 at src/label.rs:15:41: 15:50
    }

    bb1: {
        _4 = Le(_2, const 'Z');          // scope 0 at src/label.rs:15:41: 15:50
        switchInt(move _4) -> [false: bb2, otherwise: bb3]; // scope 0 at src/label.rs:15:41: 15:50
    }

    bb2: {
        _0 = _2;                         // scope 0 at src/label.rs:15:83: 15:84
        goto -> bb4;                     // scope 0 at src/label.rs:15:83: 15:84
    }

    bb3: {
        StorageLive(_5);                 // scope 0 at src/label.rs:15:54: 15:68
        StorageLive(_6);                 // scope 0 at src/label.rs:15:55: 15:62
        StorageLive(_7);                 // scope 0 at src/label.rs:15:55: 15:56
        _7 = _2;                         // scope 0 at src/label.rs:15:55: 15:56
        _6 = move _7 as u8 (Misc);       // scope 0 at src/label.rs:15:55: 15:62
        StorageDead(_7);                 // scope 0 at src/label.rs:15:61: 15:62
        _5 = Add(move _6, const 32_u8);  // scope 0 at src/label.rs:15:54: 15:68
        StorageDead(_6);                 // scope 0 at src/label.rs:15:67: 15:68
        _0 = move _5 as char (Misc);     // scope 0 at src/label.rs:15:54: 15:76
        StorageDead(_5);                 // scope 0 at src/label.rs:15:75: 15:76
        goto -> bb4;                     // scope 0 at src/label.rs:15:75: 15:76
    }

    bb4: {
        return;                          // scope 0 at src/label.rs:15:86: 15:86
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:141:1: 209:2>::from_self(_1: &UTF8Decoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:142:18: 142:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_8.rs:142:28: 142:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_8.rs:142:46: 142:64
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_8.rs:142:46: 142:64

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:142:46: 142:64
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:142:46: 142:64
        _3 = UTF8Decoder::new() -> bb1;  // scope 0 at src/codec/utf_8.rs:142:46: 142:64
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:142:46: 142:62
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::utf_8::UTF8Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:142:46: 142:64
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:142:63: 142:64
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:142:46: 142:64
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:142:65: 142:66
        return;                          // scope 0 at src/codec/utf_8.rs:142:66: 142:66
    }
}

fn hz::<impl at src/util.rs:157:22: 157:31>::eq(_1: &hz::State, _2: &hz::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::simpchinese::hz::State, &codec::simpchinese::hz::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _20: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _23: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _24: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _27: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _28: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _31: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _32: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _37: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _38: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _39: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _40: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _41: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _42: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _21: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _22: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _25: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _26: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _29: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _30: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _33: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _34: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _35: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _36: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _21;   // in scope 3 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _22;  // in scope 3 at src/util.rs:161:27: 161:29
            }
            scope 4 {
                debug __self_0 => _25;   // in scope 4 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _26;  // in scope 4 at src/util.rs:164:25: 164:27
            }
            scope 5 {
                debug __self_0 => _29;   // in scope 5 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _30;  // in scope 5 at src/util.rs:164:25: 164:27
            }
            scope 6 {
                debug __self_0 => _33;   // in scope 6 at src/util.rs:164:25: 164:27
                debug __self_1 => _34;   // in scope 6 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _35;  // in scope 6 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _36;  // in scope 6 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb19, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::simpchinese::hz::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::simpchinese::hz::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _20 = discriminant((*(_13.0: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _20) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, 4_isize: bb6, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb7, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb9, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        _19 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [4_isize: bb13, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb7: {
        StorageLive(_21);                // scope 2 at src/util.rs:161:27: 161:29
        _21 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B0).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_22);                // scope 2 at src/util.rs:161:27: 161:29
        _22 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B0).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_23);                // scope 3 at src/util.rs:161:27: 161:29
        _23 = _21;                       // scope 3 at src/util.rs:161:27: 161:29
        StorageLive(_24);                // scope 3 at src/util.rs:161:27: 161:29
        _24 = _22;                       // scope 3 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::eq(move _23, move _24) -> bb8; // scope 3 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_23);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_22);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb9: {
        StorageLive(_25);                // scope 2 at src/util.rs:164:25: 164:27
        _25 = &(((*(_13.0: &codec::simpchinese::hz::State)) as A1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_26);                // scope 2 at src/util.rs:164:25: 164:27
        _26 = &(((*(_13.1: &codec::simpchinese::hz::State)) as A1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_27);                // scope 4 at src/util.rs:164:25: 164:27
        _27 = _25;                       // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_28);                // scope 4 at src/util.rs:164:25: 164:27
        _28 = _26;                       // scope 4 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _27, move _28) -> bb10; // scope 4 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_28);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_27);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_26);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_25);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb11: {
        StorageLive(_29);                // scope 2 at src/util.rs:164:25: 164:27
        _29 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_30);                // scope 2 at src/util.rs:164:25: 164:27
        _30 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_31);                // scope 5 at src/util.rs:164:25: 164:27
        _31 = _29;                       // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_32);                // scope 5 at src/util.rs:164:25: 164:27
        _32 = _30;                       // scope 5 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _31, move _32) -> bb12; // scope 5 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_32);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_31);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_29);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb13: {
        StorageLive(_33);                // scope 2 at src/util.rs:164:25: 164:27
        _33 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_34);                // scope 2 at src/util.rs:164:32: 164:35
        _34 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_35);                // scope 2 at src/util.rs:164:25: 164:27
        _35 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_36);                // scope 2 at src/util.rs:164:32: 164:35
        _36 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_37);                // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_38);                // scope 6 at src/util.rs:164:25: 164:27
        _38 = _33;                       // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_39);                // scope 6 at src/util.rs:164:25: 164:27
        _39 = _35;                       // scope 6 at src/util.rs:164:25: 164:27
        _37 = <() as PartialEq>::eq(move _38, move _39) -> bb17; // scope 6 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        _0 = const false;                // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb16;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb15: {
        StorageLive(_40);                // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_41);                // scope 6 at src/util.rs:164:32: 164:35
        _41 = (*_34);                    // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_42);                // scope 6 at src/util.rs:164:32: 164:35
        _42 = (*_36);                    // scope 6 at src/util.rs:164:32: 164:35
        _40 = Eq(move _41, move _42);    // scope 6 at src/util.rs:164:32: 164:35
        StorageDead(_42);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_41);                // scope 6 at src/util.rs:164:34: 164:35
        _0 = move _40;                   // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb16;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb16: {
        StorageDead(_40);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_37);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_36);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_35);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_34);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_33);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb17: {
        StorageDead(_39);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_38);                // scope 6 at src/util.rs:164:26: 164:27
        switchInt(move _37) -> [false: bb14, otherwise: bb15]; // scope 6 at src/util.rs:164:32: 164:35
    }

    bb18: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb20;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb19: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb20;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb20: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn hz::transient::B2(_1: &mut StatefulDecoderHelper<hz::State, T>, _2: u8) -> hz::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _8: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:621:22: 621:25
    let _10: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:623:13: 626:14
    let mut _11: u32;                    // in scope 0 at src/codec/simpchinese.rs:623:19: 623:41
    let mut _12: u8;                     // in scope 0 at src/codec/simpchinese.rs:623:33: 623:37
    let mut _13: u8;                     // in scope 0 at src/codec/simpchinese.rs:623:39: 623:40
    let mut _14: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:624:27: 624:30
    let mut _16: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:625:23: 625:26
    let mut _17: u32;                    // in scope 0 at src/codec/simpchinese.rs:625:32: 625:34
    let mut _18: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:627:16: 627:19
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _9: u8;                      // in scope 1 at src/codec/simpchinese.rs:622:14: 622:15
        scope 2 {
            debug b => _9;               // in scope 2 at src/codec/simpchinese.rs:622:14: 622:15
            let _15: u32;                // in scope 2 at src/codec/simpchinese.rs:625:17: 625:19
            scope 3 {
                debug ch => _15;         // in scope 3 at src/codec/simpchinese.rs:625:17: 625:19
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<hz::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_7) -> [10_u8: bb6, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as B2).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 4;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb16;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_9);                 // scope 1 at src/codec/simpchinese.rs:622:14: 622:15
        _9 = _7;                         // scope 1 at src/codec/simpchinese.rs:622:14: 622:15
        StorageLive(_10);                // scope 2 at src/codec/simpchinese.rs:623:13: 626:14
        StorageLive(_11);                // scope 2 at src/codec/simpchinese.rs:623:19: 623:41
        StorageLive(_12);                // scope 2 at src/codec/simpchinese.rs:623:33: 623:37
        _12 = _2;                        // scope 2 at src/codec/simpchinese.rs:623:33: 623:37
        StorageLive(_13);                // scope 2 at src/codec/simpchinese.rs:623:39: 623:40
        _13 = _9;                        // scope 2 at src/codec/simpchinese.rs:623:39: 623:40
        _11 = hz::internal::map_two_bytes(move _12, move _13) -> bb8; // scope 2 at src/codec/simpchinese.rs:623:19: 623:41
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:623:19: 623:32
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::simpchinese::hz::internal::map_two_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageLive(_8);                 // scope 1 at src/codec/simpchinese.rs:621:22: 621:25
        _8 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:621:22: 621:25
        _0 = StatefulDecoderHelper::<hz::State, T>::err(move _8, const "invalid sequence") -> bb7; // scope 1 at src/codec/simpchinese.rs:621:22: 621:49
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:621:26: 621:29
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:621:30: 621:48
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb7: {
        StorageDead(_8);                 // scope 1 at src/codec/simpchinese.rs:621:48: 621:49
        goto -> bb15;                    // scope 1 at src/codec/simpchinese.rs:621:48: 621:49
    }

    bb8: {
        StorageDead(_13);                // scope 2 at src/codec/simpchinese.rs:623:40: 623:41
        StorageDead(_12);                // scope 2 at src/codec/simpchinese.rs:623:40: 623:41
        switchInt(_11) -> [65535_u32: bb10, otherwise: bb9]; // scope 2 at src/codec/simpchinese.rs:623:13: 623:41
    }

    bb9: {
        StorageLive(_15);                // scope 2 at src/codec/simpchinese.rs:625:17: 625:19
        _15 = _11;                       // scope 2 at src/codec/simpchinese.rs:625:17: 625:19
        StorageLive(_16);                // scope 3 at src/codec/simpchinese.rs:625:23: 625:26
        _16 = &mut (*_1);                // scope 3 at src/codec/simpchinese.rs:625:23: 625:26
        StorageLive(_17);                // scope 3 at src/codec/simpchinese.rs:625:32: 625:34
        _17 = _15;                       // scope 3 at src/codec/simpchinese.rs:625:32: 625:34
        _10 = StatefulDecoderHelper::<hz::State, T>::emit(move _16, move _17) -> bb12; // scope 3 at src/codec/simpchinese.rs:625:23: 625:35
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:625:27: 625:31
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, u32) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageLive(_14);                // scope 2 at src/codec/simpchinese.rs:624:27: 624:30
        _14 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:624:27: 624:30
        _10 = StatefulDecoderHelper::<hz::State, T>::err(move _14, const "invalid sequence") -> bb11; // scope 2 at src/codec/simpchinese.rs:624:27: 624:54
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:624:31: 624:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:624:35: 624:53
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb11: {
        StorageDead(_14);                // scope 2 at src/codec/simpchinese.rs:624:53: 624:54
        goto -> bb13;                    // scope 2 at src/codec/simpchinese.rs:624:53: 624:54
    }

    bb12: {
        StorageDead(_17);                // scope 3 at src/codec/simpchinese.rs:625:34: 625:35
        StorageDead(_16);                // scope 3 at src/codec/simpchinese.rs:625:34: 625:35
        StorageDead(_15);                // scope 2 at src/codec/simpchinese.rs:625:34: 625:35
        goto -> bb13;                    // scope 2 at src/codec/simpchinese.rs:625:34: 625:35
    }

    bb13: {
        StorageDead(_11);                // scope 2 at src/util.rs:226:72: 226:73
        StorageDead(_10);                // scope 2 at src/util.rs:226:72: 226:73
        StorageLive(_18);                // scope 2 at src/codec/simpchinese.rs:627:16: 627:19
        _18 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:627:16: 627:19
        _0 = hz::transient::B0::<T>(move _18) -> bb14; // scope 2 at src/codec/simpchinese.rs:627:13: 627:20
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:627:13: 627:15
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_18);                // scope 2 at src/codec/simpchinese.rs:627:19: 627:20
        StorageDead(_9);                 // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb15;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb15: {
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb16;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb16: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:272:1: 280:2>::raw_finish(_1: &mut UTF16LEDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:277:19: 277:28
    debug output => _2;                  // in scope 0 at src/codec/utf_16.rs:277:30: 277:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_16.rs:277:60: 277:78
    let mut _3: &mut codec::utf_16::UTF16Decoder; // in scope 0 at src/codec/utf_16.rs:278:9: 278:19
    let mut _4: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:278:31: 278:37
    let mut _5: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:278:31: 278:37

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:278:9: 278:19
        _3 = &mut ((*_1).0: codec::utf_16::UTF16Decoder); // scope 0 at src/codec/utf_16.rs:278:9: 278:19
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:278:31: 278:37
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:278:31: 278:37
        _5 = &mut (*_2);                 // scope 0 at src/codec/utf_16.rs:278:31: 278:37
        _4 = move _5 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:278:31: 278:37
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:278:36: 278:37
        _0 = UTF16Decoder::raw_finish(move _3, move _4) -> bb1; // scope 0 at src/codec/utf_16.rs:278:9: 278:38
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:278:20: 278:30
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut codec::utf_16::UTF16Decoder, &'s mut (dyn encoding_types::StringWriter + 's)) -> std::option::Option<encoding_types::CodecError> {codec::utf_16::UTF16Decoder::raw_finish}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:278:37: 278:38
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:278:37: 278:38
        return;                          // scope 0 at src/codec/utf_16.rs:279:6: 279:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:547:1: 562:2>::from_self(_1: &HZDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:548:18: 548:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:548:28: 548:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:548:46: 548:62
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:548:46: 548:62

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:548:46: 548:62
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:548:46: 548:62
        _3 = HZDecoder::new() -> bb1;    // scope 0 at src/codec/simpchinese.rs:548:46: 548:62
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:548:46: 548:60
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::simpchinese::HZDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:548:46: 548:62
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:548:61: 548:62
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:548:46: 548:62
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:548:63: 548:64
        return;                          // scope 0 at src/codec/simpchinese.rs:548:64: 548:64
    }
}

fn windows31j::State::S1(_1: (), _2: u8) -> windows31j::State {
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn windows31j::State::S1(_1: (), _2: u8) -> windows31j::State {
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as S1).0: ()) = move _1;    // scope 0 at src/util.rs:164:21: 164:38
        ((_0 as S1).1: u8) = move _2;    // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 1;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:49:1: 54:2>::whatwg_name(_1: &UTF8Encoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:51:20: 51:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/utf_8.rs:51:30: 51:50
    let mut _2: &str;                    // in scope 0 at src/codec/utf_8.rs:51:58: 51:65
    let _3: &str;                        // in scope 0 at src/codec/utf_8.rs:51:58: 51:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:51:58: 51:65
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:51:58: 51:65
        _3 = const "utf-8";              // scope 0 at src/codec/utf_8.rs:51:58: 51:65
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:51:58: 51:65
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
        _2 = _3;                         // scope 0 at src/codec/utf_8.rs:51:58: 51:65
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/utf_8.rs:51:53: 51:66
        discriminant(_0) = 1;            // scope 0 at src/codec/utf_8.rs:51:53: 51:66
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:51:65: 51:66
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:51:67: 51:68
        return;                          // scope 0 at src/codec/utf_8.rs:51:68: 51:68
    }
}

const WINDOWS_1250: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:59:68: 59:82
    let _5: &str;                        // in scope 0 at src/all.rs:59:68: 59:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1250::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1250, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1267 ~ encoding[5d2c]::all::WINDOWS_1250), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1250: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:59:68: 59:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:59:68: 59:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1250";       // scope 0 at src/all.rs:59:68: 59:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:59:68: 59:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:59:68: 59:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1250::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1250::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1250::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1250::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1250"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:59:68: 59:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:17:10: 17:15>::clone(_1: &ASCIIEncoding) -> ASCIIEncoding {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:17:10: 17:15
    let mut _0: codec::ascii::ASCIIEncoding; // return place in scope 0 at src/codec/ascii.rs:17:10: 17:15

    bb0: {
        return;                          // scope 0 at src/codec/ascii.rs:17:15: 17:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:81:1: 83:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_16.rs:82:17: 82:32
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:82:35: 82:59
    let mut _2: std::boxed::Box<codec::utf_16::UTF16LEEncoder>; // in scope 0 at src/codec/utf_16.rs:82:35: 82:59
    let mut _3: codec::utf_16::UTF16LEEncoder; // in scope 0 at src/codec/utf_16.rs:82:44: 82:58

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/utf_16.rs:82:35: 82:59
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:82:35: 82:59
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:82:44: 82:58
        _2 = Box::<UTF16LEEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/utf_16.rs:82:35: 82:59
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:82:35: 82:43
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::utf_16::UTF16LEEncoder) -> std::boxed::Box<codec::utf_16::UTF16LEEncoder> {std::boxed::Box::<codec::utf_16::UTF16LEEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:82:35: 82:59
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:82:58: 82:59
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:82:58: 82:59
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:82:35: 82:59
        StorageDead(_1);                 // scope 0 at src/codec/utf_16.rs:82:60: 82:61
        return;                          // scope 0 at src/codec/utf_16.rs:82:61: 82:61
    }
}

fn iso2022jp::State::EscapeMiddle24(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeMiddle24).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 5;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn iso2022jp::State::EscapeMiddle24(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeMiddle24).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 5;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn codec::error::<impl at src/codec/error.rs:53:1: 68:2>::raw_feed(_1: &mut ErrorDecoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:56:17: 56:26
    debug input => _2;                   // in scope 0 at src/codec/error.rs:57:17: 57:22
    debug _output => _3;                 // in scope 0 at src/codec/error.rs:57:31: 57:38
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/error.rs:57:62: 57:89
    let mut _4: bool;                    // in scope 0 at src/codec/error.rs:58:12: 58:27
    let mut _5: usize;                   // in scope 0 at src/codec/error.rs:58:12: 58:23
    let mut _6: &[u8];                   // in scope 0 at src/codec/error.rs:58:12: 58:17
    let mut _7: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/error.rs:59:17: 59:79
    let mut _8: encoding_types::CodecError; // in scope 0 at src/codec/error.rs:59:22: 59:78
    let mut _9: std::borrow::Cow<str>;   // in scope 0 at src/codec/error.rs:59:51: 59:76
    let mut _10: &str;                   // in scope 0 at src/codec/error.rs:59:51: 59:69
    let _11: &str;                       // in scope 0 at src/codec/error.rs:59:51: 59:69
    let mut _12: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/error.rs:61:17: 61:21

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/error.rs:58:12: 58:27
        StorageLive(_5);                 // scope 0 at src/codec/error.rs:58:12: 58:23
        StorageLive(_6);                 // scope 0 at src/codec/error.rs:58:12: 58:17
        _6 = _2;                         // scope 0 at src/codec/error.rs:58:12: 58:17
        _5 = Len((*_6));                 // scope 0 at src/codec/error.rs:58:12: 58:23
        StorageDead(_6);                 // scope 0 at src/codec/error.rs:58:22: 58:23
        _4 = Gt(move _5, const 0_usize); // scope 0 at src/codec/error.rs:58:12: 58:27
        StorageDead(_5);                 // scope 0 at src/codec/error.rs:58:26: 58:27
        switchInt(move _4) -> [false: bb3, otherwise: bb1]; // scope 0 at src/codec/error.rs:58:12: 58:27
    }

    bb1: {
        StorageLive(_7);                 // scope 0 at src/codec/error.rs:59:17: 59:79
        StorageLive(_8);                 // scope 0 at src/codec/error.rs:59:22: 59:78
        StorageLive(_9);                 // scope 0 at src/codec/error.rs:59:51: 59:76
        StorageLive(_10);                // scope 0 at src/codec/error.rs:59:51: 59:69
        StorageLive(_11);                // scope 0 at src/codec/error.rs:59:51: 59:69
        _11 = const "invalid sequence";  // scope 0 at src/codec/error.rs:59:51: 59:69
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/error.rs:59:51: 59:69
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
        _10 = _11;                       // scope 0 at src/codec/error.rs:59:51: 59:69
        _9 = <&str as Into<Cow<str>>>::into(move _10) -> bb2; // scope 0 at src/codec/error.rs:59:51: 59:76
                                         // mir::Constant
                                         // + span: src/codec/error.rs:59:70: 59:74
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_10);                // scope 0 at src/codec/error.rs:59:75: 59:76
        (_8.0: isize) = const 1_isize;   // scope 0 at src/codec/error.rs:59:22: 59:78
        (_8.1: std::borrow::Cow<str>) = move _9; // scope 0 at src/codec/error.rs:59:22: 59:78
        StorageDead(_9);                 // scope 0 at src/codec/error.rs:59:77: 59:78
        ((_7 as Some).0: encoding_types::CodecError) = move _8; // scope 0 at src/codec/error.rs:59:17: 59:79
        discriminant(_7) = 1;            // scope 0 at src/codec/error.rs:59:17: 59:79
        StorageDead(_8);                 // scope 0 at src/codec/error.rs:59:78: 59:79
        (_0.0: usize) = const 0_usize;   // scope 0 at src/codec/error.rs:59:13: 59:80
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _7; // scope 0 at src/codec/error.rs:59:13: 59:80
        StorageDead(_7);                 // scope 0 at src/codec/error.rs:59:79: 59:80
        StorageDead(_11);                // scope 0 at src/codec/error.rs:60:9: 60:10
        goto -> bb4;                     // scope 0 at src/codec/error.rs:58:9: 62:10
    }

    bb3: {
        StorageLive(_12);                // scope 0 at src/codec/error.rs:61:17: 61:21
        discriminant(_12) = 0;           // scope 0 at src/codec/error.rs:61:17: 61:21
        (_0.0: usize) = const 0_usize;   // scope 0 at src/codec/error.rs:61:13: 61:22
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _12; // scope 0 at src/codec/error.rs:61:13: 61:22
        StorageDead(_12);                // scope 0 at src/codec/error.rs:61:21: 61:22
        goto -> bb4;                     // scope 0 at src/codec/error.rs:58:9: 62:10
    }

    bb4: {
        StorageDead(_4);                 // scope 0 at src/codec/error.rs:62:9: 62:10
        return;                          // scope 0 at src/codec/error.rs:63:6: 63:6
    }
}

fn korean::<impl at src/codec/korean.rs:42:1: 70:2>::is_ascii_compatible(_1: &Windows949Encoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:44:28: 44:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/korean.rs:44:38: 44:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/korean.rs:44:45: 44:49
        return;                          // scope 0 at src/codec/korean.rs:44:51: 44:51
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:84:1: 88:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/tradchinese.rs:85:21: 85:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/tradchinese.rs:86:9: 86:73
    let mut _2: std::boxed::Box<codec::tradchinese::BigFive2003HKSCS2008Decoder>; // in scope 0 at src/codec/tradchinese.rs:86:9: 86:73
    let mut _3: codec::tradchinese::BigFive2003HKSCS2008Decoder; // in scope 0 at src/codec/tradchinese.rs:86:18: 86:72
    let mut _4: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:86:52: 86:70

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/tradchinese.rs:86:9: 86:73
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:86:9: 86:73
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:86:18: 86:72
        StorageLive(_4);                 // scope 0 at src/codec/tradchinese.rs:86:52: 86:70
        _4 = <bigfive2003::State as Default>::default() -> bb1; // scope 0 at src/codec/tradchinese.rs:86:52: 86:70
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:86:52: 86:68
                                         // + literal: Const { ty: fn() -> codec::tradchinese::bigfive2003::State {<codec::tradchinese::bigfive2003::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::tradchinese::bigfive2003::State) = move _4; // scope 0 at src/codec/tradchinese.rs:86:18: 86:72
        StorageDead(_4);                 // scope 0 at src/codec/tradchinese.rs:86:71: 86:72
        _2 = Box::<BigFive2003HKSCS2008Decoder>::new(move _3) -> bb2; // scope 0 at src/codec/tradchinese.rs:86:9: 86:73
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:86:9: 86:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::tradchinese::BigFive2003HKSCS2008Decoder) -> std::boxed::Box<codec::tradchinese::BigFive2003HKSCS2008Decoder> {std::boxed::Box::<codec::tradchinese::BigFive2003HKSCS2008Decoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:86:9: 86:73
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:86:72: 86:73
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:86:72: 86:73
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:86:9: 86:73
        StorageDead(_1);                 // scope 0 at src/codec/tradchinese.rs:87:5: 87:6
        return;                          // scope 0 at src/codec/tradchinese.rs:87:6: 87:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:452:1: 457:2>::whatwg_name(_1: &Windows31JEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:454:20: 454:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/japanese.rs:454:30: 454:50
    let mut _2: &str;                    // in scope 0 at src/codec/japanese.rs:454:58: 454:69
    let _3: &str;                        // in scope 0 at src/codec/japanese.rs:454:58: 454:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:454:58: 454:69
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:454:58: 454:69
        _3 = const "shift_jis";          // scope 0 at src/codec/japanese.rs:454:58: 454:69
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [115, 104, 105, 102, 116, 95, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:454:58: 454:69
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [115, 104, 105, 102, 116, 95, 106, 105, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [511], len: Size { raw: 9 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 9 }) }
        _2 = _3;                         // scope 0 at src/codec/japanese.rs:454:58: 454:69
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/japanese.rs:454:53: 454:70
        discriminant(_0) = 1;            // scope 0 at src/codec/japanese.rs:454:53: 454:70
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:454:69: 454:70
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:454:71: 454:72
        return;                          // scope 0 at src/codec/japanese.rs:454:72: 454:72
    }
}

fn japanese::<impl at src/codec/japanese.rs:789:10: 789:15>::clone(_1: &ISO2022JPEncoder) -> ISO2022JPEncoder {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:789:10: 789:15
    let mut _0: codec::japanese::ISO2022JPEncoder; // return place in scope 0 at src/codec/japanese.rs:789:10: 789:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/japanese.rs:789:10: 789:15
        return;                          // scope 0 at src/codec/japanese.rs:789:15: 789:15
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:40:1: 45:2>::whatwg_name(_1: &GB18030Encoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:42:20: 42:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/simpchinese.rs:42:30: 42:50
    let mut _2: &str;                    // in scope 0 at src/codec/simpchinese.rs:42:58: 42:67
    let _3: &str;                        // in scope 0 at src/codec/simpchinese.rs:42:58: 42:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:42:58: 42:67
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:42:58: 42:67
        _3 = const "gb18030";            // scope 0 at src/codec/simpchinese.rs:42:58: 42:67
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 49, 56, 48, 51, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:42:58: 42:67
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 49, 56, 48, 51, 48], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [127], len: Size { raw: 7 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 7 }) }
        _2 = _3;                         // scope 0 at src/codec/simpchinese.rs:42:58: 42:67
        ((_0 as Some).0: &str) = move _2; // scope 0 at src/codec/simpchinese.rs:42:53: 42:68
        discriminant(_0) = 1;            // scope 0 at src/codec/simpchinese.rs:42:53: 42:68
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:42:67: 42:68
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:42:69: 42:70
        return;                          // scope 0 at src/codec/simpchinese.rs:42:70: 42:70
    }
}

fn iso2022jp::transient::Trail0208(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>, _2: u8) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let _9: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:981:13: 984:14
    let mut _10: u32;                    // in scope 0 at src/codec/japanese.rs:981:19: 981:46
    let mut _11: u8;                     // in scope 0 at src/codec/japanese.rs:981:38: 981:42
    let mut _12: u8;                     // in scope 0 at src/codec/japanese.rs:981:44: 981:45
    let mut _13: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:982:27: 982:30
    let mut _15: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:983:23: 983:26
    let mut _16: u32;                    // in scope 0 at src/codec/japanese.rs:983:32: 983:41
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:985:22: 985:25
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _8: u8;                      // in scope 1 at src/codec/japanese.rs:980:14: 980:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/japanese.rs:980:14: 980:15
            let _14: u32;                // in scope 2 at src/codec/japanese.rs:983:17: 983:19
            scope 3 {
                debug ch => _14;         // in scope 3 at src/codec/japanese.rs:983:17: 983:19
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:980:14: 980:15
        _8 = _7;                         // scope 1 at src/codec/japanese.rs:980:14: 980:15
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:981:13: 984:14
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:981:19: 981:46
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:981:38: 981:42
        _11 = _2;                        // scope 2 at src/codec/japanese.rs:981:38: 981:42
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:981:44: 981:45
        _12 = _8;                        // scope 2 at src/codec/japanese.rs:981:44: 981:45
        _10 = iso2022jp::internal::map_two_0208_bytes(move _11, move _12) -> bb5; // scope 2 at src/codec/japanese.rs:981:19: 981:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:981:19: 981:37
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::japanese::iso2022jp::internal::map_two_0208_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as Trail0208).1: u8) = move _6; // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 8;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb12;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:981:45: 981:46
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:981:45: 981:46
        switchInt(_10) -> [65535_u32: bb7, otherwise: bb6]; // scope 2 at src/codec/japanese.rs:981:13: 981:46
    }

    bb6: {
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:983:17: 983:19
        _14 = _10;                       // scope 2 at src/codec/japanese.rs:983:17: 983:19
        StorageLive(_15);                // scope 3 at src/codec/japanese.rs:983:23: 983:26
        _15 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:983:23: 983:26
        StorageLive(_16);                // scope 3 at src/codec/japanese.rs:983:32: 983:41
        _16 = _14;                       // scope 3 at src/codec/japanese.rs:983:32: 983:34
        _9 = StatefulDecoderHelper::<iso2022jp::State, T>::emit(move _15, move _16) -> bb9; // scope 3 at src/codec/japanese.rs:983:23: 983:42
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:983:27: 983:31
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, u32) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:982:27: 982:30
        _13 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:982:27: 982:30
        _9 = StatefulDecoderHelper::<iso2022jp::State, T>::err(move _13, const "invalid sequence") -> bb8; // scope 2 at src/codec/japanese.rs:982:27: 982:54
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:982:31: 982:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:982:35: 982:53
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb8: {
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:982:53: 982:54
        goto -> bb10;                    // scope 2 at src/codec/japanese.rs:982:53: 982:54
    }

    bb9: {
        StorageDead(_16);                // scope 3 at src/codec/japanese.rs:983:41: 983:42
        StorageDead(_15);                // scope 3 at src/codec/japanese.rs:983:41: 983:42
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:983:41: 983:42
        goto -> bb10;                    // scope 2 at src/codec/japanese.rs:983:41: 983:42
    }

    bb10: {
        StorageDead(_10);                // scope 2 at src/util.rs:226:72: 226:73
        StorageDead(_9);                 // scope 2 at src/util.rs:226:72: 226:73
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:985:22: 985:25
        _17 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:985:22: 985:25
        _0 = iso2022jp::transient::Lead0208::<T>(move _17) -> bb11; // scope 2 at src/codec/japanese.rs:985:13: 985:26
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:985:13: 985:21
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Lead0208::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:985:25: 985:26
        StorageDead(_8);                 // scope 1 at src/util.rs:226:77: 226:78
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb12;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb12: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:294:1: 302:2>::raw_finish(_1: &mut UTF16BEDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:299:19: 299:28
    debug output => _2;                  // in scope 0 at src/codec/utf_16.rs:299:30: 299:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/utf_16.rs:299:60: 299:78
    let mut _3: &mut codec::utf_16::UTF16Decoder; // in scope 0 at src/codec/utf_16.rs:300:9: 300:19
    let mut _4: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:300:31: 300:37
    let mut _5: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/utf_16.rs:300:31: 300:37

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:300:9: 300:19
        _3 = &mut ((*_1).0: codec::utf_16::UTF16Decoder); // scope 0 at src/codec/utf_16.rs:300:9: 300:19
        StorageLive(_4);                 // scope 0 at src/codec/utf_16.rs:300:31: 300:37
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:300:31: 300:37
        _5 = &mut (*_2);                 // scope 0 at src/codec/utf_16.rs:300:31: 300:37
        _4 = move _5 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:300:31: 300:37
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:300:36: 300:37
        _0 = UTF16Decoder::raw_finish(move _3, move _4) -> bb1; // scope 0 at src/codec/utf_16.rs:300:9: 300:38
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:300:20: 300:30
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut codec::utf_16::UTF16Decoder, &'s mut (dyn encoding_types::StringWriter + 's)) -> std::option::Option<encoding_types::CodecError> {codec::utf_16::UTF16Decoder::raw_finish}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/codec/utf_16.rs:300:37: 300:38
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:300:37: 300:38
        return;                          // scope 0 at src/codec/utf_16.rs:301:6: 301:6
    }
}

fn eucjp::<impl at src/util.rs:157:33: 157:38>::clone(_1: &eucjp::State) -> eucjp::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                    scope 5 {
                        scope 6 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 6 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:48:10: 48:15>::clone(_1: &GB18030Encoder) -> GB18030Encoder {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:48:10: 48:15
    let mut _0: codec::simpchinese::GB18030Encoder; // return place in scope 0 at src/codec/simpchinese.rs:48:10: 48:15

    bb0: {
        return;                          // scope 0 at src/codec/simpchinese.rs:48:15: 48:15
    }
}

fn simpchinese::gb18030::raw_finish(_1: simpchinese::gb18030::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (simpchinese::gb18030::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::simpchinese::gb18030::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:311:26: 311:33
    let mut _21: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _25: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _30: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _31: codec::simpchinese::gb18030::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _32: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _33: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _34: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::simpchinese::gb18030::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _22: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _23: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _26: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _27: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _28: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug first => _19;          // in scope 4 at src/util.rs:284:36: 284:40
            let _20: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 4 at src/util.rs:284:53: 284:57
            scope 5 {
                debug ctx => _20;        // in scope 5 at src/util.rs:284:53: 284:57
            }
        }
        scope 6 {
            debug first => _22;          // in scope 6 at src/util.rs:284:36: 284:40
            debug second => _23;         // in scope 6 at src/util.rs:284:36: 284:40
            let _24: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 6 at src/util.rs:284:53: 284:57
            scope 7 {
                debug ctx => _24;        // in scope 7 at src/util.rs:284:53: 284:57
            }
        }
        scope 8 {
            debug first => _26;          // in scope 8 at src/util.rs:284:36: 284:40
            debug second => _27;         // in scope 8 at src/util.rs:284:36: 284:40
            debug third => _28;          // in scope 8 at src/util.rs:284:36: 284:40
            let _29: &mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>; // in scope 8 at src/util.rs:284:53: 284:57
            scope 9 {
                debug ctx => _29;        // in scope 9 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _34 = const simpchinese::gb18030::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(simpchinese::gb18030::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1085 ~ encoding[5d2c]::codec::simpchinese::gb18030::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _34;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T> {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<simpchinese::gb18030::State>(move _13, move _15) -> [return: bb2, unwind: bb15]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::simpchinese::gb18030::State, codec::simpchinese::gb18030::State) -> codec::simpchinese::gb18030::State {std::mem::replace::<codec::simpchinese::gb18030::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb7, 2_isize: bb9, 3_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_26);                // scope 1 at src/util.rs:284:36: 284:40
        _26 = ((_12 as S3).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_27);                // scope 1 at src/util.rs:284:36: 284:40
        _27 = ((_12 as S3).2: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_28);                // scope 1 at src/util.rs:284:36: 284:40
        _28 = ((_12 as S3).3: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_29);                // scope 8 at src/util.rs:284:53: 284:57
        _29 = &mut _4;                   // scope 8 at src/util.rs:284:60: 284:68
        StorageLive(_30);                // scope 9 at src/util.rs:317:26: 317:30
        _30 = &mut (*_29);               // scope 9 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::err(move _30, const "incomplete sequence") -> [return: bb11, unwind: bb15]; // scope 9 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/util.rs:311:26: 311:33
        _18 = &(*_17);                   // scope 3 at src/util.rs:311:26: 311:33
        _11 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::reset(move _18) -> [return: bb6, unwind: bb15]; // scope 3 at src/util.rs:311:26: 311:41
                                         // mir::Constant
                                         // + span: src/util.rs:311:34: 311:39
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/util.rs:311:40: 311:41
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb12;                    // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageLive(_19);                // scope 1 at src/util.rs:284:36: 284:40
        _19 = ((_12 as S1).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_20);                // scope 4 at src/util.rs:284:53: 284:57
        _20 = &mut _4;                   // scope 4 at src/util.rs:284:60: 284:68
        StorageLive(_21);                // scope 5 at src/util.rs:317:26: 317:30
        _21 = &mut (*_20);               // scope 5 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::err(move _21, const "incomplete sequence") -> [return: bb8, unwind: bb15]; // scope 5 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb8: {
        StorageDead(_21);                // scope 5 at src/util.rs:317:56: 317:57
        StorageDead(_20);                // scope 4 at src/util.rs:284:80: 284:81
        StorageDead(_19);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb12;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb9: {
        StorageLive(_22);                // scope 1 at src/util.rs:284:36: 284:40
        _22 = ((_12 as S2).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_23);                // scope 1 at src/util.rs:284:36: 284:40
        _23 = ((_12 as S2).2: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_24);                // scope 6 at src/util.rs:284:53: 284:57
        _24 = &mut _4;                   // scope 6 at src/util.rs:284:60: 284:68
        StorageLive(_25);                // scope 7 at src/util.rs:317:26: 317:30
        _25 = &mut (*_24);               // scope 7 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<simpchinese::gb18030::State, T>::err(move _25, const "incomplete sequence") -> [return: bb10, unwind: bb15]; // scope 7 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::gb18030::State, T>, &'static str) -> codec::simpchinese::gb18030::State {util::StatefulDecoderHelper::<codec::simpchinese::gb18030::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb10: {
        StorageDead(_25);                // scope 7 at src/util.rs:317:56: 317:57
        StorageDead(_24);                // scope 6 at src/util.rs:284:80: 284:81
        StorageDead(_23);                // scope 1 at src/util.rs:284:80: 284:81
        StorageDead(_22);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb12;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb11: {
        StorageDead(_30);                // scope 9 at src/util.rs:317:56: 317:57
        StorageDead(_29);                // scope 8 at src/util.rs:284:80: 284:81
        StorageDead(_28);                // scope 1 at src/util.rs:284:80: 284:81
        StorageDead(_27);                // scope 1 at src/util.rs:284:80: 284:81
        StorageDead(_26);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb12;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb12: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_31);                // scope 2 at src/util.rs:287:18: 287:20
        _31 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_32);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_33);                // scope 2 at src/util.rs:287:22: 287:29
        _33 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _32 = Option::<encoding_types::CodecError>::take(move _33) -> [return: bb13, unwind: bb15]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_33);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::simpchinese::gb18030::State) = move _31; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _32; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_32);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_31);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb14;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb14: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb15 (cleanup): {
        drop(_4) -> bb16;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb16 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in simpchinese::gb18030::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:64:1: 78:2>::is_ascii_compatible(_1: &UTF8Encoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:66:28: 66:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/utf_8.rs:66:38: 66:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/utf_8.rs:66:45: 66:49
        return;                          // scope 0 at src/codec/utf_8.rs:66:51: 66:51
    }
}

fn japanese::<impl at src/codec/japanese.rs:798:1: 850:2>::raw_finish(_1: &mut ISO2022JPEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:847:19: 847:28
    debug _output => _2;                 // in scope 0 at src/codec/japanese.rs:847:30: 847:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/japanese.rs:847:59: 847:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/japanese.rs:848:9: 848:13
        return;                          // scope 0 at src/codec/japanese.rs:849:6: 849:6
    }
}

fn windows949::<impl at src/util.rs:157:22: 157:31>::eq(_1: &windows949::State, _2: &windows949::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::korean::windows949::State, &codec::korean::windows949::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::korean::windows949::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _26: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _27: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _18: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _19: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _18;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _19;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _20;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _21;  // in scope 3 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb10, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::korean::windows949::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::korean::windows949::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _17 = discriminant((*(_13.0: &codec::korean::windows949::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [1_isize: bb3, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::korean::windows949::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb4, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        StorageLive(_18);                // scope 2 at src/util.rs:164:25: 164:27
        _18 = &(((*(_13.0: &codec::korean::windows949::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_19);                // scope 2 at src/util.rs:164:32: 164:35
        _19 = &(((*(_13.0: &codec::korean::windows949::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.1: &codec::korean::windows949::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.1: &codec::korean::windows949::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _18;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        _22 = <() as PartialEq>::eq(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        _0 = const false;                // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb6: {
        StorageLive(_25);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_26);                // scope 3 at src/util.rs:164:32: 164:35
        _26 = (*_19);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        _27 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        _25 = Eq(move _26, move _27);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_26);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _25;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb7: {
        StorageDead(_25);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_22);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_19);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_18);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:30: 157:31
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _22) -> [false: bb5, otherwise: bb6]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:100:1: 102:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_16.rs:101:17: 101:32
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:101:35: 101:59
    let mut _2: std::boxed::Box<codec::utf_16::UTF16BEEncoder>; // in scope 0 at src/codec/utf_16.rs:101:35: 101:59
    let mut _3: codec::utf_16::UTF16BEEncoder; // in scope 0 at src/codec/utf_16.rs:101:44: 101:58

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/utf_16.rs:101:35: 101:59
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:101:35: 101:59
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:101:44: 101:58
        _2 = Box::<UTF16BEEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/utf_16.rs:101:35: 101:59
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:101:35: 101:43
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::utf_16::UTF16BEEncoder) -> std::boxed::Box<codec::utf_16::UTF16BEEncoder> {std::boxed::Box::<codec::utf_16::UTF16BEEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:101:35: 101:59
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:101:58: 101:59
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:101:58: 101:59
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:101:35: 101:59
        StorageDead(_1);                 // scope 0 at src/codec/utf_16.rs:101:60: 101:61
        return;                          // scope 0 at src/codec/utf_16.rs:101:61: 101:61
    }
}

fn eucjp::raw_finish(_1: eucjp::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (eucjp::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::japanese::eucjp::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::japanese::eucjp::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::japanese::eucjp::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:311:26: 311:33
    let mut _20: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _22: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _25: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _28: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _29: codec::japanese::eucjp::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _30: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _31: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _32: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::japanese::eucjp::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _21: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _23: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        let _26: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug ctx => _19;            // in scope 4 at src/util.rs:284:53: 284:57
        }
        scope 5 {
            debug ctx => _21;            // in scope 5 at src/util.rs:284:53: 284:57
        }
        scope 6 {
            debug lead => _23;           // in scope 6 at src/util.rs:284:36: 284:40
            let _24: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 6 at src/util.rs:284:53: 284:57
            scope 7 {
                debug ctx => _24;        // in scope 7 at src/util.rs:284:53: 284:57
            }
        }
        scope 8 {
            debug lead => _26;           // in scope 8 at src/util.rs:284:36: 284:40
            let _27: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 8 at src/util.rs:284:53: 284:57
            scope 9 {
                debug ctx => _27;        // in scope 9 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _32 = const eucjp::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(eucjp::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:817 ~ encoding[5d2c]::codec::japanese::eucjp::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _32;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<eucjp::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::japanese::eucjp::State, T> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<eucjp::State>(move _13, move _15) -> [return: bb2, unwind: bb17]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::japanese::eucjp::State, codec::japanese::eucjp::State) -> codec::japanese::eucjp::State {std::mem::replace::<codec::japanese::eucjp::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb7, 2_isize: bb9, 3_isize: bb11, 4_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_26);                // scope 1 at src/util.rs:284:36: 284:40
        _26 = ((_12 as S4).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_27);                // scope 8 at src/util.rs:284:53: 284:57
        _27 = &mut _4;                   // scope 8 at src/util.rs:284:60: 284:68
        StorageLive(_28);                // scope 9 at src/util.rs:317:26: 317:30
        _28 = &mut (*_27);               // scope 9 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<eucjp::State, T>::err(move _28, const "incomplete sequence") -> [return: bb13, unwind: bb17]; // scope 9 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/util.rs:311:26: 311:33
        _18 = &(*_17);                   // scope 3 at src/util.rs:311:26: 311:33
        _11 = StatefulDecoderHelper::<eucjp::State, T>::reset(move _18) -> [return: bb6, unwind: bb17]; // scope 3 at src/util.rs:311:26: 311:41
                                         // mir::Constant
                                         // + span: src/util.rs:311:34: 311:39
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/util.rs:311:40: 311:41
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb14;                    // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageLive(_19);                // scope 1 at src/util.rs:284:53: 284:57
        _19 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_20);                // scope 4 at src/util.rs:317:26: 317:30
        _20 = &mut (*_19);               // scope 4 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<eucjp::State, T>::err(move _20, const "incomplete sequence") -> [return: bb8, unwind: bb17]; // scope 4 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb8: {
        StorageDead(_20);                // scope 4 at src/util.rs:317:56: 317:57
        StorageDead(_19);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb9: {
        StorageLive(_21);                // scope 1 at src/util.rs:284:53: 284:57
        _21 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_22);                // scope 5 at src/util.rs:317:26: 317:30
        _22 = &mut (*_21);               // scope 5 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<eucjp::State, T>::err(move _22, const "incomplete sequence") -> [return: bb10, unwind: bb17]; // scope 5 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb10: {
        StorageDead(_22);                // scope 5 at src/util.rs:317:56: 317:57
        StorageDead(_21);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb11: {
        StorageLive(_23);                // scope 1 at src/util.rs:284:36: 284:40
        _23 = ((_12 as S3).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_24);                // scope 6 at src/util.rs:284:53: 284:57
        _24 = &mut _4;                   // scope 6 at src/util.rs:284:60: 284:68
        StorageLive(_25);                // scope 7 at src/util.rs:317:26: 317:30
        _25 = &mut (*_24);               // scope 7 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<eucjp::State, T>::err(move _25, const "incomplete sequence") -> [return: bb12, unwind: bb17]; // scope 7 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb12: {
        StorageDead(_25);                // scope 7 at src/util.rs:317:56: 317:57
        StorageDead(_24);                // scope 6 at src/util.rs:284:80: 284:81
        StorageDead(_23);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb13: {
        StorageDead(_28);                // scope 9 at src/util.rs:317:56: 317:57
        StorageDead(_27);                // scope 8 at src/util.rs:284:80: 284:81
        StorageDead(_26);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb14: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_29);                // scope 2 at src/util.rs:287:18: 287:20
        _29 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_30);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_31);                // scope 2 at src/util.rs:287:22: 287:29
        _31 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _30 = Option::<encoding_types::CodecError>::take(move _31) -> [return: bb15, unwind: bb17]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_31);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::japanese::eucjp::State) = move _29; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _30; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_30);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_29);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb16;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb16: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb17 (cleanup): {
        drop(_4) -> bb18;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb18 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in eucjp::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:48:10: 48:15>::clone(_1: &UTF16Encoder) -> UTF16Encoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:48:10: 48:15
    let mut _0: codec::utf_16::UTF16Encoder; // return place in scope 0 at src/codec/utf_16.rs:48:10: 48:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_16.rs:48:15: 48:15
    }
}

fn korean::<impl at src/codec/korean.rs:84:1: 99:2>::is_ascii_compatible(_1: &Windows949Decoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:86:28: 86:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/korean.rs:86:38: 86:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/korean.rs:86:45: 86:49
        return;                          // scope 0 at src/codec/korean.rs:86:51: 86:51
    }
}

fn windows31j::start::S0(_1: &mut StatefulDecoderHelper<windows31j::State, T>) -> windows31j::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/japanese.rs:563:35: 563:46
    let mut _7: bool;                    // in scope 0 at src/codec/japanese.rs:563:35: 563:46
    let mut _8: bool;                    // in scope 0 at src/codec/japanese.rs:563:18: 563:29
    let mut _9: bool;                    // in scope 0 at src/codec/japanese.rs:563:18: 563:29
    let mut _10: bool;                   // in scope 0 at src/codec/japanese.rs:562:18: 562:29
    let mut _11: bool;                   // in scope 0 at src/codec/japanese.rs:562:18: 562:29
    let mut _12: bool;                   // in scope 0 at src/codec/japanese.rs:561:18: 561:29
    let mut _13: bool;                   // in scope 0 at src/codec/japanese.rs:561:18: 561:29
    let mut _15: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/codec/japanese.rs:561:33: 561:36
    let mut _16: u32;                    // in scope 0 at src/codec/japanese.rs:561:42: 561:50
    let mut _17: u8;                     // in scope 0 at src/codec/japanese.rs:561:42: 561:43
    let mut _19: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/codec/japanese.rs:562:33: 562:36
    let mut _20: u32;                    // in scope 0 at src/codec/japanese.rs:562:42: 562:66
    let mut _21: u32;                    // in scope 0 at src/codec/japanese.rs:562:42: 562:59
    let mut _22: u32;                    // in scope 0 at src/codec/japanese.rs:562:51: 562:59
    let mut _23: u8;                     // in scope 0 at src/codec/japanese.rs:562:51: 562:52
    let mut _25: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/codec/japanese.rs:563:53: 563:56
    let mut _26: u8;                     // in scope 0 at src/codec/japanese.rs:563:58: 563:59
    let mut _27: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/codec/japanese.rs:564:19: 564:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _14: u8;                     // in scope 1 at src/codec/japanese.rs:561:14: 561:29
        let _18: u8;                     // in scope 1 at src/codec/japanese.rs:562:14: 562:29
        let _24: u8;                     // in scope 1 at src/codec/japanese.rs:563:14: 563:29
        scope 2 {
            debug b => _14;              // in scope 2 at src/codec/japanese.rs:561:14: 561:29
        }
        scope 3 {
            debug b => _18;              // in scope 3 at src/codec/japanese.rs:562:14: 562:29
        }
        scope 4 {
            debug b => _24;              // in scope 4 at src/codec/japanese.rs:563:14: 563:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<windows31j::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        _12 = Le(const 0_u8, _5);        // scope 1 at src/codec/japanese.rs:561:18: 561:29
        switchInt(move _12) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/japanese.rs:561:18: 561:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb23;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _13 = Le(_5, const 128_u8);      // scope 1 at src/codec/japanese.rs:561:18: 561:29
        switchInt(move _13) -> [false: bb6, otherwise: bb13]; // scope 1 at src/codec/japanese.rs:561:18: 561:29
    }

    bb6: {
        _10 = Le(const 161_u8, _5);      // scope 1 at src/codec/japanese.rs:562:18: 562:29
        switchInt(move _10) -> [false: bb8, otherwise: bb7]; // scope 1 at src/codec/japanese.rs:562:18: 562:29
    }

    bb7: {
        _11 = Le(_5, const 223_u8);      // scope 1 at src/codec/japanese.rs:562:18: 562:29
        switchInt(move _11) -> [false: bb8, otherwise: bb15]; // scope 1 at src/codec/japanese.rs:562:18: 562:29
    }

    bb8: {
        _8 = Le(const 129_u8, _5);       // scope 1 at src/codec/japanese.rs:563:18: 563:29
        switchInt(move _8) -> [false: bb10, otherwise: bb9]; // scope 1 at src/codec/japanese.rs:563:18: 563:29
    }

    bb9: {
        _9 = Le(_5, const 159_u8);       // scope 1 at src/codec/japanese.rs:563:18: 563:29
        switchInt(move _9) -> [false: bb10, otherwise: bb18]; // scope 1 at src/codec/japanese.rs:563:18: 563:29
    }

    bb10: {
        _6 = Le(const 224_u8, _5);       // scope 1 at src/codec/japanese.rs:563:35: 563:46
        switchInt(move _6) -> [false: bb12, otherwise: bb11]; // scope 1 at src/codec/japanese.rs:563:35: 563:46
    }

    bb11: {
        _7 = Le(_5, const 252_u8);       // scope 1 at src/codec/japanese.rs:563:35: 563:46
        switchInt(move _7) -> [false: bb12, otherwise: bb19]; // scope 1 at src/codec/japanese.rs:563:35: 563:46
    }

    bb12: {
        StorageLive(_27);                // scope 1 at src/codec/japanese.rs:564:19: 564:22
        _27 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:564:19: 564:22
        _0 = StatefulDecoderHelper::<windows31j::State, T>::err(move _27, const "invalid sequence") -> bb21; // scope 1 at src/codec/japanese.rs:564:19: 564:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:564:23: 564:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>, &'static str) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:564:27: 564:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb13: {
        StorageLive(_14);                // scope 1 at src/codec/japanese.rs:561:14: 561:29
        _14 = _5;                        // scope 1 at src/codec/japanese.rs:561:14: 561:29
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:561:33: 561:36
        _15 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:561:33: 561:36
        StorageLive(_16);                // scope 2 at src/codec/japanese.rs:561:42: 561:50
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:561:42: 561:43
        _17 = _14;                       // scope 2 at src/codec/japanese.rs:561:42: 561:43
        _16 = move _17 as u32 (Misc);    // scope 2 at src/codec/japanese.rs:561:42: 561:50
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:561:49: 561:50
        _0 = StatefulDecoderHelper::<windows31j::State, T>::emit(move _15, move _16) -> bb14; // scope 2 at src/codec/japanese.rs:561:33: 561:51
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:561:37: 561:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>, u32) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        StorageDead(_16);                // scope 2 at src/codec/japanese.rs:561:50: 561:51
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:561:50: 561:51
        StorageDead(_14);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb22;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb15: {
        StorageLive(_18);                // scope 1 at src/codec/japanese.rs:562:14: 562:29
        _18 = _5;                        // scope 1 at src/codec/japanese.rs:562:14: 562:29
        StorageLive(_19);                // scope 3 at src/codec/japanese.rs:562:33: 562:36
        _19 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:562:33: 562:36
        StorageLive(_20);                // scope 3 at src/codec/japanese.rs:562:42: 562:66
        StorageLive(_21);                // scope 3 at src/codec/japanese.rs:562:42: 562:59
        StorageLive(_22);                // scope 3 at src/codec/japanese.rs:562:51: 562:59
        StorageLive(_23);                // scope 3 at src/codec/japanese.rs:562:51: 562:52
        _23 = _18;                       // scope 3 at src/codec/japanese.rs:562:51: 562:52
        _22 = move _23 as u32 (Misc);    // scope 3 at src/codec/japanese.rs:562:51: 562:59
        StorageDead(_23);                // scope 3 at src/codec/japanese.rs:562:58: 562:59
        _21 = Add(const 65377_u32, move _22); // scope 3 at src/codec/japanese.rs:562:42: 562:59
        StorageDead(_22);                // scope 3 at src/codec/japanese.rs:562:58: 562:59
        _20 = Sub(move _21, const 161_u32); // scope 3 at src/codec/japanese.rs:562:42: 562:66
        StorageDead(_21);                // scope 3 at src/codec/japanese.rs:562:65: 562:66
        _0 = StatefulDecoderHelper::<windows31j::State, T>::emit(move _19, move _20) -> bb16; // scope 3 at src/codec/japanese.rs:562:33: 562:67
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:562:37: 562:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>, u32) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:562:66: 562:67
        StorageDead(_19);                // scope 3 at src/codec/japanese.rs:562:66: 562:67
        StorageDead(_18);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb22;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb17: {
        StorageLive(_25);                // scope 4 at src/codec/japanese.rs:563:53: 563:56
        _25 = &mut (*_1);                // scope 4 at src/codec/japanese.rs:563:53: 563:56
        StorageLive(_26);                // scope 4 at src/codec/japanese.rs:563:58: 563:59
        _26 = _24;                       // scope 4 at src/codec/japanese.rs:563:58: 563:59
        _0 = windows31j::transient::S1::<T>(move _25, move _26) -> bb20; // scope 4 at src/codec/japanese.rs:563:50: 563:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:563:50: 563:52
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::windows31j::State, T>, u8) -> codec::japanese::windows31j::State {codec::japanese::windows31j::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb18: {
        StorageLive(_24);                // scope 1 at src/codec/japanese.rs:563:14: 563:29
        _24 = _5;                        // scope 1 at src/codec/japanese.rs:563:14: 563:29
        goto -> bb17;                    // scope 1 at src/util.rs:187:36: 187:84
    }

    bb19: {
        StorageLive(_24);                // scope 1 at src/codec/japanese.rs:563:31: 563:46
        _24 = _5;                        // scope 1 at src/codec/japanese.rs:563:31: 563:46
        goto -> bb17;                    // scope 1 at src/util.rs:187:36: 187:84
    }

    bb20: {
        StorageDead(_26);                // scope 4 at src/codec/japanese.rs:563:59: 563:60
        StorageDead(_25);                // scope 4 at src/codec/japanese.rs:563:59: 563:60
        StorageDead(_24);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb22;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb21: {
        StorageDead(_27);                // scope 1 at src/codec/japanese.rs:564:45: 564:46
        goto -> bb22;                    // scope 1 at src/codec/japanese.rs:564:45: 564:46
    }

    bb22: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb23;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb23: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

fn iso2022jp::start::Lead0212(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:193:37: 193:43
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:193:85: 193:97
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:196:31: 196:44
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:196:31: 196:37
    let mut _4: isize;                   // in scope 0 at src/util.rs:197:29: 197:33
    let _5: u8;                          // in scope 0 at src/util.rs:198:34: 198:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:928:22: 928:25
    let mut _7: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:929:34: 929:37
    let mut _9: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:930:29: 930:32
    let mut _10: u8;                     // in scope 0 at src/codec/japanese.rs:930:34: 930:35
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:198:34: 198:35
        let _8: u8;                      // in scope 1 at src/codec/japanese.rs:930:14: 930:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/japanese.rs:930:14: 930:15
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:196:31: 196:44
        StorageLive(_3);                 // scope 0 at src/util.rs:196:31: 196:37
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:196:31: 196:37
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:196:31: 196:44
                                         // mir::Constant
                                         // + span: src/util.rs:196:38: 196:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:196:43: 196:44
        _4 = discriminant(_2);           // scope 0 at src/util.rs:196:31: 196:44
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:196:25: 196:44
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:198:34: 198:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:198:34: 198:35
        switchInt(_5) -> [10_u8: bb6, 27_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:198:40: 198:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:196:31: 196:44
    }

    bb4: {
        discriminant(_0) = 2;            // scope 0 at src/util.rs:197:44: 197:66
        goto -> bb12;                    // scope 0 at src/util.rs:197:65: 197:66
    }

    bb5: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:930:14: 930:15
        _8 = _5;                         // scope 1 at src/codec/japanese.rs:930:14: 930:15
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:930:29: 930:32
        _9 = &mut (*_1);                 // scope 2 at src/codec/japanese.rs:930:29: 930:32
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:930:34: 930:35
        _10 = _8;                        // scope 2 at src/codec/japanese.rs:930:34: 930:35
        _0 = iso2022jp::transient::Trail0212::<T>(move _9, move _10) -> bb10; // scope 2 at src/codec/japanese.rs:930:19: 930:36
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:930:19: 930:28
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>, u8) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Trail0212::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:928:22: 928:25
        _6 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:928:22: 928:25
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::emit(move _6, const 10_u32) -> bb7; // scope 1 at src/codec/japanese.rs:928:22: 928:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:928:26: 928:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, u32) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:928:37: 928:38
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:928:37: 928:38
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:929:34: 929:37
        _7 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:929:34: 929:37
        _0 = iso2022jp::transient::EscapeStart::<T>(move _7) -> bb9; // scope 1 at src/codec/japanese.rs:929:22: 929:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:929:22: 929:33
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeStart::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:929:37: 929:38
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:929:37: 929:38
    }

    bb10: {
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:930:35: 930:36
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:930:35: 930:36
        StorageDead(_8);                 // scope 1 at src/util.rs:198:81: 198:82
        goto -> bb11;                    // scope 1 at src/util.rs:198:81: 198:82
    }

    bb11: {
        StorageDead(_5);                 // scope 0 at src/util.rs:198:85: 198:86
        goto -> bb12;                    // scope 0 at src/util.rs:198:85: 198:86
    }

    bb12: {
        StorageDead(_2);                 // scope 0 at src/util.rs:200:21: 200:22
        return;                          // scope 0 at src/util.rs:200:22: 200:22
    }
}

fn japanese::<impl at src/codec/japanese.rs:467:1: 506:2>::is_ascii_compatible(_1: &Windows31JEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:469:28: 469:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:469:38: 469:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/japanese.rs:469:45: 469:49
        return;                          // scope 0 at src/codec/japanese.rs:469:51: 469:51
    }
}

const ISO_8859_1: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:22:82: 22:86
    let mut _4: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _5: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _6: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _6 = const ISO_8859_1::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_1, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1250 ~ encoding[5d2c]::all::ISO_8859_1), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_6);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_1: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:22:82: 22:86
    let mut _3: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _4: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        discriminant(_2) = 0;            // scope 0 at src/all.rs:22:82: 22:86
        _3 = iso_8859_1::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {codec::singlebyte::iso_8859_1::forward}, val: Value(Scalar(<ZST>)) }
        _4 = iso_8859_1::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {codec::singlebyte::iso_8859_1::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-1"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:42:69: 42:81
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 49], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _3; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _4; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

const WINDOWS_1257: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:66:68: 66:82
    let _5: &str;                        // in scope 0 at src/all.rs:66:68: 66:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1257::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1257, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1274 ~ encoding[5d2c]::all::WINDOWS_1257), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1257: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:66:68: 66:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:66:68: 66:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1257";       // scope 0 at src/all.rs:66:68: 66:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:66:68: 66:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:66:68: 66:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1257::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1257::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1257::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1257::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1257"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:66:68: 66:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 55], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:55:1: 62:2>::is_ascii_compatible(_1: &GB18030Encoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:57:28: 57:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/simpchinese.rs:57:38: 57:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/simpchinese.rs:57:45: 57:49
        return;                          // scope 0 at src/codec/simpchinese.rs:57:51: 57:51
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:57:10: 57:15>::clone(_1: &UTF8Encoder) -> UTF8Encoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:57:10: 57:15
    let mut _0: codec::utf_8::UTF8Encoder; // return place in scope 0 at src/codec/utf_8.rs:57:10: 57:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_8.rs:57:15: 57:15
    }
}

fn korean::<impl at src/codec/korean.rs:24:10: 24:15>::clone(_1: &Windows949Encoding) -> Windows949Encoding {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:24:10: 24:15
    let mut _0: codec::korean::Windows949Encoding; // return place in scope 0 at src/codec/korean.rs:24:10: 24:15

    bb0: {
        return;                          // scope 0 at src/codec/korean.rs:24:15: 24:15
    }
}

fn japanese::<impl at src/codec/japanese.rs:32:1: 37:2>::raw_decoder(_1: &EUCJPEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:36:20: 36:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:36:30: 36:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:36:48: 36:71
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:36:48: 36:71

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:36:48: 36:71
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:36:48: 36:71
        _3 = EUCJP0212Decoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:36:48: 36:71
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:36:48: 36:69
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::japanese::EUCJP0212Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:36:48: 36:71
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:36:70: 36:71
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:36:48: 36:71
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:36:72: 36:73
        return;                          // scope 0 at src/codec/japanese.rs:36:73: 36:73
    }
}

fn encodings() -> &[&dyn encoding_types::Encoding + Send + Sync] {
    let mut _0: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync]; // return place in scope 0 at src/all.rs:93:23: 93:45

    bb0: {
        _0 = const ENCODINGS;            // scope 0 at src/all.rs:141:5: 141:14
                                         // ty::Const
                                         // + ty: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync]
                                         // + val: Unevaluated(ENCODINGS, [], None)
                                         // mir::Constant
                                         // + span: src/all.rs:141:5: 141:14
                                         // + literal: Const { ty: &[&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:581 ~ encoding[5d2c]::all::encodings::ENCODINGS), const_param_did: None }, substs_: Some([]), promoted: None }) }
        return;                          // scope 0 at src/all.rs:142:2: 142:2
    }
}

CHAR_CATEGORY::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at src/codec/utf_8.rs:94:28: 94:31

    bb0: {
        _0 = const 256_usize;            // scope 0 at src/codec/utf_8.rs:94:28: 94:31
        return;                          // scope 0 at src/codec/utf_8.rs:94:28: 94:31
    }
}

fn japanese::<impl at src/codec/japanese.rs:864:1: 879:2>::raw_finish(_1: &mut ISO2022JPDecoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:874:19: 874:28
    debug output => _2;                  // in scope 0 at src/codec/japanese.rs:874:30: 874:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/japanese.rs:875:18: 875:21
    let _3: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:875:14: 875:16
    let mut _4: (codec::japanese::iso2022jp::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/japanese.rs:875:25: 875:68
    let mut _5: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:875:47: 875:54
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:875:56: 875:62
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:875:56: 875:62
    let mut _8: &();                     // in scope 0 at src/codec/japanese.rs:875:64: 875:67
    let _9: &();                         // in scope 0 at src/codec/japanese.rs:875:64: 875:67
    let mut _10: codec::japanese::iso2022jp::State; // in scope 0 at src/codec/japanese.rs:876:19: 876:21
    let mut _11: &();                    // in scope 0 at src/codec/japanese.rs:875:64: 875:67
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/japanese.rs:875:14: 875:16
        debug err => _0;                 // in scope 1 at src/codec/japanese.rs:875:18: 875:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:875:25: 875:68
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:875:47: 875:54
        _5 = ((*_1).0: codec::japanese::iso2022jp::State); // scope 0 at src/codec/japanese.rs:875:47: 875:54
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:875:56: 875:62
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:875:56: 875:62
        _7 = &mut (*_2);                 // scope 0 at src/codec/japanese.rs:875:56: 875:62
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:875:56: 875:62
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:875:61: 875:62
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:875:64: 875:67
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:875:64: 875:67
        _11 = const <ISO2022JPDecoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/japanese.rs:875:64: 875:67
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<ISO2022JPDecoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:875:64: 875:67
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:446 ~ encoding[5d2c]::codec::japanese::{impl#14}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/japanese.rs:875:64: 875:67
        _8 = _9;                         // scope 0 at src/codec/japanese.rs:875:64: 875:67
        _4 = iso2022jp::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/japanese.rs:875:25: 875:68
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:875:25: 875:46
                                         // + literal: Const { ty: for<'r, 's> fn(codec::japanese::iso2022jp::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::japanese::iso2022jp::State, std::option::Option<encoding_types::CodecError>) {codec::japanese::iso2022jp::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:875:67: 875:68
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:875:67: 875:68
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:875:67: 875:68
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:875:14: 875:16
        _3 = (_4.0: codec::japanese::iso2022jp::State); // scope 0 at src/codec/japanese.rs:875:14: 875:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/japanese.rs:875:18: 875:21
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:875:68: 875:69
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:875:68: 875:69
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:876:19: 876:21
        _10 = _3;                        // scope 1 at src/codec/japanese.rs:876:19: 876:21
        ((*_1).0: codec::japanese::iso2022jp::State) = move _10; // scope 1 at src/codec/japanese.rs:876:9: 876:21
        StorageDead(_10);                // scope 1 at src/codec/japanese.rs:876:20: 876:21
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:878:5: 878:6
        return;                          // scope 0 at src/codec/japanese.rs:878:6: 878:6
    }
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:864:1: 879:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/japanese.rs:875:64: 875:67
    let mut _1: ();                      // in scope 0 at src/codec/japanese.rs:875:65: 875:67

    bb0: {
        nop;                             // scope 0 at src/codec/japanese.rs:875:65: 875:67
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:875:64: 875:67
        return;                          // scope 0 at src/codec/japanese.rs:875:64: 875:67
    }
}

fn bigfive2003::raw_finish(_1: bigfive2003::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (bigfive2003::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::tradchinese::bigfive2003::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:311:26: 311:33
    let mut _21: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _22: codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _23: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _24: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _25: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::tradchinese::bigfive2003::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug lead => _19;           // in scope 4 at src/util.rs:284:36: 284:40
            let _20: &mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>; // in scope 4 at src/util.rs:284:53: 284:57
            scope 5 {
                debug ctx => _20;        // in scope 5 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _25 = const bigfive2003::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(bigfive2003::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1226 ~ encoding[5d2c]::codec::tradchinese::bigfive2003::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _25;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<bigfive2003::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T> {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<bigfive2003::State>(move _13, move _15) -> [return: bb2, unwind: bb11]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::tradchinese::bigfive2003::State, codec::tradchinese::bigfive2003::State) -> codec::tradchinese::bigfive2003::State {std::mem::replace::<codec::tradchinese::bigfive2003::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_19);                // scope 1 at src/util.rs:284:36: 284:40
        _19 = ((_12 as S1).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_20);                // scope 4 at src/util.rs:284:53: 284:57
        _20 = &mut _4;                   // scope 4 at src/util.rs:284:60: 284:68
        StorageLive(_21);                // scope 5 at src/util.rs:317:26: 317:30
        _21 = &mut (*_20);               // scope 5 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<bigfive2003::State, T>::err(move _21, const "incomplete sequence") -> [return: bb7, unwind: bb11]; // scope 5 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>, &'static str) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/util.rs:311:26: 311:33
        _18 = &(*_17);                   // scope 3 at src/util.rs:311:26: 311:33
        _11 = StatefulDecoderHelper::<bigfive2003::State, T>::reset(move _18) -> [return: bb6, unwind: bb11]; // scope 3 at src/util.rs:311:26: 311:41
                                         // mir::Constant
                                         // + span: src/util.rs:311:34: 311:39
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::tradchinese::bigfive2003::State, T>) -> codec::tradchinese::bigfive2003::State {util::StatefulDecoderHelper::<codec::tradchinese::bigfive2003::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/util.rs:311:40: 311:41
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb8;                     // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageDead(_21);                // scope 5 at src/util.rs:317:56: 317:57
        StorageDead(_20);                // scope 4 at src/util.rs:284:80: 284:81
        StorageDead(_19);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb8;                     // scope 1 at src/util.rs:284:80: 284:81
    }

    bb8: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_22);                // scope 2 at src/util.rs:287:18: 287:20
        _22 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_23);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_24);                // scope 2 at src/util.rs:287:22: 287:29
        _24 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _23 = Option::<encoding_types::CodecError>::take(move _24) -> [return: bb9, unwind: bb11]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_24);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::tradchinese::bigfive2003::State) = move _22; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _23; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_23);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_22);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb10;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb10: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb11 (cleanup): {
        drop(_4) -> bb12;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb12 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in bigfive2003::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:122:1: 258:2>::new() -> UTF16Decoder {
    let mut _0: codec::utf_16::UTF16Decoder; // return place in scope 0 at src/codec/utf_16.rs:123:17: 123:29

    bb0: {
        (_0.0: u16) = const u16::MAX;    // scope 0 at src/codec/utf_16.rs:124:9: 124:65
        (_0.1: u16) = const u16::MAX;    // scope 0 at src/codec/utf_16.rs:124:9: 124:65
        return;                          // scope 0 at src/codec/utf_16.rs:125:6: 125:6
    }
}

const EUC_JP: &EUCJPEncoding = {
    let mut _0: &codec::japanese::EUCJPEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const EUC_JP::promoted[0];  // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::japanese::EUCJPEncoding
                                         // + val: Unevaluated(EUC_JP, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::japanese::EUCJPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1281 ~ encoding[5d2c]::all::EUC_JP), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in EUC_JP: &EUCJPEncoding = {
    let mut _0: &codec::japanese::EUCJPEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::japanese::EUCJPEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn windows31j::transient::S1(_1: &mut StatefulDecoderHelper<windows31j::State, T>, _2: u8) -> windows31j::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    debug lead => _2;                    // in scope 0 at src/util.rs:223:61: 223:65
    let mut _0: codec::japanese::windows31j::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _3: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _4: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _5: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let mut _6: u8;                      // in scope 0 at src/util.rs:225:55: 225:59
    let _7: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _9: u32;                     // in scope 0 at src/codec/japanese.rs:570:25: 570:52
    let mut _10: u8;                     // in scope 0 at src/codec/japanese.rs:570:44: 570:48
    let mut _11: u8;                     // in scope 0 at src/codec/japanese.rs:570:50: 570:51
    let mut _12: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/codec/japanese.rs:571:23: 571:26
    let mut _14: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/codec/japanese.rs:572:19: 572:22
    let mut _15: u32;                    // in scope 0 at src/codec/japanese.rs:572:28: 572:30
    scope 1 {
        debug c => _7;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _8: u8;                      // in scope 1 at src/codec/japanese.rs:570:14: 570:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/japanese.rs:570:14: 570:15
            let _13: u32;                // in scope 2 at src/codec/japanese.rs:572:13: 572:15
            scope 3 {
                debug ch => _13;         // in scope 3 at src/codec/japanese.rs:572:13: 572:15
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_4);                 // scope 0 at src/util.rs:224:31: 224:38
        _4 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = StatefulDecoderHelper::<windows31j::State, T>::read(move _4) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:224:44: 224:45
        _5 = discriminant(_3);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _5) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_7);                 // scope 0 at src/util.rs:226:34: 226:35
        _7 = ((_3 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:570:14: 570:15
        _8 = _7;                         // scope 1 at src/codec/japanese.rs:570:14: 570:15
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:570:25: 570:52
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:570:44: 570:48
        _10 = _2;                        // scope 2 at src/codec/japanese.rs:570:44: 570:48
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:570:50: 570:51
        _11 = _8;                        // scope 2 at src/codec/japanese.rs:570:50: 570:51
        _9 = windows31j::internal::map_two_0208_bytes(move _10, move _11) -> bb5; // scope 2 at src/codec/japanese.rs:570:25: 570:52
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:570:25: 570:43
                                         // + literal: Const { ty: fn(u8, u8) -> u32 {codec::japanese::windows31j::internal::map_two_0208_bytes}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:225:55: 225:59
        _6 = _2;                         // scope 0 at src/util.rs:225:55: 225:59
        ((_0 as S1).1: u8) = move _6;    // scope 0 at src/util.rs:225:44: 225:62
        discriminant(_0) = 1;            // scope 0 at src/util.rs:225:44: 225:62
        StorageDead(_6);                 // scope 0 at src/util.rs:225:61: 225:62
        goto -> bb11;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:570:51: 570:52
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:570:51: 570:52
        switchInt(_9) -> [65535_u32: bb7, otherwise: bb6]; // scope 2 at src/codec/japanese.rs:570:19: 570:52
    }

    bb6: {
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:572:13: 572:15
        _13 = _9;                        // scope 2 at src/codec/japanese.rs:572:13: 572:15
        StorageLive(_14);                // scope 3 at src/codec/japanese.rs:572:19: 572:22
        _14 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:572:19: 572:22
        StorageLive(_15);                // scope 3 at src/codec/japanese.rs:572:28: 572:30
        _15 = _13;                       // scope 3 at src/codec/japanese.rs:572:28: 572:30
        _0 = StatefulDecoderHelper::<windows31j::State, T>::emit(move _14, move _15) -> bb9; // scope 3 at src/codec/japanese.rs:572:19: 572:31
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:572:23: 572:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>, u32) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:571:23: 571:26
        _12 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:571:23: 571:26
        _0 = StatefulDecoderHelper::<windows31j::State, T>::backup_and_err(move _12, const 1_usize, const "invalid sequence") -> bb8; // scope 2 at src/codec/japanese.rs:571:23: 571:64
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:571:27: 571:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>, usize, &'static str) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:571:45: 571:63
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb8: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:571:63: 571:64
        goto -> bb10;                    // scope 2 at src/codec/japanese.rs:571:63: 571:64
    }

    bb9: {
        StorageDead(_15);                // scope 3 at src/codec/japanese.rs:572:30: 572:31
        StorageDead(_14);                // scope 3 at src/codec/japanese.rs:572:30: 572:31
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:572:30: 572:31
        goto -> bb10;                    // scope 2 at src/codec/japanese.rs:572:30: 572:31
    }

    bb10: {
        StorageDead(_9);                 // scope 2 at src/util.rs:226:77: 226:78
        StorageDead(_8);                 // scope 1 at src/util.rs:226:77: 226:78
        StorageDead(_7);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb11;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb11: {
        StorageDead(_3);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn codec::whatwg::<impl at src/codec/whatwg.rs:15:1: 20:2>::raw_encoder(_1: &EncoderOnlyUTF8Encoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/whatwg.rs:18:20: 18:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/whatwg.rs:18:30: 18:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/whatwg.rs:18:48: 18:88
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/whatwg.rs:18:48: 18:88
    let mut _4: &codec::utf_8::UTF8Encoding; // in scope 0 at src/codec/whatwg.rs:18:48: 18:74
    let mut _5: &codec::utf_8::UTF8Encoding; // in scope 0 at src/codec/whatwg.rs:18:48: 18:74

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/whatwg.rs:18:48: 18:88
        StorageLive(_3);                 // scope 0 at src/codec/whatwg.rs:18:48: 18:88
        StorageLive(_4);                 // scope 0 at src/codec/whatwg.rs:18:48: 18:74
        _5 = const <EncoderOnlyUTF8Encoding as encoding_types::Encoding>::raw_encoder::promoted[0]; // scope 0 at src/codec/whatwg.rs:18:48: 18:74
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(<EncoderOnlyUTF8Encoding as encoding_types::Encoding>::raw_encoder, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/whatwg.rs:18:48: 18:74
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:556 ~ encoding[5d2c]::codec::whatwg::{impl#0}::raw_encoder), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _4 = _5;                         // scope 0 at src/codec/whatwg.rs:18:48: 18:74
        _3 = <UTF8Encoding as encoding_types::Encoding>::raw_encoder(move _4) -> bb1; // scope 0 at src/codec/whatwg.rs:18:48: 18:88
                                         // mir::Constant
                                         // + span: src/codec/whatwg.rs:18:75: 18:86
                                         // + literal: Const { ty: for<'r> fn(&'r codec::utf_8::UTF8Encoding) -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {<codec::utf_8::UTF8Encoding as encoding_types::Encoding>::raw_encoder}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/whatwg.rs:18:48: 18:88
        StorageDead(_4);                 // scope 0 at src/codec/whatwg.rs:18:87: 18:88
        StorageDead(_3);                 // scope 0 at src/codec/whatwg.rs:18:87: 18:88
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/whatwg.rs:18:48: 18:88
        StorageDead(_2);                 // scope 0 at src/codec/whatwg.rs:18:89: 18:90
        return;                          // scope 0 at src/codec/whatwg.rs:18:90: 18:90
    }
}

promoted[0] in codec::whatwg::<impl at src/codec/whatwg.rs:15:1: 20:2>::raw_encoder: &UTF8Encoding = {
    let mut _0: &codec::utf_8::UTF8Encoding; // return place in scope 0 at src/codec/whatwg.rs:18:48: 18:74
    let mut _1: codec::utf_8::UTF8Encoding; // in scope 0 at src/codec/whatwg.rs:18:48: 18:74

    bb0: {
        nop;                             // scope 0 at src/codec/whatwg.rs:18:48: 18:74
        _0 = &_1;                        // scope 0 at src/codec/whatwg.rs:18:48: 18:74
        return;                          // scope 0 at src/codec/whatwg.rs:18:48: 18:74
    }
}

fn windows949::transient::S0(_1: &mut StatefulDecoderHelper<windows949::State, T>) -> windows949::State {
    let mut _0: codec::korean::windows949::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

fn japanese::<impl at src/codec/japanese.rs:520:1: 535:2>::is_ascii_compatible(_1: &Windows31JDecoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:522:28: 522:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/japanese.rs:522:38: 522:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/japanese.rs:522:45: 522:49
        return;                          // scope 0 at src/codec/japanese.rs:522:51: 522:51
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::read(_1: &mut StatefulDecoderHelper<St, Data>) -> Option<u8> {
    debug self => _1;                    // in scope 0 at src/util.rs:80:17: 80:26
    let mut _0: std::option::Option<u8>; // return place in scope 0 at src/util.rs:80:31: 80:41
    let mut _2: std::option::Option<&u8>; // in scope 0 at src/util.rs:81:15: 81:37
    let mut _3: &[u8];                   // in scope 0 at src/util.rs:81:15: 81:23
    let mut _4: usize;                   // in scope 0 at src/util.rs:81:28: 81:36
    let mut _5: isize;                   // in scope 0 at src/util.rs:82:13: 82:21
    let _6: u8;                          // in scope 0 at src/util.rs:82:19: 82:20
    let mut _7: u8;                      // in scope 0 at src/util.rs:82:47: 82:48
    scope 1 {
        debug c => _6;                   // in scope 1 at src/util.rs:82:19: 82:20
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:81:15: 81:37
        StorageLive(_3);                 // scope 0 at src/util.rs:81:15: 81:23
        _3 = ((*_1).0: &[u8]);           // scope 0 at src/util.rs:81:15: 81:23
        StorageLive(_4);                 // scope 0 at src/util.rs:81:28: 81:36
        _4 = ((*_1).1: usize);           // scope 0 at src/util.rs:81:28: 81:36
        _2 = core::slice::<impl [u8]>::get::<usize>(move _3, move _4) -> bb1; // scope 0 at src/util.rs:81:15: 81:37
                                         // mir::Constant
                                         // + span: src/util.rs:81:24: 81:27
                                         // + literal: Const { ty: for<'r> fn(&'r [u8], usize) -> std::option::Option<&'r <usize as std::slice::SliceIndex<[u8]>>::Output> {core::slice::<impl [u8]>::get::<usize>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_4);                 // scope 0 at src/util.rs:81:36: 81:37
        StorageDead(_3);                 // scope 0 at src/util.rs:81:36: 81:37
        _5 = discriminant(_2);           // scope 0 at src/util.rs:81:15: 81:37
        switchInt(move _5) -> [0_isize: bb2, 1_isize: bb4, otherwise: bb3]; // scope 0 at src/util.rs:81:9: 81:37
    }

    bb2: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:83:21: 83:25
        goto -> bb5;                     // scope 0 at src/util.rs:83:21: 83:25
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:81:15: 81:37
    }

    bb4: {
        StorageLive(_6);                 // scope 0 at src/util.rs:82:19: 82:20
        _6 = (*((_2 as Some).0: &u8));   // scope 0 at src/util.rs:82:19: 82:20
        ((*_1).1: usize) = Add(((*_1).1: usize), const 1_usize); // scope 1 at src/util.rs:82:27: 82:40
        StorageLive(_7);                 // scope 1 at src/util.rs:82:47: 82:48
        _7 = _6;                         // scope 1 at src/util.rs:82:47: 82:48
        ((_0 as Some).0: u8) = move _7;  // scope 1 at src/util.rs:82:42: 82:49
        discriminant(_0) = 1;            // scope 1 at src/util.rs:82:42: 82:49
        StorageDead(_7);                 // scope 1 at src/util.rs:82:48: 82:49
        StorageDead(_6);                 // scope 0 at src/util.rs:82:50: 82:51
        goto -> bb5;                     // scope 0 at src/util.rs:82:50: 82:51
    }

    bb5: {
        StorageDead(_2);                 // scope 0 at src/util.rs:85:5: 85:6
        return;                          // scope 0 at src/util.rs:85:6: 85:6
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:22:1: 27:2>::raw_decoder(_1: &UTF16LEEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:26:20: 26:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_16.rs:26:30: 26:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:26:48: 26:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:26:48: 26:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:26:48: 26:69
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:26:48: 26:69
        _3 = UTF16LEDecoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:26:48: 26:69
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:26:48: 26:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::utf_16::UTF16LEDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:26:48: 26:69
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:26:68: 26:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:26:48: 26:69
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:26:70: 26:71
        return;                          // scope 0 at src/codec/utf_16.rs:26:71: 26:71
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:84:1: 89:2>::raw_decoder(_1: &GBKEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:88:20: 88:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:88:30: 88:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:88:48: 88:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:88:48: 88:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:88:48: 88:69
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:88:48: 88:69
        _3 = GB18030Decoder::new() -> bb1; // scope 0 at src/codec/simpchinese.rs:88:48: 88:69
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:88:48: 88:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::simpchinese::GB18030Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:88:48: 88:69
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:88:68: 88:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:88:48: 88:69
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:88:70: 88:71
        return;                          // scope 0 at src/codec/simpchinese.rs:88:71: 88:71
    }
}

fn codec::error::<impl at src/codec/error.rs:21:10: 21:15>::clone(_1: &ErrorEncoder) -> ErrorEncoder {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:21:10: 21:15
    let mut _0: codec::error::ErrorEncoder; // return place in scope 0 at src/codec/error.rs:21:10: 21:15

    bb0: {
        return;                          // scope 0 at src/codec/error.rs:21:15: 21:15
    }
}

fn eucjp::start::S0(_1: &mut StatefulDecoderHelper<eucjp::State, T>) -> eucjp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:182:34: 182:41
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:182:63: 182:75
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:185:27: 185:41
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:185:27: 185:34
    let mut _4: isize;                   // in scope 0 at src/util.rs:186:25: 186:29
    let _5: u8;                          // in scope 0 at src/util.rs:187:30: 187:31
    let mut _6: bool;                    // in scope 0 at src/codec/japanese.rs:148:18: 148:29
    let mut _7: bool;                    // in scope 0 at src/codec/japanese.rs:148:18: 148:29
    let mut _8: bool;                    // in scope 0 at src/codec/japanese.rs:145:18: 145:29
    let mut _9: bool;                    // in scope 0 at src/codec/japanese.rs:145:18: 145:29
    let mut _11: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:145:33: 145:36
    let mut _12: u32;                    // in scope 0 at src/codec/japanese.rs:145:42: 145:50
    let mut _13: u8;                     // in scope 0 at src/codec/japanese.rs:145:42: 145:43
    let mut _14: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:146:25: 146:28
    let mut _15: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:147:25: 147:28
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:148:36: 148:39
    let mut _18: u8;                     // in scope 0 at src/codec/japanese.rs:148:41: 148:42
    let mut _19: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:149:19: 149:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:187:30: 187:31
        let _10: u8;                     // in scope 1 at src/codec/japanese.rs:145:14: 145:29
        let _16: u8;                     // in scope 1 at src/codec/japanese.rs:148:14: 148:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/japanese.rs:145:14: 145:29
        }
        scope 3 {
            debug b => _16;              // in scope 3 at src/codec/japanese.rs:148:14: 148:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:185:27: 185:41
        StorageLive(_3);                 // scope 0 at src/util.rs:185:27: 185:34
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:185:27: 185:34
        _2 = StatefulDecoderHelper::<eucjp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:185:27: 185:41
                                         // mir::Constant
                                         // + span: src/util.rs:185:35: 185:39
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:185:40: 185:41
        _4 = discriminant(_2);           // scope 0 at src/util.rs:185:27: 185:41
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:185:21: 185:41
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:187:30: 187:31
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:187:30: 187:31
        _8 = Le(const 0_u8, _5);         // scope 1 at src/codec/japanese.rs:145:18: 145:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/japanese.rs:145:18: 145:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:185:27: 185:41
    }

    bb4: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:186:33: 186:46
        goto -> bb20;                    // scope 0 at src/util.rs:186:33: 186:46
    }

    bb5: {
        _9 = Le(_5, const 127_u8);       // scope 1 at src/codec/japanese.rs:145:18: 145:29
        switchInt(move _9) -> [false: bb6, otherwise: bb10]; // scope 1 at src/codec/japanese.rs:145:18: 145:29
    }

    bb6: {
        switchInt(_5) -> [142_u8: bb12, 143_u8: bb14, otherwise: bb7]; // scope 1 at src/util.rs:187:36: 187:43
    }

    bb7: {
        _6 = Le(const 161_u8, _5);       // scope 1 at src/codec/japanese.rs:148:18: 148:29
        switchInt(move _6) -> [false: bb9, otherwise: bb8]; // scope 1 at src/codec/japanese.rs:148:18: 148:29
    }

    bb8: {
        _7 = Le(_5, const 254_u8);       // scope 1 at src/codec/japanese.rs:148:18: 148:29
        switchInt(move _7) -> [false: bb9, otherwise: bb16]; // scope 1 at src/codec/japanese.rs:148:18: 148:29
    }

    bb9: {
        StorageLive(_19);                // scope 1 at src/codec/japanese.rs:149:19: 149:22
        _19 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:149:19: 149:22
        _0 = StatefulDecoderHelper::<eucjp::State, T>::err(move _19, const "invalid sequence") -> bb18; // scope 1 at src/codec/japanese.rs:149:19: 149:46
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:149:23: 149:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:149:27: 149:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb10: {
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:145:14: 145:29
        _10 = _5;                        // scope 1 at src/codec/japanese.rs:145:14: 145:29
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:145:33: 145:36
        _11 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:145:33: 145:36
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:145:42: 145:50
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:145:42: 145:43
        _13 = _10;                       // scope 2 at src/codec/japanese.rs:145:42: 145:43
        _12 = move _13 as u32 (Misc);    // scope 2 at src/codec/japanese.rs:145:42: 145:50
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:145:49: 145:50
        _0 = StatefulDecoderHelper::<eucjp::State, T>::emit(move _11, move _12) -> bb11; // scope 2 at src/codec/japanese.rs:145:33: 145:51
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:145:37: 145:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, u32) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:145:50: 145:51
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:145:50: 145:51
        StorageDead(_10);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb19;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb12: {
        StorageLive(_14);                // scope 1 at src/codec/japanese.rs:146:25: 146:28
        _14 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:146:25: 146:28
        _0 = eucjp::transient::S1::<T>(move _14) -> bb13; // scope 1 at src/codec/japanese.rs:146:22: 146:29
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:146:22: 146:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_14);                // scope 1 at src/codec/japanese.rs:146:28: 146:29
        goto -> bb19;                    // scope 1 at src/codec/japanese.rs:146:28: 146:29
    }

    bb14: {
        StorageLive(_15);                // scope 1 at src/codec/japanese.rs:147:25: 147:28
        _15 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:147:25: 147:28
        _0 = eucjp::transient::S2::<T>(move _15) -> bb15; // scope 1 at src/codec/japanese.rs:147:22: 147:29
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:147:22: 147:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S2::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_15);                // scope 1 at src/codec/japanese.rs:147:28: 147:29
        goto -> bb19;                    // scope 1 at src/codec/japanese.rs:147:28: 147:29
    }

    bb16: {
        StorageLive(_16);                // scope 1 at src/codec/japanese.rs:148:14: 148:29
        _16 = _5;                        // scope 1 at src/codec/japanese.rs:148:14: 148:29
        StorageLive(_17);                // scope 3 at src/codec/japanese.rs:148:36: 148:39
        _17 = &mut (*_1);                // scope 3 at src/codec/japanese.rs:148:36: 148:39
        StorageLive(_18);                // scope 3 at src/codec/japanese.rs:148:41: 148:42
        _18 = _16;                       // scope 3 at src/codec/japanese.rs:148:41: 148:42
        _0 = eucjp::transient::S3::<T>(move _17, move _18) -> bb17; // scope 3 at src/codec/japanese.rs:148:33: 148:43
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:148:33: 148:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::eucjp::State, T>, u8) -> codec::japanese::eucjp::State {codec::japanese::eucjp::transient::S3::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_18);                // scope 3 at src/codec/japanese.rs:148:42: 148:43
        StorageDead(_17);                // scope 3 at src/codec/japanese.rs:148:42: 148:43
        StorageDead(_16);                // scope 1 at src/util.rs:187:79: 187:80
        goto -> bb19;                    // scope 1 at src/util.rs:187:79: 187:80
    }

    bb18: {
        StorageDead(_19);                // scope 1 at src/codec/japanese.rs:149:45: 149:46
        goto -> bb19;                    // scope 1 at src/codec/japanese.rs:149:45: 149:46
    }

    bb19: {
        StorageDead(_5);                 // scope 0 at src/util.rs:187:83: 187:84
        goto -> bb20;                    // scope 0 at src/util.rs:187:83: 187:84
    }

    bb20: {
        StorageDead(_2);                 // scope 0 at src/util.rs:189:17: 189:18
        return;                          // scope 0 at src/util.rs:189:18: 189:18
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:30:1: 35:2>::raw_encoder(_1: &BigFive2003Encoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:33:20: 33:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/tradchinese.rs:33:30: 33:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/tradchinese.rs:33:48: 33:73
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/tradchinese.rs:33:48: 33:73

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/tradchinese.rs:33:48: 33:73
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:33:48: 33:73
        _3 = BigFive2003Encoder::new() -> bb1; // scope 0 at src/codec/tradchinese.rs:33:48: 33:73
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:33:48: 33:71
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::tradchinese::BigFive2003Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:33:48: 33:73
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:33:72: 33:73
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:33:48: 33:73
        StorageDead(_2);                 // scope 0 at src/codec/tradchinese.rs:33:74: 33:75
        return;                          // scope 0 at src/codec/tradchinese.rs:33:75: 33:75
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:20:1: 25:2>::whatwg_name(_1: &SingleByteEncoding) -> Option<&str> {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:22:20: 22:25
    let mut _0: std::option::Option<&str>; // return place in scope 0 at src/codec/singlebyte.rs:22:30: 22:50

    bb0: {
        _0 = ((*_1).1: std::option::Option<&str>); // scope 0 at src/codec/singlebyte.rs:22:53: 22:69
        return;                          // scope 0 at src/codec/singlebyte.rs:22:71: 22:71
    }
}

fn japanese::<impl at src/codec/japanese.rs:47:1: 84:2>::raw_finish(_1: &mut EUCJPEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:81:19: 81:28
    debug _output => _2;                 // in scope 0 at src/codec/japanese.rs:81:30: 81:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/japanese.rs:81:59: 81:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/japanese.rs:82:9: 82:13
        return;                          // scope 0 at src/codec/japanese.rs:83:6: 83:6
    }
}

const ISO_8859_8: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:49:64: 49:76
    let _5: &str;                        // in scope 0 at src/all.rs:49:64: 49:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_8::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1257 ~ encoding[5d2c]::all::ISO_8859_8), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_8: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:49:64: 49:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:49:64: 49:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-8";         // scope 0 at src/all.rs:49:64: 49:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:49:64: 49:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:49:64: 49:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_8::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_8::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_8::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_8::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-8"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:49:64: 49:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 56], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

const X_USER_DEFINED: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:87:50: 87:72
    let mut _4: &str;                    // in scope 0 at src/all.rs:87:55: 87:71
    let _5: &str;                        // in scope 0 at src/all.rs:87:55: 87:71
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const X_USER_DEFINED::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(X_USER_DEFINED, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1288 ~ encoding[5d2c]::all::whatwg::X_USER_DEFINED), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in X_USER_DEFINED: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:87:50: 87:72
    let mut _3: &str;                    // in scope 0 at src/all.rs:87:55: 87:71
    let mut _4: &str;                    // in scope 0 at src/all.rs:87:55: 87:71
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "x-user-defined";     // scope 0 at src/all.rs:87:55: 87:71
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [120, 45, 117, 115, 101, 114, 45, 100, 101, 102, 105, 110, 101, 100], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })
                                         // mir::Constant
                                         // + span: src/all.rs:87:55: 87:71
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [120, 45, 117, 115, 101, 114, 45, 100, 101, 102, 105, 110, 101, 100], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:87:55: 87:71
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:87:50: 87:72
        discriminant(_2) = 1;            // scope 0 at src/all.rs:87:50: 87:72
        _5 = x_user_defined::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {codec::whatwg::x_user_defined::forward}, val: Value(Scalar(<ZST>)) }
        _6 = x_user_defined::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {codec::whatwg::x_user_defined::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "pua-mapped-binary"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [112, 117, 97, 45, 109, 97, 112, 112, 101, 100, 45, 98, 105, 110, 97, 114, 121], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [131071], len: Size { raw: 17 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 17 })
                                         // mir::Constant
                                         // + span: src/all.rs:87:22: 87:41
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [112, 117, 97, 45, 109, 97, 112, 112, 101, 100, 45, 98, 105, 110, 97, 114, 121], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [131071], len: Size { raw: 17 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 17 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn iso2022jp::transient::Katakana(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:216:80: 216:92

    bb0: {
        discriminant(_0) = 3;            // scope 0 at src/util.rs:217:25: 217:54
        return;                          // scope 0 at src/util.rs:218:22: 218:22
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:272:1: 280:2>::from_self(_1: &UTF16LEDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:273:18: 273:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_16.rs:273:28: 273:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:273:46: 273:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:273:46: 273:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:273:46: 273:67
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:273:46: 273:67
        _3 = UTF16LEDecoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:273:46: 273:67
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:273:46: 273:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::utf_16::UTF16LEDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:273:46: 273:67
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:273:66: 273:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:273:46: 273:67
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:273:68: 273:69
        return;                          // scope 0 at src/codec/utf_16.rs:273:69: 273:69
    }
}

fn iso2022jp::<impl at src/util.rs:157:33: 157:38>::clone(_1: &iso2022jp::State) -> iso2022jp::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                    scope 5 {
                        scope 6 {
                            scope 7 {
                                scope 8 {
                                    scope 9 {
                                        scope 10 {
                                            scope 11 {
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 11 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:34:1: 59:2>::raw_finish(_1: &mut ASCIIEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:56:19: 56:28
    debug _output => _2;                 // in scope 0 at src/codec/ascii.rs:56:30: 56:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/ascii.rs:56:59: 56:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/ascii.rs:57:9: 57:13
        return;                          // scope 0 at src/codec/ascii.rs:58:6: 58:6
    }
}

fn bigfive2003::internal::map_two_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/tradchinese.rs:110:35: 110:39
    debug trail => _2;                   // in scope 0 at src/codec/tradchinese.rs:110:45: 110:50
    let mut _0: u32;                     // return place in scope 0 at src/codec/tradchinese.rs:110:59: 110:62
    let _3: u16;                         // in scope 0 at src/codec/tradchinese.rs:113:13: 113:17
    let mut _4: u8;                      // in scope 0 at src/codec/tradchinese.rs:113:20: 113:24
    let mut _6: u8;                      // in scope 0 at src/codec/tradchinese.rs:114:21: 114:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/tradchinese.rs:115:27: 115:40
    let mut _9: u16;                     // in scope 0 at src/codec/tradchinese.rs:115:28: 115:32
    let mut _10: u16;                    // in scope 0 at src/codec/tradchinese.rs:115:34: 115:39
    let mut _11: bool;                   // in scope 0 at src/codec/tradchinese.rs:116:56: 116:67
    let mut _12: bool;                   // in scope 0 at src/codec/tradchinese.rs:116:56: 116:67
    let mut _13: bool;                   // in scope 0 at src/codec/tradchinese.rs:116:27: 116:38
    let mut _14: bool;                   // in scope 0 at src/codec/tradchinese.rs:116:27: 116:38
    let mut _15: bool;                   // in scope 0 at src/codec/tradchinese.rs:116:14: 116:25
    let mut _16: bool;                   // in scope 0 at src/codec/tradchinese.rs:116:14: 116:25
    let mut _18: bool;                   // in scope 0 at src/codec/tradchinese.rs:117:38: 117:50
    let mut _19: u16;                    // in scope 0 at src/codec/tradchinese.rs:117:38: 117:43
    let mut _20: u16;                    // in scope 0 at src/codec/tradchinese.rs:118:17: 118:44
    let mut _21: u16;                    // in scope 0 at src/codec/tradchinese.rs:118:17: 118:36
    let mut _22: u16;                    // in scope 0 at src/codec/tradchinese.rs:118:17: 118:30
    let mut _23: u16;                    // in scope 0 at src/codec/tradchinese.rs:118:18: 118:22
    let mut _24: u16;                    // in scope 0 at src/codec/tradchinese.rs:118:39: 118:44
    let mut _25: u16;                    // in scope 0 at src/codec/tradchinese.rs:118:47: 118:58
    let mut _26: u16;                    // in scope 0 at src/codec/tradchinese.rs:122:30: 122:35
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/tradchinese.rs:113:13: 113:17
        let _5: u16;                     // in scope 1 at src/codec/tradchinese.rs:114:13: 114:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/tradchinese.rs:114:13: 114:18
            let _7: u16;                 // in scope 2 at src/codec/tradchinese.rs:115:13: 115:18
            let _17: u16;                // in scope 2 at src/codec/tradchinese.rs:117:21: 117:32
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/tradchinese.rs:115:13: 115:18
            }
            scope 4 {
                debug trailoffset => _17; // in scope 4 at src/codec/tradchinese.rs:117:21: 117:32
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/tradchinese.rs:113:13: 113:17
        StorageLive(_4);                 // scope 0 at src/codec/tradchinese.rs:113:20: 113:24
        _4 = _1;                         // scope 0 at src/codec/tradchinese.rs:113:20: 113:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/tradchinese.rs:113:20: 113:31
        StorageDead(_4);                 // scope 0 at src/codec/tradchinese.rs:113:30: 113:31
        StorageLive(_5);                 // scope 1 at src/codec/tradchinese.rs:114:13: 114:18
        StorageLive(_6);                 // scope 1 at src/codec/tradchinese.rs:114:21: 114:26
        _6 = _2;                         // scope 1 at src/codec/tradchinese.rs:114:21: 114:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/tradchinese.rs:114:21: 114:33
        StorageDead(_6);                 // scope 1 at src/codec/tradchinese.rs:114:32: 114:33
        StorageLive(_7);                 // scope 2 at src/codec/tradchinese.rs:115:13: 115:18
        StorageLive(_8);                 // scope 2 at src/codec/tradchinese.rs:115:27: 115:40
        StorageLive(_9);                 // scope 2 at src/codec/tradchinese.rs:115:28: 115:32
        _9 = _3;                         // scope 2 at src/codec/tradchinese.rs:115:28: 115:32
        StorageLive(_10);                // scope 2 at src/codec/tradchinese.rs:115:34: 115:39
        _10 = _5;                        // scope 2 at src/codec/tradchinese.rs:115:34: 115:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/tradchinese.rs:115:27: 115:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/tradchinese.rs:115:27: 115:40
        StorageDead(_10);                // scope 2 at src/codec/tradchinese.rs:115:39: 115:40
        StorageDead(_9);                 // scope 2 at src/codec/tradchinese.rs:115:39: 115:40
        _15 = Le(const 129_u16, (_8.0: u16)); // scope 2 at src/codec/tradchinese.rs:116:14: 116:25
        switchInt(move _15) -> [false: bb6, otherwise: bb1]; // scope 2 at src/codec/tradchinese.rs:116:14: 116:25
    }

    bb1: {
        _16 = Le((_8.0: u16), const 254_u16); // scope 2 at src/codec/tradchinese.rs:116:14: 116:25
        switchInt(move _16) -> [false: bb6, otherwise: bb2]; // scope 2 at src/codec/tradchinese.rs:116:14: 116:25
    }

    bb2: {
        _13 = Le(const 64_u16, (_8.1: u16)); // scope 2 at src/codec/tradchinese.rs:116:27: 116:38
        switchInt(move _13) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/tradchinese.rs:116:27: 116:38
    }

    bb3: {
        _14 = Le((_8.1: u16), const 126_u16); // scope 2 at src/codec/tradchinese.rs:116:27: 116:38
        switchInt(move _14) -> [false: bb4, otherwise: bb7]; // scope 2 at src/codec/tradchinese.rs:116:27: 116:38
    }

    bb4: {
        _11 = Le(const 161_u16, (_8.1: u16)); // scope 2 at src/codec/tradchinese.rs:116:56: 116:67
        switchInt(move _11) -> [false: bb6, otherwise: bb5]; // scope 2 at src/codec/tradchinese.rs:116:56: 116:67
    }

    bb5: {
        _12 = Le((_8.1: u16), const 254_u16); // scope 2 at src/codec/tradchinese.rs:116:56: 116:67
        switchInt(move _12) -> [false: bb6, otherwise: bb7]; // scope 2 at src/codec/tradchinese.rs:116:56: 116:67
    }

    bb6: {
        _7 = const u16::MAX;             // scope 2 at src/codec/tradchinese.rs:120:18: 120:24
        goto -> bb11;                    // scope 2 at src/codec/tradchinese.rs:120:18: 120:24
    }

    bb7: {
        StorageLive(_17);                // scope 2 at src/codec/tradchinese.rs:117:21: 117:32
        StorageLive(_18);                // scope 2 at src/codec/tradchinese.rs:117:38: 117:50
        StorageLive(_19);                // scope 2 at src/codec/tradchinese.rs:117:38: 117:43
        _19 = _5;                        // scope 2 at src/codec/tradchinese.rs:117:38: 117:43
        _18 = Lt(move _19, const 127_u16); // scope 2 at src/codec/tradchinese.rs:117:38: 117:50
        StorageDead(_19);                // scope 2 at src/codec/tradchinese.rs:117:49: 117:50
        switchInt(move _18) -> [false: bb9, otherwise: bb8]; // scope 2 at src/codec/tradchinese.rs:117:38: 117:50
    }

    bb8: {
        _17 = const 64_u16;              // scope 2 at src/codec/tradchinese.rs:117:52: 117:56
        goto -> bb10;                    // scope 2 at src/codec/tradchinese.rs:117:35: 117:69
    }

    bb9: {
        _17 = const 98_u16;              // scope 2 at src/codec/tradchinese.rs:117:64: 117:68
        goto -> bb10;                    // scope 2 at src/codec/tradchinese.rs:117:35: 117:69
    }

    bb10: {
        StorageDead(_18);                // scope 2 at src/codec/tradchinese.rs:117:68: 117:69
        StorageLive(_20);                // scope 4 at src/codec/tradchinese.rs:118:17: 118:44
        StorageLive(_21);                // scope 4 at src/codec/tradchinese.rs:118:17: 118:36
        StorageLive(_22);                // scope 4 at src/codec/tradchinese.rs:118:17: 118:30
        StorageLive(_23);                // scope 4 at src/codec/tradchinese.rs:118:18: 118:22
        _23 = _3;                        // scope 4 at src/codec/tradchinese.rs:118:18: 118:22
        _22 = Sub(move _23, const 129_u16); // scope 4 at src/codec/tradchinese.rs:118:17: 118:30
        StorageDead(_23);                // scope 4 at src/codec/tradchinese.rs:118:29: 118:30
        _21 = Mul(move _22, const 157_u16); // scope 4 at src/codec/tradchinese.rs:118:17: 118:36
        StorageDead(_22);                // scope 4 at src/codec/tradchinese.rs:118:35: 118:36
        StorageLive(_24);                // scope 4 at src/codec/tradchinese.rs:118:39: 118:44
        _24 = _5;                        // scope 4 at src/codec/tradchinese.rs:118:39: 118:44
        _20 = Add(move _21, move _24);   // scope 4 at src/codec/tradchinese.rs:118:17: 118:44
        StorageDead(_24);                // scope 4 at src/codec/tradchinese.rs:118:43: 118:44
        StorageDead(_21);                // scope 4 at src/codec/tradchinese.rs:118:43: 118:44
        StorageLive(_25);                // scope 4 at src/codec/tradchinese.rs:118:47: 118:58
        _25 = _17;                       // scope 4 at src/codec/tradchinese.rs:118:47: 118:58
        _7 = Sub(move _20, move _25);    // scope 4 at src/codec/tradchinese.rs:118:17: 118:58
        StorageDead(_25);                // scope 4 at src/codec/tradchinese.rs:118:57: 118:58
        StorageDead(_20);                // scope 4 at src/codec/tradchinese.rs:118:57: 118:58
        StorageDead(_17);                // scope 2 at src/codec/tradchinese.rs:119:13: 119:14
        goto -> bb11;                    // scope 2 at src/codec/tradchinese.rs:119:13: 119:14
    }

    bb11: {
        StorageDead(_8);                 // scope 2 at src/codec/tradchinese.rs:121:10: 121:11
        StorageLive(_26);                // scope 3 at src/codec/tradchinese.rs:122:30: 122:35
        _26 = _7;                        // scope 3 at src/codec/tradchinese.rs:122:30: 122:35
        _0 = index_tradchinese::big5::forward(move _26) -> bb12; // scope 3 at src/codec/tradchinese.rs:122:9: 122:36
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:122:9: 122:29
                                         // + literal: Const { ty: fn(u16) -> u32 {index_tradchinese::big5::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_26);                // scope 3 at src/codec/tradchinese.rs:122:35: 122:36
        StorageDead(_7);                 // scope 2 at src/codec/tradchinese.rs:123:5: 123:6
        StorageDead(_5);                 // scope 1 at src/codec/tradchinese.rs:123:5: 123:6
        StorageDead(_3);                 // scope 0 at src/codec/tradchinese.rs:123:5: 123:6
        return;                          // scope 0 at src/codec/tradchinese.rs:123:6: 123:6
    }
}

fn simpchinese::gb18030::transient::S0(_1: &mut StatefulDecoderHelper<simpchinese::gb18030::State, T>) -> simpchinese::gb18030::State {
    let mut _0: codec::simpchinese::gb18030::State; // return place in scope 0 at src/util.rs:209:57: 209:69

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:210:21: 210:34
        return;                          // scope 0 at src/util.rs:211:18: 211:18
    }
}

const KOI8_U: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:56:56: 56:64
    let _5: &str;                        // in scope 0 at src/all.rs:56:56: 56:64
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const KOI8_U::promoted[0];  // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_U, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1264 ~ encoding[5d2c]::all::KOI8_U), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in KOI8_U: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:56:56: 56:64
    let mut _4: &str;                    // in scope 0 at src/all.rs:56:56: 56:64
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "koi8-u";             // scope 0 at src/all.rs:56:56: 56:64
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/all.rs:56:56: 56:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:56:56: 56:64
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::koi8_u::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::koi8_u::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::koi8_u::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::koi8_u::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "koi8-u";   // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/all.rs:56:56: 56:64
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [107, 111, 105, 56, 45, 117], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:774:1: 779:2>::raw_decoder(_1: &ISO2022JPEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:778:20: 778:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:778:30: 778:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:778:48: 778:71
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:778:48: 778:71

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:778:48: 778:71
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:778:48: 778:71
        _3 = ISO2022JPDecoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:778:48: 778:71
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:778:48: 778:69
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::japanese::ISO2022JPDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:778:48: 778:71
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:778:70: 778:71
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:778:48: 778:71
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:778:72: 778:73
        return;                          // scope 0 at src/codec/japanese.rs:778:73: 778:73
    }
}

fn hz::<impl at src/util.rs:168:13: 170:14>::default() -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:169:51: 169:56

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/util.rs:169:59: 169:65
        return;                          // scope 0 at src/util.rs:169:67: 169:67
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:51:1: 75:2>::raw_feed(_1: &mut UTF16Encoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter, _4: F) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:52:20: 52:29
    debug input => _2;                   // in scope 0 at src/codec/utf_16.rs:52:31: 52:36
    debug output => _3;                  // in scope 0 at src/codec/utf_16.rs:52:44: 52:50
    debug write_two_bytes => _4;         // in scope 0 at src/codec/utf_16.rs:53:20: 53:35
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/utf_16.rs:53:43: 53:70
    let _5: ();                          // in scope 0 at src/codec/utf_16.rs:55:9: 55:44
    let mut _6: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:55:9: 55:15
    let mut _7: usize;                   // in scope 0 at src/codec/utf_16.rs:55:28: 55:43
    let mut _8: usize;                   // in scope 0 at src/codec/utf_16.rs:55:28: 55:39
    let mut _9: &str;                    // in scope 0 at src/codec/utf_16.rs:55:28: 55:33
    let mut _10: std::str::Chars;        // in scope 0 at src/codec/utf_16.rs:57:19: 57:32
    let mut _11: std::str::Chars;        // in scope 0 at src/codec/utf_16.rs:57:19: 57:32
    let mut _12: &str;                   // in scope 0 at src/codec/utf_16.rs:57:19: 57:24
    let mut _13: std::str::Chars;        // in scope 0 at src/codec/utf_16.rs:57:19: 57:32
    let mut _15: std::option::Option<char>; // in scope 0 at src/codec/utf_16.rs:57:19: 57:32
    let mut _16: &mut std::str::Chars;   // in scope 0 at src/codec/utf_16.rs:57:19: 57:32
    let mut _17: &mut std::str::Chars;   // in scope 0 at src/codec/utf_16.rs:57:19: 57:32
    let mut _18: isize;                  // in scope 0 at src/codec/utf_16.rs:57:13: 57:15
    let mut _20: char;                   // in scope 0 at src/codec/utf_16.rs:57:13: 57:15
    let mut _22: bool;                   // in scope 0 at src/codec/utf_16.rs:63:17: 63:43
    let mut _23: bool;                   // in scope 0 at src/codec/utf_16.rs:63:17: 63:43
    let mut _24: bool;                   // in scope 0 at src/codec/utf_16.rs:59:40: 59:63
    let mut _25: bool;                   // in scope 0 at src/codec/utf_16.rs:59:40: 59:63
    let mut _26: bool;                   // in scope 0 at src/codec/utf_16.rs:59:17: 59:37
    let mut _27: bool;                   // in scope 0 at src/codec/utf_16.rs:59:17: 59:37
    let mut _29: char;                   // in scope 0 at src/codec/utf_16.rs:60:30: 60:32
    let _30: ();                         // in scope 0 at src/codec/utf_16.rs:61:21: 61:80
    let mut _31: &F;                     // in scope 0 at src/codec/utf_16.rs:61:21: 61:36
    let mut _32: (&mut dyn encoding_types::ByteWriter, u8, u8); // in scope 0 at src/codec/utf_16.rs:61:21: 61:80
    let mut _33: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:61:37: 61:43
    let mut _34: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:61:37: 61:43
    let mut _35: u8;                     // in scope 0 at src/codec/utf_16.rs:61:45: 61:60
    let mut _36: u32;                    // in scope 0 at src/codec/utf_16.rs:61:45: 61:54
    let mut _37: u32;                    // in scope 0 at src/codec/utf_16.rs:61:46: 61:48
    let mut _38: u8;                     // in scope 0 at src/codec/utf_16.rs:61:62: 61:79
    let mut _39: u32;                    // in scope 0 at src/codec/utf_16.rs:61:62: 61:73
    let mut _40: u32;                    // in scope 0 at src/codec/utf_16.rs:61:63: 61:65
    let mut _42: u32;                    // in scope 0 at src/codec/utf_16.rs:64:30: 64:39
    let mut _43: char;                   // in scope 0 at src/codec/utf_16.rs:64:30: 64:32
    let _44: ();                         // in scope 0 at src/codec/utf_16.rs:65:21: 66:71
    let mut _45: &F;                     // in scope 0 at src/codec/utf_16.rs:65:21: 65:36
    let mut _46: (&mut dyn encoding_types::ByteWriter, u8, u8); // in scope 0 at src/codec/utf_16.rs:65:21: 66:71
    let mut _47: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:65:37: 65:43
    let mut _48: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:65:37: 65:43
    let mut _49: u8;                     // in scope 0 at src/codec/utf_16.rs:65:45: 65:70
    let mut _50: u32;                    // in scope 0 at src/codec/utf_16.rs:65:45: 65:64
    let mut _51: u32;                    // in scope 0 at src/codec/utf_16.rs:65:53: 65:63
    let mut _52: u32;                    // in scope 0 at src/codec/utf_16.rs:65:54: 65:56
    let mut _53: u8;                     // in scope 0 at src/codec/utf_16.rs:66:45: 66:70
    let mut _54: u32;                    // in scope 0 at src/codec/utf_16.rs:66:45: 66:64
    let mut _55: u32;                    // in scope 0 at src/codec/utf_16.rs:66:46: 66:56
    let mut _56: u32;                    // in scope 0 at src/codec/utf_16.rs:66:47: 66:49
    let _57: ();                         // in scope 0 at src/codec/utf_16.rs:67:21: 68:63
    let mut _58: &F;                     // in scope 0 at src/codec/utf_16.rs:67:21: 67:36
    let mut _59: (&mut dyn encoding_types::ByteWriter, u8, u8); // in scope 0 at src/codec/utf_16.rs:67:21: 68:63
    let mut _60: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:67:37: 67:43
    let mut _61: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:67:37: 67:43
    let mut _62: u8;                     // in scope 0 at src/codec/utf_16.rs:67:45: 67:77
    let mut _63: u32;                    // in scope 0 at src/codec/utf_16.rs:67:45: 67:71
    let mut _64: u32;                    // in scope 0 at src/codec/utf_16.rs:67:53: 67:70
    let mut _65: u32;                    // in scope 0 at src/codec/utf_16.rs:67:54: 67:63
    let mut _66: u32;                    // in scope 0 at src/codec/utf_16.rs:67:55: 67:57
    let mut _67: u8;                     // in scope 0 at src/codec/utf_16.rs:68:45: 68:62
    let mut _68: u32;                    // in scope 0 at src/codec/utf_16.rs:68:45: 68:56
    let mut _69: u32;                    // in scope 0 at src/codec/utf_16.rs:68:46: 68:48
    let mut _70: usize;                  // in scope 0 at src/codec/utf_16.rs:73:10: 73:21
    let mut _71: &str;                   // in scope 0 at src/codec/utf_16.rs:73:10: 73:15
    let mut _72: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/utf_16.rs:73:23: 73:27
    scope 1 {
        debug iter => _13;               // in scope 1 at src/codec/utf_16.rs:57:19: 57:32
        let mut _14: char;               // in scope 1 at src/codec/utf_16.rs:57:19: 57:32
        scope 2 {
            debug __next => _14;         // in scope 2 at src/codec/utf_16.rs:57:19: 57:32
            let _19: char;               // in scope 2 at src/codec/utf_16.rs:57:13: 57:15
            let _21: char;               // in scope 2 at src/codec/utf_16.rs:57:13: 57:15
            scope 3 {
                debug val => _19;        // in scope 3 at src/codec/utf_16.rs:57:13: 57:15
            }
            scope 4 {
                debug ch => _21;         // in scope 4 at src/codec/utf_16.rs:57:13: 57:15
                let _28: u32;            // in scope 4 at src/codec/utf_16.rs:60:25: 60:27
                let _41: u32;            // in scope 4 at src/codec/utf_16.rs:64:25: 64:27
                scope 5 {
                    debug ch => _28;     // in scope 5 at src/codec/utf_16.rs:60:25: 60:27
                }
                scope 6 {
                    debug ch => _41;     // in scope 6 at src/codec/utf_16.rs:64:25: 64:27
                }
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:55:9: 55:44
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:55:9: 55:15
        _6 = &mut (*_3);                 // scope 0 at src/codec/utf_16.rs:55:9: 55:15
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:55:28: 55:43
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:55:28: 55:39
        StorageLive(_9);                 // scope 0 at src/codec/utf_16.rs:55:28: 55:33
        _9 = _2;                         // scope 0 at src/codec/utf_16.rs:55:28: 55:33
        _8 = core::str::<impl str>::len(move _9) -> [return: bb1, unwind: bb24]; // scope 0 at src/codec/utf_16.rs:55:28: 55:39
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:55:34: 55:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_9);                 // scope 0 at src/codec/utf_16.rs:55:38: 55:39
        _7 = Mul(move _8, const 2_usize); // scope 0 at src/codec/utf_16.rs:55:28: 55:43
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:55:42: 55:43
        _5 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _6, move _7) -> [return: bb2, unwind: bb24]; // scope 0 at src/codec/utf_16.rs:55:9: 55:44
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:55:16: 55:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:55:43: 55:44
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:55:43: 55:44
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:55:44: 55:45
        StorageLive(_10);                // scope 0 at src/codec/utf_16.rs:57:19: 57:32
        StorageLive(_11);                // scope 0 at src/codec/utf_16.rs:57:19: 57:32
        StorageLive(_12);                // scope 0 at src/codec/utf_16.rs:57:19: 57:24
        _12 = _2;                        // scope 0 at src/codec/utf_16.rs:57:19: 57:24
        _11 = core::str::<impl str>::chars(move _12) -> [return: bb3, unwind: bb24]; // scope 0 at src/codec/utf_16.rs:57:19: 57:32
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:57:25: 57:30
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> std::str::Chars<'r> {core::str::<impl str>::chars}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_12);                // scope 0 at src/codec/utf_16.rs:57:31: 57:32
        _10 = <Chars as IntoIterator>::into_iter(move _11) -> [return: bb4, unwind: bb24]; // scope 0 at src/codec/utf_16.rs:57:19: 57:32
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:57:19: 57:32
                                         // + literal: Const { ty: fn(std::str::Chars) -> <std::str::Chars as std::iter::IntoIterator>::IntoIter {<std::str::Chars as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_11);                // scope 0 at src/codec/utf_16.rs:57:31: 57:32
        StorageLive(_13);                // scope 0 at src/codec/utf_16.rs:57:19: 57:32
        _13 = move _10;                  // scope 0 at src/codec/utf_16.rs:57:19: 57:32
        goto -> bb5;                     // scope 1 at src/codec/utf_16.rs:57:9: 72:10
    }

    bb5: {
        StorageLive(_14);                // scope 1 at src/codec/utf_16.rs:57:19: 57:32
        StorageLive(_15);                // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        StorageLive(_16);                // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        StorageLive(_17);                // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        _17 = &mut _13;                  // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        _16 = &mut (*_17);               // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        _15 = <Chars as Iterator>::next(move _16) -> [return: bb6, unwind: bb24]; // scope 2 at src/codec/utf_16.rs:57:19: 57:32
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:57:19: 57:32
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::str::Chars) -> std::option::Option<<std::str::Chars as std::iter::Iterator>::Item> {<std::str::Chars as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_16);                // scope 2 at src/codec/utf_16.rs:57:31: 57:32
        _18 = discriminant(_15);         // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        switchInt(move _18) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/utf_16.rs:57:19: 57:32
    }

    bb7: {
        StorageDead(_17);                // scope 2 at src/codec/utf_16.rs:57:31: 57:32
        StorageDead(_15);                // scope 2 at src/codec/utf_16.rs:57:31: 57:32
        StorageDead(_14);                // scope 1 at src/codec/utf_16.rs:72:9: 72:10
        StorageDead(_13);                // scope 0 at src/codec/utf_16.rs:72:9: 72:10
        StorageDead(_10);                // scope 0 at src/codec/utf_16.rs:57:31: 57:32
        StorageLive(_70);                // scope 0 at src/codec/utf_16.rs:73:10: 73:21
        StorageLive(_71);                // scope 0 at src/codec/utf_16.rs:73:10: 73:15
        _71 = _2;                        // scope 0 at src/codec/utf_16.rs:73:10: 73:15
        _70 = core::str::<impl str>::len(move _71) -> [return: bb22, unwind: bb24]; // scope 0 at src/codec/utf_16.rs:73:10: 73:21
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:73:16: 73:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/utf_16.rs:57:19: 57:32
    }

    bb9: {
        StorageLive(_19);                // scope 2 at src/codec/utf_16.rs:57:13: 57:15
        _19 = ((_15 as Some).0: char);   // scope 2 at src/codec/utf_16.rs:57:13: 57:15
        StorageLive(_20);                // scope 3 at src/codec/utf_16.rs:57:13: 57:15
        _20 = _19;                       // scope 3 at src/codec/utf_16.rs:57:13: 57:15
        _14 = move _20;                  // scope 3 at src/codec/utf_16.rs:57:13: 57:15
        StorageDead(_20);                // scope 3 at src/codec/utf_16.rs:57:14: 57:15
        StorageDead(_19);                // scope 2 at src/codec/utf_16.rs:57:14: 57:15
        StorageDead(_17);                // scope 2 at src/codec/utf_16.rs:57:31: 57:32
        StorageDead(_15);                // scope 2 at src/codec/utf_16.rs:57:31: 57:32
        StorageLive(_21);                // scope 2 at src/codec/utf_16.rs:57:13: 57:15
        _21 = _14;                       // scope 2 at src/codec/utf_16.rs:57:19: 57:32
        _26 = Le(const '\u{0}', _21);    // scope 4 at src/codec/utf_16.rs:59:17: 59:37
        switchInt(move _26) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/utf_16.rs:59:17: 59:37
    }

    bb10: {
        _27 = Le(_21, const '\u{d7ff}'); // scope 4 at src/codec/utf_16.rs:59:17: 59:37
        switchInt(move _27) -> [false: bb11, otherwise: bb16]; // scope 4 at src/codec/utf_16.rs:59:17: 59:37
    }

    bb11: {
        _24 = Le(const '\u{e000}', _21); // scope 4 at src/codec/utf_16.rs:59:40: 59:63
        switchInt(move _24) -> [false: bb13, otherwise: bb12]; // scope 4 at src/codec/utf_16.rs:59:40: 59:63
    }

    bb12: {
        _25 = Le(_21, const '\u{ffff}'); // scope 4 at src/codec/utf_16.rs:59:40: 59:63
        switchInt(move _25) -> [false: bb13, otherwise: bb16]; // scope 4 at src/codec/utf_16.rs:59:40: 59:63
    }

    bb13: {
        _22 = Le(const '', _21);        // scope 4 at src/codec/utf_16.rs:63:17: 63:43
        switchInt(move _22) -> [false: bb15, otherwise: bb14]; // scope 4 at src/codec/utf_16.rs:63:17: 63:43
    }

    bb14: {
        _23 = Le(_21, const '\u{10ffff}'); // scope 4 at src/codec/utf_16.rs:63:17: 63:43
        switchInt(move _23) -> [false: bb15, otherwise: bb18]; // scope 4 at src/codec/utf_16.rs:63:17: 63:43
    }

    bb15: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb24; // scope 4 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb16: {
        StorageLive(_28);                // scope 4 at src/codec/utf_16.rs:60:25: 60:27
        StorageLive(_29);                // scope 4 at src/codec/utf_16.rs:60:30: 60:32
        _29 = _21;                       // scope 4 at src/codec/utf_16.rs:60:30: 60:32
        _28 = move _29 as u32 (Misc);    // scope 4 at src/codec/utf_16.rs:60:30: 60:39
        StorageDead(_29);                // scope 4 at src/codec/utf_16.rs:60:38: 60:39
        StorageLive(_30);                // scope 5 at src/codec/utf_16.rs:61:21: 61:80
        StorageLive(_31);                // scope 5 at src/codec/utf_16.rs:61:21: 61:36
        _31 = &_4;                       // scope 5 at src/codec/utf_16.rs:61:21: 61:36
        StorageLive(_32);                // scope 5 at src/codec/utf_16.rs:61:21: 61:80
        StorageLive(_33);                // scope 5 at src/codec/utf_16.rs:61:37: 61:43
        StorageLive(_34);                // scope 5 at src/codec/utf_16.rs:61:37: 61:43
        _34 = &mut (*_3);                // scope 5 at src/codec/utf_16.rs:61:37: 61:43
        _33 = move _34 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 5 at src/codec/utf_16.rs:61:37: 61:43
        StorageDead(_34);                // scope 5 at src/codec/utf_16.rs:61:42: 61:43
        StorageLive(_35);                // scope 5 at src/codec/utf_16.rs:61:45: 61:60
        StorageLive(_36);                // scope 5 at src/codec/utf_16.rs:61:45: 61:54
        StorageLive(_37);                // scope 5 at src/codec/utf_16.rs:61:46: 61:48
        _37 = _28;                       // scope 5 at src/codec/utf_16.rs:61:46: 61:48
        _36 = Shr(move _37, const 8_i32); // scope 5 at src/codec/utf_16.rs:61:45: 61:54
        StorageDead(_37);                // scope 5 at src/codec/utf_16.rs:61:53: 61:54
        _35 = move _36 as u8 (Misc);     // scope 5 at src/codec/utf_16.rs:61:45: 61:60
        StorageDead(_36);                // scope 5 at src/codec/utf_16.rs:61:59: 61:60
        StorageLive(_38);                // scope 5 at src/codec/utf_16.rs:61:62: 61:79
        StorageLive(_39);                // scope 5 at src/codec/utf_16.rs:61:62: 61:73
        StorageLive(_40);                // scope 5 at src/codec/utf_16.rs:61:63: 61:65
        _40 = _28;                       // scope 5 at src/codec/utf_16.rs:61:63: 61:65
        _39 = BitAnd(move _40, const 255_u32); // scope 5 at src/codec/utf_16.rs:61:62: 61:73
        StorageDead(_40);                // scope 5 at src/codec/utf_16.rs:61:72: 61:73
        _38 = move _39 as u8 (Misc);     // scope 5 at src/codec/utf_16.rs:61:62: 61:79
        StorageDead(_39);                // scope 5 at src/codec/utf_16.rs:61:78: 61:79
        (_32.0: &mut dyn encoding_types::ByteWriter) = move _33; // scope 5 at src/codec/utf_16.rs:61:21: 61:80
        (_32.1: u8) = move _35;          // scope 5 at src/codec/utf_16.rs:61:21: 61:80
        (_32.2: u8) = move _38;          // scope 5 at src/codec/utf_16.rs:61:21: 61:80
        _30 = <F as Fn<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::call(move _31, move _32) -> [return: bb17, unwind: bb24]; // scope 5 at src/codec/utf_16.rs:61:21: 61:80
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:61:21: 61:36
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (&mut dyn encoding_types::ByteWriter, u8, u8)) -> <F as std::ops::FnOnce<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::Output {<F as std::ops::Fn<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_38);                // scope 5 at src/codec/utf_16.rs:61:79: 61:80
        StorageDead(_35);                // scope 5 at src/codec/utf_16.rs:61:79: 61:80
        StorageDead(_33);                // scope 5 at src/codec/utf_16.rs:61:79: 61:80
        StorageDead(_32);                // scope 5 at src/codec/utf_16.rs:61:79: 61:80
        StorageDead(_31);                // scope 5 at src/codec/utf_16.rs:61:79: 61:80
        StorageDead(_30);                // scope 5 at src/codec/utf_16.rs:61:80: 61:81
        StorageDead(_28);                // scope 4 at src/codec/utf_16.rs:62:17: 62:18
        goto -> bb21;                    // scope 4 at src/codec/utf_16.rs:62:17: 62:18
    }

    bb18: {
        StorageLive(_41);                // scope 4 at src/codec/utf_16.rs:64:25: 64:27
        StorageLive(_42);                // scope 4 at src/codec/utf_16.rs:64:30: 64:39
        StorageLive(_43);                // scope 4 at src/codec/utf_16.rs:64:30: 64:32
        _43 = _21;                       // scope 4 at src/codec/utf_16.rs:64:30: 64:32
        _42 = move _43 as u32 (Misc);    // scope 4 at src/codec/utf_16.rs:64:30: 64:39
        StorageDead(_43);                // scope 4 at src/codec/utf_16.rs:64:38: 64:39
        _41 = Sub(move _42, const 65536_u32); // scope 4 at src/codec/utf_16.rs:64:30: 64:49
        StorageDead(_42);                // scope 4 at src/codec/utf_16.rs:64:48: 64:49
        StorageLive(_44);                // scope 6 at src/codec/utf_16.rs:65:21: 66:71
        StorageLive(_45);                // scope 6 at src/codec/utf_16.rs:65:21: 65:36
        _45 = &_4;                       // scope 6 at src/codec/utf_16.rs:65:21: 65:36
        StorageLive(_46);                // scope 6 at src/codec/utf_16.rs:65:21: 66:71
        StorageLive(_47);                // scope 6 at src/codec/utf_16.rs:65:37: 65:43
        StorageLive(_48);                // scope 6 at src/codec/utf_16.rs:65:37: 65:43
        _48 = &mut (*_3);                // scope 6 at src/codec/utf_16.rs:65:37: 65:43
        _47 = move _48 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 6 at src/codec/utf_16.rs:65:37: 65:43
        StorageDead(_48);                // scope 6 at src/codec/utf_16.rs:65:42: 65:43
        StorageLive(_49);                // scope 6 at src/codec/utf_16.rs:65:45: 65:70
        StorageLive(_50);                // scope 6 at src/codec/utf_16.rs:65:45: 65:64
        StorageLive(_51);                // scope 6 at src/codec/utf_16.rs:65:53: 65:63
        StorageLive(_52);                // scope 6 at src/codec/utf_16.rs:65:54: 65:56
        _52 = _41;                       // scope 6 at src/codec/utf_16.rs:65:54: 65:56
        _51 = Shr(move _52, const 18_i32); // scope 6 at src/codec/utf_16.rs:65:53: 65:63
        StorageDead(_52);                // scope 6 at src/codec/utf_16.rs:65:62: 65:63
        _50 = BitOr(const 216_u32, move _51); // scope 6 at src/codec/utf_16.rs:65:45: 65:64
        StorageDead(_51);                // scope 6 at src/codec/utf_16.rs:65:63: 65:64
        _49 = move _50 as u8 (Misc);     // scope 6 at src/codec/utf_16.rs:65:45: 65:70
        StorageDead(_50);                // scope 6 at src/codec/utf_16.rs:65:69: 65:70
        StorageLive(_53);                // scope 6 at src/codec/utf_16.rs:66:45: 66:70
        StorageLive(_54);                // scope 6 at src/codec/utf_16.rs:66:45: 66:64
        StorageLive(_55);                // scope 6 at src/codec/utf_16.rs:66:46: 66:56
        StorageLive(_56);                // scope 6 at src/codec/utf_16.rs:66:47: 66:49
        _56 = _41;                       // scope 6 at src/codec/utf_16.rs:66:47: 66:49
        _55 = Shr(move _56, const 10_i32); // scope 6 at src/codec/utf_16.rs:66:46: 66:56
        StorageDead(_56);                // scope 6 at src/codec/utf_16.rs:66:55: 66:56
        _54 = BitAnd(move _55, const 255_u32); // scope 6 at src/codec/utf_16.rs:66:45: 66:64
        StorageDead(_55);                // scope 6 at src/codec/utf_16.rs:66:63: 66:64
        _53 = move _54 as u8 (Misc);     // scope 6 at src/codec/utf_16.rs:66:45: 66:70
        StorageDead(_54);                // scope 6 at src/codec/utf_16.rs:66:69: 66:70
        (_46.0: &mut dyn encoding_types::ByteWriter) = move _47; // scope 6 at src/codec/utf_16.rs:65:21: 66:71
        (_46.1: u8) = move _49;          // scope 6 at src/codec/utf_16.rs:65:21: 66:71
        (_46.2: u8) = move _53;          // scope 6 at src/codec/utf_16.rs:65:21: 66:71
        _44 = <F as Fn<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::call(move _45, move _46) -> [return: bb19, unwind: bb24]; // scope 6 at src/codec/utf_16.rs:65:21: 66:71
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:65:21: 65:36
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (&mut dyn encoding_types::ByteWriter, u8, u8)) -> <F as std::ops::FnOnce<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::Output {<F as std::ops::Fn<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_53);                // scope 6 at src/codec/utf_16.rs:66:70: 66:71
        StorageDead(_49);                // scope 6 at src/codec/utf_16.rs:66:70: 66:71
        StorageDead(_47);                // scope 6 at src/codec/utf_16.rs:66:70: 66:71
        StorageDead(_46);                // scope 6 at src/codec/utf_16.rs:66:70: 66:71
        StorageDead(_45);                // scope 6 at src/codec/utf_16.rs:66:70: 66:71
        StorageDead(_44);                // scope 6 at src/codec/utf_16.rs:66:71: 66:72
        StorageLive(_57);                // scope 6 at src/codec/utf_16.rs:67:21: 68:63
        StorageLive(_58);                // scope 6 at src/codec/utf_16.rs:67:21: 67:36
        _58 = &_4;                       // scope 6 at src/codec/utf_16.rs:67:21: 67:36
        StorageLive(_59);                // scope 6 at src/codec/utf_16.rs:67:21: 68:63
        StorageLive(_60);                // scope 6 at src/codec/utf_16.rs:67:37: 67:43
        StorageLive(_61);                // scope 6 at src/codec/utf_16.rs:67:37: 67:43
        _61 = &mut (*_3);                // scope 6 at src/codec/utf_16.rs:67:37: 67:43
        _60 = move _61 as &mut dyn encoding_types::ByteWriter (Pointer(Unsize)); // scope 6 at src/codec/utf_16.rs:67:37: 67:43
        StorageDead(_61);                // scope 6 at src/codec/utf_16.rs:67:42: 67:43
        StorageLive(_62);                // scope 6 at src/codec/utf_16.rs:67:45: 67:77
        StorageLive(_63);                // scope 6 at src/codec/utf_16.rs:67:45: 67:71
        StorageLive(_64);                // scope 6 at src/codec/utf_16.rs:67:53: 67:70
        StorageLive(_65);                // scope 6 at src/codec/utf_16.rs:67:54: 67:63
        StorageLive(_66);                // scope 6 at src/codec/utf_16.rs:67:55: 67:57
        _66 = _41;                       // scope 6 at src/codec/utf_16.rs:67:55: 67:57
        _65 = Shr(move _66, const 8_i32); // scope 6 at src/codec/utf_16.rs:67:54: 67:63
        StorageDead(_66);                // scope 6 at src/codec/utf_16.rs:67:62: 67:63
        _64 = BitAnd(move _65, const 3_u32); // scope 6 at src/codec/utf_16.rs:67:53: 67:70
        StorageDead(_65);                // scope 6 at src/codec/utf_16.rs:67:69: 67:70
        _63 = BitOr(const 220_u32, move _64); // scope 6 at src/codec/utf_16.rs:67:45: 67:71
        StorageDead(_64);                // scope 6 at src/codec/utf_16.rs:67:70: 67:71
        _62 = move _63 as u8 (Misc);     // scope 6 at src/codec/utf_16.rs:67:45: 67:77
        StorageDead(_63);                // scope 6 at src/codec/utf_16.rs:67:76: 67:77
        StorageLive(_67);                // scope 6 at src/codec/utf_16.rs:68:45: 68:62
        StorageLive(_68);                // scope 6 at src/codec/utf_16.rs:68:45: 68:56
        StorageLive(_69);                // scope 6 at src/codec/utf_16.rs:68:46: 68:48
        _69 = _41;                       // scope 6 at src/codec/utf_16.rs:68:46: 68:48
        _68 = BitAnd(move _69, const 255_u32); // scope 6 at src/codec/utf_16.rs:68:45: 68:56
        StorageDead(_69);                // scope 6 at src/codec/utf_16.rs:68:55: 68:56
        _67 = move _68 as u8 (Misc);     // scope 6 at src/codec/utf_16.rs:68:45: 68:62
        StorageDead(_68);                // scope 6 at src/codec/utf_16.rs:68:61: 68:62
        (_59.0: &mut dyn encoding_types::ByteWriter) = move _60; // scope 6 at src/codec/utf_16.rs:67:21: 68:63
        (_59.1: u8) = move _62;          // scope 6 at src/codec/utf_16.rs:67:21: 68:63
        (_59.2: u8) = move _67;          // scope 6 at src/codec/utf_16.rs:67:21: 68:63
        _57 = <F as Fn<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::call(move _58, move _59) -> [return: bb20, unwind: bb24]; // scope 6 at src/codec/utf_16.rs:67:21: 68:63
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:67:21: 67:36
                                         // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r F, (&mut dyn encoding_types::ByteWriter, u8, u8)) -> <F as std::ops::FnOnce<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::Output {<F as std::ops::Fn<(&mut dyn encoding_types::ByteWriter, u8, u8)>>::call}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_67);                // scope 6 at src/codec/utf_16.rs:68:62: 68:63
        StorageDead(_62);                // scope 6 at src/codec/utf_16.rs:68:62: 68:63
        StorageDead(_60);                // scope 6 at src/codec/utf_16.rs:68:62: 68:63
        StorageDead(_59);                // scope 6 at src/codec/utf_16.rs:68:62: 68:63
        StorageDead(_58);                // scope 6 at src/codec/utf_16.rs:68:62: 68:63
        StorageDead(_57);                // scope 6 at src/codec/utf_16.rs:68:63: 68:64
        StorageDead(_41);                // scope 4 at src/codec/utf_16.rs:69:17: 69:18
        goto -> bb21;                    // scope 4 at src/codec/utf_16.rs:69:17: 69:18
    }

    bb21: {
        StorageDead(_21);                // scope 2 at src/codec/utf_16.rs:72:9: 72:10
        StorageDead(_14);                // scope 1 at src/codec/utf_16.rs:72:9: 72:10
        goto -> bb5;                     // scope 1 at src/codec/utf_16.rs:57:9: 72:10
    }

    bb22: {
        StorageDead(_71);                // scope 0 at src/codec/utf_16.rs:73:20: 73:21
        StorageLive(_72);                // scope 0 at src/codec/utf_16.rs:73:23: 73:27
        discriminant(_72) = 0;           // scope 0 at src/codec/utf_16.rs:73:23: 73:27
        (_0.0: usize) = move _70;        // scope 0 at src/codec/utf_16.rs:73:9: 73:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _72; // scope 0 at src/codec/utf_16.rs:73:9: 73:28
        StorageDead(_72);                // scope 0 at src/codec/utf_16.rs:73:27: 73:28
        StorageDead(_70);                // scope 0 at src/codec/utf_16.rs:73:27: 73:28
        drop(_4) -> bb23;                // scope 0 at src/codec/utf_16.rs:74:5: 74:6
    }

    bb23: {
        return;                          // scope 0 at src/codec/utf_16.rs:74:6: 74:6
    }

    bb24 (cleanup): {
        drop(_4) -> bb25;                // scope 0 at src/codec/utf_16.rs:74:5: 74:6
    }

    bb25 (cleanup): {
        resume;                          // scope 0 at src/codec/utf_16.rs:52:5: 74:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:99:1: 106:2>::raw_finish(_1: &mut GBKEncoder, _2: &mut dyn encoding_types::ByteWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:105:19: 105:28
    debug _output => _2;                 // in scope 0 at src/codec/simpchinese.rs:105:30: 105:37
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/simpchinese.rs:105:59: 105:77

    bb0: {
        discriminant(_0) = 0;            // scope 0 at src/codec/simpchinese.rs:105:80: 105:84
        return;                          // scope 0 at src/codec/simpchinese.rs:105:86: 105:86
    }
}

fn codec::error::<impl at src/codec/error.rs:49:1: 51:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/error.rs:50:21: 50:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/error.rs:50:39: 50:61
    let mut _2: std::boxed::Box<codec::error::ErrorDecoder>; // in scope 0 at src/codec/error.rs:50:39: 50:61
    let mut _3: codec::error::ErrorDecoder; // in scope 0 at src/codec/error.rs:50:48: 50:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/error.rs:50:39: 50:61
        StorageLive(_2);                 // scope 0 at src/codec/error.rs:50:39: 50:61
        StorageLive(_3);                 // scope 0 at src/codec/error.rs:50:48: 50:60
        _2 = Box::<ErrorDecoder>::new(move _3) -> bb1; // scope 0 at src/codec/error.rs:50:39: 50:61
                                         // mir::Constant
                                         // + span: src/codec/error.rs:50:39: 50:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::error::ErrorDecoder) -> std::boxed::Box<codec::error::ErrorDecoder> {std::boxed::Box::<codec::error::ErrorDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:50:39: 50:61
        StorageDead(_3);                 // scope 0 at src/codec/error.rs:50:60: 50:61
        StorageDead(_2);                 // scope 0 at src/codec/error.rs:50:60: 50:61
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/error.rs:50:39: 50:61
        StorageDead(_1);                 // scope 0 at src/codec/error.rs:50:62: 50:63
        return;                          // scope 0 at src/codec/error.rs:50:63: 50:63
    }
}

fn korean::<impl at src/codec/korean.rs:38:1: 40:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/korean.rs:39:21: 39:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/korean.rs:39:39: 39:66
    let mut _2: std::boxed::Box<codec::korean::Windows949Encoder>; // in scope 0 at src/codec/korean.rs:39:39: 39:66
    let mut _3: codec::korean::Windows949Encoder; // in scope 0 at src/codec/korean.rs:39:48: 39:65

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/korean.rs:39:39: 39:66
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:39:39: 39:66
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:39:48: 39:65
        _2 = Box::<Windows949Encoder>::new(move _3) -> bb1; // scope 0 at src/codec/korean.rs:39:39: 39:66
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:39:39: 39:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::korean::Windows949Encoder) -> std::boxed::Box<codec::korean::Windows949Encoder> {std::boxed::Box::<codec::korean::Windows949Encoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:39:39: 39:66
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:39:65: 39:66
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:39:65: 39:66
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:39:39: 39:66
        StorageDead(_1);                 // scope 0 at src/codec/korean.rs:39:67: 39:68
        return;                          // scope 0 at src/codec/korean.rs:39:68: 39:68
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:45:1: 76:2>::raw_feed(_1: &mut BigFive2003Encoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:49:17: 49:26
    debug input => _2;                   // in scope 0 at src/codec/tradchinese.rs:49:28: 49:33
    debug output => _3;                  // in scope 0 at src/codec/tradchinese.rs:49:41: 49:47
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/tradchinese.rs:49:69: 49:96
    let _4: ();                          // in scope 0 at src/codec/tradchinese.rs:50:9: 50:40
    let mut _5: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/tradchinese.rs:50:9: 50:15
    let mut _6: usize;                   // in scope 0 at src/codec/tradchinese.rs:50:28: 50:39
    let mut _7: &str;                    // in scope 0 at src/codec/tradchinese.rs:50:28: 50:33
    let mut _8: util::StrCharIndexIterator; // in scope 0 at src/codec/tradchinese.rs:52:28: 52:46
    let mut _9: util::StrCharIndexIterator; // in scope 0 at src/codec/tradchinese.rs:52:28: 52:46
    let mut _10: &&str;                  // in scope 0 at src/codec/tradchinese.rs:52:28: 52:33
    let mut _11: util::StrCharIndexIterator; // in scope 0 at src/codec/tradchinese.rs:52:28: 52:46
    let mut _13: std::option::Option<((usize, usize), char)>; // in scope 0 at src/codec/tradchinese.rs:52:28: 52:46
    let mut _14: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/tradchinese.rs:52:28: 52:46
    let mut _15: &mut util::StrCharIndexIterator; // in scope 0 at src/codec/tradchinese.rs:52:28: 52:46
    let mut _16: isize;                  // in scope 0 at src/codec/tradchinese.rs:52:13: 52:24
    let mut _18: ((usize, usize), char); // in scope 0 at src/codec/tradchinese.rs:52:13: 52:24
    let mut _22: bool;                   // in scope 0 at src/codec/tradchinese.rs:53:16: 53:29
    let mut _23: char;                   // in scope 0 at src/codec/tradchinese.rs:53:16: 53:18
    let _24: ();                         // in scope 0 at src/codec/tradchinese.rs:54:17: 54:44
    let mut _25: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/tradchinese.rs:54:17: 54:23
    let mut _26: u8;                     // in scope 0 at src/codec/tradchinese.rs:54:35: 54:43
    let mut _27: char;                   // in scope 0 at src/codec/tradchinese.rs:54:35: 54:37
    let mut _29: u32;                    // in scope 0 at src/codec/tradchinese.rs:56:49: 56:58
    let mut _30: char;                   // in scope 0 at src/codec/tradchinese.rs:56:49: 56:51
    let mut _31: bool;                   // in scope 0 at src/codec/tradchinese.rs:57:20: 57:62
    let mut _32: u16;                    // in scope 0 at src/codec/tradchinese.rs:57:20: 57:23
    let mut _33: bool;                   // in scope 0 at src/codec/tradchinese.rs:57:37: 57:62
    let mut _34: u16;                    // in scope 0 at src/codec/tradchinese.rs:57:37: 57:40
    let mut _35: u16;                    // in scope 0 at src/codec/tradchinese.rs:57:43: 57:62
    let mut _36: usize;                  // in scope 0 at src/codec/tradchinese.rs:59:29: 59:30
    let mut _37: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/tradchinese.rs:59:32: 61:23
    let mut _38: encoding_types::CodecError; // in scope 0 at src/codec/tradchinese.rs:59:37: 61:22
    let mut _39: isize;                  // in scope 0 at src/codec/tradchinese.rs:60:31: 60:41
    let mut _40: usize;                  // in scope 0 at src/codec/tradchinese.rs:60:31: 60:32
    let mut _41: std::borrow::Cow<str>;  // in scope 0 at src/codec/tradchinese.rs:60:50: 60:84
    let mut _42: &str;                   // in scope 0 at src/codec/tradchinese.rs:60:50: 60:77
    let _43: &str;                       // in scope 0 at src/codec/tradchinese.rs:60:50: 60:77
    let mut _45: u16;                    // in scope 0 at src/codec/tradchinese.rs:63:28: 63:37
    let mut _46: u16;                    // in scope 0 at src/codec/tradchinese.rs:63:28: 63:31
    let mut _48: u16;                    // in scope 0 at src/codec/tradchinese.rs:64:29: 64:32
    let mut _50: bool;                   // in scope 0 at src/codec/tradchinese.rs:65:38: 65:50
    let mut _51: u16;                    // in scope 0 at src/codec/tradchinese.rs:65:38: 65:43
    let _52: ();                         // in scope 0 at src/codec/tradchinese.rs:66:17: 66:46
    let mut _53: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/tradchinese.rs:66:17: 66:23
    let mut _54: u8;                     // in scope 0 at src/codec/tradchinese.rs:66:35: 66:45
    let mut _55: u16;                    // in scope 0 at src/codec/tradchinese.rs:66:35: 66:39
    let _56: ();                         // in scope 0 at src/codec/tradchinese.rs:67:17: 67:63
    let mut _57: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/tradchinese.rs:67:17: 67:23
    let mut _58: u8;                     // in scope 0 at src/codec/tradchinese.rs:67:35: 67:62
    let mut _59: u16;                    // in scope 0 at src/codec/tradchinese.rs:67:35: 67:56
    let mut _60: u16;                    // in scope 0 at src/codec/tradchinese.rs:67:36: 67:41
    let mut _61: u16;                    // in scope 0 at src/codec/tradchinese.rs:67:44: 67:55
    let mut _62: usize;                  // in scope 0 at src/codec/tradchinese.rs:70:10: 70:21
    let mut _63: &str;                   // in scope 0 at src/codec/tradchinese.rs:70:10: 70:15
    let mut _64: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/tradchinese.rs:70:23: 70:27
    scope 1 {
        debug iter => _11;               // in scope 1 at src/codec/tradchinese.rs:52:28: 52:46
        let mut _12: ((usize, usize), char); // in scope 1 at src/codec/tradchinese.rs:52:28: 52:46
        scope 2 {
            debug __next => _12;         // in scope 2 at src/codec/tradchinese.rs:52:28: 52:46
            let _17: ((usize, usize), char); // in scope 2 at src/codec/tradchinese.rs:52:13: 52:24
            let _19: usize;              // in scope 2 at src/codec/tradchinese.rs:52:15: 52:16
            let _20: usize;              // in scope 2 at src/codec/tradchinese.rs:52:17: 52:18
            let _21: char;               // in scope 2 at src/codec/tradchinese.rs:52:21: 52:23
            scope 3 {
                debug val => _17;        // in scope 3 at src/codec/tradchinese.rs:52:13: 52:24
            }
            scope 4 {
                debug i => _19;          // in scope 4 at src/codec/tradchinese.rs:52:15: 52:16
                debug j => _20;          // in scope 4 at src/codec/tradchinese.rs:52:17: 52:18
                debug ch => _21;         // in scope 4 at src/codec/tradchinese.rs:52:21: 52:23
                let _28: u16;            // in scope 4 at src/codec/tradchinese.rs:56:21: 56:24
                scope 5 {
                    debug ptr => _28;    // in scope 5 at src/codec/tradchinese.rs:56:21: 56:24
                    let _44: u16;        // in scope 5 at src/codec/tradchinese.rs:63:21: 63:25
                    scope 6 {
                        debug lead => _44; // in scope 6 at src/codec/tradchinese.rs:63:21: 63:25
                        let _47: u16;    // in scope 6 at src/codec/tradchinese.rs:64:21: 64:26
                        scope 7 {
                            debug trail => _47; // in scope 7 at src/codec/tradchinese.rs:64:21: 64:26
                            let _49: u16; // in scope 7 at src/codec/tradchinese.rs:65:21: 65:32
                            scope 8 {
                                debug trailoffset => _49; // in scope 8 at src/codec/tradchinese.rs:65:21: 65:32
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/tradchinese.rs:50:9: 50:40
        StorageLive(_5);                 // scope 0 at src/codec/tradchinese.rs:50:9: 50:15
        _5 = &mut (*_3);                 // scope 0 at src/codec/tradchinese.rs:50:9: 50:15
        StorageLive(_6);                 // scope 0 at src/codec/tradchinese.rs:50:28: 50:39
        StorageLive(_7);                 // scope 0 at src/codec/tradchinese.rs:50:28: 50:33
        _7 = _2;                         // scope 0 at src/codec/tradchinese.rs:50:28: 50:33
        _6 = core::str::<impl str>::len(move _7) -> bb1; // scope 0 at src/codec/tradchinese.rs:50:28: 50:39
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:50:34: 50:37
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/tradchinese.rs:50:38: 50:39
        _4 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint(move _5, move _6) -> bb2; // scope 0 at src/codec/tradchinese.rs:50:9: 50:40
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:50:16: 50:27
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, usize) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_6);                 // scope 0 at src/codec/tradchinese.rs:50:39: 50:40
        StorageDead(_5);                 // scope 0 at src/codec/tradchinese.rs:50:39: 50:40
        StorageDead(_4);                 // scope 0 at src/codec/tradchinese.rs:50:40: 50:41
        StorageLive(_8);                 // scope 0 at src/codec/tradchinese.rs:52:28: 52:46
        StorageLive(_9);                 // scope 0 at src/codec/tradchinese.rs:52:28: 52:46
        StorageLive(_10);                // scope 0 at src/codec/tradchinese.rs:52:28: 52:33
        _10 = &_2;                       // scope 0 at src/codec/tradchinese.rs:52:28: 52:33
        _9 = <&str as StrCharIndex>::index_iter(move _10) -> bb3; // scope 0 at src/codec/tradchinese.rs:52:28: 52:46
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:52:34: 52:44
                                         // + literal: Const { ty: for<'r> fn(&'r &str) -> util::StrCharIndexIterator {<&str as util::StrCharIndex>::index_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb3: {
        StorageDead(_10);                // scope 0 at src/codec/tradchinese.rs:52:45: 52:46
        _8 = <StrCharIndexIterator as IntoIterator>::into_iter(move _9) -> bb4; // scope 0 at src/codec/tradchinese.rs:52:28: 52:46
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:52:28: 52:46
                                         // + literal: Const { ty: fn(util::StrCharIndexIterator) -> <util::StrCharIndexIterator as std::iter::IntoIterator>::IntoIter {<util::StrCharIndexIterator as std::iter::IntoIterator>::into_iter}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_9);                 // scope 0 at src/codec/tradchinese.rs:52:45: 52:46
        StorageLive(_11);                // scope 0 at src/codec/tradchinese.rs:52:28: 52:46
        _11 = move _8;                   // scope 0 at src/codec/tradchinese.rs:52:28: 52:46
        goto -> bb5;                     // scope 1 at src/codec/tradchinese.rs:52:9: 69:10
    }

    bb5: {
        StorageLive(_12);                // scope 1 at src/codec/tradchinese.rs:52:28: 52:46
        StorageLive(_13);                // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
        StorageLive(_14);                // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
        StorageLive(_15);                // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
        _15 = &mut _11;                  // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
        _14 = &mut (*_15);               // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
        _13 = <StrCharIndexIterator as Iterator>::next(move _14) -> bb6; // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:52:28: 52:46
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StrCharIndexIterator) -> std::option::Option<<util::StrCharIndexIterator as std::iter::Iterator>::Item> {<util::StrCharIndexIterator as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_14);                // scope 2 at src/codec/tradchinese.rs:52:45: 52:46
        _16 = discriminant(_13);         // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
        switchInt(move _16) -> [0_isize: bb7, 1_isize: bb9, otherwise: bb8]; // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
    }

    bb7: {
        StorageDead(_15);                // scope 2 at src/codec/tradchinese.rs:52:45: 52:46
        StorageDead(_13);                // scope 2 at src/codec/tradchinese.rs:52:45: 52:46
        StorageDead(_12);                // scope 1 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_11);                // scope 0 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_8);                 // scope 0 at src/codec/tradchinese.rs:52:45: 52:46
        StorageLive(_62);                // scope 0 at src/codec/tradchinese.rs:70:10: 70:21
        StorageLive(_63);                // scope 0 at src/codec/tradchinese.rs:70:10: 70:15
        _63 = _2;                        // scope 0 at src/codec/tradchinese.rs:70:10: 70:15
        _62 = core::str::<impl str>::len(move _63) -> bb26; // scope 0 at src/codec/tradchinese.rs:70:10: 70:21
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:70:16: 70:19
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> usize {core::str::<impl str>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        unreachable;                     // scope 2 at src/codec/tradchinese.rs:52:28: 52:46
    }

    bb9: {
        StorageLive(_17);                // scope 2 at src/codec/tradchinese.rs:52:13: 52:24
        _17 = ((_13 as Some).0: ((usize, usize), char)); // scope 2 at src/codec/tradchinese.rs:52:13: 52:24
        StorageLive(_18);                // scope 3 at src/codec/tradchinese.rs:52:13: 52:24
        _18 = _17;                       // scope 3 at src/codec/tradchinese.rs:52:13: 52:24
        _12 = move _18;                  // scope 3 at src/codec/tradchinese.rs:52:13: 52:24
        StorageDead(_18);                // scope 3 at src/codec/tradchinese.rs:52:23: 52:24
        StorageDead(_17);                // scope 2 at src/codec/tradchinese.rs:52:23: 52:24
        StorageDead(_15);                // scope 2 at src/codec/tradchinese.rs:52:45: 52:46
        StorageDead(_13);                // scope 2 at src/codec/tradchinese.rs:52:45: 52:46
        StorageLive(_19);                // scope 2 at src/codec/tradchinese.rs:52:15: 52:16
        _19 = ((_12.0: (usize, usize)).0: usize); // scope 2 at src/codec/tradchinese.rs:52:15: 52:16
        StorageLive(_20);                // scope 2 at src/codec/tradchinese.rs:52:17: 52:18
        _20 = ((_12.0: (usize, usize)).1: usize); // scope 2 at src/codec/tradchinese.rs:52:17: 52:18
        StorageLive(_21);                // scope 2 at src/codec/tradchinese.rs:52:21: 52:23
        _21 = (_12.1: char);             // scope 2 at src/codec/tradchinese.rs:52:21: 52:23
        StorageLive(_22);                // scope 4 at src/codec/tradchinese.rs:53:16: 53:29
        StorageLive(_23);                // scope 4 at src/codec/tradchinese.rs:53:16: 53:18
        _23 = _21;                       // scope 4 at src/codec/tradchinese.rs:53:16: 53:18
        _22 = Lt(move _23, const '\u{80}'); // scope 4 at src/codec/tradchinese.rs:53:16: 53:29
        StorageDead(_23);                // scope 4 at src/codec/tradchinese.rs:53:28: 53:29
        switchInt(move _22) -> [false: bb11, otherwise: bb10]; // scope 4 at src/codec/tradchinese.rs:53:16: 53:29
    }

    bb10: {
        StorageLive(_24);                // scope 4 at src/codec/tradchinese.rs:54:17: 54:44
        StorageLive(_25);                // scope 4 at src/codec/tradchinese.rs:54:17: 54:23
        _25 = &mut (*_3);                // scope 4 at src/codec/tradchinese.rs:54:17: 54:23
        StorageLive(_26);                // scope 4 at src/codec/tradchinese.rs:54:35: 54:43
        StorageLive(_27);                // scope 4 at src/codec/tradchinese.rs:54:35: 54:37
        _27 = _21;                       // scope 4 at src/codec/tradchinese.rs:54:35: 54:37
        _26 = move _27 as u8 (Misc);     // scope 4 at src/codec/tradchinese.rs:54:35: 54:43
        StorageDead(_27);                // scope 4 at src/codec/tradchinese.rs:54:42: 54:43
        _24 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _25, move _26) -> bb12; // scope 4 at src/codec/tradchinese.rs:54:17: 54:44
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:54:24: 54:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageLive(_28);                // scope 4 at src/codec/tradchinese.rs:56:21: 56:24
        StorageLive(_29);                // scope 4 at src/codec/tradchinese.rs:56:49: 56:58
        StorageLive(_30);                // scope 4 at src/codec/tradchinese.rs:56:49: 56:51
        _30 = _21;                       // scope 4 at src/codec/tradchinese.rs:56:49: 56:51
        _29 = move _30 as u32 (Misc);    // scope 4 at src/codec/tradchinese.rs:56:49: 56:58
        StorageDead(_30);                // scope 4 at src/codec/tradchinese.rs:56:57: 56:58
        _28 = index_tradchinese::big5::backward(move _29) -> bb13; // scope 4 at src/codec/tradchinese.rs:56:27: 56:59
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:56:27: 56:48
                                         // + literal: Const { ty: fn(u32) -> u16 {index_tradchinese::big5::backward}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_26);                // scope 4 at src/codec/tradchinese.rs:54:43: 54:44
        StorageDead(_25);                // scope 4 at src/codec/tradchinese.rs:54:43: 54:44
        StorageDead(_24);                // scope 4 at src/codec/tradchinese.rs:54:44: 54:45
        goto -> bb25;                    // scope 4 at src/codec/tradchinese.rs:53:13: 68:14
    }

    bb13: {
        StorageDead(_29);                // scope 4 at src/codec/tradchinese.rs:56:58: 56:59
        StorageLive(_31);                // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
        StorageLive(_32);                // scope 5 at src/codec/tradchinese.rs:57:20: 57:23
        _32 = _28;                       // scope 5 at src/codec/tradchinese.rs:57:20: 57:23
        switchInt(move _32) -> [u16::MAX: bb14, otherwise: bb15]; // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
    }

    bb14: {
        StorageDead(_32);                // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
        _31 = const true;                // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
        goto -> bb16;                    // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
    }

    bb15: {
        StorageDead(_32);                // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
        StorageLive(_33);                // scope 5 at src/codec/tradchinese.rs:57:37: 57:62
        StorageLive(_34);                // scope 5 at src/codec/tradchinese.rs:57:37: 57:40
        _34 = _28;                       // scope 5 at src/codec/tradchinese.rs:57:37: 57:40
        StorageLive(_35);                // scope 5 at src/codec/tradchinese.rs:57:43: 57:62
        _35 = const 5024_u16;            // scope 5 at src/codec/tradchinese.rs:57:43: 57:62
        _33 = Lt(move _34, move _35);    // scope 5 at src/codec/tradchinese.rs:57:37: 57:62
        StorageDead(_35);                // scope 5 at src/codec/tradchinese.rs:57:61: 57:62
        StorageDead(_34);                // scope 5 at src/codec/tradchinese.rs:57:61: 57:62
        _31 = move _33;                  // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
        goto -> bb16;                    // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
    }

    bb16: {
        StorageDead(_33);                // scope 5 at src/codec/tradchinese.rs:57:61: 57:62
        switchInt(move _31) -> [false: bb19, otherwise: bb17]; // scope 5 at src/codec/tradchinese.rs:57:20: 57:62
    }

    bb17: {
        StorageLive(_36);                // scope 5 at src/codec/tradchinese.rs:59:29: 59:30
        _36 = _19;                       // scope 5 at src/codec/tradchinese.rs:59:29: 59:30
        StorageLive(_37);                // scope 5 at src/codec/tradchinese.rs:59:32: 61:23
        StorageLive(_38);                // scope 5 at src/codec/tradchinese.rs:59:37: 61:22
        StorageLive(_39);                // scope 5 at src/codec/tradchinese.rs:60:31: 60:41
        StorageLive(_40);                // scope 5 at src/codec/tradchinese.rs:60:31: 60:32
        _40 = _20;                       // scope 5 at src/codec/tradchinese.rs:60:31: 60:32
        _39 = move _40 as isize (Misc);  // scope 5 at src/codec/tradchinese.rs:60:31: 60:41
        StorageDead(_40);                // scope 5 at src/codec/tradchinese.rs:60:40: 60:41
        StorageLive(_41);                // scope 5 at src/codec/tradchinese.rs:60:50: 60:84
        StorageLive(_42);                // scope 5 at src/codec/tradchinese.rs:60:50: 60:77
        StorageLive(_43);                // scope 5 at src/codec/tradchinese.rs:60:50: 60:77
        _43 = const "unrepresentable character"; // scope 5 at src/codec/tradchinese.rs:60:50: 60:77
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:60:50: 60:77
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _42 = _43;                       // scope 5 at src/codec/tradchinese.rs:60:50: 60:77
        _41 = <&str as Into<Cow<str>>>::into(move _42) -> bb18; // scope 5 at src/codec/tradchinese.rs:60:50: 60:84
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:60:78: 60:82
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb18: {
        StorageDead(_42);                // scope 5 at src/codec/tradchinese.rs:60:83: 60:84
        (_38.0: isize) = move _39;       // scope 5 at src/codec/tradchinese.rs:59:37: 61:22
        (_38.1: std::borrow::Cow<str>) = move _41; // scope 5 at src/codec/tradchinese.rs:59:37: 61:22
        StorageDead(_41);                // scope 5 at src/codec/tradchinese.rs:61:21: 61:22
        StorageDead(_39);                // scope 5 at src/codec/tradchinese.rs:61:21: 61:22
        ((_37 as Some).0: encoding_types::CodecError) = move _38; // scope 5 at src/codec/tradchinese.rs:59:32: 61:23
        discriminant(_37) = 1;           // scope 5 at src/codec/tradchinese.rs:59:32: 61:23
        StorageDead(_38);                // scope 5 at src/codec/tradchinese.rs:61:22: 61:23
        (_0.0: usize) = move _36;        // scope 5 at src/codec/tradchinese.rs:59:28: 61:24
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _37; // scope 5 at src/codec/tradchinese.rs:59:28: 61:24
        StorageDead(_37);                // scope 5 at src/codec/tradchinese.rs:61:23: 61:24
        StorageDead(_36);                // scope 5 at src/codec/tradchinese.rs:61:23: 61:24
        StorageDead(_43);                // scope 5 at src/codec/tradchinese.rs:61:24: 61:25
        StorageDead(_31);                // scope 5 at src/codec/tradchinese.rs:62:17: 62:18
        StorageDead(_28);                // scope 4 at src/codec/tradchinese.rs:68:13: 68:14
        StorageDead(_22);                // scope 4 at src/codec/tradchinese.rs:68:13: 68:14
        StorageDead(_21);                // scope 2 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_20);                // scope 2 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_19);                // scope 2 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_12);                // scope 1 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_11);                // scope 0 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_8);                 // scope 0 at src/codec/tradchinese.rs:52:45: 52:46
        goto -> bb27;                    // scope 0 at src/codec/tradchinese.rs:71:6: 71:6
    }

    bb19: {
        StorageDead(_31);                // scope 5 at src/codec/tradchinese.rs:62:17: 62:18
        StorageLive(_44);                // scope 5 at src/codec/tradchinese.rs:63:21: 63:25
        StorageLive(_45);                // scope 5 at src/codec/tradchinese.rs:63:28: 63:37
        StorageLive(_46);                // scope 5 at src/codec/tradchinese.rs:63:28: 63:31
        _46 = _28;                       // scope 5 at src/codec/tradchinese.rs:63:28: 63:31
        _45 = Div(move _46, const 157_u16); // scope 5 at src/codec/tradchinese.rs:63:28: 63:37
        StorageDead(_46);                // scope 5 at src/codec/tradchinese.rs:63:36: 63:37
        _44 = Add(move _45, const 129_u16); // scope 5 at src/codec/tradchinese.rs:63:28: 63:44
        StorageDead(_45);                // scope 5 at src/codec/tradchinese.rs:63:43: 63:44
        StorageLive(_47);                // scope 6 at src/codec/tradchinese.rs:64:21: 64:26
        StorageLive(_48);                // scope 6 at src/codec/tradchinese.rs:64:29: 64:32
        _48 = _28;                       // scope 6 at src/codec/tradchinese.rs:64:29: 64:32
        _47 = Rem(move _48, const 157_u16); // scope 6 at src/codec/tradchinese.rs:64:29: 64:38
        StorageDead(_48);                // scope 6 at src/codec/tradchinese.rs:64:37: 64:38
        StorageLive(_49);                // scope 7 at src/codec/tradchinese.rs:65:21: 65:32
        StorageLive(_50);                // scope 7 at src/codec/tradchinese.rs:65:38: 65:50
        StorageLive(_51);                // scope 7 at src/codec/tradchinese.rs:65:38: 65:43
        _51 = _47;                       // scope 7 at src/codec/tradchinese.rs:65:38: 65:43
        _50 = Lt(move _51, const 63_u16); // scope 7 at src/codec/tradchinese.rs:65:38: 65:50
        StorageDead(_51);                // scope 7 at src/codec/tradchinese.rs:65:49: 65:50
        switchInt(move _50) -> [false: bb21, otherwise: bb20]; // scope 7 at src/codec/tradchinese.rs:65:38: 65:50
    }

    bb20: {
        _49 = const 64_u16;              // scope 7 at src/codec/tradchinese.rs:65:52: 65:56
        goto -> bb22;                    // scope 7 at src/codec/tradchinese.rs:65:35: 65:69
    }

    bb21: {
        _49 = const 98_u16;              // scope 7 at src/codec/tradchinese.rs:65:64: 65:68
        goto -> bb22;                    // scope 7 at src/codec/tradchinese.rs:65:35: 65:69
    }

    bb22: {
        StorageDead(_50);                // scope 7 at src/codec/tradchinese.rs:65:68: 65:69
        StorageLive(_52);                // scope 8 at src/codec/tradchinese.rs:66:17: 66:46
        StorageLive(_53);                // scope 8 at src/codec/tradchinese.rs:66:17: 66:23
        _53 = &mut (*_3);                // scope 8 at src/codec/tradchinese.rs:66:17: 66:23
        StorageLive(_54);                // scope 8 at src/codec/tradchinese.rs:66:35: 66:45
        StorageLive(_55);                // scope 8 at src/codec/tradchinese.rs:66:35: 66:39
        _55 = _44;                       // scope 8 at src/codec/tradchinese.rs:66:35: 66:39
        _54 = move _55 as u8 (Misc);     // scope 8 at src/codec/tradchinese.rs:66:35: 66:45
        StorageDead(_55);                // scope 8 at src/codec/tradchinese.rs:66:44: 66:45
        _52 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _53, move _54) -> bb23; // scope 8 at src/codec/tradchinese.rs:66:17: 66:46
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:66:24: 66:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb23: {
        StorageDead(_54);                // scope 8 at src/codec/tradchinese.rs:66:45: 66:46
        StorageDead(_53);                // scope 8 at src/codec/tradchinese.rs:66:45: 66:46
        StorageDead(_52);                // scope 8 at src/codec/tradchinese.rs:66:46: 66:47
        StorageLive(_56);                // scope 8 at src/codec/tradchinese.rs:67:17: 67:63
        StorageLive(_57);                // scope 8 at src/codec/tradchinese.rs:67:17: 67:23
        _57 = &mut (*_3);                // scope 8 at src/codec/tradchinese.rs:67:17: 67:23
        StorageLive(_58);                // scope 8 at src/codec/tradchinese.rs:67:35: 67:62
        StorageLive(_59);                // scope 8 at src/codec/tradchinese.rs:67:35: 67:56
        StorageLive(_60);                // scope 8 at src/codec/tradchinese.rs:67:36: 67:41
        _60 = _47;                       // scope 8 at src/codec/tradchinese.rs:67:36: 67:41
        StorageLive(_61);                // scope 8 at src/codec/tradchinese.rs:67:44: 67:55
        _61 = _49;                       // scope 8 at src/codec/tradchinese.rs:67:44: 67:55
        _59 = Add(move _60, move _61);   // scope 8 at src/codec/tradchinese.rs:67:35: 67:56
        StorageDead(_61);                // scope 8 at src/codec/tradchinese.rs:67:55: 67:56
        StorageDead(_60);                // scope 8 at src/codec/tradchinese.rs:67:55: 67:56
        _58 = move _59 as u8 (Misc);     // scope 8 at src/codec/tradchinese.rs:67:35: 67:62
        StorageDead(_59);                // scope 8 at src/codec/tradchinese.rs:67:61: 67:62
        _56 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _57, move _58) -> bb24; // scope 8 at src/codec/tradchinese.rs:67:17: 67:63
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:67:24: 67:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_58);                // scope 8 at src/codec/tradchinese.rs:67:62: 67:63
        StorageDead(_57);                // scope 8 at src/codec/tradchinese.rs:67:62: 67:63
        StorageDead(_56);                // scope 8 at src/codec/tradchinese.rs:67:63: 67:64
        StorageDead(_49);                // scope 7 at src/codec/tradchinese.rs:68:13: 68:14
        StorageDead(_47);                // scope 6 at src/codec/tradchinese.rs:68:13: 68:14
        StorageDead(_44);                // scope 5 at src/codec/tradchinese.rs:68:13: 68:14
        StorageDead(_28);                // scope 4 at src/codec/tradchinese.rs:68:13: 68:14
        goto -> bb25;                    // scope 4 at src/codec/tradchinese.rs:53:13: 68:14
    }

    bb25: {
        StorageDead(_22);                // scope 4 at src/codec/tradchinese.rs:68:13: 68:14
        StorageDead(_21);                // scope 2 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_20);                // scope 2 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_19);                // scope 2 at src/codec/tradchinese.rs:69:9: 69:10
        StorageDead(_12);                // scope 1 at src/codec/tradchinese.rs:69:9: 69:10
        goto -> bb5;                     // scope 1 at src/codec/tradchinese.rs:52:9: 69:10
    }

    bb26: {
        StorageDead(_63);                // scope 0 at src/codec/tradchinese.rs:70:20: 70:21
        StorageLive(_64);                // scope 0 at src/codec/tradchinese.rs:70:23: 70:27
        discriminant(_64) = 0;           // scope 0 at src/codec/tradchinese.rs:70:23: 70:27
        (_0.0: usize) = move _62;        // scope 0 at src/codec/tradchinese.rs:70:9: 70:28
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _64; // scope 0 at src/codec/tradchinese.rs:70:9: 70:28
        StorageDead(_64);                // scope 0 at src/codec/tradchinese.rs:70:27: 70:28
        StorageDead(_62);                // scope 0 at src/codec/tradchinese.rs:70:27: 70:28
        goto -> bb27;                    // scope 0 at src/codec/tradchinese.rs:71:6: 71:6
    }

    bb27: {
        return;                          // scope 0 at src/codec/tradchinese.rs:71:6: 71:6
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:39:1: 67:2>::is_ascii_compatible(_1: &SingleByteEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:41:28: 41:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/singlebyte.rs:41:38: 41:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/singlebyte.rs:41:45: 41:49
        return;                          // scope 0 at src/codec/singlebyte.rs:41:51: 41:51
    }
}

fn japanese::<impl at src/codec/japanese.rs:98:1: 113:2>::raw_finish(_1: &mut EUCJP0212Decoder, _2: &mut dyn encoding_types::StringWriter) -> Option<encoding_types::CodecError> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:108:19: 108:28
    debug output => _2;                  // in scope 0 at src/codec/japanese.rs:108:30: 108:36
    let mut _0: std::option::Option<encoding_types::CodecError>; // return place in scope 0 at src/codec/japanese.rs:109:18: 109:21
    let _3: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:109:14: 109:16
    let mut _4: (codec::japanese::eucjp::State, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/japanese.rs:109:25: 109:64
    let mut _5: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:109:43: 109:50
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:109:52: 109:58
    let mut _7: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/japanese.rs:109:52: 109:58
    let mut _8: &();                     // in scope 0 at src/codec/japanese.rs:109:60: 109:63
    let _9: &();                         // in scope 0 at src/codec/japanese.rs:109:60: 109:63
    let mut _10: codec::japanese::eucjp::State; // in scope 0 at src/codec/japanese.rs:110:19: 110:21
    let mut _11: &();                    // in scope 0 at src/codec/japanese.rs:109:60: 109:63
    scope 1 {
        debug st => _3;                  // in scope 1 at src/codec/japanese.rs:109:14: 109:16
        debug err => _0;                 // in scope 1 at src/codec/japanese.rs:109:18: 109:21
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:109:25: 109:64
        StorageLive(_5);                 // scope 0 at src/codec/japanese.rs:109:43: 109:50
        _5 = ((*_1).0: codec::japanese::eucjp::State); // scope 0 at src/codec/japanese.rs:109:43: 109:50
        StorageLive(_6);                 // scope 0 at src/codec/japanese.rs:109:52: 109:58
        StorageLive(_7);                 // scope 0 at src/codec/japanese.rs:109:52: 109:58
        _7 = &mut (*_2);                 // scope 0 at src/codec/japanese.rs:109:52: 109:58
        _6 = move _7 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:109:52: 109:58
        StorageDead(_7);                 // scope 0 at src/codec/japanese.rs:109:57: 109:58
        StorageLive(_8);                 // scope 0 at src/codec/japanese.rs:109:60: 109:63
        StorageLive(_9);                 // scope 0 at src/codec/japanese.rs:109:60: 109:63
        _11 = const <EUCJP0212Decoder as encoding_types::RawDecoder>::raw_finish::promoted[0]; // scope 0 at src/codec/japanese.rs:109:60: 109:63
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<EUCJP0212Decoder as encoding_types::RawDecoder>::raw_finish, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:109:60: 109:63
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:405 ~ encoding[5d2c]::codec::japanese::{impl#4}::raw_finish), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _9 = _11;                        // scope 0 at src/codec/japanese.rs:109:60: 109:63
        _8 = _9;                         // scope 0 at src/codec/japanese.rs:109:60: 109:63
        _4 = eucjp::raw_finish::<()>(move _5, move _6, move _8) -> bb1; // scope 0 at src/codec/japanese.rs:109:25: 109:64
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:109:25: 109:42
                                         // + literal: Const { ty: for<'r, 's> fn(codec::japanese::eucjp::State, &'r mut (dyn encoding_types::StringWriter + 'r), &'s ()) -> (codec::japanese::eucjp::State, std::option::Option<encoding_types::CodecError>) {codec::japanese::eucjp::raw_finish::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/codec/japanese.rs:109:63: 109:64
        StorageDead(_6);                 // scope 0 at src/codec/japanese.rs:109:63: 109:64
        StorageDead(_5);                 // scope 0 at src/codec/japanese.rs:109:63: 109:64
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:109:14: 109:16
        _3 = (_4.0: codec::japanese::eucjp::State); // scope 0 at src/codec/japanese.rs:109:14: 109:16
        _0 = move (_4.1: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/japanese.rs:109:18: 109:21
        StorageDead(_9);                 // scope 0 at src/codec/japanese.rs:109:64: 109:65
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:109:64: 109:65
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:110:19: 110:21
        _10 = _3;                        // scope 1 at src/codec/japanese.rs:110:19: 110:21
        ((*_1).0: codec::japanese::eucjp::State) = move _10; // scope 1 at src/codec/japanese.rs:110:9: 110:21
        StorageDead(_10);                // scope 1 at src/codec/japanese.rs:110:20: 110:21
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:112:5: 112:6
        return;                          // scope 0 at src/codec/japanese.rs:112:6: 112:6
    }
}

promoted[0] in japanese::<impl at src/codec/japanese.rs:98:1: 113:2>::raw_finish: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/japanese.rs:109:60: 109:63
    let mut _1: ();                      // in scope 0 at src/codec/japanese.rs:109:61: 109:63

    bb0: {
        nop;                             // scope 0 at src/codec/japanese.rs:109:61: 109:63
        _0 = &_1;                        // scope 0 at src/codec/japanese.rs:109:60: 109:63
        return;                          // scope 0 at src/codec/japanese.rs:109:60: 109:63
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:19:10: 19:15>::clone(_1: &UTF16LEEncoding) -> UTF16LEEncoding {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:19:10: 19:15
    let mut _0: codec::utf_16::UTF16LEEncoding; // return place in scope 0 at src/codec/utf_16.rs:19:10: 19:15

    bb0: {
        return;                          // scope 0 at src/codec/utf_16.rs:19:15: 19:15
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:141:1: 209:2>::raw_feed::{closure#0}(_1: &mut [closure@src/codec/utf_8.rs:158:51: 158:67], _2: &u8) -> bool {
    let mut _0: bool;                    // return place in scope 0 at src/codec/utf_8.rs:158:57: 158:57
    let _3: u8;                          // in scope 0 at src/codec/utf_8.rs:158:53: 158:55
    let mut _4: u8;                      // in scope 0 at src/codec/utf_8.rs:158:57: 158:59
    scope 1 {
        debug ch => _3;                  // in scope 1 at src/codec/utf_8.rs:158:53: 158:55
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:158:53: 158:55
        _3 = (*_2);                      // scope 0 at src/codec/utf_8.rs:158:53: 158:55
        StorageLive(_4);                 // scope 1 at src/codec/utf_8.rs:158:57: 158:59
        _4 = _3;                         // scope 1 at src/codec/utf_8.rs:158:57: 158:59
        _0 = Ge(move _4, const 128_u8);  // scope 1 at src/codec/utf_8.rs:158:57: 158:67
        StorageDead(_4);                 // scope 1 at src/codec/utf_8.rs:158:66: 158:67
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:158:66: 158:67
        return;                          // scope 0 at src/codec/utf_8.rs:158:67: 158:67
    }
}

fn eucjp::transient::S1(_1: &mut StatefulDecoderHelper<eucjp::State, T>) -> eucjp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::japanese::eucjp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: bool;                    // in scope 0 at src/codec/japanese.rs:156:14: 156:25
    let mut _7: bool;                    // in scope 0 at src/codec/japanese.rs:156:14: 156:25
    let mut _8: bool;                    // in scope 0 at src/codec/japanese.rs:155:18: 155:29
    let mut _9: bool;                    // in scope 0 at src/codec/japanese.rs:155:18: 155:29
    let mut _11: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:155:33: 155:36
    let mut _12: u32;                    // in scope 0 at src/codec/japanese.rs:155:42: 155:66
    let mut _13: u32;                    // in scope 0 at src/codec/japanese.rs:155:42: 155:59
    let mut _14: u32;                    // in scope 0 at src/codec/japanese.rs:155:51: 155:59
    let mut _15: u8;                     // in scope 0 at src/codec/japanese.rs:155:51: 155:52
    let mut _16: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:156:29: 156:32
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>; // in scope 0 at src/codec/japanese.rs:157:19: 157:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
        let _10: u8;                     // in scope 1 at src/codec/japanese.rs:155:14: 155:29
        scope 2 {
            debug b => _10;              // in scope 2 at src/codec/japanese.rs:155:14: 155:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<eucjp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        _8 = Le(const 161_u8, _5);       // scope 1 at src/codec/japanese.rs:155:18: 155:29
        switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 1 at src/codec/japanese.rs:155:18: 155:29
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 1;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb15;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        _9 = Le(_5, const 223_u8);       // scope 1 at src/codec/japanese.rs:155:18: 155:29
        switchInt(move _9) -> [false: bb6, otherwise: bb9]; // scope 1 at src/codec/japanese.rs:155:18: 155:29
    }

    bb6: {
        _6 = Le(const 161_u8, _5);       // scope 1 at src/codec/japanese.rs:156:14: 156:25
        switchInt(move _6) -> [false: bb8, otherwise: bb7]; // scope 1 at src/codec/japanese.rs:156:14: 156:25
    }

    bb7: {
        _7 = Le(_5, const 254_u8);       // scope 1 at src/codec/japanese.rs:156:14: 156:25
        switchInt(move _7) -> [false: bb8, otherwise: bb11]; // scope 1 at src/codec/japanese.rs:156:14: 156:25
    }

    bb8: {
        StorageLive(_17);                // scope 1 at src/codec/japanese.rs:157:19: 157:22
        _17 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:157:19: 157:22
        _0 = StatefulDecoderHelper::<eucjp::State, T>::backup_and_err(move _17, const 1_usize, const "invalid sequence") -> bb13; // scope 1 at src/codec/japanese.rs:157:19: 157:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:157:23: 157:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, usize, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:157:41: 157:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb9: {
        StorageLive(_10);                // scope 1 at src/codec/japanese.rs:155:14: 155:29
        _10 = _5;                        // scope 1 at src/codec/japanese.rs:155:14: 155:29
        StorageLive(_11);                // scope 2 at src/codec/japanese.rs:155:33: 155:36
        _11 = &mut (*_1);                // scope 2 at src/codec/japanese.rs:155:33: 155:36
        StorageLive(_12);                // scope 2 at src/codec/japanese.rs:155:42: 155:66
        StorageLive(_13);                // scope 2 at src/codec/japanese.rs:155:42: 155:59
        StorageLive(_14);                // scope 2 at src/codec/japanese.rs:155:51: 155:59
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:155:51: 155:52
        _15 = _10;                       // scope 2 at src/codec/japanese.rs:155:51: 155:52
        _14 = move _15 as u32 (Misc);    // scope 2 at src/codec/japanese.rs:155:51: 155:59
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:155:58: 155:59
        _13 = Add(const 65377_u32, move _14); // scope 2 at src/codec/japanese.rs:155:42: 155:59
        StorageDead(_14);                // scope 2 at src/codec/japanese.rs:155:58: 155:59
        _12 = Sub(move _13, const 161_u32); // scope 2 at src/codec/japanese.rs:155:42: 155:66
        StorageDead(_13);                // scope 2 at src/codec/japanese.rs:155:65: 155:66
        _0 = StatefulDecoderHelper::<eucjp::State, T>::emit(move _11, move _12) -> bb10; // scope 2 at src/codec/japanese.rs:155:33: 155:67
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:155:37: 155:41
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, u32) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_12);                // scope 2 at src/codec/japanese.rs:155:66: 155:67
        StorageDead(_11);                // scope 2 at src/codec/japanese.rs:155:66: 155:67
        StorageDead(_10);                // scope 1 at src/util.rs:226:77: 226:78
        goto -> bb14;                    // scope 1 at src/util.rs:226:77: 226:78
    }

    bb11: {
        StorageLive(_16);                // scope 1 at src/codec/japanese.rs:156:29: 156:32
        _16 = &mut (*_1);                // scope 1 at src/codec/japanese.rs:156:29: 156:32
        _0 = StatefulDecoderHelper::<eucjp::State, T>::err(move _16, const "invalid sequence") -> bb12; // scope 1 at src/codec/japanese.rs:156:29: 156:56
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:156:33: 156:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::eucjp::State, T>, &'static str) -> codec::japanese::eucjp::State {util::StatefulDecoderHelper::<codec::japanese::eucjp::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:156:37: 156:55
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb12: {
        StorageDead(_16);                // scope 1 at src/codec/japanese.rs:156:55: 156:56
        goto -> bb14;                    // scope 1 at src/codec/japanese.rs:156:55: 156:56
    }

    bb13: {
        StorageDead(_17);                // scope 1 at src/codec/japanese.rs:157:59: 157:60
        goto -> bb14;                    // scope 1 at src/codec/japanese.rs:157:59: 157:60
    }

    bb14: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb15;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb15: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:70:10: 70:15>::clone(_1: &SingleByteDecoder) -> SingleByteDecoder {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:70:10: 70:15
    let mut _0: codec::singlebyte::SingleByteDecoder; // return place in scope 0 at src/codec/singlebyte.rs:70:10: 70:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/singlebyte.rs:70:10: 70:15
        return;                          // scope 0 at src/codec/singlebyte.rs:70:15: 70:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:294:1: 302:2>::from_self(_1: &UTF16BEDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:295:18: 295:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_16.rs:295:28: 295:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:295:46: 295:67
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_16.rs:295:46: 295:67

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:295:46: 295:67
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:295:46: 295:67
        _3 = UTF16BEDecoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:295:46: 295:67
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:295:46: 295:65
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::utf_16::UTF16BEDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:295:46: 295:67
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:295:66: 295:67
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:295:46: 295:67
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:295:68: 295:69
        return;                          // scope 0 at src/codec/utf_16.rs:295:69: 295:69
    }
}

fn eucjp::<impl at src/util.rs:157:22: 157:31>::eq(_1: &eucjp::State, _2: &eucjp::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::japanese::eucjp::State, &codec::japanese::eucjp::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::japanese::eucjp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _20: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _27: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _28: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _33: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _34: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _35: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _36: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _37: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _38: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _43: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _44: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _45: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _46: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _47: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _48: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _21: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _22: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _25: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _26: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _29: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _30: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _31: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _32: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _39: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _40: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _41: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _42: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _21;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _22;  // in scope 3 at src/util.rs:164:25: 164:27
            }
            scope 4 {
                debug __self_0 => _25;   // in scope 4 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _26;  // in scope 4 at src/util.rs:164:25: 164:27
            }
            scope 5 {
                debug __self_0 => _29;   // in scope 5 at src/util.rs:164:25: 164:27
                debug __self_1 => _30;   // in scope 5 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _31;  // in scope 5 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _32;  // in scope 5 at src/util.rs:164:32: 164:35
            }
            scope 6 {
                debug __self_0 => _39;   // in scope 6 at src/util.rs:164:25: 164:27
                debug __self_1 => _40;   // in scope 6 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _41;  // in scope 6 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _42;  // in scope 6 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb22, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::japanese::eucjp::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::japanese::eucjp::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _20 = discriminant((*(_13.0: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _20) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, 4_isize: bb6, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb7, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb9, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        _19 = discriminant((*(_13.1: &codec::japanese::eucjp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [4_isize: bb16, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb7: {
        StorageLive(_21);                // scope 2 at src/util.rs:164:25: 164:27
        _21 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_22);                // scope 2 at src/util.rs:164:25: 164:27
        _22 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _21;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _22;                       // scope 3 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_22);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb9: {
        StorageLive(_25);                // scope 2 at src/util.rs:164:25: 164:27
        _25 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_26);                // scope 2 at src/util.rs:164:25: 164:27
        _26 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_27);                // scope 4 at src/util.rs:164:25: 164:27
        _27 = _25;                       // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_28);                // scope 4 at src/util.rs:164:25: 164:27
        _28 = _26;                       // scope 4 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _27, move _28) -> bb10; // scope 4 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_28);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_27);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_26);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_25);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb11: {
        StorageLive(_29);                // scope 2 at src/util.rs:164:25: 164:27
        _29 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_30);                // scope 2 at src/util.rs:164:32: 164:35
        _30 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_31);                // scope 2 at src/util.rs:164:25: 164:27
        _31 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S3).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_32);                // scope 2 at src/util.rs:164:32: 164:35
        _32 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S3).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_33);                // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_34);                // scope 5 at src/util.rs:164:25: 164:27
        _34 = _29;                       // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_35);                // scope 5 at src/util.rs:164:25: 164:27
        _35 = _31;                       // scope 5 at src/util.rs:164:25: 164:27
        _33 = <() as PartialEq>::eq(move _34, move _35) -> bb15; // scope 5 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        _0 = const false;                // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb13: {
        StorageLive(_36);                // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_37);                // scope 5 at src/util.rs:164:32: 164:35
        _37 = (*_30);                    // scope 5 at src/util.rs:164:32: 164:35
        StorageLive(_38);                // scope 5 at src/util.rs:164:32: 164:35
        _38 = (*_32);                    // scope 5 at src/util.rs:164:32: 164:35
        _36 = Eq(move _37, move _38);    // scope 5 at src/util.rs:164:32: 164:35
        StorageDead(_38);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_37);                // scope 5 at src/util.rs:164:34: 164:35
        _0 = move _36;                   // scope 5 at src/util.rs:164:32: 164:35
        goto -> bb14;                    // scope 5 at src/util.rs:164:32: 164:35
    }

    bb14: {
        StorageDead(_36);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_33);                // scope 5 at src/util.rs:164:34: 164:35
        StorageDead(_32);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_31);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_29);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb15: {
        StorageDead(_35);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_34);                // scope 5 at src/util.rs:164:26: 164:27
        switchInt(move _33) -> [false: bb12, otherwise: bb13]; // scope 5 at src/util.rs:164:32: 164:35
    }

    bb16: {
        StorageLive(_39);                // scope 2 at src/util.rs:164:25: 164:27
        _39 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S4).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_40);                // scope 2 at src/util.rs:164:32: 164:35
        _40 = &(((*(_13.0: &codec::japanese::eucjp::State)) as S4).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_41);                // scope 2 at src/util.rs:164:25: 164:27
        _41 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S4).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_42);                // scope 2 at src/util.rs:164:32: 164:35
        _42 = &(((*(_13.1: &codec::japanese::eucjp::State)) as S4).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_43);                // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_44);                // scope 6 at src/util.rs:164:25: 164:27
        _44 = _39;                       // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_45);                // scope 6 at src/util.rs:164:25: 164:27
        _45 = _41;                       // scope 6 at src/util.rs:164:25: 164:27
        _43 = <() as PartialEq>::eq(move _44, move _45) -> bb20; // scope 6 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        _0 = const false;                // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb19;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb18: {
        StorageLive(_46);                // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_47);                // scope 6 at src/util.rs:164:32: 164:35
        _47 = (*_40);                    // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_48);                // scope 6 at src/util.rs:164:32: 164:35
        _48 = (*_42);                    // scope 6 at src/util.rs:164:32: 164:35
        _46 = Eq(move _47, move _48);    // scope 6 at src/util.rs:164:32: 164:35
        StorageDead(_48);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_47);                // scope 6 at src/util.rs:164:34: 164:35
        _0 = move _46;                   // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb19;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb19: {
        StorageDead(_46);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_43);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_42);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_41);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_40);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_39);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb21;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb20: {
        StorageDead(_45);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_44);                // scope 6 at src/util.rs:164:26: 164:27
        switchInt(move _43) -> [false: bb17, otherwise: bb18]; // scope 6 at src/util.rs:164:32: 164:35
    }

    bb21: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb23;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb22: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb23;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb23: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn write_ascii_bytes(_1: &mut dyn encoding_types::StringWriter, _2: &[u8]) -> () {
    debug output => _1;                  // in scope 0 at src/codec/ascii.rs:76:30: 76:36
    debug buf => _2;                     // in scope 0 at src/codec/ascii.rs:76:57: 76:60
    let mut _0: ();                      // return place in scope 0 at src/codec/ascii.rs:76:69: 76:69
    let _3: ();                          // in scope 0 at src/codec/ascii.rs:77:13: 77:59
    let mut _4: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/ascii.rs:77:13: 77:19
    let mut _5: &str;                    // in scope 0 at src/codec/ascii.rs:77:30: 77:58
    let mut _6: &[u8];                   // in scope 0 at src/codec/ascii.rs:77:53: 77:56
    scope 1 {
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/ascii.rs:77:13: 77:59
        StorageLive(_4);                 // scope 0 at src/codec/ascii.rs:77:13: 77:19
        _4 = &mut (*_1);                 // scope 0 at src/codec/ascii.rs:77:13: 77:19
        StorageLive(_5);                 // scope 0 at src/codec/ascii.rs:77:30: 77:58
        StorageLive(_6);                 // scope 1 at src/codec/ascii.rs:77:53: 77:56
        _6 = _2;                         // scope 1 at src/codec/ascii.rs:77:53: 77:56
        _5 = transmute::<&[u8], &str>(move _6) -> bb1; // scope 1 at src/codec/ascii.rs:77:38: 77:57
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:77:38: 77:52
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(&[u8]) -> &str {std::intrinsics::transmute::<&[u8], &str>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_6);                 // scope 1 at src/codec/ascii.rs:77:56: 77:57
        _3 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_str(move _4, move _5) -> bb2; // scope 0 at src/codec/ascii.rs:77:13: 77:59
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:77:20: 77:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut dyn encoding_types::StringWriter, &'s str) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::write_str}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_5);                 // scope 0 at src/codec/ascii.rs:77:58: 77:59
        StorageDead(_4);                 // scope 0 at src/codec/ascii.rs:77:58: 77:59
        StorageDead(_3);                 // scope 0 at src/codec/ascii.rs:77:59: 77:60
        return;                          // scope 0 at src/codec/ascii.rs:78:10: 78:10
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:261:10: 261:15>::clone(_1: &UTF16LEDecoder) -> UTF16LEDecoder {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:261:10: 261:15
    let mut _0: codec::utf_16::UTF16LEDecoder; // return place in scope 0 at src/codec/utf_16.rs:261:10: 261:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/utf_16.rs:261:10: 261:15
        return;                          // scope 0 at src/codec/utf_16.rs:261:15: 261:15
    }
}

fn hz::raw_finish(_1: hz::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (hz::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::simpchinese::hz::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::simpchinese::hz::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::simpchinese::hz::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:585:18: 585:21
    let mut _20: &util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:595:18: 595:21
    let mut _22: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:606:18: 606:21
    let mut _24: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:616:18: 616:21
    let mut _27: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:628:18: 628:21
    let mut _28: codec::simpchinese::hz::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _29: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _30: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _31: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::simpchinese::hz::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 1 at src/util.rs:281:57: 281:63
        let _21: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _23: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 1 at src/util.rs:284:53: 284:57
        let _25: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug ctx => _19;            // in scope 4 at src/util.rs:281:57: 281:63
        }
        scope 5 {
            debug ctx => _21;            // in scope 5 at src/util.rs:284:53: 284:57
        }
        scope 6 {
            debug ctx => _23;            // in scope 6 at src/util.rs:284:53: 284:57
        }
        scope 7 {
            debug lead => _25;           // in scope 7 at src/util.rs:284:36: 284:40
            let _26: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 7 at src/util.rs:284:53: 284:57
            scope 8 {
                debug ctx => _26;        // in scope 8 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _31 = const hz::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(hz::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1161 ~ encoding[5d2c]::codec::simpchinese::hz::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _31;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<hz::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::simpchinese::hz::State, T> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<hz::State>(move _13, move _15) -> [return: bb2, unwind: bb17]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::simpchinese::hz::State, codec::simpchinese::hz::State) -> codec::simpchinese::hz::State {std::mem::replace::<codec::simpchinese::hz::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb7, 2_isize: bb9, 3_isize: bb11, 4_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_25);                // scope 1 at src/util.rs:284:36: 284:40
        _25 = ((_12 as B2).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_26);                // scope 7 at src/util.rs:284:53: 284:57
        _26 = &mut _4;                   // scope 7 at src/util.rs:284:60: 284:68
        StorageLive(_27);                // scope 8 at src/codec/simpchinese.rs:628:18: 628:21
        _27 = &mut (*_26);               // scope 8 at src/codec/simpchinese.rs:628:18: 628:21
        _11 = StatefulDecoderHelper::<hz::State, T>::err(move _27, const "incomplete sequence") -> [return: bb13, unwind: bb17]; // scope 8 at src/codec/simpchinese.rs:628:18: 628:48
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:628:22: 628:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:628:26: 628:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/codec/simpchinese.rs:585:18: 585:21
        _18 = &(*_17);                   // scope 3 at src/codec/simpchinese.rs:585:18: 585:21
        _11 = StatefulDecoderHelper::<hz::State, T>::reset(move _18) -> [return: bb6, unwind: bb17]; // scope 3 at src/codec/simpchinese.rs:585:18: 585:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:585:22: 585:27
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/codec/simpchinese.rs:585:28: 585:29
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb14;                    // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageLive(_19);                // scope 1 at src/util.rs:281:57: 281:63
        _19 = &mut _4;                   // scope 1 at src/util.rs:281:66: 281:74
        StorageLive(_20);                // scope 4 at src/codec/simpchinese.rs:595:18: 595:21
        _20 = &(*_19);                   // scope 4 at src/codec/simpchinese.rs:595:18: 595:21
        _11 = StatefulDecoderHelper::<hz::State, T>::reset(move _20) -> [return: bb8, unwind: bb17]; // scope 4 at src/codec/simpchinese.rs:595:18: 595:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:595:22: 595:27
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_20);                // scope 4 at src/codec/simpchinese.rs:595:28: 595:29
        StorageDead(_19);                // scope 1 at src/util.rs:281:88: 281:89
        goto -> bb14;                    // scope 1 at src/util.rs:281:88: 281:89
    }

    bb9: {
        StorageLive(_21);                // scope 1 at src/util.rs:284:53: 284:57
        _21 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_22);                // scope 5 at src/codec/simpchinese.rs:606:18: 606:21
        _22 = &mut (*_21);               // scope 5 at src/codec/simpchinese.rs:606:18: 606:21
        _11 = StatefulDecoderHelper::<hz::State, T>::err(move _22, const "incomplete sequence") -> [return: bb10, unwind: bb17]; // scope 5 at src/codec/simpchinese.rs:606:18: 606:48
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:606:22: 606:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:606:26: 606:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb10: {
        StorageDead(_22);                // scope 5 at src/codec/simpchinese.rs:606:47: 606:48
        StorageDead(_21);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb11: {
        StorageLive(_23);                // scope 1 at src/util.rs:284:53: 284:57
        _23 = &mut _4;                   // scope 1 at src/util.rs:284:60: 284:68
        StorageLive(_24);                // scope 6 at src/codec/simpchinese.rs:616:18: 616:21
        _24 = &mut (*_23);               // scope 6 at src/codec/simpchinese.rs:616:18: 616:21
        _11 = StatefulDecoderHelper::<hz::State, T>::err(move _24, const "incomplete sequence") -> [return: bb12, unwind: bb17]; // scope 6 at src/codec/simpchinese.rs:616:18: 616:48
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:616:22: 616:25
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:616:26: 616:47
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb12: {
        StorageDead(_24);                // scope 6 at src/codec/simpchinese.rs:616:47: 616:48
        StorageDead(_23);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb13: {
        StorageDead(_27);                // scope 8 at src/codec/simpchinese.rs:628:47: 628:48
        StorageDead(_26);                // scope 7 at src/util.rs:284:80: 284:81
        StorageDead(_25);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb14;                    // scope 1 at src/util.rs:284:80: 284:81
    }

    bb14: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_28);                // scope 2 at src/util.rs:287:18: 287:20
        _28 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_29);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_30);                // scope 2 at src/util.rs:287:22: 287:29
        _30 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _29 = Option::<encoding_types::CodecError>::take(move _30) -> [return: bb15, unwind: bb17]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_30);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::simpchinese::hz::State) = move _28; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _29; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_29);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_28);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb16;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb16: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb17 (cleanup): {
        drop(_4) -> bb18;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb18 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in hz::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:60:1: 62:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_8.rs:61:21: 61:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_8.rs:61:39: 61:60
    let mut _2: std::boxed::Box<codec::utf_8::UTF8Encoder>; // in scope 0 at src/codec/utf_8.rs:61:39: 61:60
    let mut _3: codec::utf_8::UTF8Encoder; // in scope 0 at src/codec/utf_8.rs:61:48: 61:59

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/utf_8.rs:61:39: 61:60
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:61:39: 61:60
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:61:48: 61:59
        _2 = Box::<UTF8Encoder>::new(move _3) -> bb1; // scope 0 at src/codec/utf_8.rs:61:39: 61:60
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:61:39: 61:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::utf_8::UTF8Encoder) -> std::boxed::Box<codec::utf_8::UTF8Encoder> {std::boxed::Box::<codec::utf_8::UTF8Encoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:61:39: 61:60
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:61:59: 61:60
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:61:59: 61:60
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:61:39: 61:60
        StorageDead(_1);                 // scope 0 at src/codec/utf_8.rs:61:61: 61:62
        return;                          // scope 0 at src/codec/utf_8.rs:61:62: 61:62
    }
}

fn iso2022jp::start::Lead0208(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:193:37: 193:43
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:193:85: 193:97
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:196:31: 196:44
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:196:31: 196:37
    let mut _4: isize;                   // in scope 0 at src/util.rs:197:29: 197:33
    let _5: u8;                          // in scope 0 at src/util.rs:198:34: 198:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:920:22: 920:25
    let mut _7: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:921:34: 921:37
    let mut _9: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:922:29: 922:32
    let mut _10: u8;                     // in scope 0 at src/codec/japanese.rs:922:34: 922:35
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:198:34: 198:35
        let _8: u8;                      // in scope 1 at src/codec/japanese.rs:922:14: 922:15
        scope 2 {
            debug b => _8;               // in scope 2 at src/codec/japanese.rs:922:14: 922:15
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:196:31: 196:44
        StorageLive(_3);                 // scope 0 at src/util.rs:196:31: 196:37
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:196:31: 196:37
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:196:31: 196:44
                                         // mir::Constant
                                         // + span: src/util.rs:196:38: 196:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:196:43: 196:44
        _4 = discriminant(_2);           // scope 0 at src/util.rs:196:31: 196:44
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:196:25: 196:44
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:198:34: 198:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:198:34: 198:35
        switchInt(_5) -> [10_u8: bb6, 27_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:198:40: 198:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:196:31: 196:44
    }

    bb4: {
        discriminant(_0) = 1;            // scope 0 at src/util.rs:197:44: 197:66
        goto -> bb12;                    // scope 0 at src/util.rs:197:65: 197:66
    }

    bb5: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:922:14: 922:15
        _8 = _5;                         // scope 1 at src/codec/japanese.rs:922:14: 922:15
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:922:29: 922:32
        _9 = &mut (*_1);                 // scope 2 at src/codec/japanese.rs:922:29: 922:32
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:922:34: 922:35
        _10 = _8;                        // scope 2 at src/codec/japanese.rs:922:34: 922:35
        _0 = iso2022jp::transient::Trail0208::<T>(move _9, move _10) -> bb10; // scope 2 at src/codec/japanese.rs:922:19: 922:36
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:922:19: 922:28
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>, u8) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Trail0208::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:920:22: 920:25
        _6 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:920:22: 920:25
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::emit(move _6, const 10_u32) -> bb7; // scope 1 at src/codec/japanese.rs:920:22: 920:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:920:26: 920:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, u32) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::emit}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:920:37: 920:38
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:920:37: 920:38
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:921:34: 921:37
        _7 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:921:34: 921:37
        _0 = iso2022jp::transient::EscapeStart::<T>(move _7) -> bb9; // scope 1 at src/codec/japanese.rs:921:22: 921:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:921:22: 921:33
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeStart::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:921:37: 921:38
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:921:37: 921:38
    }

    bb10: {
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:922:35: 922:36
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:922:35: 922:36
        StorageDead(_8);                 // scope 1 at src/util.rs:198:81: 198:82
        goto -> bb11;                    // scope 1 at src/util.rs:198:81: 198:82
    }

    bb11: {
        StorageDead(_5);                 // scope 0 at src/util.rs:198:85: 198:86
        goto -> bb12;                    // scope 0 at src/util.rs:198:85: 198:86
    }

    bb12: {
        StorageDead(_2);                 // scope 0 at src/util.rs:200:21: 200:22
        return;                          // scope 0 at src/util.rs:200:22: 200:22
    }
}

fn bigfive2003::<impl at src/util.rs:157:33: 157:38>::clone(_1: &bigfive2003::State) -> bigfive2003::State {
    debug self => _1;                    // in scope 0 at src/util.rs:157:33: 157:38
    let mut _0: codec::tradchinese::bigfive2003::State; // return place in scope 0 at src/util.rs:157:33: 157:38
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 2 at src/util.rs:157:33: 157:38
        return;                          // scope 0 at src/util.rs:157:38: 157:38
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:85:1: 94:2>::raw_feed::{closure#0}(_1: &[closure@src/codec/utf_16.rs:88:46: 91:10], _2: &mut dyn encoding_types::ByteWriter, _3: u8, _4: u8) -> () {
    debug output => _2;                  // in scope 0 at src/codec/utf_16.rs:88:47: 88:53
    debug msb => _3;                     // in scope 0 at src/codec/utf_16.rs:88:72: 88:75
    debug lsb => _4;                     // in scope 0 at src/codec/utf_16.rs:88:81: 88:84
    let mut _0: ();                      // return place in scope 0 at src/codec/utf_16.rs:88:90: 88:90
    let _5: ();                          // in scope 0 at src/codec/utf_16.rs:89:13: 89:35
    let mut _6: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:89:13: 89:19
    let mut _7: u8;                      // in scope 0 at src/codec/utf_16.rs:89:31: 89:34
    let _8: ();                          // in scope 0 at src/codec/utf_16.rs:90:13: 90:35
    let mut _9: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:90:13: 90:19
    let mut _10: u8;                     // in scope 0 at src/codec/utf_16.rs:90:31: 90:34

    bb0: {
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:89:13: 89:35
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:89:13: 89:19
        _6 = &mut (*_2);                 // scope 0 at src/codec/utf_16.rs:89:13: 89:19
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:89:31: 89:34
        _7 = _4;                         // scope 0 at src/codec/utf_16.rs:89:31: 89:34
        _5 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _6, move _7) -> bb1; // scope 0 at src/codec/utf_16.rs:89:13: 89:35
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:89:20: 89:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:89:34: 89:35
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:89:34: 89:35
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:89:35: 89:36
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:90:13: 90:35
        StorageLive(_9);                 // scope 0 at src/codec/utf_16.rs:90:13: 90:19
        _9 = &mut (*_2);                 // scope 0 at src/codec/utf_16.rs:90:13: 90:19
        StorageLive(_10);                // scope 0 at src/codec/utf_16.rs:90:31: 90:34
        _10 = _3;                        // scope 0 at src/codec/utf_16.rs:90:31: 90:34
        _8 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _9, move _10) -> bb2; // scope 0 at src/codec/utf_16.rs:90:13: 90:35
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:90:20: 90:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_10);                // scope 0 at src/codec/utf_16.rs:90:34: 90:35
        StorageDead(_9);                 // scope 0 at src/codec/utf_16.rs:90:34: 90:35
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:90:35: 90:36
        return;                          // scope 0 at src/codec/utf_16.rs:91:10: 91:10
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:165:1: 180:2>::is_ascii_compatible(_1: &GB18030Decoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:167:28: 167:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/simpchinese.rs:167:38: 167:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/simpchinese.rs:167:45: 167:49
        return;                          // scope 0 at src/codec/simpchinese.rs:167:51: 167:51
    }
}

const WINDOWS_1254: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:63:68: 63:82
    let _5: &str;                        // in scope 0 at src/all.rs:63:68: 63:82
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const WINDOWS_1254::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1254, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1271 ~ encoding[5d2c]::all::WINDOWS_1254), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in WINDOWS_1254: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:63:68: 63:82
    let mut _4: &str;                    // in scope 0 at src/all.rs:63:68: 63:82
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "windows-1254";       // scope 0 at src/all.rs:63:68: 63:82
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:63:68: 63:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:63:68: 63:82
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::windows_1254::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::windows_1254::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::windows_1254::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::windows_1254::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "windows-1254"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 })
                                         // mir::Constant
                                         // + span: src/all.rs:63:68: 63:82
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [119, 105, 110, 100, 111, 119, 115, 45, 49, 50, 53, 52], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 12 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn korean::<impl at src/codec/korean.rs:78:1: 82:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/korean.rs:79:21: 79:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/korean.rs:80:9: 80:63
    let mut _2: std::boxed::Box<codec::korean::Windows949Decoder>; // in scope 0 at src/codec/korean.rs:80:9: 80:63
    let mut _3: codec::korean::Windows949Decoder; // in scope 0 at src/codec/korean.rs:80:18: 80:62
    let mut _4: codec::korean::windows949::State; // in scope 0 at src/codec/korean.rs:80:42: 80:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/korean.rs:80:9: 80:63
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:80:9: 80:63
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:80:18: 80:62
        StorageLive(_4);                 // scope 0 at src/codec/korean.rs:80:42: 80:60
        _4 = <windows949::State as Default>::default() -> bb1; // scope 0 at src/codec/korean.rs:80:42: 80:60
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:80:42: 80:58
                                         // + literal: Const { ty: fn() -> codec::korean::windows949::State {<codec::korean::windows949::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::korean::windows949::State) = move _4; // scope 0 at src/codec/korean.rs:80:18: 80:62
        StorageDead(_4);                 // scope 0 at src/codec/korean.rs:80:61: 80:62
        _2 = Box::<Windows949Decoder>::new(move _3) -> bb2; // scope 0 at src/codec/korean.rs:80:9: 80:63
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:80:9: 80:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::korean::Windows949Decoder) -> std::boxed::Box<codec::korean::Windows949Decoder> {std::boxed::Box::<codec::korean::Windows949Decoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:80:9: 80:63
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:80:62: 80:63
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:80:62: 80:63
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:80:9: 80:63
        StorageDead(_1);                 // scope 0 at src/codec/korean.rs:81:5: 81:6
        return;                          // scope 0 at src/codec/korean.rs:81:6: 81:6
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:90:1: 105:2>::raw_feed(_1: &mut BigFive2003HKSCS2008Decoder, _2: &[u8], _3: &mut dyn encoding_types::StringWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:94:17: 94:26
    debug input => _2;                   // in scope 0 at src/codec/tradchinese.rs:94:28: 94:33
    debug output => _3;                  // in scope 0 at src/codec/tradchinese.rs:94:42: 94:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/tradchinese.rs:94:72: 94:99
    let _4: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:95:14: 95:16
    let _5: usize;                       // in scope 0 at src/codec/tradchinese.rs:95:18: 95:27
    let _6: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/tradchinese.rs:95:29: 95:32
    let mut _7: (codec::tradchinese::bigfive2003::State, usize, std::option::Option<encoding_types::CodecError>); // in scope 0 at src/codec/tradchinese.rs:95:36: 95:86
    let mut _8: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:95:58: 95:65
    let mut _9: &[u8];                   // in scope 0 at src/codec/tradchinese.rs:95:67: 95:72
    let mut _10: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/tradchinese.rs:95:74: 95:80
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/codec/tradchinese.rs:95:74: 95:80
    let mut _12: &();                    // in scope 0 at src/codec/tradchinese.rs:95:82: 95:85
    let _13: &();                        // in scope 0 at src/codec/tradchinese.rs:95:82: 95:85
    let mut _14: codec::tradchinese::bigfive2003::State; // in scope 0 at src/codec/tradchinese.rs:96:19: 96:21
    let mut _15: usize;                  // in scope 0 at src/codec/tradchinese.rs:97:10: 97:19
    let mut _16: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/tradchinese.rs:97:21: 97:24
    let mut _17: &();                    // in scope 0 at src/codec/tradchinese.rs:95:82: 95:85
    scope 1 {
        debug st => _4;                  // in scope 1 at src/codec/tradchinese.rs:95:14: 95:16
        debug processed => _5;           // in scope 1 at src/codec/tradchinese.rs:95:18: 95:27
        debug err => _6;                 // in scope 1 at src/codec/tradchinese.rs:95:29: 95:32
    }

    bb0: {
        StorageLive(_7);                 // scope 0 at src/codec/tradchinese.rs:95:36: 95:86
        StorageLive(_8);                 // scope 0 at src/codec/tradchinese.rs:95:58: 95:65
        _8 = ((*_1).0: codec::tradchinese::bigfive2003::State); // scope 0 at src/codec/tradchinese.rs:95:58: 95:65
        StorageLive(_9);                 // scope 0 at src/codec/tradchinese.rs:95:67: 95:72
        _9 = _2;                         // scope 0 at src/codec/tradchinese.rs:95:67: 95:72
        StorageLive(_10);                // scope 0 at src/codec/tradchinese.rs:95:74: 95:80
        StorageLive(_11);                // scope 0 at src/codec/tradchinese.rs:95:74: 95:80
        _11 = &mut (*_3);                // scope 0 at src/codec/tradchinese.rs:95:74: 95:80
        _10 = move _11 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/codec/tradchinese.rs:95:74: 95:80
        StorageDead(_11);                // scope 0 at src/codec/tradchinese.rs:95:79: 95:80
        StorageLive(_12);                // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
        StorageLive(_13);                // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
        _17 = const <BigFive2003HKSCS2008Decoder as encoding_types::RawDecoder>::raw_feed::promoted[0]; // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
                                         // ty::Const
                                         // + ty: &()
                                         // + val: Unevaluated(<BigFive2003HKSCS2008Decoder as encoding_types::RawDecoder>::raw_feed, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:95:82: 95:85
                                         // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:546 ~ encoding[5d2c]::codec::tradchinese::{impl#4}::raw_feed), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _13 = _17;                       // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
        _12 = _13;                       // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
        _7 = bigfive2003::raw_feed::<()>(move _8, move _9, move _10, move _12) -> bb1; // scope 0 at src/codec/tradchinese.rs:95:36: 95:86
                                         // mir::Constant
                                         // + span: src/codec/tradchinese.rs:95:36: 95:57
                                         // + literal: Const { ty: for<'r, 's, 't0> fn(codec::tradchinese::bigfive2003::State, &'r [u8], &'s mut (dyn encoding_types::StringWriter + 's), &'t0 ()) -> (codec::tradchinese::bigfive2003::State, usize, std::option::Option<encoding_types::CodecError>) {codec::tradchinese::bigfive2003::raw_feed::<()>}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_12);                // scope 0 at src/codec/tradchinese.rs:95:85: 95:86
        StorageDead(_10);                // scope 0 at src/codec/tradchinese.rs:95:85: 95:86
        StorageDead(_9);                 // scope 0 at src/codec/tradchinese.rs:95:85: 95:86
        StorageDead(_8);                 // scope 0 at src/codec/tradchinese.rs:95:85: 95:86
        StorageLive(_4);                 // scope 0 at src/codec/tradchinese.rs:95:14: 95:16
        _4 = (_7.0: codec::tradchinese::bigfive2003::State); // scope 0 at src/codec/tradchinese.rs:95:14: 95:16
        StorageLive(_5);                 // scope 0 at src/codec/tradchinese.rs:95:18: 95:27
        _5 = (_7.1: usize);              // scope 0 at src/codec/tradchinese.rs:95:18: 95:27
        StorageLive(_6);                 // scope 0 at src/codec/tradchinese.rs:95:29: 95:32
        _6 = move (_7.2: std::option::Option<encoding_types::CodecError>); // scope 0 at src/codec/tradchinese.rs:95:29: 95:32
        StorageDead(_13);                // scope 0 at src/codec/tradchinese.rs:95:86: 95:87
        StorageDead(_7);                 // scope 0 at src/codec/tradchinese.rs:95:86: 95:87
        StorageLive(_14);                // scope 1 at src/codec/tradchinese.rs:96:19: 96:21
        _14 = _4;                        // scope 1 at src/codec/tradchinese.rs:96:19: 96:21
        ((*_1).0: codec::tradchinese::bigfive2003::State) = move _14; // scope 1 at src/codec/tradchinese.rs:96:9: 96:21
        StorageDead(_14);                // scope 1 at src/codec/tradchinese.rs:96:20: 96:21
        StorageLive(_15);                // scope 1 at src/codec/tradchinese.rs:97:10: 97:19
        _15 = _5;                        // scope 1 at src/codec/tradchinese.rs:97:10: 97:19
        StorageLive(_16);                // scope 1 at src/codec/tradchinese.rs:97:21: 97:24
        _16 = move _6;                   // scope 1 at src/codec/tradchinese.rs:97:21: 97:24
        (_0.0: usize) = move _15;        // scope 1 at src/codec/tradchinese.rs:97:9: 97:25
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _16; // scope 1 at src/codec/tradchinese.rs:97:9: 97:25
        StorageDead(_16);                // scope 1 at src/codec/tradchinese.rs:97:24: 97:25
        StorageDead(_15);                // scope 1 at src/codec/tradchinese.rs:97:24: 97:25
        StorageDead(_6);                 // scope 0 at src/codec/tradchinese.rs:98:5: 98:6
        StorageDead(_5);                 // scope 0 at src/codec/tradchinese.rs:98:5: 98:6
        StorageDead(_4);                 // scope 0 at src/codec/tradchinese.rs:98:5: 98:6
        return;                          // scope 0 at src/codec/tradchinese.rs:98:6: 98:6
    }
}

promoted[0] in tradchinese::<impl at src/codec/tradchinese.rs:90:1: 105:2>::raw_feed: &() = {
    let mut _0: &();                     // return place in scope 0 at src/codec/tradchinese.rs:95:82: 95:85
    let mut _1: ();                      // in scope 0 at src/codec/tradchinese.rs:95:83: 95:85

    bb0: {
        nop;                             // scope 0 at src/codec/tradchinese.rs:95:83: 95:85
        _0 = &_1;                        // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
        return;                          // scope 0 at src/codec/tradchinese.rs:95:82: 95:85
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:81:1: 111:2>::is_ascii_compatible(_1: &SingleByteDecoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/singlebyte.rs:83:28: 83:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/singlebyte.rs:83:38: 83:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/singlebyte.rs:83:45: 83:49
        return;                          // scope 0 at src/codec/singlebyte.rs:83:51: 83:51
    }
}

fn japanese::<impl at src/codec/japanese.rs:463:1: 465:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:464:21: 464:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:464:39: 464:66
    let mut _2: std::boxed::Box<codec::japanese::Windows31JEncoder>; // in scope 0 at src/codec/japanese.rs:464:39: 464:66
    let mut _3: codec::japanese::Windows31JEncoder; // in scope 0 at src/codec/japanese.rs:464:48: 464:65

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/japanese.rs:464:39: 464:66
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:464:39: 464:66
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:464:48: 464:65
        _2 = Box::<Windows31JEncoder>::new(move _3) -> bb1; // scope 0 at src/codec/japanese.rs:464:39: 464:66
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:464:39: 464:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::japanese::Windows31JEncoder) -> std::boxed::Box<codec::japanese::Windows31JEncoder> {std::boxed::Box::<codec::japanese::Windows31JEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:464:39: 464:66
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:464:65: 464:66
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:464:65: 464:66
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:464:39: 464:66
        StorageDead(_1);                 // scope 0 at src/codec/japanese.rs:464:67: 464:68
        return;                          // scope 0 at src/codec/japanese.rs:464:68: 464:68
    }
}

const ERROR: &ErrorEncoding = {
    let mut _0: &codec::error::ErrorEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::error::ErrorEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::error::ErrorEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::error::ErrorEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const ERROR::promoted[0];   // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::error::ErrorEncoding
                                         // + val: Unevaluated(ERROR, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::error::ErrorEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1247 ~ encoding[5d2c]::all::ERROR), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in ERROR: &ErrorEncoding = {
    let mut _0: &codec::error::ErrorEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::error::ErrorEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn eucjp::internal::map_two_0208_bytes(_1: u8, _2: u8) -> u32 {
    debug lead => _1;                    // in scope 0 at src/codec/japanese.rs:118:40: 118:44
    debug trail => _2;                   // in scope 0 at src/codec/japanese.rs:118:50: 118:55
    let mut _0: u32;                     // return place in scope 0 at src/codec/japanese.rs:118:64: 118:67
    let _3: u16;                         // in scope 0 at src/codec/japanese.rs:121:13: 121:17
    let mut _4: u8;                      // in scope 0 at src/codec/japanese.rs:121:20: 121:24
    let mut _6: u8;                      // in scope 0 at src/codec/japanese.rs:122:21: 122:26
    let mut _8: (u16, u16);              // in scope 0 at src/codec/japanese.rs:123:27: 123:40
    let mut _9: u16;                     // in scope 0 at src/codec/japanese.rs:123:28: 123:32
    let mut _10: u16;                    // in scope 0 at src/codec/japanese.rs:123:34: 123:39
    let mut _11: bool;                   // in scope 0 at src/codec/japanese.rs:124:27: 124:38
    let mut _12: bool;                   // in scope 0 at src/codec/japanese.rs:124:27: 124:38
    let mut _13: bool;                   // in scope 0 at src/codec/japanese.rs:124:14: 124:25
    let mut _14: bool;                   // in scope 0 at src/codec/japanese.rs:124:14: 124:25
    let mut _15: u16;                    // in scope 0 at src/codec/japanese.rs:124:43: 124:69
    let mut _16: u16;                    // in scope 0 at src/codec/japanese.rs:124:43: 124:61
    let mut _17: u16;                    // in scope 0 at src/codec/japanese.rs:124:43: 124:56
    let mut _18: u16;                    // in scope 0 at src/codec/japanese.rs:124:44: 124:48
    let mut _19: u16;                    // in scope 0 at src/codec/japanese.rs:124:64: 124:69
    let mut _20: u16;                    // in scope 0 at src/codec/japanese.rs:127:33: 127:38
    scope 1 {
        debug lead => _3;                // in scope 1 at src/codec/japanese.rs:121:13: 121:17
        let _5: u16;                     // in scope 1 at src/codec/japanese.rs:122:13: 122:18
        scope 2 {
            debug trail => _5;           // in scope 2 at src/codec/japanese.rs:122:13: 122:18
            let _7: u16;                 // in scope 2 at src/codec/japanese.rs:123:13: 123:18
            scope 3 {
                debug index => _7;       // in scope 3 at src/codec/japanese.rs:123:13: 123:18
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:121:13: 121:17
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:121:20: 121:24
        _4 = _1;                         // scope 0 at src/codec/japanese.rs:121:20: 121:24
        _3 = move _4 as u16 (Misc);      // scope 0 at src/codec/japanese.rs:121:20: 121:31
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:121:30: 121:31
        StorageLive(_5);                 // scope 1 at src/codec/japanese.rs:122:13: 122:18
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:122:21: 122:26
        _6 = _2;                         // scope 1 at src/codec/japanese.rs:122:21: 122:26
        _5 = move _6 as u16 (Misc);      // scope 1 at src/codec/japanese.rs:122:21: 122:33
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:122:32: 122:33
        StorageLive(_7);                 // scope 2 at src/codec/japanese.rs:123:13: 123:18
        StorageLive(_8);                 // scope 2 at src/codec/japanese.rs:123:27: 123:40
        StorageLive(_9);                 // scope 2 at src/codec/japanese.rs:123:28: 123:32
        _9 = _3;                         // scope 2 at src/codec/japanese.rs:123:28: 123:32
        StorageLive(_10);                // scope 2 at src/codec/japanese.rs:123:34: 123:39
        _10 = _5;                        // scope 2 at src/codec/japanese.rs:123:34: 123:39
        (_8.0: u16) = move _9;           // scope 2 at src/codec/japanese.rs:123:27: 123:40
        (_8.1: u16) = move _10;          // scope 2 at src/codec/japanese.rs:123:27: 123:40
        StorageDead(_10);                // scope 2 at src/codec/japanese.rs:123:39: 123:40
        StorageDead(_9);                 // scope 2 at src/codec/japanese.rs:123:39: 123:40
        _13 = Le(const 161_u16, (_8.0: u16)); // scope 2 at src/codec/japanese.rs:124:14: 124:25
        switchInt(move _13) -> [false: bb4, otherwise: bb1]; // scope 2 at src/codec/japanese.rs:124:14: 124:25
    }

    bb1: {
        _14 = Le((_8.0: u16), const 254_u16); // scope 2 at src/codec/japanese.rs:124:14: 124:25
        switchInt(move _14) -> [false: bb4, otherwise: bb2]; // scope 2 at src/codec/japanese.rs:124:14: 124:25
    }

    bb2: {
        _11 = Le(const 161_u16, (_8.1: u16)); // scope 2 at src/codec/japanese.rs:124:27: 124:38
        switchInt(move _11) -> [false: bb4, otherwise: bb3]; // scope 2 at src/codec/japanese.rs:124:27: 124:38
    }

    bb3: {
        _12 = Le((_8.1: u16), const 254_u16); // scope 2 at src/codec/japanese.rs:124:27: 124:38
        switchInt(move _12) -> [false: bb4, otherwise: bb5]; // scope 2 at src/codec/japanese.rs:124:27: 124:38
    }

    bb4: {
        _7 = const u16::MAX;             // scope 2 at src/codec/japanese.rs:125:18: 125:24
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:125:18: 125:24
    }

    bb5: {
        StorageLive(_15);                // scope 2 at src/codec/japanese.rs:124:43: 124:69
        StorageLive(_16);                // scope 2 at src/codec/japanese.rs:124:43: 124:61
        StorageLive(_17);                // scope 2 at src/codec/japanese.rs:124:43: 124:56
        StorageLive(_18);                // scope 2 at src/codec/japanese.rs:124:44: 124:48
        _18 = _3;                        // scope 2 at src/codec/japanese.rs:124:44: 124:48
        _17 = Sub(move _18, const 161_u16); // scope 2 at src/codec/japanese.rs:124:43: 124:56
        StorageDead(_18);                // scope 2 at src/codec/japanese.rs:124:55: 124:56
        _16 = Mul(move _17, const 94_u16); // scope 2 at src/codec/japanese.rs:124:43: 124:61
        StorageDead(_17);                // scope 2 at src/codec/japanese.rs:124:60: 124:61
        StorageLive(_19);                // scope 2 at src/codec/japanese.rs:124:64: 124:69
        _19 = _5;                        // scope 2 at src/codec/japanese.rs:124:64: 124:69
        _15 = Add(move _16, move _19);   // scope 2 at src/codec/japanese.rs:124:43: 124:69
        StorageDead(_19);                // scope 2 at src/codec/japanese.rs:124:68: 124:69
        StorageDead(_16);                // scope 2 at src/codec/japanese.rs:124:68: 124:69
        _7 = Sub(move _15, const 161_u16); // scope 2 at src/codec/japanese.rs:124:43: 124:76
        StorageDead(_15);                // scope 2 at src/codec/japanese.rs:124:75: 124:76
        goto -> bb6;                     // scope 2 at src/codec/japanese.rs:124:75: 124:76
    }

    bb6: {
        StorageDead(_8);                 // scope 2 at src/codec/japanese.rs:126:10: 126:11
        StorageLive(_20);                // scope 3 at src/codec/japanese.rs:127:33: 127:38
        _20 = _7;                        // scope 3 at src/codec/japanese.rs:127:33: 127:38
        _0 = index_japanese::jis0208::forward(move _20) -> bb7; // scope 3 at src/codec/japanese.rs:127:9: 127:39
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:127:9: 127:32
                                         // + literal: Const { ty: fn(u16) -> u32 {index_japanese::jis0208::forward}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_20);                // scope 3 at src/codec/japanese.rs:127:38: 127:39
        StorageDead(_7);                 // scope 2 at src/codec/japanese.rs:128:5: 128:6
        StorageDead(_5);                 // scope 1 at src/codec/japanese.rs:128:5: 128:6
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:128:5: 128:6
        return;                          // scope 0 at src/codec/japanese.rs:128:6: 128:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:51:1: 53:2>::new() -> Box<dyn encoding_types::RawEncoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:52:21: 52:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:52:39: 52:63
    let mut _2: std::boxed::Box<codec::simpchinese::GB18030Encoder>; // in scope 0 at src/codec/simpchinese.rs:52:39: 52:63
    let mut _3: codec::simpchinese::GB18030Encoder; // in scope 0 at src/codec/simpchinese.rs:52:48: 52:62

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/simpchinese.rs:52:39: 52:63
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:52:39: 52:63
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:52:48: 52:62
        _2 = Box::<GB18030Encoder>::new(move _3) -> bb1; // scope 0 at src/codec/simpchinese.rs:52:39: 52:63
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:52:39: 52:47
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::simpchinese::GB18030Encoder) -> std::boxed::Box<codec::simpchinese::GB18030Encoder> {std::boxed::Box::<codec::simpchinese::GB18030Encoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:52:39: 52:63
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:52:62: 52:63
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:52:62: 52:63
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:52:39: 52:63
        StorageDead(_1);                 // scope 0 at src/codec/simpchinese.rs:52:64: 52:65
        return;                          // scope 0 at src/codec/simpchinese.rs:52:65: 52:65
    }
}

fn iso2022jp::raw_feed(_1: iso2022jp::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (iso2022jp::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::japanese::iso2022jp::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _17: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _18: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _19: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _20: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _21: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _22: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:242:64: 242:72
    let mut _23: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _24: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _25: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _26: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _27: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _28: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _29: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _30: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _32: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _33: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _34: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _36: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _37: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _38: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _39: (std::option::Option<encoding_types::CodecError>, codec::japanese::iso2022jp::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _40: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _41: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _42: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _43: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _44: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _45: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _46: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _47: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _48: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _49: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _51: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _52: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _53: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _54: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _55: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _56: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _57: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _58: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _60: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _61: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _62: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _63: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _64: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _65: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _66: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _67: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _68: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:259:68: 259:76
    let mut _69: (std::option::Option<encoding_types::CodecError>, codec::japanese::iso2022jp::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _70: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _71: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _72: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _73: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _74: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _75: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _76: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _77: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _78: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _79: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _81: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _82: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _83: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _84: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _85: codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _86: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _87: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::japanese::iso2022jp::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _31: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            let _35: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _50: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _59: codec::japanese::iso2022jp::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 6 {
                    debug err => _50;    // in scope 6 at src/util.rs:252:27: 252:30
                }
                scope 7 {
                    debug st_ => _59;    // in scope 7 at src/util.rs:256:25: 256:28
                    let _80: encoding_types::CodecError; // in scope 7 at src/util.rs:267:31: 267:34
                    scope 8 {
                        debug err => _80; // in scope 8 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug lead => _31;       // in scope 4 at src/util.rs:245:36: 245:40
            }
            scope 5 {
                debug lead => _35;       // in scope 5 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<iso2022jp::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb6, 2_isize: bb8, 3_isize: bb10, 4_isize: bb12, 5_isize: bb14, 6_isize: bb16, 7_isize: bb18, 8_isize: bb20, 9_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_35);                // scope 2 at src/util.rs:245:36: 245:40
        _35 = ((_1 as Trail0212).1: u8); // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_36);                // scope 5 at src/util.rs:245:62: 245:70
        StorageLive(_37);                // scope 5 at src/util.rs:245:62: 245:70
        _37 = &mut _9;                   // scope 5 at src/util.rs:245:62: 245:70
        _36 = &mut (*_37);               // scope 5 at src/util.rs:245:62: 245:70
        StorageLive(_38);                // scope 5 at src/util.rs:245:75: 245:79
        _38 = _35;                       // scope 5 at src/util.rs:245:75: 245:79
        _15 = iso2022jp::transient::Trail0212::<T>(move _36, move _38) -> [return: bb22, unwind: bb56]; // scope 5 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>, u8) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Trail0212::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb23;                    // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageLive(_17);                // scope 2 at src/util.rs:242:64: 242:72
        StorageLive(_18);                // scope 2 at src/util.rs:242:64: 242:72
        _18 = &mut _9;                   // scope 2 at src/util.rs:242:64: 242:72
        _17 = &mut (*_18);               // scope 2 at src/util.rs:242:64: 242:72
        _15 = iso2022jp::start::Lead0208::<T>(move _17) -> [return: bb7, unwind: bb56]; // scope 2 at src/util.rs:242:58: 242:86
                                         // mir::Constant
                                         // + span: src/util.rs:242:51: 242:63
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::Lead0208::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_18);                // scope 2 at src/util.rs:242:85: 242:86
        StorageDead(_17);                // scope 2 at src/util.rs:242:85: 242:86
        goto -> bb23;                    // scope 2 at src/util.rs:242:85: 242:86
    }

    bb8: {
        StorageLive(_19);                // scope 2 at src/util.rs:242:64: 242:72
        StorageLive(_20);                // scope 2 at src/util.rs:242:64: 242:72
        _20 = &mut _9;                   // scope 2 at src/util.rs:242:64: 242:72
        _19 = &mut (*_20);               // scope 2 at src/util.rs:242:64: 242:72
        _15 = iso2022jp::start::Lead0212::<T>(move _19) -> [return: bb9, unwind: bb56]; // scope 2 at src/util.rs:242:58: 242:86
                                         // mir::Constant
                                         // + span: src/util.rs:242:51: 242:63
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::Lead0212::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_20);                // scope 2 at src/util.rs:242:85: 242:86
        StorageDead(_19);                // scope 2 at src/util.rs:242:85: 242:86
        goto -> bb23;                    // scope 2 at src/util.rs:242:85: 242:86
    }

    bb10: {
        StorageLive(_21);                // scope 2 at src/util.rs:242:64: 242:72
        StorageLive(_22);                // scope 2 at src/util.rs:242:64: 242:72
        _22 = &mut _9;                   // scope 2 at src/util.rs:242:64: 242:72
        _21 = &mut (*_22);               // scope 2 at src/util.rs:242:64: 242:72
        _15 = iso2022jp::start::Katakana::<T>(move _21) -> [return: bb11, unwind: bb56]; // scope 2 at src/util.rs:242:58: 242:86
                                         // mir::Constant
                                         // + span: src/util.rs:242:51: 242:63
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::Katakana::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb11: {
        StorageDead(_22);                // scope 2 at src/util.rs:242:85: 242:86
        StorageDead(_21);                // scope 2 at src/util.rs:242:85: 242:86
        goto -> bb23;                    // scope 2 at src/util.rs:242:85: 242:86
    }

    bb12: {
        StorageLive(_23);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_24);                // scope 2 at src/util.rs:245:62: 245:70
        _24 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _23 = &mut (*_24);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = iso2022jp::transient::EscapeStart::<T>(move _23) -> [return: bb13, unwind: bb56]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeStart::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_24);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_23);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb23;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb14: {
        StorageLive(_25);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_26);                // scope 2 at src/util.rs:245:62: 245:70
        _26 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _25 = &mut (*_26);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = iso2022jp::transient::EscapeMiddle24::<T>(move _25) -> [return: bb15, unwind: bb56]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeMiddle24::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_26);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_25);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb23;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb16: {
        StorageLive(_27);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_28);                // scope 2 at src/util.rs:245:62: 245:70
        _28 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _27 = &mut (*_28);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = iso2022jp::transient::EscapeMiddle28::<T>(move _27) -> [return: bb17, unwind: bb56]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeMiddle28::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_28);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_27);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb23;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb18: {
        StorageLive(_29);                // scope 2 at src/util.rs:245:62: 245:70
        StorageLive(_30);                // scope 2 at src/util.rs:245:62: 245:70
        _30 = &mut _9;                   // scope 2 at src/util.rs:245:62: 245:70
        _29 = &mut (*_30);               // scope 2 at src/util.rs:245:62: 245:70
        _15 = iso2022jp::transient::EscapeFinal::<T>(move _29) -> [return: bb19, unwind: bb56]; // scope 2 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeFinal::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_30);                // scope 2 at src/util.rs:245:81: 245:82
        StorageDead(_29);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb23;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb20: {
        StorageLive(_31);                // scope 2 at src/util.rs:245:36: 245:40
        _31 = ((_1 as Trail0208).1: u8); // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_32);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_33);                // scope 4 at src/util.rs:245:62: 245:70
        _33 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _32 = &mut (*_33);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_34);                // scope 4 at src/util.rs:245:75: 245:79
        _34 = _31;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = iso2022jp::transient::Trail0208::<T>(move _32, move _34) -> [return: bb21, unwind: bb56]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>, u8) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Trail0208::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb21: {
        StorageDead(_34);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_33);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_32);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_31);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb23;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb22: {
        StorageDead(_38);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_37);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_36);                // scope 5 at src/util.rs:245:81: 245:82
        StorageDead(_35);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb23;                    // scope 2 at src/util.rs:245:81: 245:82
    }

    bb23: {
        StorageLive(_39);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_40);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_41);                // scope 3 at src/util.rs:248:24: 248:31
        _41 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _40 = Option::<encoding_types::CodecError>::take(move _41) -> [return: bb24, unwind: bb56]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb24: {
        StorageDead(_41);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_42);                // scope 3 at src/util.rs:248:40: 248:43
        _42 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_39.0: std::option::Option<encoding_types::CodecError>) = move _40; // scope 3 at src/util.rs:248:23: 248:44
        (_39.1: codec::japanese::iso2022jp::State) = move _42; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_42);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_40);                // scope 3 at src/util.rs:248:43: 248:44
        _44 = discriminant((_39.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _44) -> [0_isize: bb25, 1_isize: bb26, otherwise: bb27]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb25: {
        _43 = discriminant((_39.1: codec::japanese::iso2022jp::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _43) -> [0_isize: bb28, 1_isize: bb28, 2_isize: bb28, 3_isize: bb28, otherwise: bb29]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb26: {
        StorageLive(_50);                // scope 3 at src/util.rs:252:27: 252:30
        _50 = move (((_39.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_51);                // scope 6 at src/util.rs:252:49: 252:52
        _51 = _15;                       // scope 6 at src/util.rs:252:49: 252:52
        StorageLive(_52);                // scope 6 at src/util.rs:252:54: 252:63
        _52 = _14;                       // scope 6 at src/util.rs:252:54: 252:63
        StorageLive(_53);                // scope 6 at src/util.rs:252:65: 252:74
        StorageLive(_54);                // scope 6 at src/util.rs:252:70: 252:73
        _54 = move _50;                  // scope 6 at src/util.rs:252:70: 252:73
        ((_53 as Some).0: encoding_types::CodecError) = move _54; // scope 6 at src/util.rs:252:65: 252:74
        discriminant(_53) = 1;           // scope 6 at src/util.rs:252:65: 252:74
        StorageDead(_54);                // scope 6 at src/util.rs:252:73: 252:74
        (_0.0: codec::japanese::iso2022jp::State) = move _51; // scope 6 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _52;        // scope 6 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _53; // scope 6 at src/util.rs:252:48: 252:75
        StorageDead(_53);                // scope 6 at src/util.rs:252:74: 252:75
        StorageDead(_52);                // scope 6 at src/util.rs:252:74: 252:75
        StorageDead(_51);                // scope 6 at src/util.rs:252:74: 252:75
        StorageDead(_50);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb52;                    // scope 3 at no-location
    }

    bb27: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb28: {
        StorageLive(_45);                // scope 3 at src/util.rs:249:70: 249:73
        _45 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _45;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_45);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_46);                // scope 3 at src/util.rs:249:87: 249:94
        _46 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _46;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_46);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_39);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb30;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb29: {
        StorageLive(_47);                // scope 3 at src/util.rs:251:44: 251:47
        _47 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_48);                // scope 3 at src/util.rs:251:49: 251:58
        _48 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_49);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_49) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::japanese::iso2022jp::State) = move _47; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _48;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _49; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_49);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_48);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_47);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb52;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb30: {
        StorageLive(_55);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_56);                // scope 3 at src/util.rs:255:23: 255:30
        _56 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_57);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_58);                // scope 3 at src/util.rs:255:33: 255:40
        _58 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _57 = core::slice::<impl [u8]>::len(move _58) -> [return: bb31, unwind: bb56]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb31: {
        StorageDead(_58);                // scope 3 at src/util.rs:255:45: 255:46
        _55 = Lt(move _56, move _57);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_57);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_56);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _55) -> [false: bb49, otherwise: bb32]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb32: {
        StorageLive(_59);                // scope 3 at src/util.rs:256:25: 256:28
        _60 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _60) -> [0_isize: bb34, 1_isize: bb36, 2_isize: bb38, 3_isize: bb40, otherwise: bb33]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb33: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb56; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb34: {
        StorageLive(_61);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_62);                // scope 3 at src/util.rs:257:49: 257:57
        _62 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _61 = &mut (*_62);               // scope 3 at src/util.rs:257:49: 257:57
        _59 = iso2022jp::start::ASCII::<T>(move _61) -> [return: bb35, unwind: bb56]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::ASCII::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb35: {
        StorageDead(_62);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_61);                // scope 3 at src/util.rs:257:57: 257:58
        goto -> bb42;                    // scope 3 at src/util.rs:257:57: 257:58
    }

    bb36: {
        StorageLive(_63);                // scope 3 at src/util.rs:259:68: 259:76
        StorageLive(_64);                // scope 3 at src/util.rs:259:68: 259:76
        _64 = &mut _9;                   // scope 3 at src/util.rs:259:68: 259:76
        _63 = &mut (*_64);               // scope 3 at src/util.rs:259:68: 259:76
        _59 = iso2022jp::start::Lead0208::<T>(move _63) -> [return: bb37, unwind: bb56]; // scope 3 at src/util.rs:259:62: 259:90
                                         // mir::Constant
                                         // + span: src/util.rs:259:55: 259:67
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::Lead0208::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb37: {
        StorageDead(_64);                // scope 3 at src/util.rs:259:89: 259:90
        StorageDead(_63);                // scope 3 at src/util.rs:259:89: 259:90
        goto -> bb42;                    // scope 3 at src/util.rs:259:89: 259:90
    }

    bb38: {
        StorageLive(_65);                // scope 3 at src/util.rs:259:68: 259:76
        StorageLive(_66);                // scope 3 at src/util.rs:259:68: 259:76
        _66 = &mut _9;                   // scope 3 at src/util.rs:259:68: 259:76
        _65 = &mut (*_66);               // scope 3 at src/util.rs:259:68: 259:76
        _59 = iso2022jp::start::Lead0212::<T>(move _65) -> [return: bb39, unwind: bb56]; // scope 3 at src/util.rs:259:62: 259:90
                                         // mir::Constant
                                         // + span: src/util.rs:259:55: 259:67
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::Lead0212::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb39: {
        StorageDead(_66);                // scope 3 at src/util.rs:259:89: 259:90
        StorageDead(_65);                // scope 3 at src/util.rs:259:89: 259:90
        goto -> bb42;                    // scope 3 at src/util.rs:259:89: 259:90
    }

    bb40: {
        StorageLive(_67);                // scope 3 at src/util.rs:259:68: 259:76
        StorageLive(_68);                // scope 3 at src/util.rs:259:68: 259:76
        _68 = &mut _9;                   // scope 3 at src/util.rs:259:68: 259:76
        _67 = &mut (*_68);               // scope 3 at src/util.rs:259:68: 259:76
        _59 = iso2022jp::start::Katakana::<T>(move _67) -> [return: bb41, unwind: bb56]; // scope 3 at src/util.rs:259:62: 259:90
                                         // mir::Constant
                                         // + span: src/util.rs:259:55: 259:67
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::start::Katakana::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb41: {
        StorageDead(_68);                // scope 3 at src/util.rs:259:89: 259:90
        StorageDead(_67);                // scope 3 at src/util.rs:259:89: 259:90
        goto -> bb42;                    // scope 3 at src/util.rs:259:89: 259:90
    }

    bb42: {
        StorageLive(_69);                // scope 7 at src/util.rs:263:27: 263:48
        StorageLive(_70);                // scope 7 at src/util.rs:263:28: 263:42
        StorageLive(_71);                // scope 7 at src/util.rs:263:28: 263:35
        _71 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 7 at src/util.rs:263:28: 263:35
        _70 = Option::<encoding_types::CodecError>::take(move _71) -> [return: bb43, unwind: bb56]; // scope 7 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb43: {
        StorageDead(_71);                // scope 7 at src/util.rs:263:41: 263:42
        StorageLive(_72);                // scope 7 at src/util.rs:263:44: 263:47
        _72 = _59;                       // scope 7 at src/util.rs:263:44: 263:47
        (_69.0: std::option::Option<encoding_types::CodecError>) = move _70; // scope 7 at src/util.rs:263:27: 263:48
        (_69.1: codec::japanese::iso2022jp::State) = move _72; // scope 7 at src/util.rs:263:27: 263:48
        StorageDead(_72);                // scope 7 at src/util.rs:263:47: 263:48
        StorageDead(_70);                // scope 7 at src/util.rs:263:47: 263:48
        _74 = discriminant((_69.0: std::option::Option<encoding_types::CodecError>)); // scope 7 at src/util.rs:263:27: 263:48
        switchInt(move _74) -> [0_isize: bb44, 1_isize: bb45, otherwise: bb46]; // scope 7 at src/util.rs:263:21: 263:48
    }

    bb44: {
        _73 = discriminant((_69.1: codec::japanese::iso2022jp::State)); // scope 7 at src/util.rs:263:27: 263:48
        switchInt(move _73) -> [0_isize: bb47, 1_isize: bb47, 2_isize: bb47, 3_isize: bb47, otherwise: bb48]; // scope 7 at src/util.rs:263:21: 263:48
    }

    bb45: {
        StorageLive(_80);                // scope 7 at src/util.rs:267:31: 267:34
        _80 = move (((_69.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 7 at src/util.rs:267:31: 267:34
        StorageLive(_81);                // scope 8 at src/util.rs:267:53: 267:56
        _81 = _59;                       // scope 8 at src/util.rs:267:53: 267:56
        StorageLive(_82);                // scope 8 at src/util.rs:267:58: 267:67
        _82 = _14;                       // scope 8 at src/util.rs:267:58: 267:67
        StorageLive(_83);                // scope 8 at src/util.rs:267:69: 267:78
        StorageLive(_84);                // scope 8 at src/util.rs:267:74: 267:77
        _84 = move _80;                  // scope 8 at src/util.rs:267:74: 267:77
        ((_83 as Some).0: encoding_types::CodecError) = move _84; // scope 8 at src/util.rs:267:69: 267:78
        discriminant(_83) = 1;           // scope 8 at src/util.rs:267:69: 267:78
        StorageDead(_84);                // scope 8 at src/util.rs:267:77: 267:78
        (_0.0: codec::japanese::iso2022jp::State) = move _81; // scope 8 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _82;        // scope 8 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _83; // scope 8 at src/util.rs:267:52: 267:79
        StorageDead(_83);                // scope 8 at src/util.rs:267:78: 267:79
        StorageDead(_82);                // scope 8 at src/util.rs:267:78: 267:79
        StorageDead(_81);                // scope 8 at src/util.rs:267:78: 267:79
        StorageDead(_80);                // scope 7 at src/util.rs:267:81: 267:82
        goto -> bb51;                    // scope 7 at no-location
    }

    bb46: {
        unreachable;                     // scope 7 at src/util.rs:263:27: 263:48
    }

    bb47: {
        StorageLive(_75);                // scope 7 at src/util.rs:264:74: 264:77
        _75 = _59;                       // scope 7 at src/util.rs:264:74: 264:77
        _1 = move _75;                   // scope 7 at src/util.rs:264:69: 264:77
        StorageDead(_75);                // scope 7 at src/util.rs:264:76: 264:77
        StorageLive(_76);                // scope 7 at src/util.rs:264:91: 264:98
        _76 = (_9.1: usize);             // scope 7 at src/util.rs:264:91: 264:98
        _14 = move _76;                  // scope 7 at src/util.rs:264:79: 264:98
        StorageDead(_76);                // scope 7 at src/util.rs:264:97: 264:98
        StorageDead(_59);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_69);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_55);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb30;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb48: {
        StorageLive(_77);                // scope 7 at src/util.rs:266:48: 266:51
        _77 = _59;                       // scope 7 at src/util.rs:266:48: 266:51
        StorageLive(_78);                // scope 7 at src/util.rs:266:53: 266:62
        _78 = _14;                       // scope 7 at src/util.rs:266:53: 266:62
        StorageLive(_79);                // scope 7 at src/util.rs:266:64: 266:68
        discriminant(_79) = 0;           // scope 7 at src/util.rs:266:64: 266:68
        (_0.0: codec::japanese::iso2022jp::State) = move _77; // scope 7 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _78;        // scope 7 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _79; // scope 7 at src/util.rs:266:47: 266:69
        StorageDead(_79);                // scope 7 at src/util.rs:266:68: 266:69
        StorageDead(_78);                // scope 7 at src/util.rs:266:68: 266:69
        StorageDead(_77);                // scope 7 at src/util.rs:266:68: 266:69
        goto -> bb51;                    // scope 7 at src/util.rs:266:40: 266:69
    }

    bb49: {
        StorageDead(_55);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_85);                // scope 3 at src/util.rs:271:18: 271:20
        _85 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_86);                // scope 3 at src/util.rs:271:22: 271:31
        _86 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_87);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_87) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::japanese::iso2022jp::State) = move _85; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _86;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _87; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_87);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_86);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_85);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb50;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb50: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb55;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb51: {
        StorageDead(_59);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_69);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_55);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb53;                    // scope 3 at no-location
    }

    bb52: {
        StorageDead(_39);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb53;                    // scope 3 at no-location
    }

    bb53: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb54;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb54: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb55;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb55: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb56 (cleanup): {
        drop(_9) -> bb57;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb57 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

fn iso2022jp::State::EscapeStart(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeStart).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 4;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

// MIR FOR CTFE
fn iso2022jp::State::EscapeStart(_1: ()) -> iso2022jp::State {
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:164:21: 164:38

    bb0: {
        ((_0 as EscapeStart).0: ()) = move _1; // scope 0 at src/util.rs:164:21: 164:38
        discriminant(_0) = 4;            // scope 0 at src/util.rs:164:21: 164:38
        return;                          // scope 0 at src/util.rs:164:21: 164:38
    }
}

fn japanese::<impl at src/codec/japanese.rs:32:1: 37:2>::name(_1: &EUCJPEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:33:13: 33:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/japanese.rs:33:23: 33:35

    bb0: {
        _0 = const "euc-jp";             // scope 0 at src/codec/japanese.rs:33:38: 33:46
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:33:38: 33:46
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 117, 99, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [63], len: Size { raw: 6 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 6 }) }
        return;                          // scope 0 at src/codec/japanese.rs:33:48: 33:48
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:88:1: 92:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/utf_8.rs:89:21: 89:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/utf_8.rs:90:9: 90:83
    let mut _2: std::boxed::Box<codec::utf_8::UTF8Decoder>; // in scope 0 at src/codec/utf_8.rs:90:9: 90:83
    let mut _3: codec::utf_8::UTF8Decoder; // in scope 0 at src/codec/utf_8.rs:90:18: 90:82
    let mut _4: [u8; 4];                 // in scope 0 at src/codec/utf_8.rs:90:52: 90:58

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/utf_8.rs:90:9: 90:83
        StorageLive(_2);                 // scope 0 at src/codec/utf_8.rs:90:9: 90:83
        StorageLive(_3);                 // scope 0 at src/codec/utf_8.rs:90:18: 90:82
        StorageLive(_4);                 // scope 0 at src/codec/utf_8.rs:90:52: 90:58
        _4 = [const 0_u8; 4];            // scope 0 at src/codec/utf_8.rs:90:52: 90:58
        (_3.0: usize) = const 0_usize;   // scope 0 at src/codec/utf_8.rs:90:18: 90:82
        (_3.1: [u8; 4]) = move _4;       // scope 0 at src/codec/utf_8.rs:90:18: 90:82
        (_3.2: u8) = const 0_u8;         // scope 0 at src/codec/utf_8.rs:90:18: 90:82
        StorageDead(_4);                 // scope 0 at src/codec/utf_8.rs:90:81: 90:82
        _2 = Box::<UTF8Decoder>::new(move _3) -> bb1; // scope 0 at src/codec/utf_8.rs:90:9: 90:83
                                         // mir::Constant
                                         // + span: src/codec/utf_8.rs:90:9: 90:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::utf_8::UTF8Decoder) -> std::boxed::Box<codec::utf_8::UTF8Decoder> {std::boxed::Box::<codec::utf_8::UTF8Decoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:90:9: 90:83
        StorageDead(_3);                 // scope 0 at src/codec/utf_8.rs:90:82: 90:83
        StorageDead(_2);                 // scope 0 at src/codec/utf_8.rs:90:82: 90:83
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_8.rs:90:9: 90:83
        StorageDead(_1);                 // scope 0 at src/codec/utf_8.rs:91:5: 91:6
        return;                          // scope 0 at src/codec/utf_8.rs:91:6: 91:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:864:1: 879:2>::from_self(_1: &ISO2022JPDecoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:865:18: 865:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:865:28: 865:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:865:46: 865:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:865:46: 865:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:865:46: 865:69
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:865:46: 865:69
        _3 = ISO2022JPDecoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:865:46: 865:69
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:865:46: 865:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::japanese::ISO2022JPDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:865:46: 865:69
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:865:68: 865:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:865:46: 865:69
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:865:70: 865:71
        return;                          // scope 0 at src/codec/japanese.rs:865:71: 865:71
    }
}

fn hz::start::B0(_1: &mut StatefulDecoderHelper<hz::State, T>) -> hz::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:193:37: 193:43
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:193:85: 193:97
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:196:31: 196:44
    let mut _3: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/util.rs:196:31: 196:37
    let mut _4: isize;                   // in scope 0 at src/util.rs:197:29: 197:33
    let _5: u8;                          // in scope 0 at src/util.rs:198:34: 198:35
    let mut _6: bool;                    // in scope 0 at src/codec/simpchinese.rs:592:18: 592:29
    let mut _7: bool;                    // in scope 0 at src/codec/simpchinese.rs:592:18: 592:29
    let mut _8: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:591:25: 591:28
    let mut _10: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:592:36: 592:39
    let mut _11: u8;                     // in scope 0 at src/codec/simpchinese.rs:592:41: 592:42
    let mut _12: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:593:22: 593:25
    let _13: codec::simpchinese::hz::State; // in scope 0 at src/codec/simpchinese.rs:594:19: 594:46
    let mut _14: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:594:19: 594:22
    let mut _15: &mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>; // in scope 0 at src/codec/simpchinese.rs:594:51: 594:54
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:198:34: 198:35
        let _9: u8;                      // in scope 1 at src/codec/simpchinese.rs:592:14: 592:29
        scope 2 {
            debug b => _9;               // in scope 2 at src/codec/simpchinese.rs:592:14: 592:29
        }
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:196:31: 196:44
        StorageLive(_3);                 // scope 0 at src/util.rs:196:31: 196:37
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:196:31: 196:37
        _2 = StatefulDecoderHelper::<hz::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:196:31: 196:44
                                         // mir::Constant
                                         // + span: src/util.rs:196:38: 196:42
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:196:43: 196:44
        _4 = discriminant(_2);           // scope 0 at src/util.rs:196:31: 196:44
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:196:25: 196:44
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:198:34: 198:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:198:34: 198:35
        switchInt(_5) -> [126_u8: bb9, otherwise: bb5]; // scope 1 at src/util.rs:198:40: 198:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:196:31: 196:44
    }

    bb4: {
        discriminant(_0) = 1;            // scope 0 at src/util.rs:197:44: 197:66
        goto -> bb18;                    // scope 0 at src/util.rs:197:65: 197:66
    }

    bb5: {
        _6 = Le(const 32_u8, _5);        // scope 1 at src/codec/simpchinese.rs:592:18: 592:29
        switchInt(move _6) -> [false: bb7, otherwise: bb6]; // scope 1 at src/codec/simpchinese.rs:592:18: 592:29
    }

    bb6: {
        _7 = Le(_5, const 127_u8);       // scope 1 at src/codec/simpchinese.rs:592:18: 592:29
        switchInt(move _7) -> [false: bb7, otherwise: bb11]; // scope 1 at src/codec/simpchinese.rs:592:18: 592:29
    }

    bb7: {
        switchInt(_5) -> [10_u8: bb13, otherwise: bb8]; // scope 1 at src/util.rs:198:40: 198:47
    }

    bb8: {
        StorageLive(_13);                // scope 1 at src/codec/simpchinese.rs:594:19: 594:46
        StorageLive(_14);                // scope 1 at src/codec/simpchinese.rs:594:19: 594:22
        _14 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:594:19: 594:22
        _13 = StatefulDecoderHelper::<hz::State, T>::err(move _14, const "invalid sequence") -> bb15; // scope 1 at src/codec/simpchinese.rs:594:19: 594:46
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:594:23: 594:26
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:594:27: 594:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb9: {
        StorageLive(_8);                 // scope 1 at src/codec/simpchinese.rs:591:25: 591:28
        _8 = &mut (*_1);                 // scope 1 at src/codec/simpchinese.rs:591:25: 591:28
        _0 = hz::transient::B1::<T>(move _8) -> bb10; // scope 1 at src/codec/simpchinese.rs:591:22: 591:29
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:591:22: 591:24
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_8);                 // scope 1 at src/codec/simpchinese.rs:591:28: 591:29
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:591:28: 591:29
    }

    bb11: {
        StorageLive(_9);                 // scope 1 at src/codec/simpchinese.rs:592:14: 592:29
        _9 = _5;                         // scope 1 at src/codec/simpchinese.rs:592:14: 592:29
        StorageLive(_10);                // scope 2 at src/codec/simpchinese.rs:592:36: 592:39
        _10 = &mut (*_1);                // scope 2 at src/codec/simpchinese.rs:592:36: 592:39
        StorageLive(_11);                // scope 2 at src/codec/simpchinese.rs:592:41: 592:42
        _11 = _9;                        // scope 2 at src/codec/simpchinese.rs:592:41: 592:42
        _0 = hz::transient::B2::<T>(move _10, move _11) -> bb12; // scope 2 at src/codec/simpchinese.rs:592:33: 592:43
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:592:33: 592:35
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>, u8) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B2::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_11);                // scope 2 at src/codec/simpchinese.rs:592:42: 592:43
        StorageDead(_10);                // scope 2 at src/codec/simpchinese.rs:592:42: 592:43
        StorageDead(_9);                 // scope 1 at src/util.rs:198:81: 198:82
        goto -> bb17;                    // scope 1 at src/util.rs:198:81: 198:82
    }

    bb13: {
        StorageLive(_12);                // scope 1 at src/codec/simpchinese.rs:593:22: 593:25
        _12 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:593:22: 593:25
        _0 = StatefulDecoderHelper::<hz::State, T>::err(move _12, const "invalid sequence") -> bb14; // scope 1 at src/codec/simpchinese.rs:593:22: 593:49
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:593:26: 593:29
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::simpchinese::hz::State, T>, &'static str) -> codec::simpchinese::hz::State {util::StatefulDecoderHelper::<codec::simpchinese::hz::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:593:30: 593:48
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb14: {
        StorageDead(_12);                // scope 1 at src/codec/simpchinese.rs:593:48: 593:49
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:593:48: 593:49
    }

    bb15: {
        StorageDead(_14);                // scope 1 at src/codec/simpchinese.rs:594:45: 594:46
        StorageDead(_13);                // scope 1 at src/util.rs:198:76: 198:77
        StorageLive(_15);                // scope 1 at src/codec/simpchinese.rs:594:51: 594:54
        _15 = &mut (*_1);                // scope 1 at src/codec/simpchinese.rs:594:51: 594:54
        _0 = hz::transient::B0::<T>(move _15) -> bb16; // scope 1 at src/codec/simpchinese.rs:594:48: 594:55
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:594:48: 594:50
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::simpchinese::hz::State, T>) -> codec::simpchinese::hz::State {codec::simpchinese::hz::transient::B0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb16: {
        StorageDead(_15);                // scope 1 at src/codec/simpchinese.rs:594:54: 594:55
        goto -> bb17;                    // scope 1 at src/codec/simpchinese.rs:594:54: 594:55
    }

    bb17: {
        StorageDead(_5);                 // scope 0 at src/util.rs:198:85: 198:86
        goto -> bb18;                    // scope 0 at src/util.rs:198:85: 198:86
    }

    bb18: {
        StorageDead(_2);                 // scope 0 at src/util.rs:200:21: 200:22
        return;                          // scope 0 at src/util.rs:200:22: 200:22
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:104:1: 113:2>::raw_feed::{closure#0}(_1: &[closure@src/codec/utf_16.rs:107:46: 110:10], _2: &mut dyn encoding_types::ByteWriter, _3: u8, _4: u8) -> () {
    debug output => _2;                  // in scope 0 at src/codec/utf_16.rs:107:47: 107:53
    debug msb => _3;                     // in scope 0 at src/codec/utf_16.rs:107:72: 107:75
    debug lsb => _4;                     // in scope 0 at src/codec/utf_16.rs:107:81: 107:84
    let mut _0: ();                      // return place in scope 0 at src/codec/utf_16.rs:107:90: 107:90
    let _5: ();                          // in scope 0 at src/codec/utf_16.rs:108:13: 108:35
    let mut _6: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:108:13: 108:19
    let mut _7: u8;                      // in scope 0 at src/codec/utf_16.rs:108:31: 108:34
    let _8: ();                          // in scope 0 at src/codec/utf_16.rs:109:13: 109:35
    let mut _9: &mut dyn encoding_types::ByteWriter; // in scope 0 at src/codec/utf_16.rs:109:13: 109:19
    let mut _10: u8;                     // in scope 0 at src/codec/utf_16.rs:109:31: 109:34

    bb0: {
        StorageLive(_5);                 // scope 0 at src/codec/utf_16.rs:108:13: 108:35
        StorageLive(_6);                 // scope 0 at src/codec/utf_16.rs:108:13: 108:19
        _6 = &mut (*_2);                 // scope 0 at src/codec/utf_16.rs:108:13: 108:19
        StorageLive(_7);                 // scope 0 at src/codec/utf_16.rs:108:31: 108:34
        _7 = _3;                         // scope 0 at src/codec/utf_16.rs:108:31: 108:34
        _5 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _6, move _7) -> bb1; // scope 0 at src/codec/utf_16.rs:108:13: 108:35
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:108:20: 108:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/codec/utf_16.rs:108:34: 108:35
        StorageDead(_6);                 // scope 0 at src/codec/utf_16.rs:108:34: 108:35
        StorageDead(_5);                 // scope 0 at src/codec/utf_16.rs:108:35: 108:36
        StorageLive(_8);                 // scope 0 at src/codec/utf_16.rs:109:13: 109:35
        StorageLive(_9);                 // scope 0 at src/codec/utf_16.rs:109:13: 109:19
        _9 = &mut (*_2);                 // scope 0 at src/codec/utf_16.rs:109:13: 109:19
        StorageLive(_10);                // scope 0 at src/codec/utf_16.rs:109:31: 109:34
        _10 = _4;                        // scope 0 at src/codec/utf_16.rs:109:31: 109:34
        _8 = <dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte(move _9, move _10) -> bb2; // scope 0 at src/codec/utf_16.rs:109:13: 109:35
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:109:20: 109:30
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::ByteWriter, u8) {<dyn encoding_types::ByteWriter as encoding_types::ByteWriter>::write_byte}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_10);                // scope 0 at src/codec/utf_16.rs:109:34: 109:35
        StorageDead(_9);                 // scope 0 at src/codec/utf_16.rs:109:34: 109:35
        StorageDead(_8);                 // scope 0 at src/codec/utf_16.rs:109:35: 109:36
        return;                          // scope 0 at src/codec/utf_16.rs:110:10: 110:10
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:465:1: 470:2>::raw_decoder(_1: &HZEncoding) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:469:20: 469:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/simpchinese.rs:469:30: 469:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:469:48: 469:64
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/simpchinese.rs:469:48: 469:64

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:469:48: 469:64
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:469:48: 469:64
        _3 = HZDecoder::new() -> bb1;    // scope 0 at src/codec/simpchinese.rs:469:48: 469:64
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:469:48: 469:62
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::simpchinese::HZDecoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:469:48: 469:64
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:469:63: 469:64
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:469:48: 469:64
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:469:65: 469:66
        return;                          // scope 0 at src/codec/simpchinese.rs:469:66: 469:66
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:20:1: 24:2>::name(_1: &ASCIIEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:21:13: 21:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/ascii.rs:21:23: 21:35

    bb0: {
        _0 = const "ascii";              // scope 0 at src/codec/ascii.rs:21:38: 21:45
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [97, 115, 99, 105, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/codec/ascii.rs:21:38: 21:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [97, 115, 99, 105, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
        return;                          // scope 0 at src/codec/ascii.rs:21:47: 21:47
    }
}

fn tradchinese::<impl at src/codec/tradchinese.rs:79:10: 79:15>::clone(_1: &BigFive2003HKSCS2008Decoder) -> BigFive2003HKSCS2008Decoder {
    debug self => _1;                    // in scope 0 at src/codec/tradchinese.rs:79:10: 79:15
    let mut _0: codec::tradchinese::BigFive2003HKSCS2008Decoder; // return place in scope 0 at src/codec/tradchinese.rs:79:10: 79:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/tradchinese.rs:79:10: 79:15
        return;                          // scope 0 at src/codec/tradchinese.rs:79:15: 79:15
    }
}

const UTF_16LE: &UTF16LEEncoding = {
    let mut _0: &codec::utf_16::UTF16LEEncoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const UTF_16LE::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16LEEncoding
                                         // + val: Unevaluated(UTF_16LE, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::utf_16::UTF16LEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1278 ~ encoding[5d2c]::all::UTF_16LE), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in UTF_16LE: &UTF16LEEncoding = {
    let mut _0: &codec::utf_16::UTF16LEEncoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::utf_16::UTF16LEEncoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

const ISO_8859_5: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:29:38: 29:84
    let _1: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14
    let _2: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _3: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _4: &str;                    // in scope 0 at src/all.rs:46:64: 46:76
    let _5: &str;                        // in scope 0 at src/all.rs:46:64: 46:76
    let mut _6: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _7: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56
    let mut _8: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:13: 35:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:30:13: 35:14
        _8 = const ISO_8859_5::promoted[0]; // scope 0 at src/all.rs:30:13: 35:14
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_5, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:30:13: 35:14
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1254 ~ encoding[5d2c]::all::ISO_8859_5), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_8);                     // scope 0 at src/all.rs:30:13: 35:14
        _0 = &(*_1);                     // scope 0 at src/all.rs:30:13: 35:14
        StorageDead(_1);                 // scope 0 at src/all.rs:35:13: 35:14
        return;                          // scope 0 at src/all.rs:29:22: 35:15
    }
}

promoted[0] in ISO_8859_5: &SingleByteEncoding = {
    let mut _0: &codec::singlebyte::SingleByteEncoding; // return place in scope 0 at src/all.rs:30:13: 35:14
    let mut _1: codec::singlebyte::SingleByteEncoding; // in scope 0 at src/all.rs:30:14: 35:14
    let mut _2: std::option::Option<&str>; // in scope 0 at src/all.rs:25:82: 25:93
    let mut _3: &str;                    // in scope 0 at src/all.rs:46:64: 46:76
    let mut _4: &str;                    // in scope 0 at src/all.rs:46:64: 46:76
    let mut _5: fn(u8) -> u16;           // in scope 0 at src/all.rs:33:34: 33:54
    let mut _6: fn(u32) -> u8;           // in scope 0 at src/all.rs:34:35: 34:56

    bb0: {
        _4 = const "iso-8859-5";         // scope 0 at src/all.rs:46:64: 46:76
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:46:64: 46:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        _3 = &(*_4);                     // scope 0 at src/all.rs:46:64: 46:76
        ((_2 as Some).0: &str) = move _3; // scope 0 at src/all.rs:25:82: 25:93
        discriminant(_2) = 1;            // scope 0 at src/all.rs:25:82: 25:93
        _5 = index_singlebyte::iso_8859_5::forward as fn(u8) -> u16 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:33:34: 33:54
                                         // mir::Constant
                                         // + span: src/all.rs:33:34: 33:54
                                         // + literal: Const { ty: fn(u8) -> u16 {index_singlebyte::iso_8859_5::forward}, val: Value(Scalar(<ZST>)) }
        _6 = index_singlebyte::iso_8859_5::backward as fn(u32) -> u8 (Pointer(ReifyFnPointer)); // scope 0 at src/all.rs:34:35: 34:56
                                         // mir::Constant
                                         // + span: src/all.rs:34:35: 34:56
                                         // + literal: Const { ty: fn(u32) -> u8 {index_singlebyte::iso_8859_5::backward}, val: Value(Scalar(<ZST>)) }
        (_1.0: &str) = const "iso-8859-5"; // scope 0 at src/all.rs:30:14: 35:14
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 })
                                         // mir::Constant
                                         // + span: src/all.rs:46:64: 46:76
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 56, 56, 53, 57, 45, 53], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1023], len: Size { raw: 10 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 10 }) }
        (_1.1: std::option::Option<&str>) = move _2; // scope 0 at src/all.rs:30:14: 35:14
        (_1.2: fn(u8) -> u16) = move _5; // scope 0 at src/all.rs:30:14: 35:14
        (_1.3: fn(u32) -> u8) = move _6; // scope 0 at src/all.rs:30:14: 35:14
        _0 = &_1;                        // scope 0 at src/all.rs:30:13: 35:14
        return;                          // scope 0 at src/all.rs:30:13: 35:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:514:1: 518:2>::new() -> Box<dyn encoding_types::RawDecoder> {
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:515:21: 515:36
    let mut _1: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:516:9: 516:63
    let mut _2: std::boxed::Box<codec::japanese::Windows31JDecoder>; // in scope 0 at src/codec/japanese.rs:516:9: 516:63
    let mut _3: codec::japanese::Windows31JDecoder; // in scope 0 at src/codec/japanese.rs:516:18: 516:62
    let mut _4: codec::japanese::windows31j::State; // in scope 0 at src/codec/japanese.rs:516:42: 516:60

    bb0: {
        StorageLive(_1);                 // scope 0 at src/codec/japanese.rs:516:9: 516:63
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:516:9: 516:63
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:516:18: 516:62
        StorageLive(_4);                 // scope 0 at src/codec/japanese.rs:516:42: 516:60
        _4 = <windows31j::State as Default>::default() -> bb1; // scope 0 at src/codec/japanese.rs:516:42: 516:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:516:42: 516:58
                                         // + literal: Const { ty: fn() -> codec::japanese::windows31j::State {<codec::japanese::windows31j::State as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        (_3.0: codec::japanese::windows31j::State) = move _4; // scope 0 at src/codec/japanese.rs:516:18: 516:62
        StorageDead(_4);                 // scope 0 at src/codec/japanese.rs:516:61: 516:62
        _2 = Box::<Windows31JDecoder>::new(move _3) -> bb2; // scope 0 at src/codec/japanese.rs:516:9: 516:63
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:516:9: 516:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::japanese::Windows31JDecoder) -> std::boxed::Box<codec::japanese::Windows31JDecoder> {std::boxed::Box::<codec::japanese::Windows31JDecoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        _1 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:516:9: 516:63
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:516:62: 516:63
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:516:62: 516:63
        _0 = move _1 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:516:9: 516:63
        StorageDead(_1);                 // scope 0 at src/codec/japanese.rs:517:5: 517:6
        return;                          // scope 0 at src/codec/japanese.rs:517:6: 517:6
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:473:10: 473:15>::clone(_1: &HZEncoder) -> HZEncoder {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:473:10: 473:15
    let mut _0: codec::simpchinese::HZEncoder; // return place in scope 0 at src/codec/simpchinese.rs:473:10: 473:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/simpchinese.rs:473:10: 473:15
        return;                          // scope 0 at src/codec/simpchinese.rs:473:15: 473:15
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:22:1: 27:2>::name(_1: &UTF16LEEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:23:13: 23:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/utf_16.rs:23:23: 23:35

    bb0: {
        _0 = const "utf-16le";           // scope 0 at src/codec/utf_16.rs:23:38: 23:48
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 108, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:23:38: 23:48
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 116, 102, 45, 49, 54, 108, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }
        return;                          // scope 0 at src/codec/utf_16.rs:23:50: 23:50
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:84:1: 89:2>::name(_1: &GBKEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:85:13: 85:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/simpchinese.rs:85:23: 85:35

    bb0: {
        _0 = const "gbk";                // scope 0 at src/codec/simpchinese.rs:85:38: 85:43
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 })
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:85:38: 85:43
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [103, 98, 107], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [7], len: Size { raw: 3 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 3 }) }
        return;                          // scope 0 at src/codec/simpchinese.rs:85:45: 85:45
    }
}

fn codec::error::<impl at src/codec/error.rs:14:1: 18:2>::name(_1: &ErrorEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:15:13: 15:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/error.rs:15:23: 15:35

    bb0: {
        _0 = const "error";              // scope 0 at src/codec/error.rs:15:38: 15:45
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [101, 114, 114, 111, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 })
                                         // mir::Constant
                                         // + span: src/codec/error.rs:15:38: 15:45
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 114, 114, 111, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 5 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 5 }) }
        return;                          // scope 0 at src/codec/error.rs:15:47: 15:47
    }
}

fn japanese::<impl at src/codec/japanese.rs:47:1: 84:2>::from_self(_1: &EUCJPEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:48:18: 48:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/japanese.rs:48:28: 48:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:48:46: 48:65
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/japanese.rs:48:46: 48:65

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:48:46: 48:65
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:48:46: 48:65
        _3 = EUCJPEncoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:48:46: 48:65
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:48:46: 48:63
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::japanese::EUCJPEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:48:46: 48:65
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:48:64: 48:65
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:48:46: 48:65
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:48:66: 48:67
        return;                          // scope 0 at src/codec/japanese.rs:48:67: 48:67
    }
}

static ACCEPT_STATE: u8 = {
    let mut _0: u8;                      // return place in scope 0 at src/codec/utf_8.rs:132:22: 132:24

    bb0: {
        _0 = const 0_u8;                 // scope 0 at src/codec/utf_8.rs:132:27: 132:28
        return;                          // scope 0 at src/codec/utf_8.rs:132:1: 132:29
    }
}

const GB18030: &GB18030Encoding = {
    let mut _0: &codec::simpchinese::GB18030Encoding; // return place in scope 0 at src/all.rs:16:38: 16:65
    let _1: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:16:68: 16:88
    let _2: codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:16:71: 16:88
    let mut _3: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:16:68: 16:88

    bb0: {
        StorageLive(_1);                 // scope 0 at src/all.rs:16:68: 16:88
        _3 = const GB18030::promoted[0]; // scope 0 at src/all.rs:16:68: 16:88
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GB18030Encoding
                                         // + val: Unevaluated(GB18030, [], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/all.rs:16:68: 16:88
                                         // + literal: Const { ty: &codec::simpchinese::GB18030Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1285 ~ encoding[5d2c]::all::GB18030), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }
        _1 = &(*_3);                     // scope 0 at src/all.rs:16:68: 16:88
        _0 = &(*_1);                     // scope 0 at src/all.rs:16:68: 16:88
        StorageDead(_1);                 // scope 0 at src/all.rs:16:87: 16:88
        return;                          // scope 0 at src/all.rs:16:22: 16:89
    }
}

promoted[0] in GB18030: &GB18030Encoding = {
    let mut _0: &codec::simpchinese::GB18030Encoding; // return place in scope 0 at src/all.rs:16:68: 16:88
    let mut _1: codec::simpchinese::GB18030Encoding; // in scope 0 at src/all.rs:16:71: 16:88

    bb0: {
        nop;                             // scope 0 at src/all.rs:16:71: 16:88
        _0 = &_1;                        // scope 0 at src/all.rs:16:68: 16:88
        return;                          // scope 0 at src/all.rs:16:68: 16:88
    }
}

fn hz::transient::B0(_1: &mut StatefulDecoderHelper<hz::State, T>) -> hz::State {
    let mut _0: codec::simpchinese::hz::State; // return place in scope 0 at src/util.rs:216:80: 216:92

    bb0: {
        discriminant(_0) = 1;            // scope 0 at src/util.rs:217:25: 217:54
        return;                          // scope 0 at src/util.rs:218:22: 218:22
    }
}

fn iso2022jp::<impl at src/util.rs:157:22: 157:31>::eq(_1: &iso2022jp::State, _2: &iso2022jp::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::japanese::iso2022jp::State, &codec::japanese::iso2022jp::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::japanese::iso2022jp::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _20: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _21: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _23: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _24: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _25: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _28: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _29: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _32: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _33: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _36: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _37: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _40: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _41: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _44: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _45: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _48: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _49: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _52: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _53: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _58: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _59: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _60: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _61: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _62: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _63: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _68: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _69: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _70: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _71: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _72: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _73: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _26: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _27: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _30: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _31: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _34: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _35: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _38: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _39: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _42: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _43: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _46: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _47: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _50: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _51: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _54: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _55: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _56: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _57: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _64: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _65: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _66: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _67: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _26;   // in scope 3 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _27;  // in scope 3 at src/util.rs:161:27: 161:29
            }
            scope 4 {
                debug __self_0 => _30;   // in scope 4 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _31;  // in scope 4 at src/util.rs:161:27: 161:29
            }
            scope 5 {
                debug __self_0 => _34;   // in scope 5 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _35;  // in scope 5 at src/util.rs:161:27: 161:29
            }
            scope 6 {
                debug __self_0 => _38;   // in scope 6 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _39;  // in scope 6 at src/util.rs:164:25: 164:27
            }
            scope 7 {
                debug __self_0 => _42;   // in scope 7 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _43;  // in scope 7 at src/util.rs:164:25: 164:27
            }
            scope 8 {
                debug __self_0 => _46;   // in scope 8 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _47;  // in scope 8 at src/util.rs:164:25: 164:27
            }
            scope 9 {
                debug __self_0 => _50;   // in scope 9 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _51;  // in scope 9 at src/util.rs:164:25: 164:27
            }
            scope 10 {
                debug __self_0 => _54;   // in scope 10 at src/util.rs:164:25: 164:27
                debug __self_1 => _55;   // in scope 10 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _56;  // in scope 10 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _57;  // in scope 10 at src/util.rs:164:32: 164:35
            }
            scope 11 {
                debug __self_0 => _64;   // in scope 11 at src/util.rs:164:25: 164:27
                debug __self_1 => _65;   // in scope 11 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _66;  // in scope 11 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _67;  // in scope 11 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb37, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::japanese::iso2022jp::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::japanese::iso2022jp::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _25 = discriminant((*(_13.0: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _25) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, 4_isize: bb6, 5_isize: bb7, 6_isize: bb8, 7_isize: bb9, 8_isize: bb10, 9_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb12, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb14, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb16, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        _19 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [4_isize: bb18, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb7: {
        _20 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _20) -> [5_isize: bb20, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb8: {
        _21 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _21) -> [6_isize: bb22, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb9: {
        _22 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _22) -> [7_isize: bb24, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _23 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _23) -> [8_isize: bb26, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        _24 = discriminant((*(_13.1: &codec::japanese::iso2022jp::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _24) -> [9_isize: bb31, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb12: {
        StorageLive(_26);                // scope 2 at src/util.rs:161:27: 161:29
        _26 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Lead0208).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_27);                // scope 2 at src/util.rs:161:27: 161:29
        _27 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Lead0208).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_28);                // scope 3 at src/util.rs:161:27: 161:29
        _28 = _26;                       // scope 3 at src/util.rs:161:27: 161:29
        StorageLive(_29);                // scope 3 at src/util.rs:161:27: 161:29
        _29 = _27;                       // scope 3 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::eq(move _28, move _29) -> bb13; // scope 3 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb13: {
        StorageDead(_29);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_28);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_27);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_26);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb14: {
        StorageLive(_30);                // scope 2 at src/util.rs:161:27: 161:29
        _30 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Lead0212).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_31);                // scope 2 at src/util.rs:161:27: 161:29
        _31 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Lead0212).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_32);                // scope 4 at src/util.rs:161:27: 161:29
        _32 = _30;                       // scope 4 at src/util.rs:161:27: 161:29
        StorageLive(_33);                // scope 4 at src/util.rs:161:27: 161:29
        _33 = _31;                       // scope 4 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::eq(move _32, move _33) -> bb15; // scope 4 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_33);                // scope 4 at src/util.rs:161:28: 161:29
        StorageDead(_32);                // scope 4 at src/util.rs:161:28: 161:29
        StorageDead(_31);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb16: {
        StorageLive(_34);                // scope 2 at src/util.rs:161:27: 161:29
        _34 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Katakana).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_35);                // scope 2 at src/util.rs:161:27: 161:29
        _35 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Katakana).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_36);                // scope 5 at src/util.rs:161:27: 161:29
        _36 = _34;                       // scope 5 at src/util.rs:161:27: 161:29
        StorageLive(_37);                // scope 5 at src/util.rs:161:27: 161:29
        _37 = _35;                       // scope 5 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::eq(move _36, move _37) -> bb17; // scope 5 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb17: {
        StorageDead(_37);                // scope 5 at src/util.rs:161:28: 161:29
        StorageDead(_36);                // scope 5 at src/util.rs:161:28: 161:29
        StorageDead(_35);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_34);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb18: {
        StorageLive(_38);                // scope 2 at src/util.rs:164:25: 164:27
        _38 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeStart).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_39);                // scope 2 at src/util.rs:164:25: 164:27
        _39 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeStart).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_40);                // scope 6 at src/util.rs:164:25: 164:27
        _40 = _38;                       // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_41);                // scope 6 at src/util.rs:164:25: 164:27
        _41 = _39;                       // scope 6 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _40, move _41) -> bb19; // scope 6 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_41);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_40);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_39);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_38);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb20: {
        StorageLive(_42);                // scope 2 at src/util.rs:164:25: 164:27
        _42 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeMiddle24).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_43);                // scope 2 at src/util.rs:164:25: 164:27
        _43 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeMiddle24).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_44);                // scope 7 at src/util.rs:164:25: 164:27
        _44 = _42;                       // scope 7 at src/util.rs:164:25: 164:27
        StorageLive(_45);                // scope 7 at src/util.rs:164:25: 164:27
        _45 = _43;                       // scope 7 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _44, move _45) -> bb21; // scope 7 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb21: {
        StorageDead(_45);                // scope 7 at src/util.rs:164:26: 164:27
        StorageDead(_44);                // scope 7 at src/util.rs:164:26: 164:27
        StorageDead(_43);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_42);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb22: {
        StorageLive(_46);                // scope 2 at src/util.rs:164:25: 164:27
        _46 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeMiddle28).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_47);                // scope 2 at src/util.rs:164:25: 164:27
        _47 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeMiddle28).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_48);                // scope 8 at src/util.rs:164:25: 164:27
        _48 = _46;                       // scope 8 at src/util.rs:164:25: 164:27
        StorageLive(_49);                // scope 8 at src/util.rs:164:25: 164:27
        _49 = _47;                       // scope 8 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _48, move _49) -> bb23; // scope 8 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb23: {
        StorageDead(_49);                // scope 8 at src/util.rs:164:26: 164:27
        StorageDead(_48);                // scope 8 at src/util.rs:164:26: 164:27
        StorageDead(_47);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_46);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb24: {
        StorageLive(_50);                // scope 2 at src/util.rs:164:25: 164:27
        _50 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as EscapeFinal).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_51);                // scope 2 at src/util.rs:164:25: 164:27
        _51 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as EscapeFinal).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_52);                // scope 9 at src/util.rs:164:25: 164:27
        _52 = _50;                       // scope 9 at src/util.rs:164:25: 164:27
        StorageLive(_53);                // scope 9 at src/util.rs:164:25: 164:27
        _53 = _51;                       // scope 9 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::eq(move _52, move _53) -> bb25; // scope 9 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb25: {
        StorageDead(_53);                // scope 9 at src/util.rs:164:26: 164:27
        StorageDead(_52);                // scope 9 at src/util.rs:164:26: 164:27
        StorageDead(_51);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_50);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb26: {
        StorageLive(_54);                // scope 2 at src/util.rs:164:25: 164:27
        _54 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0208).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_55);                // scope 2 at src/util.rs:164:32: 164:35
        _55 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0208).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_56);                // scope 2 at src/util.rs:164:25: 164:27
        _56 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0208).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_57);                // scope 2 at src/util.rs:164:32: 164:35
        _57 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0208).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_58);                // scope 10 at src/util.rs:164:25: 164:27
        StorageLive(_59);                // scope 10 at src/util.rs:164:25: 164:27
        _59 = _54;                       // scope 10 at src/util.rs:164:25: 164:27
        StorageLive(_60);                // scope 10 at src/util.rs:164:25: 164:27
        _60 = _56;                       // scope 10 at src/util.rs:164:25: 164:27
        _58 = <() as PartialEq>::eq(move _59, move _60) -> bb30; // scope 10 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb27: {
        _0 = const false;                // scope 10 at src/util.rs:164:32: 164:35
        goto -> bb29;                    // scope 10 at src/util.rs:164:32: 164:35
    }

    bb28: {
        StorageLive(_61);                // scope 10 at src/util.rs:164:32: 164:35
        StorageLive(_62);                // scope 10 at src/util.rs:164:32: 164:35
        _62 = (*_55);                    // scope 10 at src/util.rs:164:32: 164:35
        StorageLive(_63);                // scope 10 at src/util.rs:164:32: 164:35
        _63 = (*_57);                    // scope 10 at src/util.rs:164:32: 164:35
        _61 = Eq(move _62, move _63);    // scope 10 at src/util.rs:164:32: 164:35
        StorageDead(_63);                // scope 10 at src/util.rs:164:34: 164:35
        StorageDead(_62);                // scope 10 at src/util.rs:164:34: 164:35
        _0 = move _61;                   // scope 10 at src/util.rs:164:32: 164:35
        goto -> bb29;                    // scope 10 at src/util.rs:164:32: 164:35
    }

    bb29: {
        StorageDead(_61);                // scope 10 at src/util.rs:164:34: 164:35
        StorageDead(_58);                // scope 10 at src/util.rs:164:34: 164:35
        StorageDead(_57);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_56);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_55);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_54);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb30: {
        StorageDead(_60);                // scope 10 at src/util.rs:164:26: 164:27
        StorageDead(_59);                // scope 10 at src/util.rs:164:26: 164:27
        switchInt(move _58) -> [false: bb27, otherwise: bb28]; // scope 10 at src/util.rs:164:32: 164:35
    }

    bb31: {
        StorageLive(_64);                // scope 2 at src/util.rs:164:25: 164:27
        _64 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0212).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_65);                // scope 2 at src/util.rs:164:32: 164:35
        _65 = &(((*(_13.0: &codec::japanese::iso2022jp::State)) as Trail0212).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_66);                // scope 2 at src/util.rs:164:25: 164:27
        _66 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0212).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_67);                // scope 2 at src/util.rs:164:32: 164:35
        _67 = &(((*(_13.1: &codec::japanese::iso2022jp::State)) as Trail0212).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_68);                // scope 11 at src/util.rs:164:25: 164:27
        StorageLive(_69);                // scope 11 at src/util.rs:164:25: 164:27
        _69 = _64;                       // scope 11 at src/util.rs:164:25: 164:27
        StorageLive(_70);                // scope 11 at src/util.rs:164:25: 164:27
        _70 = _66;                       // scope 11 at src/util.rs:164:25: 164:27
        _68 = <() as PartialEq>::eq(move _69, move _70) -> bb35; // scope 11 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb32: {
        _0 = const false;                // scope 11 at src/util.rs:164:32: 164:35
        goto -> bb34;                    // scope 11 at src/util.rs:164:32: 164:35
    }

    bb33: {
        StorageLive(_71);                // scope 11 at src/util.rs:164:32: 164:35
        StorageLive(_72);                // scope 11 at src/util.rs:164:32: 164:35
        _72 = (*_65);                    // scope 11 at src/util.rs:164:32: 164:35
        StorageLive(_73);                // scope 11 at src/util.rs:164:32: 164:35
        _73 = (*_67);                    // scope 11 at src/util.rs:164:32: 164:35
        _71 = Eq(move _72, move _73);    // scope 11 at src/util.rs:164:32: 164:35
        StorageDead(_73);                // scope 11 at src/util.rs:164:34: 164:35
        StorageDead(_72);                // scope 11 at src/util.rs:164:34: 164:35
        _0 = move _71;                   // scope 11 at src/util.rs:164:32: 164:35
        goto -> bb34;                    // scope 11 at src/util.rs:164:32: 164:35
    }

    bb34: {
        StorageDead(_71);                // scope 11 at src/util.rs:164:34: 164:35
        StorageDead(_68);                // scope 11 at src/util.rs:164:34: 164:35
        StorageDead(_67);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_66);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_65);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_64);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb36;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb35: {
        StorageDead(_70);                // scope 11 at src/util.rs:164:26: 164:27
        StorageDead(_69);                // scope 11 at src/util.rs:164:26: 164:27
        switchInt(move _68) -> [false: bb32, otherwise: bb33]; // scope 11 at src/util.rs:164:32: 164:35
    }

    bb36: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb38;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb37: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb38;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb38: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn codec::ascii::<impl at src/codec/ascii.rs:34:1: 59:2>::is_ascii_compatible(_1: &ASCIIEncoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/ascii.rs:36:28: 36:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/ascii.rs:36:38: 36:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/ascii.rs:36:45: 36:49
        return;                          // scope 0 at src/codec/ascii.rs:36:51: 36:51
    }
}

fn windows31j::raw_finish(_1: windows31j::State, _2: &mut dyn encoding_types::StringWriter, _3: &T) -> (windows31j::State, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:274:34: 274:40
    debug output => _2;                  // in scope 0 at src/util.rs:274:49: 274:55
    debug data => _3;                    // in scope 0 at src/util.rs:275:34: 275:38
    let mut _0: (codec::japanese::windows31j::State, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:275:47: 275:83
    let mut _4: util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:277:21: 277:28
    let mut _5: &[u8];                   // in scope 0 at src/util.rs:277:66: 277:69
    let mut _6: &[u8; 0];                // in scope 0 at src/util.rs:277:66: 277:69
    let _7: &[u8; 0];                    // in scope 0 at src/util.rs:277:66: 277:69
    let mut _8: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _9: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:277:71: 277:77
    let mut _10: &T;                     // in scope 0 at src/util.rs:277:79: 277:83
    let mut _12: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:278:32: 278:68
    let mut _13: &mut codec::japanese::windows31j::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _14: &mut codec::japanese::windows31j::State; // in scope 0 at src/util.rs:278:52: 278:59
    let mut _15: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:278:61: 278:67
    let mut _16: isize;                  // in scope 0 at src/util.rs:279:21: 279:27
    let mut _18: &util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:311:26: 311:33
    let mut _21: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 0 at src/util.rs:317:26: 317:30
    let mut _22: codec::japanese::windows31j::State; // in scope 0 at src/util.rs:287:18: 287:20
    let mut _23: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:36
    let mut _24: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:287:22: 287:29
    let mut _25: &[u8; 0];               // in scope 0 at src/util.rs:277:66: 277:69
    scope 1 {
        debug ctx => _4;                 // in scope 1 at src/util.rs:277:21: 277:28
        let _11: codec::japanese::windows31j::State; // in scope 1 at src/util.rs:278:21: 278:23
        let _17: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 1 at src/util.rs:279:37: 279:44
        let _19: u8;                     // in scope 1 at src/util.rs:284:36: 284:40
        scope 2 {
            debug st => _11;             // in scope 2 at src/util.rs:278:21: 278:23
        }
        scope 3 {
            debug ctx => _17;            // in scope 3 at src/util.rs:279:37: 279:44
        }
        scope 4 {
            debug lead => _19;           // in scope 4 at src/util.rs:284:36: 284:40
            let _20: &mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>; // in scope 4 at src/util.rs:284:53: 284:57
            scope 5 {
                debug ctx => _20;        // in scope 5 at src/util.rs:284:53: 284:57
            }
        }
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/util.rs:277:21: 277:28
        StorageLive(_5);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_6);                 // scope 0 at src/util.rs:277:66: 277:69
        StorageLive(_7);                 // scope 0 at src/util.rs:277:66: 277:69
        _25 = const windows31j::raw_finish::<T>::promoted[0]; // scope 0 at src/util.rs:277:66: 277:69
                                         // ty::Const
                                         // + ty: &[u8; 0]
                                         // + val: Unevaluated(windows31j::raw_finish, [T], Some(promoted[0]))
                                         // mir::Constant
                                         // + span: src/util.rs:277:66: 277:69
                                         // + literal: Const { ty: &[u8; 0], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:883 ~ encoding[5d2c]::codec::japanese::windows31j::raw_finish), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }
        _7 = _25;                        // scope 0 at src/util.rs:277:66: 277:69
        _6 = _7;                         // scope 0 at src/util.rs:277:66: 277:69
        _5 = move _6 as &[u8] (Pointer(Unsize)); // scope 0 at src/util.rs:277:66: 277:69
        StorageDead(_6);                 // scope 0 at src/util.rs:277:68: 277:69
        StorageLive(_8);                 // scope 0 at src/util.rs:277:71: 277:77
        StorageLive(_9);                 // scope 0 at src/util.rs:277:71: 277:77
        _9 = &mut (*_2);                 // scope 0 at src/util.rs:277:71: 277:77
        _8 = move _9 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:277:71: 277:77
        StorageDead(_9);                 // scope 0 at src/util.rs:277:76: 277:77
        StorageLive(_10);                // scope 0 at src/util.rs:277:79: 277:83
        _10 = _3;                        // scope 0 at src/util.rs:277:79: 277:83
        _4 = StatefulDecoderHelper::<windows31j::State, T>::new(move _5, move _8, move _10) -> bb1; // scope 0 at src/util.rs:277:31: 277:84
                                         // mir::Constant
                                         // + span: src/util.rs:277:31: 277:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::japanese::windows31j::State, T> {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_10);                // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_8);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_5);                 // scope 0 at src/util.rs:277:83: 277:84
        StorageDead(_7);                 // scope 0 at src/util.rs:277:84: 277:85
        StorageLive(_11);                // scope 1 at src/util.rs:278:21: 278:23
        StorageLive(_12);                // scope 1 at src/util.rs:278:32: 278:68
        StorageLive(_13);                // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_14);                // scope 1 at src/util.rs:278:52: 278:59
        _14 = &mut _1;                   // scope 1 at src/util.rs:278:52: 278:59
        _13 = &mut (*_14);               // scope 1 at src/util.rs:278:52: 278:59
        StorageLive(_15);                // scope 1 at src/util.rs:278:61: 278:67
        discriminant(_15) = 0;           // scope 1 at src/util.rs:278:61: 278:67
        _12 = std::mem::replace::<windows31j::State>(move _13, move _15) -> [return: bb2, unwind: bb11]; // scope 1 at src/util.rs:278:32: 278:68
                                         // mir::Constant
                                         // + span: src/util.rs:278:32: 278:51
                                         // + literal: Const { ty: for<'r> fn(&'r mut codec::japanese::windows31j::State, codec::japanese::windows31j::State) -> codec::japanese::windows31j::State {std::mem::replace::<codec::japanese::windows31j::State>}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_15);                // scope 1 at src/util.rs:278:67: 278:68
        StorageDead(_13);                // scope 1 at src/util.rs:278:67: 278:68
        _16 = discriminant(_12);         // scope 1 at src/util.rs:278:32: 278:68
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 1 at src/util.rs:278:26: 278:68
    }

    bb3: {
        StorageLive(_19);                // scope 1 at src/util.rs:284:36: 284:40
        _19 = ((_12 as S1).1: u8);       // scope 1 at src/util.rs:284:36: 284:40
        StorageLive(_20);                // scope 4 at src/util.rs:284:53: 284:57
        _20 = &mut _4;                   // scope 4 at src/util.rs:284:60: 284:68
        StorageLive(_21);                // scope 5 at src/util.rs:317:26: 317:30
        _21 = &mut (*_20);               // scope 5 at src/util.rs:317:26: 317:30
        _11 = StatefulDecoderHelper::<windows31j::State, T>::err(move _21, const "incomplete sequence") -> [return: bb7, unwind: bb11]; // scope 5 at src/util.rs:317:26: 317:57
                                         // mir::Constant
                                         // + span: src/util.rs:317:31: 317:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>, &'static str) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 })
                                         // mir::Constant
                                         // + span: src/util.rs:317:35: 317:56
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [524287], len: Size { raw: 19 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 19 }) }
    }

    bb4: {
        unreachable;                     // scope 1 at src/util.rs:278:32: 278:68
    }

    bb5: {
        StorageLive(_17);                // scope 1 at src/util.rs:279:37: 279:44
        _17 = &mut _4;                   // scope 1 at src/util.rs:279:47: 279:55
        StorageLive(_18);                // scope 3 at src/util.rs:311:26: 311:33
        _18 = &(*_17);                   // scope 3 at src/util.rs:311:26: 311:33
        _11 = StatefulDecoderHelper::<windows31j::State, T>::reset(move _18) -> [return: bb6, unwind: bb11]; // scope 3 at src/util.rs:311:26: 311:41
                                         // mir::Constant
                                         // + span: src/util.rs:311:34: 311:39
                                         // + literal: Const { ty: for<'r> fn(&'r util::StatefulDecoderHelper<codec::japanese::windows31j::State, T>) -> codec::japanese::windows31j::State {util::StatefulDecoderHelper::<codec::japanese::windows31j::State, T>::reset}, val: Value(Scalar(<ZST>)) }
    }

    bb6: {
        StorageDead(_18);                // scope 3 at src/util.rs:311:40: 311:41
        StorageDead(_17);                // scope 1 at src/util.rs:279:70: 279:71
        goto -> bb8;                     // scope 1 at src/util.rs:279:70: 279:71
    }

    bb7: {
        StorageDead(_21);                // scope 5 at src/util.rs:317:56: 317:57
        StorageDead(_20);                // scope 4 at src/util.rs:284:80: 284:81
        StorageDead(_19);                // scope 1 at src/util.rs:284:80: 284:81
        goto -> bb8;                     // scope 1 at src/util.rs:284:80: 284:81
    }

    bb8: {
        StorageDead(_14);                // scope 1 at src/util.rs:286:18: 286:19
        StorageDead(_12);                // scope 1 at src/util.rs:286:18: 286:19
        StorageLive(_22);                // scope 2 at src/util.rs:287:18: 287:20
        _22 = _11;                       // scope 2 at src/util.rs:287:18: 287:20
        StorageLive(_23);                // scope 2 at src/util.rs:287:22: 287:36
        StorageLive(_24);                // scope 2 at src/util.rs:287:22: 287:29
        _24 = &mut (_4.3: std::option::Option<encoding_types::CodecError>); // scope 2 at src/util.rs:287:22: 287:29
        _23 = Option::<encoding_types::CodecError>::take(move _24) -> [return: bb9, unwind: bb11]; // scope 2 at src/util.rs:287:22: 287:36
                                         // mir::Constant
                                         // + span: src/util.rs:287:30: 287:34
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_24);                // scope 2 at src/util.rs:287:35: 287:36
        (_0.0: codec::japanese::windows31j::State) = move _22; // scope 2 at src/util.rs:287:17: 287:37
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _23; // scope 2 at src/util.rs:287:17: 287:37
        StorageDead(_23);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_22);                // scope 2 at src/util.rs:287:36: 287:37
        StorageDead(_11);                // scope 1 at src/util.rs:288:13: 288:14
        drop(_4) -> bb10;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb10: {
        StorageDead(_4);                 // scope 0 at src/util.rs:288:13: 288:14
        return;                          // scope 0 at src/util.rs:288:14: 288:14
    }

    bb11 (cleanup): {
        drop(_4) -> bb12;                // scope 0 at src/util.rs:288:13: 288:14
    }

    bb12 (cleanup): {
        resume;                          // scope 0 at src/util.rs:274:13: 288:14
    }
}

promoted[0] in windows31j::raw_finish: &[u8; 0] = {
    let mut _0: &[u8; 0];                // return place in scope 0 at src/util.rs:277:66: 277:69
    let mut _1: [u8; 0];                 // in scope 0 at src/util.rs:277:67: 277:69

    bb0: {
        _1 = [];                         // scope 0 at src/util.rs:277:67: 277:69
        _0 = &_1;                        // scope 0 at src/util.rs:277:66: 277:69
        return;                          // scope 0 at src/util.rs:277:66: 277:69
    }
}

fn x_user_defined::backward(_1: u32) -> u8 {
    debug code => _1;                    // in scope 0 at src/codec/whatwg.rs:30:21: 30:25
    let mut _0: u8;                      // return place in scope 0 at src/codec/whatwg.rs:30:35: 30:37
    let mut _2: u32;                     // in scope 0 at src/codec/whatwg.rs:31:12: 31:26
    let mut _3: u32;                     // in scope 0 at src/codec/whatwg.rs:31:13: 31:17
    let mut _4: u32;                     // in scope 0 at src/codec/whatwg.rs:31:20: 31:25
    let mut _5: u32;                     // in scope 0 at src/codec/whatwg.rs:31:38: 31:51
    let mut _6: u32;                     // in scope 0 at src/codec/whatwg.rs:31:39: 31:43

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/whatwg.rs:31:12: 31:26
        StorageLive(_3);                 // scope 0 at src/codec/whatwg.rs:31:13: 31:17
        _3 = _1;                         // scope 0 at src/codec/whatwg.rs:31:13: 31:17
        StorageLive(_4);                 // scope 0 at src/codec/whatwg.rs:31:20: 31:25
        _4 = const 4294967168_u32;       // scope 0 at src/codec/whatwg.rs:31:20: 31:25
        _2 = BitAnd(move _3, move _4);   // scope 0 at src/codec/whatwg.rs:31:12: 31:26
        StorageDead(_4);                 // scope 0 at src/codec/whatwg.rs:31:25: 31:26
        StorageDead(_3);                 // scope 0 at src/codec/whatwg.rs:31:25: 31:26
        switchInt(move _2) -> [63360_u32: bb1, otherwise: bb2]; // scope 0 at src/codec/whatwg.rs:31:12: 31:36
    }

    bb1: {
        StorageDead(_2);                 // scope 0 at src/codec/whatwg.rs:31:12: 31:36
        StorageLive(_5);                 // scope 0 at src/codec/whatwg.rs:31:38: 31:51
        StorageLive(_6);                 // scope 0 at src/codec/whatwg.rs:31:39: 31:43
        _6 = _1;                         // scope 0 at src/codec/whatwg.rs:31:39: 31:43
        _5 = BitAnd(move _6, const 255_u32); // scope 0 at src/codec/whatwg.rs:31:38: 31:51
        StorageDead(_6);                 // scope 0 at src/codec/whatwg.rs:31:50: 31:51
        _0 = move _5 as u8 (Misc);       // scope 0 at src/codec/whatwg.rs:31:38: 31:57
        StorageDead(_5);                 // scope 0 at src/codec/whatwg.rs:31:56: 31:57
        goto -> bb3;                     // scope 0 at src/codec/whatwg.rs:31:9: 31:67
    }

    bb2: {
        StorageDead(_2);                 // scope 0 at src/codec/whatwg.rs:31:12: 31:36
        _0 = const 0_u8;                 // scope 0 at src/codec/whatwg.rs:31:65: 31:66
        goto -> bb3;                     // scope 0 at src/codec/whatwg.rs:31:9: 31:67
    }

    bb3: {
        return;                          // scope 0 at src/codec/whatwg.rs:32:6: 32:6
    }
}

fn windows949::raw_feed(_1: windows949::State, _2: &[u8], _3: &mut dyn encoding_types::StringWriter, _4: &T) -> (windows949::State, usize, Option<encoding_types::CodecError>) {
    debug st => _1;                      // in scope 0 at src/util.rs:232:32: 232:38
    debug input => _2;                   // in scope 0 at src/util.rs:232:47: 232:52
    debug output => _3;                  // in scope 0 at src/util.rs:232:61: 232:67
    debug data => _4;                    // in scope 0 at src/util.rs:233:32: 233:36
    let mut _0: (codec::korean::windows949::State, usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/util.rs:233:45: 233:88
    let _5: ();                          // in scope 0 at src/util.rs:234:17: 234:48
    let mut _6: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:234:17: 234:23
    let mut _7: usize;                   // in scope 0 at src/util.rs:234:36: 234:47
    let mut _8: &[u8];                   // in scope 0 at src/util.rs:234:36: 234:41
    let mut _9: util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:236:21: 236:28
    let mut _10: &[u8];                  // in scope 0 at src/util.rs:236:66: 236:71
    let mut _11: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _12: &mut dyn encoding_types::StringWriter; // in scope 0 at src/util.rs:236:73: 236:79
    let mut _13: &T;                     // in scope 0 at src/util.rs:236:81: 236:85
    let mut _16: isize;                  // in scope 0 at src/util.rs:240:21: 240:27
    let mut _18: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _19: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:245:62: 245:70
    let mut _20: u8;                     // in scope 0 at src/util.rs:245:75: 245:79
    let mut _21: (std::option::Option<encoding_types::CodecError>, codec::korean::windows949::State); // in scope 0 at src/util.rs:248:23: 248:44
    let mut _22: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:38
    let mut _23: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:248:24: 248:31
    let mut _24: codec::korean::windows949::State; // in scope 0 at src/util.rs:248:40: 248:43
    let mut _25: isize;                  // in scope 0 at src/util.rs:249:28: 249:34
    let mut _26: isize;                  // in scope 0 at src/util.rs:249:22: 249:26
    let mut _27: codec::korean::windows949::State; // in scope 0 at src/util.rs:249:70: 249:73
    let mut _28: usize;                  // in scope 0 at src/util.rs:249:87: 249:94
    let mut _29: codec::korean::windows949::State; // in scope 0 at src/util.rs:251:44: 251:47
    let mut _30: usize;                  // in scope 0 at src/util.rs:251:49: 251:58
    let mut _31: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:251:60: 251:64
    let mut _33: codec::korean::windows949::State; // in scope 0 at src/util.rs:252:49: 252:52
    let mut _34: usize;                  // in scope 0 at src/util.rs:252:54: 252:63
    let mut _35: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:252:65: 252:74
    let mut _36: encoding_types::CodecError; // in scope 0 at src/util.rs:252:70: 252:73
    let mut _37: bool;                   // in scope 0 at src/util.rs:255:23: 255:46
    let mut _38: usize;                  // in scope 0 at src/util.rs:255:23: 255:30
    let mut _39: usize;                  // in scope 0 at src/util.rs:255:33: 255:46
    let mut _40: &[u8];                  // in scope 0 at src/util.rs:255:33: 255:40
    let mut _42: isize;                  // in scope 0 at src/util.rs:257:25: 257:31
    let mut _43: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _44: &mut util::StatefulDecoderHelper<codec::korean::windows949::State, T>; // in scope 0 at src/util.rs:257:49: 257:57
    let mut _45: (std::option::Option<encoding_types::CodecError>, codec::korean::windows949::State); // in scope 0 at src/util.rs:263:27: 263:48
    let mut _46: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:42
    let mut _47: &mut std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:263:28: 263:35
    let mut _48: codec::korean::windows949::State; // in scope 0 at src/util.rs:263:44: 263:47
    let mut _49: isize;                  // in scope 0 at src/util.rs:264:32: 264:38
    let mut _50: isize;                  // in scope 0 at src/util.rs:264:26: 264:30
    let mut _51: codec::korean::windows949::State; // in scope 0 at src/util.rs:264:74: 264:77
    let mut _52: usize;                  // in scope 0 at src/util.rs:264:91: 264:98
    let mut _53: codec::korean::windows949::State; // in scope 0 at src/util.rs:266:48: 266:51
    let mut _54: usize;                  // in scope 0 at src/util.rs:266:53: 266:62
    let mut _55: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:266:64: 266:68
    let mut _57: codec::korean::windows949::State; // in scope 0 at src/util.rs:267:53: 267:56
    let mut _58: usize;                  // in scope 0 at src/util.rs:267:58: 267:67
    let mut _59: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:267:69: 267:78
    let mut _60: encoding_types::CodecError; // in scope 0 at src/util.rs:267:74: 267:77
    let mut _61: codec::korean::windows949::State; // in scope 0 at src/util.rs:271:18: 271:20
    let mut _62: usize;                  // in scope 0 at src/util.rs:271:22: 271:31
    let mut _63: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:271:33: 271:37
    scope 1 {
        debug ctx => _9;                 // in scope 1 at src/util.rs:236:21: 236:28
        let mut _14: usize;              // in scope 1 at src/util.rs:237:21: 237:34
        scope 2 {
            debug processed => _14;      // in scope 2 at src/util.rs:237:21: 237:34
            let _15: codec::korean::windows949::State; // in scope 2 at src/util.rs:239:21: 239:24
            let _17: u8;                 // in scope 2 at src/util.rs:245:36: 245:40
            scope 3 {
                debug st_ => _15;        // in scope 3 at src/util.rs:239:21: 239:24
                let _32: encoding_types::CodecError; // in scope 3 at src/util.rs:252:27: 252:30
                let _41: codec::korean::windows949::State; // in scope 3 at src/util.rs:256:25: 256:28
                scope 5 {
                    debug err => _32;    // in scope 5 at src/util.rs:252:27: 252:30
                }
                scope 6 {
                    debug st_ => _41;    // in scope 6 at src/util.rs:256:25: 256:28
                    let _56: encoding_types::CodecError; // in scope 6 at src/util.rs:267:31: 267:34
                    scope 7 {
                        debug err => _56; // in scope 7 at src/util.rs:267:31: 267:34
                    }
                }
            }
            scope 4 {
                debug lead => _17;       // in scope 4 at src/util.rs:245:36: 245:40
            }
        }
    }

    bb0: {
        StorageLive(_5);                 // scope 0 at src/util.rs:234:17: 234:48
        StorageLive(_6);                 // scope 0 at src/util.rs:234:17: 234:23
        _6 = &mut (*_3);                 // scope 0 at src/util.rs:234:17: 234:23
        StorageLive(_7);                 // scope 0 at src/util.rs:234:36: 234:47
        StorageLive(_8);                 // scope 0 at src/util.rs:234:36: 234:41
        _8 = _2;                         // scope 0 at src/util.rs:234:36: 234:41
        _7 = Len((*_8));                 // scope 0 at src/util.rs:234:36: 234:47
        StorageDead(_8);                 // scope 0 at src/util.rs:234:46: 234:47
        _5 = <dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint(move _6, move _7) -> bb1; // scope 0 at src/util.rs:234:17: 234:48
                                         // mir::Constant
                                         // + span: src/util.rs:234:24: 234:35
                                         // + literal: Const { ty: for<'r> fn(&'r mut dyn encoding_types::StringWriter, usize) {<dyn encoding_types::StringWriter as encoding_types::StringWriter>::writer_hint}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_7);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_6);                 // scope 0 at src/util.rs:234:47: 234:48
        StorageDead(_5);                 // scope 0 at src/util.rs:234:48: 234:49
        StorageLive(_9);                 // scope 0 at src/util.rs:236:21: 236:28
        StorageLive(_10);                // scope 0 at src/util.rs:236:66: 236:71
        _10 = _2;                        // scope 0 at src/util.rs:236:66: 236:71
        StorageLive(_11);                // scope 0 at src/util.rs:236:73: 236:79
        StorageLive(_12);                // scope 0 at src/util.rs:236:73: 236:79
        _12 = &mut (*_3);                // scope 0 at src/util.rs:236:73: 236:79
        _11 = move _12 as &mut dyn encoding_types::StringWriter (Pointer(Unsize)); // scope 0 at src/util.rs:236:73: 236:79
        StorageDead(_12);                // scope 0 at src/util.rs:236:78: 236:79
        StorageLive(_13);                // scope 0 at src/util.rs:236:81: 236:85
        _13 = _4;                        // scope 0 at src/util.rs:236:81: 236:85
        _9 = StatefulDecoderHelper::<windows949::State, T>::new(move _10, move _11, move _13) -> bb2; // scope 0 at src/util.rs:236:31: 236:86
                                         // mir::Constant
                                         // + span: src/util.rs:236:31: 236:65
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[u8], &mut dyn encoding_types::StringWriter, &T) -> util::StatefulDecoderHelper<codec::korean::windows949::State, T> {util::StatefulDecoderHelper::<codec::korean::windows949::State, T>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_13);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_11);                // scope 0 at src/util.rs:236:85: 236:86
        StorageDead(_10);                // scope 0 at src/util.rs:236:85: 236:86
        StorageLive(_14);                // scope 1 at src/util.rs:237:21: 237:34
        _14 = const 0_usize;             // scope 1 at src/util.rs:237:37: 237:38
        StorageLive(_15);                // scope 2 at src/util.rs:239:21: 239:24
        _16 = discriminant(_1);          // scope 2 at src/util.rs:239:33: 239:35
        switchInt(move _16) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 2 at src/util.rs:239:27: 239:35
    }

    bb3: {
        StorageLive(_17);                // scope 2 at src/util.rs:245:36: 245:40
        _17 = ((_1 as S1).1: u8);        // scope 2 at src/util.rs:245:36: 245:40
        StorageLive(_18);                // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_19);                // scope 4 at src/util.rs:245:62: 245:70
        _19 = &mut _9;                   // scope 4 at src/util.rs:245:62: 245:70
        _18 = &mut (*_19);               // scope 4 at src/util.rs:245:62: 245:70
        StorageLive(_20);                // scope 4 at src/util.rs:245:75: 245:79
        _20 = _17;                       // scope 4 at src/util.rs:245:75: 245:79
        _15 = windows949::transient::S1::<T>(move _18, move _20) -> [return: bb6, unwind: bb33]; // scope 4 at src/util.rs:245:58: 245:82
                                         // mir::Constant
                                         // + span: src/util.rs:245:47: 245:61
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::korean::windows949::State, T>, u8) -> codec::korean::windows949::State {codec::korean::windows949::transient::S1::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        unreachable;                     // scope 2 at src/util.rs:239:33: 239:35
    }

    bb5: {
        discriminant(_15) = 0;           // scope 2 at src/util.rs:240:31: 240:37
        goto -> bb7;                     // scope 2 at src/util.rs:240:31: 240:37
    }

    bb6: {
        StorageDead(_20);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_19);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_18);                // scope 4 at src/util.rs:245:81: 245:82
        StorageDead(_17);                // scope 2 at src/util.rs:245:81: 245:82
        goto -> bb7;                     // scope 2 at src/util.rs:245:81: 245:82
    }

    bb7: {
        StorageLive(_21);                // scope 3 at src/util.rs:248:23: 248:44
        StorageLive(_22);                // scope 3 at src/util.rs:248:24: 248:38
        StorageLive(_23);                // scope 3 at src/util.rs:248:24: 248:31
        _23 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 3 at src/util.rs:248:24: 248:31
        _22 = Option::<encoding_types::CodecError>::take(move _23) -> [return: bb8, unwind: bb33]; // scope 3 at src/util.rs:248:24: 248:38
                                         // mir::Constant
                                         // + span: src/util.rs:248:32: 248:36
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_23);                // scope 3 at src/util.rs:248:37: 248:38
        StorageLive(_24);                // scope 3 at src/util.rs:248:40: 248:43
        _24 = _15;                       // scope 3 at src/util.rs:248:40: 248:43
        (_21.0: std::option::Option<encoding_types::CodecError>) = move _22; // scope 3 at src/util.rs:248:23: 248:44
        (_21.1: codec::korean::windows949::State) = move _24; // scope 3 at src/util.rs:248:23: 248:44
        StorageDead(_24);                // scope 3 at src/util.rs:248:43: 248:44
        StorageDead(_22);                // scope 3 at src/util.rs:248:43: 248:44
        _26 = discriminant((_21.0: std::option::Option<encoding_types::CodecError>)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _26) -> [0_isize: bb9, 1_isize: bb10, otherwise: bb11]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb9: {
        _25 = discriminant((_21.1: codec::korean::windows949::State)); // scope 3 at src/util.rs:248:23: 248:44
        switchInt(move _25) -> [0_isize: bb12, otherwise: bb13]; // scope 3 at src/util.rs:248:17: 248:44
    }

    bb10: {
        StorageLive(_32);                // scope 3 at src/util.rs:252:27: 252:30
        _32 = move (((_21.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 3 at src/util.rs:252:27: 252:30
        StorageLive(_33);                // scope 5 at src/util.rs:252:49: 252:52
        _33 = _15;                       // scope 5 at src/util.rs:252:49: 252:52
        StorageLive(_34);                // scope 5 at src/util.rs:252:54: 252:63
        _34 = _14;                       // scope 5 at src/util.rs:252:54: 252:63
        StorageLive(_35);                // scope 5 at src/util.rs:252:65: 252:74
        StorageLive(_36);                // scope 5 at src/util.rs:252:70: 252:73
        _36 = move _32;                  // scope 5 at src/util.rs:252:70: 252:73
        ((_35 as Some).0: encoding_types::CodecError) = move _36; // scope 5 at src/util.rs:252:65: 252:74
        discriminant(_35) = 1;           // scope 5 at src/util.rs:252:65: 252:74
        StorageDead(_36);                // scope 5 at src/util.rs:252:73: 252:74
        (_0.0: codec::korean::windows949::State) = move _33; // scope 5 at src/util.rs:252:48: 252:75
        (_0.1: usize) = move _34;        // scope 5 at src/util.rs:252:48: 252:75
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _35; // scope 5 at src/util.rs:252:48: 252:75
        StorageDead(_35);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_34);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_33);                // scope 5 at src/util.rs:252:74: 252:75
        StorageDead(_32);                // scope 3 at src/util.rs:252:77: 252:78
        goto -> bb29;                    // scope 3 at no-location
    }

    bb11: {
        unreachable;                     // scope 3 at src/util.rs:248:23: 248:44
    }

    bb12: {
        StorageLive(_27);                // scope 3 at src/util.rs:249:70: 249:73
        _27 = _15;                       // scope 3 at src/util.rs:249:70: 249:73
        _1 = move _27;                   // scope 3 at src/util.rs:249:65: 249:73
        StorageDead(_27);                // scope 3 at src/util.rs:249:72: 249:73
        StorageLive(_28);                // scope 3 at src/util.rs:249:87: 249:94
        _28 = (_9.1: usize);             // scope 3 at src/util.rs:249:87: 249:94
        _14 = move _28;                  // scope 3 at src/util.rs:249:75: 249:94
        StorageDead(_28);                // scope 3 at src/util.rs:249:93: 249:94
        StorageDead(_21);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb14;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb13: {
        StorageLive(_29);                // scope 3 at src/util.rs:251:44: 251:47
        _29 = _15;                       // scope 3 at src/util.rs:251:44: 251:47
        StorageLive(_30);                // scope 3 at src/util.rs:251:49: 251:58
        _30 = _14;                       // scope 3 at src/util.rs:251:49: 251:58
        StorageLive(_31);                // scope 3 at src/util.rs:251:60: 251:64
        discriminant(_31) = 0;           // scope 3 at src/util.rs:251:60: 251:64
        (_0.0: codec::korean::windows949::State) = move _29; // scope 3 at src/util.rs:251:43: 251:65
        (_0.1: usize) = move _30;        // scope 3 at src/util.rs:251:43: 251:65
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _31; // scope 3 at src/util.rs:251:43: 251:65
        StorageDead(_31);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_30);                // scope 3 at src/util.rs:251:64: 251:65
        StorageDead(_29);                // scope 3 at src/util.rs:251:64: 251:65
        goto -> bb29;                    // scope 3 at src/util.rs:251:36: 251:65
    }

    bb14: {
        StorageLive(_37);                // scope 3 at src/util.rs:255:23: 255:46
        StorageLive(_38);                // scope 3 at src/util.rs:255:23: 255:30
        _38 = (_9.1: usize);             // scope 3 at src/util.rs:255:23: 255:30
        StorageLive(_39);                // scope 3 at src/util.rs:255:33: 255:46
        StorageLive(_40);                // scope 3 at src/util.rs:255:33: 255:40
        _40 = (_9.0: &[u8]);             // scope 3 at src/util.rs:255:33: 255:40
        _39 = core::slice::<impl [u8]>::len(move _40) -> [return: bb15, unwind: bb33]; // scope 3 at src/util.rs:255:33: 255:46
                                         // mir::Constant
                                         // + span: src/util.rs:255:41: 255:44
                                         // + literal: Const { ty: for<'r> fn(&'r [u8]) -> usize {core::slice::<impl [u8]>::len}, val: Value(Scalar(<ZST>)) }
    }

    bb15: {
        StorageDead(_40);                // scope 3 at src/util.rs:255:45: 255:46
        _37 = Lt(move _38, move _39);    // scope 3 at src/util.rs:255:23: 255:46
        StorageDead(_39);                // scope 3 at src/util.rs:255:45: 255:46
        StorageDead(_38);                // scope 3 at src/util.rs:255:45: 255:46
        switchInt(move _37) -> [false: bb26, otherwise: bb16]; // scope 3 at src/util.rs:255:23: 255:46
    }

    bb16: {
        StorageLive(_41);                // scope 3 at src/util.rs:256:25: 256:28
        _42 = discriminant(_1);          // scope 3 at src/util.rs:256:37: 256:39
        switchInt(move _42) -> [0_isize: bb18, otherwise: bb17]; // scope 3 at src/util.rs:256:31: 256:39
    }

    bb17: {
        core::panicking::panic(const "internal error: entered unreachable code") -> bb33; // scope 3 at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:39
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panic.rs:28:9: 28:33
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 })
                                         // mir::Constant
                                         // + span: /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/macros/mod.rs:591:24: 591:66
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 116, 101, 114, 110, 97, 108, 32, 101, 114, 114, 111, 114, 58, 32, 101, 110, 116, 101, 114, 101, 100, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 32, 99, 111, 100, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1099511627775], len: Size { raw: 40 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 40 }) }
    }

    bb18: {
        StorageLive(_43);                // scope 3 at src/util.rs:257:49: 257:57
        StorageLive(_44);                // scope 3 at src/util.rs:257:49: 257:57
        _44 = &mut _9;                   // scope 3 at src/util.rs:257:49: 257:57
        _43 = &mut (*_44);               // scope 3 at src/util.rs:257:49: 257:57
        _41 = windows949::start::S0::<T>(move _43) -> [return: bb19, unwind: bb33]; // scope 3 at src/util.rs:257:42: 257:58
                                         // mir::Constant
                                         // + span: src/util.rs:257:35: 257:48
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::korean::windows949::State, T>) -> codec::korean::windows949::State {codec::korean::windows949::start::S0::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb19: {
        StorageDead(_44);                // scope 3 at src/util.rs:257:57: 257:58
        StorageDead(_43);                // scope 3 at src/util.rs:257:57: 257:58
        StorageLive(_45);                // scope 6 at src/util.rs:263:27: 263:48
        StorageLive(_46);                // scope 6 at src/util.rs:263:28: 263:42
        StorageLive(_47);                // scope 6 at src/util.rs:263:28: 263:35
        _47 = &mut (_9.3: std::option::Option<encoding_types::CodecError>); // scope 6 at src/util.rs:263:28: 263:35
        _46 = Option::<encoding_types::CodecError>::take(move _47) -> [return: bb20, unwind: bb33]; // scope 6 at src/util.rs:263:28: 263:42
                                         // mir::Constant
                                         // + span: src/util.rs:263:36: 263:40
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::option::Option<encoding_types::CodecError>) -> std::option::Option<encoding_types::CodecError> {std::option::Option::<encoding_types::CodecError>::take}, val: Value(Scalar(<ZST>)) }
    }

    bb20: {
        StorageDead(_47);                // scope 6 at src/util.rs:263:41: 263:42
        StorageLive(_48);                // scope 6 at src/util.rs:263:44: 263:47
        _48 = _41;                       // scope 6 at src/util.rs:263:44: 263:47
        (_45.0: std::option::Option<encoding_types::CodecError>) = move _46; // scope 6 at src/util.rs:263:27: 263:48
        (_45.1: codec::korean::windows949::State) = move _48; // scope 6 at src/util.rs:263:27: 263:48
        StorageDead(_48);                // scope 6 at src/util.rs:263:47: 263:48
        StorageDead(_46);                // scope 6 at src/util.rs:263:47: 263:48
        _50 = discriminant((_45.0: std::option::Option<encoding_types::CodecError>)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _50) -> [0_isize: bb21, 1_isize: bb22, otherwise: bb23]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb21: {
        _49 = discriminant((_45.1: codec::korean::windows949::State)); // scope 6 at src/util.rs:263:27: 263:48
        switchInt(move _49) -> [0_isize: bb24, otherwise: bb25]; // scope 6 at src/util.rs:263:21: 263:48
    }

    bb22: {
        StorageLive(_56);                // scope 6 at src/util.rs:267:31: 267:34
        _56 = move (((_45.0: std::option::Option<encoding_types::CodecError>) as Some).0: encoding_types::CodecError); // scope 6 at src/util.rs:267:31: 267:34
        StorageLive(_57);                // scope 7 at src/util.rs:267:53: 267:56
        _57 = _41;                       // scope 7 at src/util.rs:267:53: 267:56
        StorageLive(_58);                // scope 7 at src/util.rs:267:58: 267:67
        _58 = _14;                       // scope 7 at src/util.rs:267:58: 267:67
        StorageLive(_59);                // scope 7 at src/util.rs:267:69: 267:78
        StorageLive(_60);                // scope 7 at src/util.rs:267:74: 267:77
        _60 = move _56;                  // scope 7 at src/util.rs:267:74: 267:77
        ((_59 as Some).0: encoding_types::CodecError) = move _60; // scope 7 at src/util.rs:267:69: 267:78
        discriminant(_59) = 1;           // scope 7 at src/util.rs:267:69: 267:78
        StorageDead(_60);                // scope 7 at src/util.rs:267:77: 267:78
        (_0.0: codec::korean::windows949::State) = move _57; // scope 7 at src/util.rs:267:52: 267:79
        (_0.1: usize) = move _58;        // scope 7 at src/util.rs:267:52: 267:79
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _59; // scope 7 at src/util.rs:267:52: 267:79
        StorageDead(_59);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_58);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_57);                // scope 7 at src/util.rs:267:78: 267:79
        StorageDead(_56);                // scope 6 at src/util.rs:267:81: 267:82
        goto -> bb28;                    // scope 6 at no-location
    }

    bb23: {
        unreachable;                     // scope 6 at src/util.rs:263:27: 263:48
    }

    bb24: {
        StorageLive(_51);                // scope 6 at src/util.rs:264:74: 264:77
        _51 = _41;                       // scope 6 at src/util.rs:264:74: 264:77
        _1 = move _51;                   // scope 6 at src/util.rs:264:69: 264:77
        StorageDead(_51);                // scope 6 at src/util.rs:264:76: 264:77
        StorageLive(_52);                // scope 6 at src/util.rs:264:91: 264:98
        _52 = (_9.1: usize);             // scope 6 at src/util.rs:264:91: 264:98
        _14 = move _52;                  // scope 6 at src/util.rs:264:79: 264:98
        StorageDead(_52);                // scope 6 at src/util.rs:264:97: 264:98
        StorageDead(_41);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb14;                    // scope 3 at src/util.rs:255:17: 269:18
    }

    bb25: {
        StorageLive(_53);                // scope 6 at src/util.rs:266:48: 266:51
        _53 = _41;                       // scope 6 at src/util.rs:266:48: 266:51
        StorageLive(_54);                // scope 6 at src/util.rs:266:53: 266:62
        _54 = _14;                       // scope 6 at src/util.rs:266:53: 266:62
        StorageLive(_55);                // scope 6 at src/util.rs:266:64: 266:68
        discriminant(_55) = 0;           // scope 6 at src/util.rs:266:64: 266:68
        (_0.0: codec::korean::windows949::State) = move _53; // scope 6 at src/util.rs:266:47: 266:69
        (_0.1: usize) = move _54;        // scope 6 at src/util.rs:266:47: 266:69
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _55; // scope 6 at src/util.rs:266:47: 266:69
        StorageDead(_55);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_54);                // scope 6 at src/util.rs:266:68: 266:69
        StorageDead(_53);                // scope 6 at src/util.rs:266:68: 266:69
        goto -> bb28;                    // scope 6 at src/util.rs:266:40: 266:69
    }

    bb26: {
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        StorageLive(_61);                // scope 3 at src/util.rs:271:18: 271:20
        _61 = _1;                        // scope 3 at src/util.rs:271:18: 271:20
        StorageLive(_62);                // scope 3 at src/util.rs:271:22: 271:31
        _62 = _14;                       // scope 3 at src/util.rs:271:22: 271:31
        StorageLive(_63);                // scope 3 at src/util.rs:271:33: 271:37
        discriminant(_63) = 0;           // scope 3 at src/util.rs:271:33: 271:37
        (_0.0: codec::korean::windows949::State) = move _61; // scope 3 at src/util.rs:271:17: 271:38
        (_0.1: usize) = move _62;        // scope 3 at src/util.rs:271:17: 271:38
        (_0.2: std::option::Option<encoding_types::CodecError>) = move _63; // scope 3 at src/util.rs:271:17: 271:38
        StorageDead(_63);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_62);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_61);                // scope 3 at src/util.rs:271:37: 271:38
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb27;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb27: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb32;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb28: {
        StorageDead(_41);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_45);                // scope 3 at src/util.rs:269:17: 269:18
        StorageDead(_37);                // scope 3 at src/util.rs:269:17: 269:18
        goto -> bb30;                    // scope 3 at no-location
    }

    bb29: {
        StorageDead(_21);                // scope 3 at src/util.rs:253:17: 253:18
        goto -> bb30;                    // scope 3 at no-location
    }

    bb30: {
        StorageDead(_15);                // scope 2 at src/util.rs:272:13: 272:14
        StorageDead(_14);                // scope 1 at src/util.rs:272:13: 272:14
        drop(_9) -> bb31;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb31: {
        StorageDead(_9);                 // scope 0 at src/util.rs:272:13: 272:14
        goto -> bb32;                    // scope 0 at src/util.rs:272:14: 272:14
    }

    bb32: {
        return;                          // scope 0 at src/util.rs:272:14: 272:14
    }

    bb33 (cleanup): {
        drop(_9) -> bb34;                // scope 0 at src/util.rs:272:13: 272:14
    }

    bb34 (cleanup): {
        resume;                          // scope 0 at src/util.rs:232:13: 272:14
    }
}

fn japanese::<impl at src/codec/japanese.rs:774:1: 779:2>::name(_1: &ISO2022JPEncoding) -> &str {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:775:13: 775:18
    let mut _0: &str;                    // return place in scope 0 at src/codec/japanese.rs:775:23: 775:35

    bb0: {
        _0 = const "iso-2022-jp";        // scope 0 at src/codec/japanese.rs:775:38: 775:51
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:775:38: 775:51
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 115, 111, 45, 50, 48, 50, 50, 45, 106, 112], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2047], len: Size { raw: 11 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 11 }) }
        return;                          // scope 0 at src/codec/japanese.rs:775:53: 775:53
    }
}

fn util::<impl at src/util.rs:69:1: 130:2>::err(_1: &mut StatefulDecoderHelper<St, Data>, _2: &str) -> St {
    debug self => _1;                    // in scope 0 at src/util.rs:114:16: 114:25
    debug msg => _2;                     // in scope 0 at src/util.rs:114:27: 114:30
    let mut _0: St;                      // return place in scope 0 at src/util.rs:114:49: 114:51
    let mut _3: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/util.rs:115:20: 115:90
    let mut _4: encoding_types::CodecError; // in scope 0 at src/util.rs:115:25: 115:89
    let mut _5: isize;                   // in scope 0 at src/util.rs:115:51: 115:68
    let mut _6: usize;                   // in scope 0 at src/util.rs:115:51: 115:59
    let mut _7: std::borrow::Cow<str>;   // in scope 0 at src/util.rs:115:77: 115:87
    let mut _8: &str;                    // in scope 0 at src/util.rs:115:77: 115:80

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:115:20: 115:90
        StorageLive(_4);                 // scope 0 at src/util.rs:115:25: 115:89
        StorageLive(_5);                 // scope 0 at src/util.rs:115:51: 115:68
        StorageLive(_6);                 // scope 0 at src/util.rs:115:51: 115:59
        _6 = ((*_1).1: usize);           // scope 0 at src/util.rs:115:51: 115:59
        _5 = move _6 as isize (Misc);    // scope 0 at src/util.rs:115:51: 115:68
        StorageDead(_6);                 // scope 0 at src/util.rs:115:67: 115:68
        StorageLive(_7);                 // scope 0 at src/util.rs:115:77: 115:87
        StorageLive(_8);                 // scope 0 at src/util.rs:115:77: 115:80
        _8 = _2;                         // scope 0 at src/util.rs:115:77: 115:80
        _7 = <&str as Into<Cow<str>>>::into(move _8) -> bb1; // scope 0 at src/util.rs:115:77: 115:87
                                         // mir::Constant
                                         // + span: src/util.rs:115:81: 115:85
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_8);                 // scope 0 at src/util.rs:115:86: 115:87
        (_4.0: isize) = move _5;         // scope 0 at src/util.rs:115:25: 115:89
        (_4.1: std::borrow::Cow<str>) = move _7; // scope 0 at src/util.rs:115:25: 115:89
        StorageDead(_7);                 // scope 0 at src/util.rs:115:88: 115:89
        StorageDead(_5);                 // scope 0 at src/util.rs:115:88: 115:89
        ((_3 as Some).0: encoding_types::CodecError) = move _4; // scope 0 at src/util.rs:115:20: 115:90
        discriminant(_3) = 1;            // scope 0 at src/util.rs:115:20: 115:90
        StorageDead(_4);                 // scope 0 at src/util.rs:115:89: 115:90
        drop(((*_1).3: std::option::Option<encoding_types::CodecError>)) -> [return: bb4, unwind: bb3]; // scope 0 at src/util.rs:115:9: 115:17
    }

    bb2: {
        return;                          // scope 0 at src/util.rs:117:6: 117:6
    }

    bb3 (cleanup): {
        ((*_1).3: std::option::Option<encoding_types::CodecError>) = move _3; // scope 0 at src/util.rs:115:9: 115:17
        resume;                          // scope 0 at src/util.rs:114:5: 117:6
    }

    bb4: {
        ((*_1).3: std::option::Option<encoding_types::CodecError>) = move _3; // scope 0 at src/util.rs:115:9: 115:17
        StorageDead(_3);                 // scope 0 at src/util.rs:115:89: 115:90
        _0 = <St as Default>::default() -> bb2; // scope 0 at src/util.rs:116:9: 116:27
                                         // mir::Constant
                                         // + span: src/util.rs:116:9: 116:25
                                         // + literal: Const { ty: fn() -> St {<St as std::default::Default>::default}, val: Value(Scalar(<ZST>)) }
    }
}

fn utf_16::<impl at src/codec/utf_16.rs:40:1: 45:2>::raw_encoder(_1: &UTF16BEEncoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/utf_16.rs:43:20: 43:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/utf_16.rs:43:30: 43:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:43:48: 43:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/utf_16.rs:43:48: 43:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/utf_16.rs:43:48: 43:69
        StorageLive(_3);                 // scope 0 at src/codec/utf_16.rs:43:48: 43:69
        _3 = UTF16BEEncoder::new() -> bb1; // scope 0 at src/codec/utf_16.rs:43:48: 43:69
                                         // mir::Constant
                                         // + span: src/codec/utf_16.rs:43:48: 43:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::utf_16::UTF16BEEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:43:48: 43:69
        StorageDead(_3);                 // scope 0 at src/codec/utf_16.rs:43:68: 43:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/utf_16.rs:43:48: 43:69
        StorageDead(_2);                 // scope 0 at src/codec/utf_16.rs:43:70: 43:71
        return;                          // scope 0 at src/codec/utf_16.rs:43:71: 43:71
    }
}

fn simpchinese::<impl at src/codec/simpchinese.rs:99:1: 106:2>::from_self(_1: &GBKEncoder) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/simpchinese.rs:100:18: 100:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/simpchinese.rs:100:28: 100:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:100:46: 100:63
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/simpchinese.rs:100:46: 100:63

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/simpchinese.rs:100:46: 100:63
        StorageLive(_3);                 // scope 0 at src/codec/simpchinese.rs:100:46: 100:63
        _3 = GBKEncoder::new() -> bb1;   // scope 0 at src/codec/simpchinese.rs:100:46: 100:63
                                         // mir::Constant
                                         // + span: src/codec/simpchinese.rs:100:46: 100:61
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::simpchinese::GBKEncoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:100:46: 100:63
        StorageDead(_3);                 // scope 0 at src/codec/simpchinese.rs:100:62: 100:63
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/simpchinese.rs:100:46: 100:63
        StorageDead(_2);                 // scope 0 at src/codec/simpchinese.rs:100:64: 100:65
        return;                          // scope 0 at src/codec/simpchinese.rs:100:65: 100:65
    }
}

fn codec::error::<impl at src/codec/error.rs:28:1: 43:2>::raw_feed(_1: &mut ErrorEncoder, _2: &str, _3: &mut dyn encoding_types::ByteWriter) -> (usize, Option<encoding_types::CodecError>) {
    debug self => _1;                    // in scope 0 at src/codec/error.rs:31:17: 31:26
    debug input => _2;                   // in scope 0 at src/codec/error.rs:31:28: 31:33
    debug _output => _3;                 // in scope 0 at src/codec/error.rs:31:41: 31:48
    let mut _0: (usize, std::option::Option<encoding_types::CodecError>); // return place in scope 0 at src/codec/error.rs:31:70: 31:97
    let mut _4: std::option::Option<char>; // in scope 0 at src/codec/error.rs:32:27: 32:47
    let mut _5: &mut std::str::Chars;    // in scope 0 at src/codec/error.rs:32:27: 32:40
    let mut _6: std::str::Chars;         // in scope 0 at src/codec/error.rs:32:27: 32:40
    let mut _7: &str;                    // in scope 0 at src/codec/error.rs:32:27: 32:32
    let mut _8: isize;                   // in scope 0 at src/codec/error.rs:32:16: 32:24
    let _9: char;                        // in scope 0 at src/codec/error.rs:32:21: 32:23
    let mut _10: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/error.rs:33:17: 34:79
    let mut _11: encoding_types::CodecError; // in scope 0 at src/codec/error.rs:33:22: 34:78
    let mut _12: isize;                  // in scope 0 at src/codec/error.rs:33:41: 33:63
    let mut _13: usize;                  // in scope 0 at src/codec/error.rs:33:41: 33:54
    let mut _14: char;                   // in scope 0 at src/codec/error.rs:33:41: 33:43
    let mut _15: std::borrow::Cow<str>;  // in scope 0 at src/codec/error.rs:34:42: 34:76
    let mut _16: &str;                   // in scope 0 at src/codec/error.rs:34:42: 34:69
    let _17: &str;                       // in scope 0 at src/codec/error.rs:34:42: 34:69
    let mut _18: std::option::Option<encoding_types::CodecError>; // in scope 0 at src/codec/error.rs:36:17: 36:21
    scope 1 {
        debug ch => _9;                  // in scope 1 at src/codec/error.rs:32:21: 32:23
    }

    bb0: {
        StorageLive(_4);                 // scope 0 at src/codec/error.rs:32:27: 32:47
        StorageLive(_5);                 // scope 0 at src/codec/error.rs:32:27: 32:40
        StorageLive(_6);                 // scope 0 at src/codec/error.rs:32:27: 32:40
        StorageLive(_7);                 // scope 0 at src/codec/error.rs:32:27: 32:32
        _7 = _2;                         // scope 0 at src/codec/error.rs:32:27: 32:32
        _6 = core::str::<impl str>::chars(move _7) -> bb1; // scope 0 at src/codec/error.rs:32:27: 32:40
                                         // mir::Constant
                                         // + span: src/codec/error.rs:32:33: 32:38
                                         // + literal: Const { ty: for<'r> fn(&'r str) -> std::str::Chars<'r> {core::str::<impl str>::chars}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _5 = &mut _6;                    // scope 0 at src/codec/error.rs:32:27: 32:40
        StorageDead(_7);                 // scope 0 at src/codec/error.rs:32:39: 32:40
        _4 = <Chars as Iterator>::next(move _5) -> bb2; // scope 0 at src/codec/error.rs:32:27: 32:47
                                         // mir::Constant
                                         // + span: src/codec/error.rs:32:41: 32:45
                                         // + literal: Const { ty: for<'r> fn(&'r mut std::str::Chars) -> std::option::Option<<std::str::Chars as std::iter::Iterator>::Item> {<std::str::Chars as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }
    }

    bb2: {
        StorageDead(_5);                 // scope 0 at src/codec/error.rs:32:46: 32:47
        _8 = discriminant(_4);           // scope 0 at src/codec/error.rs:32:16: 32:24
        switchInt(move _8) -> [1_isize: bb3, otherwise: bb6]; // scope 0 at src/codec/error.rs:32:16: 32:24
    }

    bb3: {
        StorageLive(_9);                 // scope 0 at src/codec/error.rs:32:21: 32:23
        _9 = ((_4 as Some).0: char);     // scope 0 at src/codec/error.rs:32:21: 32:23
        StorageLive(_10);                // scope 0 at src/codec/error.rs:33:17: 34:79
        StorageLive(_11);                // scope 0 at src/codec/error.rs:33:22: 34:78
        StorageLive(_12);                // scope 0 at src/codec/error.rs:33:41: 33:63
        StorageLive(_13);                // scope 0 at src/codec/error.rs:33:41: 33:54
        StorageLive(_14);                // scope 0 at src/codec/error.rs:33:41: 33:43
        _14 = _9;                        // scope 0 at src/codec/error.rs:33:41: 33:43
        _13 = char::methods::<impl char>::len_utf8(move _14) -> bb4; // scope 0 at src/codec/error.rs:33:41: 33:54
                                         // mir::Constant
                                         // + span: src/codec/error.rs:33:44: 33:52
                                         // + literal: Const { ty: fn(char) -> usize {std::char::methods::<impl char>::len_utf8}, val: Value(Scalar(<ZST>)) }
    }

    bb4: {
        StorageDead(_14);                // scope 0 at src/codec/error.rs:33:53: 33:54
        _12 = move _13 as isize (Misc);  // scope 0 at src/codec/error.rs:33:41: 33:63
        StorageDead(_13);                // scope 0 at src/codec/error.rs:33:62: 33:63
        StorageLive(_15);                // scope 0 at src/codec/error.rs:34:42: 34:76
        StorageLive(_16);                // scope 0 at src/codec/error.rs:34:42: 34:69
        StorageLive(_17);                // scope 0 at src/codec/error.rs:34:42: 34:69
        _17 = const "unrepresentable character"; // scope 0 at src/codec/error.rs:34:42: 34:69
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 })
                                         // mir::Constant
                                         // + span: src/codec/error.rs:34:42: 34:69
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [117, 110, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [33554431], len: Size { raw: 25 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 25 }) }
        _16 = _17;                       // scope 0 at src/codec/error.rs:34:42: 34:69
        _15 = <&str as Into<Cow<str>>>::into(move _16) -> bb5; // scope 0 at src/codec/error.rs:34:42: 34:76
                                         // mir::Constant
                                         // + span: src/codec/error.rs:34:70: 34:74
                                         // + literal: Const { ty: fn(&str) -> std::borrow::Cow<str> {<&str as std::convert::Into<std::borrow::Cow<str>>>::into}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        StorageDead(_16);                // scope 0 at src/codec/error.rs:34:75: 34:76
        (_11.0: isize) = move _12;       // scope 0 at src/codec/error.rs:33:22: 34:78
        (_11.1: std::borrow::Cow<str>) = move _15; // scope 0 at src/codec/error.rs:33:22: 34:78
        StorageDead(_15);                // scope 0 at src/codec/error.rs:34:77: 34:78
        StorageDead(_12);                // scope 0 at src/codec/error.rs:34:77: 34:78
        ((_10 as Some).0: encoding_types::CodecError) = move _11; // scope 0 at src/codec/error.rs:33:17: 34:79
        discriminant(_10) = 1;           // scope 0 at src/codec/error.rs:33:17: 34:79
        StorageDead(_11);                // scope 0 at src/codec/error.rs:34:78: 34:79
        (_0.0: usize) = const 0_usize;   // scope 0 at src/codec/error.rs:33:13: 34:80
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _10; // scope 0 at src/codec/error.rs:33:13: 34:80
        StorageDead(_10);                // scope 0 at src/codec/error.rs:34:79: 34:80
        StorageDead(_17);                // scope 0 at src/codec/error.rs:35:9: 35:10
        StorageDead(_9);                 // scope 0 at src/codec/error.rs:35:9: 35:10
        goto -> bb7;                     // scope 0 at src/codec/error.rs:32:9: 37:10
    }

    bb6: {
        StorageLive(_18);                // scope 0 at src/codec/error.rs:36:17: 36:21
        discriminant(_18) = 0;           // scope 0 at src/codec/error.rs:36:17: 36:21
        (_0.0: usize) = const 0_usize;   // scope 0 at src/codec/error.rs:36:13: 36:22
        (_0.1: std::option::Option<encoding_types::CodecError>) = move _18; // scope 0 at src/codec/error.rs:36:13: 36:22
        StorageDead(_18);                // scope 0 at src/codec/error.rs:36:21: 36:22
        goto -> bb7;                     // scope 0 at src/codec/error.rs:32:9: 37:10
    }

    bb7: {
        StorageDead(_6);                 // scope 0 at src/codec/error.rs:38:5: 38:6
        StorageDead(_4);                 // scope 0 at src/codec/error.rs:38:5: 38:6
        return;                          // scope 0 at src/codec/error.rs:38:6: 38:6
    }
}

fn korean::<impl at src/codec/korean.rs:27:1: 32:2>::raw_encoder(_1: &Windows949Encoding) -> Box<dyn encoding_types::RawEncoder> {
    debug self => _1;                    // in scope 0 at src/codec/korean.rs:30:20: 30:25
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/korean.rs:30:30: 30:45
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/korean.rs:30:48: 30:72
    let mut _3: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/korean.rs:30:48: 30:72

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/korean.rs:30:48: 30:72
        StorageLive(_3);                 // scope 0 at src/codec/korean.rs:30:48: 30:72
        _3 = Windows949Encoder::new() -> bb1; // scope 0 at src/codec/korean.rs:30:48: 30:72
                                         // mir::Constant
                                         // + span: src/codec/korean.rs:30:48: 30:70
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawEncoder + 'static)> {codec::korean::Windows949Encoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:30:48: 30:72
        StorageDead(_3);                 // scope 0 at src/codec/korean.rs:30:71: 30:72
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/korean.rs:30:48: 30:72
        StorageDead(_2);                 // scope 0 at src/codec/korean.rs:30:73: 30:74
        return;                          // scope 0 at src/codec/korean.rs:30:74: 30:74
    }
}

fn hz::<impl at src/util.rs:157:22: 157:31>::ne(_1: &hz::State, _2: &hz::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::simpchinese::hz::State, &codec::simpchinese::hz::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::simpchinese::hz::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _18: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _19: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _20: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _23: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _24: &();                    // in scope 0 at src/util.rs:161:27: 161:29
    let mut _27: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _28: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _31: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _32: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _37: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _38: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _39: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _40: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _41: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _42: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _21: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _22: &();                // in scope 2 at src/util.rs:161:27: 161:29
            let _25: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _26: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _29: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _30: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _33: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _34: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _35: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _36: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _21;   // in scope 3 at src/util.rs:161:27: 161:29
                debug __arg_1_0 => _22;  // in scope 3 at src/util.rs:161:27: 161:29
            }
            scope 4 {
                debug __self_0 => _25;   // in scope 4 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _26;  // in scope 4 at src/util.rs:164:25: 164:27
            }
            scope 5 {
                debug __self_0 => _29;   // in scope 5 at src/util.rs:164:25: 164:27
                debug __arg_1_0 => _30;  // in scope 5 at src/util.rs:164:25: 164:27
            }
            scope 6 {
                debug __self_0 => _33;   // in scope 6 at src/util.rs:164:25: 164:27
                debug __self_1 => _34;   // in scope 6 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _35;  // in scope 6 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _36;  // in scope 6 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb19, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::simpchinese::hz::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::simpchinese::hz::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _20 = discriminant((*(_13.0: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _20) -> [1_isize: bb3, 2_isize: bb4, 3_isize: bb5, 4_isize: bb6, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb7, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        _17 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [2_isize: bb9, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb5: {
        _18 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _18) -> [3_isize: bb11, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb6: {
        _19 = discriminant((*(_13.1: &codec::simpchinese::hz::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _19) -> [4_isize: bb13, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb7: {
        StorageLive(_21);                // scope 2 at src/util.rs:161:27: 161:29
        _21 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B0).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_22);                // scope 2 at src/util.rs:161:27: 161:29
        _22 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B0).0: ()); // scope 2 at src/util.rs:161:27: 161:29
        StorageLive(_23);                // scope 3 at src/util.rs:161:27: 161:29
        _23 = _21;                       // scope 3 at src/util.rs:161:27: 161:29
        StorageLive(_24);                // scope 3 at src/util.rs:161:27: 161:29
        _24 = _22;                       // scope 3 at src/util.rs:161:27: 161:29
        _0 = <() as PartialEq>::ne(move _23, move _24) -> bb8; // scope 3 at src/util.rs:161:27: 161:29
                                         // mir::Constant
                                         // + span: src/util.rs:161:27: 161:29
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_23);                // scope 3 at src/util.rs:161:28: 161:29
        StorageDead(_22);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb9: {
        StorageLive(_25);                // scope 2 at src/util.rs:164:25: 164:27
        _25 = &(((*(_13.0: &codec::simpchinese::hz::State)) as A1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_26);                // scope 2 at src/util.rs:164:25: 164:27
        _26 = &(((*(_13.1: &codec::simpchinese::hz::State)) as A1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_27);                // scope 4 at src/util.rs:164:25: 164:27
        _27 = _25;                       // scope 4 at src/util.rs:164:25: 164:27
        StorageLive(_28);                // scope 4 at src/util.rs:164:25: 164:27
        _28 = _26;                       // scope 4 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _27, move _28) -> bb10; // scope 4 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb10: {
        StorageDead(_28);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_27);                // scope 4 at src/util.rs:164:26: 164:27
        StorageDead(_26);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_25);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb11: {
        StorageLive(_29);                // scope 2 at src/util.rs:164:25: 164:27
        _29 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_30);                // scope 2 at src/util.rs:164:25: 164:27
        _30 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_31);                // scope 5 at src/util.rs:164:25: 164:27
        _31 = _29;                       // scope 5 at src/util.rs:164:25: 164:27
        StorageLive(_32);                // scope 5 at src/util.rs:164:25: 164:27
        _32 = _30;                       // scope 5 at src/util.rs:164:25: 164:27
        _0 = <() as PartialEq>::ne(move _31, move _32) -> bb12; // scope 5 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb12: {
        StorageDead(_32);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_31);                // scope 5 at src/util.rs:164:26: 164:27
        StorageDead(_30);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_29);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb13: {
        StorageLive(_33);                // scope 2 at src/util.rs:164:25: 164:27
        _33 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_34);                // scope 2 at src/util.rs:164:32: 164:35
        _34 = &(((*(_13.0: &codec::simpchinese::hz::State)) as B2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_35);                // scope 2 at src/util.rs:164:25: 164:27
        _35 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B2).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_36);                // scope 2 at src/util.rs:164:32: 164:35
        _36 = &(((*(_13.1: &codec::simpchinese::hz::State)) as B2).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_37);                // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_38);                // scope 6 at src/util.rs:164:25: 164:27
        _38 = _33;                       // scope 6 at src/util.rs:164:25: 164:27
        StorageLive(_39);                // scope 6 at src/util.rs:164:25: 164:27
        _39 = _35;                       // scope 6 at src/util.rs:164:25: 164:27
        _37 = <() as PartialEq>::ne(move _38, move _39) -> bb17; // scope 6 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::ne}, val: Value(Scalar(<ZST>)) }
    }

    bb14: {
        _0 = const true;                 // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb16;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb15: {
        StorageLive(_40);                // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_41);                // scope 6 at src/util.rs:164:32: 164:35
        _41 = (*_34);                    // scope 6 at src/util.rs:164:32: 164:35
        StorageLive(_42);                // scope 6 at src/util.rs:164:32: 164:35
        _42 = (*_36);                    // scope 6 at src/util.rs:164:32: 164:35
        _40 = Ne(move _41, move _42);    // scope 6 at src/util.rs:164:32: 164:35
        StorageDead(_42);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_41);                // scope 6 at src/util.rs:164:34: 164:35
        _0 = move _40;                   // scope 6 at src/util.rs:164:32: 164:35
        goto -> bb16;                    // scope 6 at src/util.rs:164:32: 164:35
    }

    bb16: {
        StorageDead(_40);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_37);                // scope 6 at src/util.rs:164:34: 164:35
        StorageDead(_36);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_35);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_34);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_33);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb18;                    // scope 2 at src/util.rs:157:30: 157:31
    }

    bb17: {
        StorageDead(_39);                // scope 6 at src/util.rs:164:26: 164:27
        StorageDead(_38);                // scope 6 at src/util.rs:164:26: 164:27
        switchInt(move _37) -> [false: bb15, otherwise: bb14]; // scope 6 at src/util.rs:164:32: 164:35
    }

    bb18: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb20;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb19: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb20;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb20: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}

fn singlebyte::<impl at src/codec/singlebyte.rs:33:1: 37:2>::new(_1: fn(u32) -> u8) -> Box<dyn encoding_types::RawEncoder> {
    debug index_backward => _1;          // in scope 0 at src/codec/singlebyte.rs:34:16: 34:30
    let mut _0: std::boxed::Box<dyn encoding_types::RawEncoder>; // return place in scope 0 at src/codec/singlebyte.rs:34:64: 34:79
    let mut _2: std::boxed::Box<dyn encoding_types::RawEncoder>; // in scope 0 at src/codec/singlebyte.rs:35:9: 35:71
    let mut _3: std::boxed::Box<codec::singlebyte::SingleByteEncoder>; // in scope 0 at src/codec/singlebyte.rs:35:9: 35:71
    let mut _4: codec::singlebyte::SingleByteEncoder; // in scope 0 at src/codec/singlebyte.rs:35:18: 35:70
    let mut _5: fn(u32) -> u8;           // in scope 0 at src/codec/singlebyte.rs:35:54: 35:68

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/singlebyte.rs:35:9: 35:71
        StorageLive(_3);                 // scope 0 at src/codec/singlebyte.rs:35:9: 35:71
        StorageLive(_4);                 // scope 0 at src/codec/singlebyte.rs:35:18: 35:70
        StorageLive(_5);                 // scope 0 at src/codec/singlebyte.rs:35:54: 35:68
        _5 = _1;                         // scope 0 at src/codec/singlebyte.rs:35:54: 35:68
        (_4.0: fn(u32) -> u8) = move _5; // scope 0 at src/codec/singlebyte.rs:35:18: 35:70
        StorageDead(_5);                 // scope 0 at src/codec/singlebyte.rs:35:69: 35:70
        _3 = Box::<SingleByteEncoder>::new(move _4) -> bb1; // scope 0 at src/codec/singlebyte.rs:35:9: 35:71
                                         // mir::Constant
                                         // + span: src/codec/singlebyte.rs:35:9: 35:17
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(codec::singlebyte::SingleByteEncoder) -> std::boxed::Box<codec::singlebyte::SingleByteEncoder> {std::boxed::Box::<codec::singlebyte::SingleByteEncoder>::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:35:9: 35:71
        StorageDead(_4);                 // scope 0 at src/codec/singlebyte.rs:35:70: 35:71
        StorageDead(_3);                 // scope 0 at src/codec/singlebyte.rs:35:70: 35:71
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawEncoder> (Pointer(Unsize)); // scope 0 at src/codec/singlebyte.rs:35:9: 35:71
        StorageDead(_2);                 // scope 0 at src/codec/singlebyte.rs:36:5: 36:6
        return;                          // scope 0 at src/codec/singlebyte.rs:36:6: 36:6
    }
}

fn japanese::<impl at src/codec/japanese.rs:98:1: 113:2>::from_self(_1: &EUCJP0212Decoder) -> Box<dyn encoding_types::RawDecoder> {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:99:18: 99:23
    let mut _0: std::boxed::Box<dyn encoding_types::RawDecoder>; // return place in scope 0 at src/codec/japanese.rs:99:28: 99:43
    let mut _2: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:99:46: 99:69
    let mut _3: std::boxed::Box<dyn encoding_types::RawDecoder>; // in scope 0 at src/codec/japanese.rs:99:46: 99:69

    bb0: {
        StorageLive(_2);                 // scope 0 at src/codec/japanese.rs:99:46: 99:69
        StorageLive(_3);                 // scope 0 at src/codec/japanese.rs:99:46: 99:69
        _3 = EUCJP0212Decoder::new() -> bb1; // scope 0 at src/codec/japanese.rs:99:46: 99:69
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:99:46: 99:67
                                         // + literal: Const { ty: fn() -> std::boxed::Box<(dyn encoding_types::RawDecoder + 'static)> {codec::japanese::EUCJP0212Decoder::new}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        _2 = move _3 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:99:46: 99:69
        StorageDead(_3);                 // scope 0 at src/codec/japanese.rs:99:68: 99:69
        _0 = move _2 as std::boxed::Box<dyn encoding_types::RawDecoder> (Pointer(Unsize)); // scope 0 at src/codec/japanese.rs:99:46: 99:69
        StorageDead(_2);                 // scope 0 at src/codec/japanese.rs:99:70: 99:71
        return;                          // scope 0 at src/codec/japanese.rs:99:71: 99:71
    }
}

fn encoding_from_windows_code_page(_1: usize) -> Option<&dyn encoding_types::Encoding + Send + Sync> {
    debug cp => _1;                      // in scope 0 at src/label.rs:282:40: 282:42
    let mut _0: std::option::Option<&dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync>; // return place in scope 0 at src/label.rs:282:54: 282:73
    let mut _2: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:284:23: 284:48
    let mut _3: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:284:23: 284:48
    let _4: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:284:23: 284:48
    let mut _5: &codec::utf_8::UTF8Encoding; // in scope 0 at src/label.rs:284:23: 284:33
    let _6: &codec::utf_8::UTF8Encoding; // in scope 0 at src/label.rs:284:23: 284:33
    let mut _7: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:285:21: 285:47
    let mut _8: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:285:21: 285:47
    let _9: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:285:21: 285:47
    let mut _10: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:285:21: 285:32
    let _11: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:285:21: 285:32
    let mut _12: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:286:23: 286:53
    let mut _13: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:286:23: 286:53
    let _14: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:286:23: 286:53
    let mut _15: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:286:23: 286:38
    let _16: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:286:23: 286:38
    let mut _17: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:287:23: 287:53
    let mut _18: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:287:23: 287:53
    let _19: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:287:23: 287:53
    let mut _20: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:287:23: 287:38
    let _21: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:287:23: 287:38
    let mut _22: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:288:23: 288:53
    let mut _23: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:288:23: 288:53
    let _24: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:288:23: 288:53
    let mut _25: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:288:23: 288:38
    let _26: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:288:23: 288:38
    let mut _27: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:289:23: 289:53
    let mut _28: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:289:23: 289:53
    let _29: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:289:23: 289:53
    let mut _30: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:289:23: 289:38
    let _31: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:289:23: 289:38
    let mut _32: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:290:23: 290:53
    let mut _33: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:290:23: 290:53
    let _34: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:290:23: 290:53
    let mut _35: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:290:23: 290:38
    let _36: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:290:23: 290:38
    let mut _37: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:291:23: 291:53
    let mut _38: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:291:23: 291:53
    let _39: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:291:23: 291:53
    let mut _40: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:291:23: 291:38
    let _41: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:291:23: 291:38
    let mut _42: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:292:23: 292:53
    let mut _43: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:292:23: 292:53
    let _44: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:292:23: 292:53
    let mut _45: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:292:23: 292:38
    let _46: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:292:23: 292:38
    let mut _47: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:293:23: 293:53
    let mut _48: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:293:23: 293:53
    let _49: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:293:23: 293:53
    let mut _50: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:293:23: 293:38
    let _51: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:293:23: 293:38
    let mut _52: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:294:23: 294:63
    let mut _53: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:294:23: 294:63
    let _54: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:294:23: 294:63
    let mut _55: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:294:23: 294:48
    let _56: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:294:23: 294:48
    let mut _57: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:295:23: 295:54
    let mut _58: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:295:23: 295:54
    let _59: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:295:23: 295:54
    let mut _60: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:295:23: 295:39
    let _61: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:295:23: 295:39
    let mut _62: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:296:23: 296:54
    let mut _63: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:296:23: 296:54
    let _64: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:296:23: 296:54
    let mut _65: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:296:23: 296:39
    let _66: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:296:23: 296:39
    let mut _67: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:297:23: 297:49
    let mut _68: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:297:23: 297:49
    let _69: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:297:23: 297:49
    let mut _70: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:297:23: 297:34
    let _71: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:297:23: 297:34
    let mut _72: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:298:23: 298:49
    let mut _73: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:298:23: 298:49
    let _74: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:298:23: 298:49
    let mut _75: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:298:23: 298:34
    let _76: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:298:23: 298:34
    let mut _77: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:299:23: 299:52
    let mut _78: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:299:23: 299:52
    let _79: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:299:23: 299:52
    let mut _80: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:299:23: 299:37
    let _81: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:299:23: 299:37
    let mut _82: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:300:21: 300:52
    let mut _83: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:300:21: 300:52
    let _84: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:300:21: 300:52
    let mut _85: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:300:21: 300:37
    let _86: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:300:21: 300:37
    let mut _87: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:301:22: 301:54
    let mut _88: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:301:22: 301:54
    let _89: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:301:22: 301:54
    let mut _90: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:301:22: 301:39
    let _91: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:301:22: 301:39
    let mut _92: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:302:22: 302:54
    let mut _93: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:302:22: 302:54
    let _94: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:302:22: 302:54
    let mut _95: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:302:22: 302:39
    let _96: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:302:22: 302:39
    let mut _97: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:303:22: 303:54
    let mut _98: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:303:22: 303:54
    let _99: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:303:22: 303:54
    let mut _100: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:303:22: 303:39
    let _101: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:303:22: 303:39
    let mut _102: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:304:22: 304:54
    let mut _103: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:304:22: 304:54
    let _104: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:304:22: 304:54
    let mut _105: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:304:22: 304:39
    let _106: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:304:22: 304:39
    let mut _107: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:305:22: 305:54
    let mut _108: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:305:22: 305:54
    let _109: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:305:22: 305:54
    let mut _110: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:305:22: 305:39
    let _111: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:305:22: 305:39
    let mut _112: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:306:22: 306:54
    let mut _113: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:306:22: 306:54
    let _114: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:306:22: 306:54
    let mut _115: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:306:22: 306:39
    let _116: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:306:22: 306:39
    let mut _117: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:307:22: 307:54
    let mut _118: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:307:22: 307:54
    let _119: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:307:22: 307:54
    let mut _120: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:307:22: 307:39
    let _121: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:307:22: 307:39
    let mut _122: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:308:22: 308:54
    let mut _123: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:308:22: 308:54
    let _124: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:308:22: 308:54
    let mut _125: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:308:22: 308:39
    let _126: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:308:22: 308:39
    let mut _127: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:309:22: 309:54
    let mut _128: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:309:22: 309:54
    let _129: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:309:22: 309:54
    let mut _130: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:309:22: 309:39
    let _131: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:309:22: 309:39
    let mut _132: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:310:22: 310:54
    let mut _133: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:310:22: 310:54
    let _134: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:310:22: 310:54
    let mut _135: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:310:22: 310:39
    let _136: &codec::singlebyte::SingleByteEncoding; // in scope 0 at src/label.rs:310:22: 310:39
    let mut _137: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:311:29: 311:56
    let mut _138: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:311:29: 311:56
    let _139: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:311:29: 311:56
    let mut _140: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/label.rs:311:29: 311:41
    let _141: &codec::simpchinese::GB18030Encoding; // in scope 0 at src/label.rs:311:29: 311:41
    let mut _142: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:312:23: 312:45
    let mut _143: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:312:23: 312:45
    let _144: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:312:23: 312:45
    let mut _145: &codec::simpchinese::HZEncoding; // in scope 0 at src/label.rs:312:23: 312:30
    let _146: &codec::simpchinese::HZEncoding; // in scope 0 at src/label.rs:312:23: 312:30
    let mut _147: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:313:21: 313:50
    let mut _148: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:313:21: 313:50
    let _149: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:313:21: 313:50
    let mut _150: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/label.rs:313:21: 313:35
    let _151: &codec::tradchinese::BigFive2003Encoding; // in scope 0 at src/label.rs:313:21: 313:35
    let mut _152: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:314:23: 314:49
    let mut _153: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:314:23: 314:49
    let _154: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:314:23: 314:49
    let mut _155: &codec::japanese::EUCJPEncoding; // in scope 0 at src/label.rs:314:23: 314:34
    let _156: &codec::japanese::EUCJPEncoding; // in scope 0 at src/label.rs:314:23: 314:34
    let mut _157: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:315:23: 315:54
    let mut _158: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:315:23: 315:54
    let _159: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:315:23: 315:54
    let mut _160: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/label.rs:315:23: 315:39
    let _161: &codec::japanese::ISO2022JPEncoding; // in scope 0 at src/label.rs:315:23: 315:39
    let mut _162: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:316:21: 316:52
    let mut _163: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:316:21: 316:52
    let _164: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:316:21: 316:52
    let mut _165: &codec::japanese::Windows31JEncoding; // in scope 0 at src/label.rs:316:21: 316:37
    let _166: &codec::japanese::Windows31JEncoding; // in scope 0 at src/label.rs:316:21: 316:37
    let mut _167: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:317:21: 317:52
    let mut _168: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:317:21: 317:52
    let _169: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:317:21: 317:52
    let mut _170: &codec::korean::Windows949Encoding; // in scope 0 at src/label.rs:317:21: 317:37
    let _171: &codec::korean::Windows949Encoding; // in scope 0 at src/label.rs:317:21: 317:37
    let mut _172: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:318:22: 318:50
    let mut _173: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:318:22: 318:50
    let _174: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:318:22: 318:50
    let mut _175: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/label.rs:318:22: 318:35
    let _176: &codec::utf_16::UTF16BEEncoding; // in scope 0 at src/label.rs:318:22: 318:35
    let mut _177: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:319:22: 319:50
    let mut _178: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:319:22: 319:50
    let _179: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync; // in scope 0 at src/label.rs:319:22: 319:50
    let mut _180: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/label.rs:319:22: 319:35
    let _181: &codec::utf_16::UTF16LEEncoding; // in scope 0 at src/label.rs:319:22: 319:35

    bb0: {
        switchInt(_1) -> [65001_usize: bb2, 866_usize: bb3, 28591_usize: bb4, 28592_usize: bb5, 28593_usize: bb6, 28594_usize: bb7, 28595_usize: bb8, 28596_usize: bb9, 28597_usize: bb10, 28598_usize: bb11, 38598_usize: bb12, 28603_usize: bb13, 28605_usize: bb14, 20866_usize: bb15, 21866_usize: bb16, 10000_usize: bb17, 874_usize: bb18, 1250_usize: bb19, 1251_usize: bb20, 1252_usize: bb21, 1253_usize: bb22, 1254_usize: bb23, 1255_usize: bb24, 1256_usize: bb25, 1257_usize: bb26, 1258_usize: bb27, 1259_usize: bb28, 936_usize: bb29, 54936_usize: bb29, 52936_usize: bb30, 950_usize: bb31, 20932_usize: bb32, 50220_usize: bb33, 932_usize: bb34, 949_usize: bb35, 1201_usize: bb36, 1200_usize: bb37, otherwise: bb1]; // scope 0 at src/label.rs:283:5: 283:13
    }

    bb1: {
        discriminant(_0) = 0;            // scope 0 at src/label.rs:320:14: 320:18
        goto -> bb38;                    // scope 0 at src/label.rs:320:14: 320:18
    }

    bb2: {
        StorageLive(_2);                 // scope 0 at src/label.rs:284:23: 284:48
        StorageLive(_3);                 // scope 0 at src/label.rs:284:23: 284:48
        StorageLive(_4);                 // scope 0 at src/label.rs:284:23: 284:48
        StorageLive(_5);                 // scope 0 at src/label.rs:284:23: 284:33
        StorageLive(_6);                 // scope 0 at src/label.rs:284:23: 284:33
        _6 = const UTF_8;                // scope 0 at src/label.rs:284:23: 284:33
                                         // ty::Const
                                         // + ty: &codec::utf_8::UTF8Encoding
                                         // + val: Unevaluated(UTF_8, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:284:23: 284:33
                                         // + literal: Const { ty: &codec::utf_8::UTF8Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1277 ~ encoding[5d2c]::all::UTF_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _5 = _6;                         // scope 0 at src/label.rs:284:23: 284:33
        _4 = move _5 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:284:23: 284:33
        StorageDead(_5);                 // scope 0 at src/label.rs:284:32: 284:33
        _3 = _4;                         // scope 0 at src/label.rs:284:23: 284:48
        _2 = move _3 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:284:23: 284:48
        StorageDead(_3);                 // scope 0 at src/label.rs:284:47: 284:48
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _2; // scope 0 at src/label.rs:284:18: 284:49
        discriminant(_0) = 1;            // scope 0 at src/label.rs:284:18: 284:49
        StorageDead(_6);                 // scope 0 at src/label.rs:284:48: 284:49
        StorageDead(_4);                 // scope 0 at src/label.rs:284:48: 284:49
        StorageDead(_2);                 // scope 0 at src/label.rs:284:48: 284:49
        goto -> bb38;                    // scope 0 at src/label.rs:284:48: 284:49
    }

    bb3: {
        StorageLive(_7);                 // scope 0 at src/label.rs:285:21: 285:47
        StorageLive(_8);                 // scope 0 at src/label.rs:285:21: 285:47
        StorageLive(_9);                 // scope 0 at src/label.rs:285:21: 285:47
        StorageLive(_10);                // scope 0 at src/label.rs:285:21: 285:32
        StorageLive(_11);                // scope 0 at src/label.rs:285:21: 285:32
        _11 = const IBM866;              // scope 0 at src/label.rs:285:21: 285:32
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(IBM866, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:285:21: 285:32
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1249 ~ encoding[5d2c]::all::IBM866), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _10 = _11;                       // scope 0 at src/label.rs:285:21: 285:32
        _9 = move _10 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:285:21: 285:32
        StorageDead(_10);                // scope 0 at src/label.rs:285:31: 285:32
        _8 = _9;                         // scope 0 at src/label.rs:285:21: 285:47
        _7 = move _8 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:285:21: 285:47
        StorageDead(_8);                 // scope 0 at src/label.rs:285:46: 285:47
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _7; // scope 0 at src/label.rs:285:16: 285:48
        discriminant(_0) = 1;            // scope 0 at src/label.rs:285:16: 285:48
        StorageDead(_11);                // scope 0 at src/label.rs:285:47: 285:48
        StorageDead(_9);                 // scope 0 at src/label.rs:285:47: 285:48
        StorageDead(_7);                 // scope 0 at src/label.rs:285:47: 285:48
        goto -> bb38;                    // scope 0 at src/label.rs:285:47: 285:48
    }

    bb4: {
        StorageLive(_12);                // scope 0 at src/label.rs:286:23: 286:53
        StorageLive(_13);                // scope 0 at src/label.rs:286:23: 286:53
        StorageLive(_14);                // scope 0 at src/label.rs:286:23: 286:53
        StorageLive(_15);                // scope 0 at src/label.rs:286:23: 286:38
        StorageLive(_16);                // scope 0 at src/label.rs:286:23: 286:38
        _16 = const ISO_8859_1;          // scope 0 at src/label.rs:286:23: 286:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_1, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:286:23: 286:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1250 ~ encoding[5d2c]::all::ISO_8859_1), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _15 = _16;                       // scope 0 at src/label.rs:286:23: 286:38
        _14 = move _15 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:286:23: 286:38
        StorageDead(_15);                // scope 0 at src/label.rs:286:37: 286:38
        _13 = _14;                       // scope 0 at src/label.rs:286:23: 286:53
        _12 = move _13 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:286:23: 286:53
        StorageDead(_13);                // scope 0 at src/label.rs:286:52: 286:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _12; // scope 0 at src/label.rs:286:18: 286:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:286:18: 286:54
        StorageDead(_16);                // scope 0 at src/label.rs:286:53: 286:54
        StorageDead(_14);                // scope 0 at src/label.rs:286:53: 286:54
        StorageDead(_12);                // scope 0 at src/label.rs:286:53: 286:54
        goto -> bb38;                    // scope 0 at src/label.rs:286:53: 286:54
    }

    bb5: {
        StorageLive(_17);                // scope 0 at src/label.rs:287:23: 287:53
        StorageLive(_18);                // scope 0 at src/label.rs:287:23: 287:53
        StorageLive(_19);                // scope 0 at src/label.rs:287:23: 287:53
        StorageLive(_20);                // scope 0 at src/label.rs:287:23: 287:38
        StorageLive(_21);                // scope 0 at src/label.rs:287:23: 287:38
        _21 = const ISO_8859_2;          // scope 0 at src/label.rs:287:23: 287:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_2, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:287:23: 287:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1251 ~ encoding[5d2c]::all::ISO_8859_2), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _20 = _21;                       // scope 0 at src/label.rs:287:23: 287:38
        _19 = move _20 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:287:23: 287:38
        StorageDead(_20);                // scope 0 at src/label.rs:287:37: 287:38
        _18 = _19;                       // scope 0 at src/label.rs:287:23: 287:53
        _17 = move _18 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:287:23: 287:53
        StorageDead(_18);                // scope 0 at src/label.rs:287:52: 287:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _17; // scope 0 at src/label.rs:287:18: 287:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:287:18: 287:54
        StorageDead(_21);                // scope 0 at src/label.rs:287:53: 287:54
        StorageDead(_19);                // scope 0 at src/label.rs:287:53: 287:54
        StorageDead(_17);                // scope 0 at src/label.rs:287:53: 287:54
        goto -> bb38;                    // scope 0 at src/label.rs:287:53: 287:54
    }

    bb6: {
        StorageLive(_22);                // scope 0 at src/label.rs:288:23: 288:53
        StorageLive(_23);                // scope 0 at src/label.rs:288:23: 288:53
        StorageLive(_24);                // scope 0 at src/label.rs:288:23: 288:53
        StorageLive(_25);                // scope 0 at src/label.rs:288:23: 288:38
        StorageLive(_26);                // scope 0 at src/label.rs:288:23: 288:38
        _26 = const ISO_8859_3;          // scope 0 at src/label.rs:288:23: 288:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_3, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:288:23: 288:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1252 ~ encoding[5d2c]::all::ISO_8859_3), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _25 = _26;                       // scope 0 at src/label.rs:288:23: 288:38
        _24 = move _25 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:288:23: 288:38
        StorageDead(_25);                // scope 0 at src/label.rs:288:37: 288:38
        _23 = _24;                       // scope 0 at src/label.rs:288:23: 288:53
        _22 = move _23 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:288:23: 288:53
        StorageDead(_23);                // scope 0 at src/label.rs:288:52: 288:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _22; // scope 0 at src/label.rs:288:18: 288:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:288:18: 288:54
        StorageDead(_26);                // scope 0 at src/label.rs:288:53: 288:54
        StorageDead(_24);                // scope 0 at src/label.rs:288:53: 288:54
        StorageDead(_22);                // scope 0 at src/label.rs:288:53: 288:54
        goto -> bb38;                    // scope 0 at src/label.rs:288:53: 288:54
    }

    bb7: {
        StorageLive(_27);                // scope 0 at src/label.rs:289:23: 289:53
        StorageLive(_28);                // scope 0 at src/label.rs:289:23: 289:53
        StorageLive(_29);                // scope 0 at src/label.rs:289:23: 289:53
        StorageLive(_30);                // scope 0 at src/label.rs:289:23: 289:38
        StorageLive(_31);                // scope 0 at src/label.rs:289:23: 289:38
        _31 = const ISO_8859_4;          // scope 0 at src/label.rs:289:23: 289:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_4, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:289:23: 289:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1253 ~ encoding[5d2c]::all::ISO_8859_4), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _30 = _31;                       // scope 0 at src/label.rs:289:23: 289:38
        _29 = move _30 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:289:23: 289:38
        StorageDead(_30);                // scope 0 at src/label.rs:289:37: 289:38
        _28 = _29;                       // scope 0 at src/label.rs:289:23: 289:53
        _27 = move _28 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:289:23: 289:53
        StorageDead(_28);                // scope 0 at src/label.rs:289:52: 289:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _27; // scope 0 at src/label.rs:289:18: 289:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:289:18: 289:54
        StorageDead(_31);                // scope 0 at src/label.rs:289:53: 289:54
        StorageDead(_29);                // scope 0 at src/label.rs:289:53: 289:54
        StorageDead(_27);                // scope 0 at src/label.rs:289:53: 289:54
        goto -> bb38;                    // scope 0 at src/label.rs:289:53: 289:54
    }

    bb8: {
        StorageLive(_32);                // scope 0 at src/label.rs:290:23: 290:53
        StorageLive(_33);                // scope 0 at src/label.rs:290:23: 290:53
        StorageLive(_34);                // scope 0 at src/label.rs:290:23: 290:53
        StorageLive(_35);                // scope 0 at src/label.rs:290:23: 290:38
        StorageLive(_36);                // scope 0 at src/label.rs:290:23: 290:38
        _36 = const ISO_8859_5;          // scope 0 at src/label.rs:290:23: 290:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_5, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:290:23: 290:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1254 ~ encoding[5d2c]::all::ISO_8859_5), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _35 = _36;                       // scope 0 at src/label.rs:290:23: 290:38
        _34 = move _35 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:290:23: 290:38
        StorageDead(_35);                // scope 0 at src/label.rs:290:37: 290:38
        _33 = _34;                       // scope 0 at src/label.rs:290:23: 290:53
        _32 = move _33 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:290:23: 290:53
        StorageDead(_33);                // scope 0 at src/label.rs:290:52: 290:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _32; // scope 0 at src/label.rs:290:18: 290:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:290:18: 290:54
        StorageDead(_36);                // scope 0 at src/label.rs:290:53: 290:54
        StorageDead(_34);                // scope 0 at src/label.rs:290:53: 290:54
        StorageDead(_32);                // scope 0 at src/label.rs:290:53: 290:54
        goto -> bb38;                    // scope 0 at src/label.rs:290:53: 290:54
    }

    bb9: {
        StorageLive(_37);                // scope 0 at src/label.rs:291:23: 291:53
        StorageLive(_38);                // scope 0 at src/label.rs:291:23: 291:53
        StorageLive(_39);                // scope 0 at src/label.rs:291:23: 291:53
        StorageLive(_40);                // scope 0 at src/label.rs:291:23: 291:38
        StorageLive(_41);                // scope 0 at src/label.rs:291:23: 291:38
        _41 = const ISO_8859_6;          // scope 0 at src/label.rs:291:23: 291:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_6, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:291:23: 291:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1255 ~ encoding[5d2c]::all::ISO_8859_6), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _40 = _41;                       // scope 0 at src/label.rs:291:23: 291:38
        _39 = move _40 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:291:23: 291:38
        StorageDead(_40);                // scope 0 at src/label.rs:291:37: 291:38
        _38 = _39;                       // scope 0 at src/label.rs:291:23: 291:53
        _37 = move _38 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:291:23: 291:53
        StorageDead(_38);                // scope 0 at src/label.rs:291:52: 291:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _37; // scope 0 at src/label.rs:291:18: 291:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:291:18: 291:54
        StorageDead(_41);                // scope 0 at src/label.rs:291:53: 291:54
        StorageDead(_39);                // scope 0 at src/label.rs:291:53: 291:54
        StorageDead(_37);                // scope 0 at src/label.rs:291:53: 291:54
        goto -> bb38;                    // scope 0 at src/label.rs:291:53: 291:54
    }

    bb10: {
        StorageLive(_42);                // scope 0 at src/label.rs:292:23: 292:53
        StorageLive(_43);                // scope 0 at src/label.rs:292:23: 292:53
        StorageLive(_44);                // scope 0 at src/label.rs:292:23: 292:53
        StorageLive(_45);                // scope 0 at src/label.rs:292:23: 292:38
        StorageLive(_46);                // scope 0 at src/label.rs:292:23: 292:38
        _46 = const ISO_8859_7;          // scope 0 at src/label.rs:292:23: 292:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_7, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:292:23: 292:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1256 ~ encoding[5d2c]::all::ISO_8859_7), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _45 = _46;                       // scope 0 at src/label.rs:292:23: 292:38
        _44 = move _45 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:292:23: 292:38
        StorageDead(_45);                // scope 0 at src/label.rs:292:37: 292:38
        _43 = _44;                       // scope 0 at src/label.rs:292:23: 292:53
        _42 = move _43 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:292:23: 292:53
        StorageDead(_43);                // scope 0 at src/label.rs:292:52: 292:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _42; // scope 0 at src/label.rs:292:18: 292:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:292:18: 292:54
        StorageDead(_46);                // scope 0 at src/label.rs:292:53: 292:54
        StorageDead(_44);                // scope 0 at src/label.rs:292:53: 292:54
        StorageDead(_42);                // scope 0 at src/label.rs:292:53: 292:54
        goto -> bb38;                    // scope 0 at src/label.rs:292:53: 292:54
    }

    bb11: {
        StorageLive(_47);                // scope 0 at src/label.rs:293:23: 293:53
        StorageLive(_48);                // scope 0 at src/label.rs:293:23: 293:53
        StorageLive(_49);                // scope 0 at src/label.rs:293:23: 293:53
        StorageLive(_50);                // scope 0 at src/label.rs:293:23: 293:38
        StorageLive(_51);                // scope 0 at src/label.rs:293:23: 293:38
        _51 = const ISO_8859_8;          // scope 0 at src/label.rs:293:23: 293:38
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:293:23: 293:38
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1257 ~ encoding[5d2c]::all::ISO_8859_8), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _50 = _51;                       // scope 0 at src/label.rs:293:23: 293:38
        _49 = move _50 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:293:23: 293:38
        StorageDead(_50);                // scope 0 at src/label.rs:293:37: 293:38
        _48 = _49;                       // scope 0 at src/label.rs:293:23: 293:53
        _47 = move _48 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:293:23: 293:53
        StorageDead(_48);                // scope 0 at src/label.rs:293:52: 293:53
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _47; // scope 0 at src/label.rs:293:18: 293:54
        discriminant(_0) = 1;            // scope 0 at src/label.rs:293:18: 293:54
        StorageDead(_51);                // scope 0 at src/label.rs:293:53: 293:54
        StorageDead(_49);                // scope 0 at src/label.rs:293:53: 293:54
        StorageDead(_47);                // scope 0 at src/label.rs:293:53: 293:54
        goto -> bb38;                    // scope 0 at src/label.rs:293:53: 293:54
    }

    bb12: {
        StorageLive(_52);                // scope 0 at src/label.rs:294:23: 294:63
        StorageLive(_53);                // scope 0 at src/label.rs:294:23: 294:63
        StorageLive(_54);                // scope 0 at src/label.rs:294:23: 294:63
        StorageLive(_55);                // scope 0 at src/label.rs:294:23: 294:48
        StorageLive(_56);                // scope 0 at src/label.rs:294:23: 294:48
        _56 = const ISO_8859_8_I;        // scope 0 at src/label.rs:294:23: 294:48
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_8_I, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:294:23: 294:48
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1289 ~ encoding[5d2c]::all::whatwg::ISO_8859_8_I), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _55 = _56;                       // scope 0 at src/label.rs:294:23: 294:48
        _54 = move _55 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:294:23: 294:48
        StorageDead(_55);                // scope 0 at src/label.rs:294:47: 294:48
        _53 = _54;                       // scope 0 at src/label.rs:294:23: 294:63
        _52 = move _53 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:294:23: 294:63
        StorageDead(_53);                // scope 0 at src/label.rs:294:62: 294:63
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _52; // scope 0 at src/label.rs:294:18: 294:64
        discriminant(_0) = 1;            // scope 0 at src/label.rs:294:18: 294:64
        StorageDead(_56);                // scope 0 at src/label.rs:294:63: 294:64
        StorageDead(_54);                // scope 0 at src/label.rs:294:63: 294:64
        StorageDead(_52);                // scope 0 at src/label.rs:294:63: 294:64
        goto -> bb38;                    // scope 0 at src/label.rs:294:63: 294:64
    }

    bb13: {
        StorageLive(_57);                // scope 0 at src/label.rs:295:23: 295:54
        StorageLive(_58);                // scope 0 at src/label.rs:295:23: 295:54
        StorageLive(_59);                // scope 0 at src/label.rs:295:23: 295:54
        StorageLive(_60);                // scope 0 at src/label.rs:295:23: 295:39
        StorageLive(_61);                // scope 0 at src/label.rs:295:23: 295:39
        _61 = const ISO_8859_13;         // scope 0 at src/label.rs:295:23: 295:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_13, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:295:23: 295:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1259 ~ encoding[5d2c]::all::ISO_8859_13), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _60 = _61;                       // scope 0 at src/label.rs:295:23: 295:39
        _59 = move _60 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:295:23: 295:39
        StorageDead(_60);                // scope 0 at src/label.rs:295:38: 295:39
        _58 = _59;                       // scope 0 at src/label.rs:295:23: 295:54
        _57 = move _58 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:295:23: 295:54
        StorageDead(_58);                // scope 0 at src/label.rs:295:53: 295:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _57; // scope 0 at src/label.rs:295:18: 295:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:295:18: 295:55
        StorageDead(_61);                // scope 0 at src/label.rs:295:54: 295:55
        StorageDead(_59);                // scope 0 at src/label.rs:295:54: 295:55
        StorageDead(_57);                // scope 0 at src/label.rs:295:54: 295:55
        goto -> bb38;                    // scope 0 at src/label.rs:295:54: 295:55
    }

    bb14: {
        StorageLive(_62);                // scope 0 at src/label.rs:296:23: 296:54
        StorageLive(_63);                // scope 0 at src/label.rs:296:23: 296:54
        StorageLive(_64);                // scope 0 at src/label.rs:296:23: 296:54
        StorageLive(_65);                // scope 0 at src/label.rs:296:23: 296:39
        StorageLive(_66);                // scope 0 at src/label.rs:296:23: 296:39
        _66 = const ISO_8859_15;         // scope 0 at src/label.rs:296:23: 296:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(ISO_8859_15, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:296:23: 296:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1261 ~ encoding[5d2c]::all::ISO_8859_15), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _65 = _66;                       // scope 0 at src/label.rs:296:23: 296:39
        _64 = move _65 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:296:23: 296:39
        StorageDead(_65);                // scope 0 at src/label.rs:296:38: 296:39
        _63 = _64;                       // scope 0 at src/label.rs:296:23: 296:54
        _62 = move _63 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:296:23: 296:54
        StorageDead(_63);                // scope 0 at src/label.rs:296:53: 296:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _62; // scope 0 at src/label.rs:296:18: 296:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:296:18: 296:55
        StorageDead(_66);                // scope 0 at src/label.rs:296:54: 296:55
        StorageDead(_64);                // scope 0 at src/label.rs:296:54: 296:55
        StorageDead(_62);                // scope 0 at src/label.rs:296:54: 296:55
        goto -> bb38;                    // scope 0 at src/label.rs:296:54: 296:55
    }

    bb15: {
        StorageLive(_67);                // scope 0 at src/label.rs:297:23: 297:49
        StorageLive(_68);                // scope 0 at src/label.rs:297:23: 297:49
        StorageLive(_69);                // scope 0 at src/label.rs:297:23: 297:49
        StorageLive(_70);                // scope 0 at src/label.rs:297:23: 297:34
        StorageLive(_71);                // scope 0 at src/label.rs:297:23: 297:34
        _71 = const KOI8_R;              // scope 0 at src/label.rs:297:23: 297:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_R, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:297:23: 297:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1263 ~ encoding[5d2c]::all::KOI8_R), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _70 = _71;                       // scope 0 at src/label.rs:297:23: 297:34
        _69 = move _70 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:297:23: 297:34
        StorageDead(_70);                // scope 0 at src/label.rs:297:33: 297:34
        _68 = _69;                       // scope 0 at src/label.rs:297:23: 297:49
        _67 = move _68 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:297:23: 297:49
        StorageDead(_68);                // scope 0 at src/label.rs:297:48: 297:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _67; // scope 0 at src/label.rs:297:18: 297:50
        discriminant(_0) = 1;            // scope 0 at src/label.rs:297:18: 297:50
        StorageDead(_71);                // scope 0 at src/label.rs:297:49: 297:50
        StorageDead(_69);                // scope 0 at src/label.rs:297:49: 297:50
        StorageDead(_67);                // scope 0 at src/label.rs:297:49: 297:50
        goto -> bb38;                    // scope 0 at src/label.rs:297:49: 297:50
    }

    bb16: {
        StorageLive(_72);                // scope 0 at src/label.rs:298:23: 298:49
        StorageLive(_73);                // scope 0 at src/label.rs:298:23: 298:49
        StorageLive(_74);                // scope 0 at src/label.rs:298:23: 298:49
        StorageLive(_75);                // scope 0 at src/label.rs:298:23: 298:34
        StorageLive(_76);                // scope 0 at src/label.rs:298:23: 298:34
        _76 = const KOI8_U;              // scope 0 at src/label.rs:298:23: 298:34
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(KOI8_U, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:298:23: 298:34
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1264 ~ encoding[5d2c]::all::KOI8_U), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _75 = _76;                       // scope 0 at src/label.rs:298:23: 298:34
        _74 = move _75 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:298:23: 298:34
        StorageDead(_75);                // scope 0 at src/label.rs:298:33: 298:34
        _73 = _74;                       // scope 0 at src/label.rs:298:23: 298:49
        _72 = move _73 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:298:23: 298:49
        StorageDead(_73);                // scope 0 at src/label.rs:298:48: 298:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _72; // scope 0 at src/label.rs:298:18: 298:50
        discriminant(_0) = 1;            // scope 0 at src/label.rs:298:18: 298:50
        StorageDead(_76);                // scope 0 at src/label.rs:298:49: 298:50
        StorageDead(_74);                // scope 0 at src/label.rs:298:49: 298:50
        StorageDead(_72);                // scope 0 at src/label.rs:298:49: 298:50
        goto -> bb38;                    // scope 0 at src/label.rs:298:49: 298:50
    }

    bb17: {
        StorageLive(_77);                // scope 0 at src/label.rs:299:23: 299:52
        StorageLive(_78);                // scope 0 at src/label.rs:299:23: 299:52
        StorageLive(_79);                // scope 0 at src/label.rs:299:23: 299:52
        StorageLive(_80);                // scope 0 at src/label.rs:299:23: 299:37
        StorageLive(_81);                // scope 0 at src/label.rs:299:23: 299:37
        _81 = const MAC_ROMAN;           // scope 0 at src/label.rs:299:23: 299:37
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_ROMAN, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:299:23: 299:37
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1265 ~ encoding[5d2c]::all::MAC_ROMAN), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _80 = _81;                       // scope 0 at src/label.rs:299:23: 299:37
        _79 = move _80 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:299:23: 299:37
        StorageDead(_80);                // scope 0 at src/label.rs:299:36: 299:37
        _78 = _79;                       // scope 0 at src/label.rs:299:23: 299:52
        _77 = move _78 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:299:23: 299:52
        StorageDead(_78);                // scope 0 at src/label.rs:299:51: 299:52
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _77; // scope 0 at src/label.rs:299:18: 299:53
        discriminant(_0) = 1;            // scope 0 at src/label.rs:299:18: 299:53
        StorageDead(_81);                // scope 0 at src/label.rs:299:52: 299:53
        StorageDead(_79);                // scope 0 at src/label.rs:299:52: 299:53
        StorageDead(_77);                // scope 0 at src/label.rs:299:52: 299:53
        goto -> bb38;                    // scope 0 at src/label.rs:299:52: 299:53
    }

    bb18: {
        StorageLive(_82);                // scope 0 at src/label.rs:300:21: 300:52
        StorageLive(_83);                // scope 0 at src/label.rs:300:21: 300:52
        StorageLive(_84);                // scope 0 at src/label.rs:300:21: 300:52
        StorageLive(_85);                // scope 0 at src/label.rs:300:21: 300:37
        StorageLive(_86);                // scope 0 at src/label.rs:300:21: 300:37
        _86 = const WINDOWS_874;         // scope 0 at src/label.rs:300:21: 300:37
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_874, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:300:21: 300:37
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1266 ~ encoding[5d2c]::all::WINDOWS_874), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _85 = _86;                       // scope 0 at src/label.rs:300:21: 300:37
        _84 = move _85 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:300:21: 300:37
        StorageDead(_85);                // scope 0 at src/label.rs:300:36: 300:37
        _83 = _84;                       // scope 0 at src/label.rs:300:21: 300:52
        _82 = move _83 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:300:21: 300:52
        StorageDead(_83);                // scope 0 at src/label.rs:300:51: 300:52
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _82; // scope 0 at src/label.rs:300:16: 300:53
        discriminant(_0) = 1;            // scope 0 at src/label.rs:300:16: 300:53
        StorageDead(_86);                // scope 0 at src/label.rs:300:52: 300:53
        StorageDead(_84);                // scope 0 at src/label.rs:300:52: 300:53
        StorageDead(_82);                // scope 0 at src/label.rs:300:52: 300:53
        goto -> bb38;                    // scope 0 at src/label.rs:300:52: 300:53
    }

    bb19: {
        StorageLive(_87);                // scope 0 at src/label.rs:301:22: 301:54
        StorageLive(_88);                // scope 0 at src/label.rs:301:22: 301:54
        StorageLive(_89);                // scope 0 at src/label.rs:301:22: 301:54
        StorageLive(_90);                // scope 0 at src/label.rs:301:22: 301:39
        StorageLive(_91);                // scope 0 at src/label.rs:301:22: 301:39
        _91 = const WINDOWS_1250;        // scope 0 at src/label.rs:301:22: 301:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1250, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:301:22: 301:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1267 ~ encoding[5d2c]::all::WINDOWS_1250), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _90 = _91;                       // scope 0 at src/label.rs:301:22: 301:39
        _89 = move _90 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:301:22: 301:39
        StorageDead(_90);                // scope 0 at src/label.rs:301:38: 301:39
        _88 = _89;                       // scope 0 at src/label.rs:301:22: 301:54
        _87 = move _88 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:301:22: 301:54
        StorageDead(_88);                // scope 0 at src/label.rs:301:53: 301:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _87; // scope 0 at src/label.rs:301:17: 301:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:301:17: 301:55
        StorageDead(_91);                // scope 0 at src/label.rs:301:54: 301:55
        StorageDead(_89);                // scope 0 at src/label.rs:301:54: 301:55
        StorageDead(_87);                // scope 0 at src/label.rs:301:54: 301:55
        goto -> bb38;                    // scope 0 at src/label.rs:301:54: 301:55
    }

    bb20: {
        StorageLive(_92);                // scope 0 at src/label.rs:302:22: 302:54
        StorageLive(_93);                // scope 0 at src/label.rs:302:22: 302:54
        StorageLive(_94);                // scope 0 at src/label.rs:302:22: 302:54
        StorageLive(_95);                // scope 0 at src/label.rs:302:22: 302:39
        StorageLive(_96);                // scope 0 at src/label.rs:302:22: 302:39
        _96 = const WINDOWS_1251;        // scope 0 at src/label.rs:302:22: 302:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1251, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:302:22: 302:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1268 ~ encoding[5d2c]::all::WINDOWS_1251), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _95 = _96;                       // scope 0 at src/label.rs:302:22: 302:39
        _94 = move _95 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:302:22: 302:39
        StorageDead(_95);                // scope 0 at src/label.rs:302:38: 302:39
        _93 = _94;                       // scope 0 at src/label.rs:302:22: 302:54
        _92 = move _93 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:302:22: 302:54
        StorageDead(_93);                // scope 0 at src/label.rs:302:53: 302:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _92; // scope 0 at src/label.rs:302:17: 302:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:302:17: 302:55
        StorageDead(_96);                // scope 0 at src/label.rs:302:54: 302:55
        StorageDead(_94);                // scope 0 at src/label.rs:302:54: 302:55
        StorageDead(_92);                // scope 0 at src/label.rs:302:54: 302:55
        goto -> bb38;                    // scope 0 at src/label.rs:302:54: 302:55
    }

    bb21: {
        StorageLive(_97);                // scope 0 at src/label.rs:303:22: 303:54
        StorageLive(_98);                // scope 0 at src/label.rs:303:22: 303:54
        StorageLive(_99);                // scope 0 at src/label.rs:303:22: 303:54
        StorageLive(_100);               // scope 0 at src/label.rs:303:22: 303:39
        StorageLive(_101);               // scope 0 at src/label.rs:303:22: 303:39
        _101 = const WINDOWS_1252;       // scope 0 at src/label.rs:303:22: 303:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1252, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:303:22: 303:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1269 ~ encoding[5d2c]::all::WINDOWS_1252), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _100 = _101;                     // scope 0 at src/label.rs:303:22: 303:39
        _99 = move _100 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:303:22: 303:39
        StorageDead(_100);               // scope 0 at src/label.rs:303:38: 303:39
        _98 = _99;                       // scope 0 at src/label.rs:303:22: 303:54
        _97 = move _98 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:303:22: 303:54
        StorageDead(_98);                // scope 0 at src/label.rs:303:53: 303:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _97; // scope 0 at src/label.rs:303:17: 303:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:303:17: 303:55
        StorageDead(_101);               // scope 0 at src/label.rs:303:54: 303:55
        StorageDead(_99);                // scope 0 at src/label.rs:303:54: 303:55
        StorageDead(_97);                // scope 0 at src/label.rs:303:54: 303:55
        goto -> bb38;                    // scope 0 at src/label.rs:303:54: 303:55
    }

    bb22: {
        StorageLive(_102);               // scope 0 at src/label.rs:304:22: 304:54
        StorageLive(_103);               // scope 0 at src/label.rs:304:22: 304:54
        StorageLive(_104);               // scope 0 at src/label.rs:304:22: 304:54
        StorageLive(_105);               // scope 0 at src/label.rs:304:22: 304:39
        StorageLive(_106);               // scope 0 at src/label.rs:304:22: 304:39
        _106 = const WINDOWS_1253;       // scope 0 at src/label.rs:304:22: 304:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1253, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:304:22: 304:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1270 ~ encoding[5d2c]::all::WINDOWS_1253), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _105 = _106;                     // scope 0 at src/label.rs:304:22: 304:39
        _104 = move _105 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:304:22: 304:39
        StorageDead(_105);               // scope 0 at src/label.rs:304:38: 304:39
        _103 = _104;                     // scope 0 at src/label.rs:304:22: 304:54
        _102 = move _103 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:304:22: 304:54
        StorageDead(_103);               // scope 0 at src/label.rs:304:53: 304:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _102; // scope 0 at src/label.rs:304:17: 304:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:304:17: 304:55
        StorageDead(_106);               // scope 0 at src/label.rs:304:54: 304:55
        StorageDead(_104);               // scope 0 at src/label.rs:304:54: 304:55
        StorageDead(_102);               // scope 0 at src/label.rs:304:54: 304:55
        goto -> bb38;                    // scope 0 at src/label.rs:304:54: 304:55
    }

    bb23: {
        StorageLive(_107);               // scope 0 at src/label.rs:305:22: 305:54
        StorageLive(_108);               // scope 0 at src/label.rs:305:22: 305:54
        StorageLive(_109);               // scope 0 at src/label.rs:305:22: 305:54
        StorageLive(_110);               // scope 0 at src/label.rs:305:22: 305:39
        StorageLive(_111);               // scope 0 at src/label.rs:305:22: 305:39
        _111 = const WINDOWS_1254;       // scope 0 at src/label.rs:305:22: 305:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1254, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:305:22: 305:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1271 ~ encoding[5d2c]::all::WINDOWS_1254), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _110 = _111;                     // scope 0 at src/label.rs:305:22: 305:39
        _109 = move _110 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:305:22: 305:39
        StorageDead(_110);               // scope 0 at src/label.rs:305:38: 305:39
        _108 = _109;                     // scope 0 at src/label.rs:305:22: 305:54
        _107 = move _108 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:305:22: 305:54
        StorageDead(_108);               // scope 0 at src/label.rs:305:53: 305:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _107; // scope 0 at src/label.rs:305:17: 305:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:305:17: 305:55
        StorageDead(_111);               // scope 0 at src/label.rs:305:54: 305:55
        StorageDead(_109);               // scope 0 at src/label.rs:305:54: 305:55
        StorageDead(_107);               // scope 0 at src/label.rs:305:54: 305:55
        goto -> bb38;                    // scope 0 at src/label.rs:305:54: 305:55
    }

    bb24: {
        StorageLive(_112);               // scope 0 at src/label.rs:306:22: 306:54
        StorageLive(_113);               // scope 0 at src/label.rs:306:22: 306:54
        StorageLive(_114);               // scope 0 at src/label.rs:306:22: 306:54
        StorageLive(_115);               // scope 0 at src/label.rs:306:22: 306:39
        StorageLive(_116);               // scope 0 at src/label.rs:306:22: 306:39
        _116 = const WINDOWS_1255;       // scope 0 at src/label.rs:306:22: 306:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1255, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:306:22: 306:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1272 ~ encoding[5d2c]::all::WINDOWS_1255), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _115 = _116;                     // scope 0 at src/label.rs:306:22: 306:39
        _114 = move _115 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:306:22: 306:39
        StorageDead(_115);               // scope 0 at src/label.rs:306:38: 306:39
        _113 = _114;                     // scope 0 at src/label.rs:306:22: 306:54
        _112 = move _113 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:306:22: 306:54
        StorageDead(_113);               // scope 0 at src/label.rs:306:53: 306:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _112; // scope 0 at src/label.rs:306:17: 306:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:306:17: 306:55
        StorageDead(_116);               // scope 0 at src/label.rs:306:54: 306:55
        StorageDead(_114);               // scope 0 at src/label.rs:306:54: 306:55
        StorageDead(_112);               // scope 0 at src/label.rs:306:54: 306:55
        goto -> bb38;                    // scope 0 at src/label.rs:306:54: 306:55
    }

    bb25: {
        StorageLive(_117);               // scope 0 at src/label.rs:307:22: 307:54
        StorageLive(_118);               // scope 0 at src/label.rs:307:22: 307:54
        StorageLive(_119);               // scope 0 at src/label.rs:307:22: 307:54
        StorageLive(_120);               // scope 0 at src/label.rs:307:22: 307:39
        StorageLive(_121);               // scope 0 at src/label.rs:307:22: 307:39
        _121 = const WINDOWS_1256;       // scope 0 at src/label.rs:307:22: 307:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1256, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:307:22: 307:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1273 ~ encoding[5d2c]::all::WINDOWS_1256), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _120 = _121;                     // scope 0 at src/label.rs:307:22: 307:39
        _119 = move _120 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:307:22: 307:39
        StorageDead(_120);               // scope 0 at src/label.rs:307:38: 307:39
        _118 = _119;                     // scope 0 at src/label.rs:307:22: 307:54
        _117 = move _118 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:307:22: 307:54
        StorageDead(_118);               // scope 0 at src/label.rs:307:53: 307:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _117; // scope 0 at src/label.rs:307:17: 307:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:307:17: 307:55
        StorageDead(_121);               // scope 0 at src/label.rs:307:54: 307:55
        StorageDead(_119);               // scope 0 at src/label.rs:307:54: 307:55
        StorageDead(_117);               // scope 0 at src/label.rs:307:54: 307:55
        goto -> bb38;                    // scope 0 at src/label.rs:307:54: 307:55
    }

    bb26: {
        StorageLive(_122);               // scope 0 at src/label.rs:308:22: 308:54
        StorageLive(_123);               // scope 0 at src/label.rs:308:22: 308:54
        StorageLive(_124);               // scope 0 at src/label.rs:308:22: 308:54
        StorageLive(_125);               // scope 0 at src/label.rs:308:22: 308:39
        StorageLive(_126);               // scope 0 at src/label.rs:308:22: 308:39
        _126 = const WINDOWS_1257;       // scope 0 at src/label.rs:308:22: 308:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1257, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:308:22: 308:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1274 ~ encoding[5d2c]::all::WINDOWS_1257), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _125 = _126;                     // scope 0 at src/label.rs:308:22: 308:39
        _124 = move _125 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:308:22: 308:39
        StorageDead(_125);               // scope 0 at src/label.rs:308:38: 308:39
        _123 = _124;                     // scope 0 at src/label.rs:308:22: 308:54
        _122 = move _123 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:308:22: 308:54
        StorageDead(_123);               // scope 0 at src/label.rs:308:53: 308:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _122; // scope 0 at src/label.rs:308:17: 308:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:308:17: 308:55
        StorageDead(_126);               // scope 0 at src/label.rs:308:54: 308:55
        StorageDead(_124);               // scope 0 at src/label.rs:308:54: 308:55
        StorageDead(_122);               // scope 0 at src/label.rs:308:54: 308:55
        goto -> bb38;                    // scope 0 at src/label.rs:308:54: 308:55
    }

    bb27: {
        StorageLive(_127);               // scope 0 at src/label.rs:309:22: 309:54
        StorageLive(_128);               // scope 0 at src/label.rs:309:22: 309:54
        StorageLive(_129);               // scope 0 at src/label.rs:309:22: 309:54
        StorageLive(_130);               // scope 0 at src/label.rs:309:22: 309:39
        StorageLive(_131);               // scope 0 at src/label.rs:309:22: 309:39
        _131 = const WINDOWS_1258;       // scope 0 at src/label.rs:309:22: 309:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(WINDOWS_1258, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:309:22: 309:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1275 ~ encoding[5d2c]::all::WINDOWS_1258), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _130 = _131;                     // scope 0 at src/label.rs:309:22: 309:39
        _129 = move _130 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:309:22: 309:39
        StorageDead(_130);               // scope 0 at src/label.rs:309:38: 309:39
        _128 = _129;                     // scope 0 at src/label.rs:309:22: 309:54
        _127 = move _128 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:309:22: 309:54
        StorageDead(_128);               // scope 0 at src/label.rs:309:53: 309:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _127; // scope 0 at src/label.rs:309:17: 309:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:309:17: 309:55
        StorageDead(_131);               // scope 0 at src/label.rs:309:54: 309:55
        StorageDead(_129);               // scope 0 at src/label.rs:309:54: 309:55
        StorageDead(_127);               // scope 0 at src/label.rs:309:54: 309:55
        goto -> bb38;                    // scope 0 at src/label.rs:309:54: 309:55
    }

    bb28: {
        StorageLive(_132);               // scope 0 at src/label.rs:310:22: 310:54
        StorageLive(_133);               // scope 0 at src/label.rs:310:22: 310:54
        StorageLive(_134);               // scope 0 at src/label.rs:310:22: 310:54
        StorageLive(_135);               // scope 0 at src/label.rs:310:22: 310:39
        StorageLive(_136);               // scope 0 at src/label.rs:310:22: 310:39
        _136 = const MAC_CYRILLIC;       // scope 0 at src/label.rs:310:22: 310:39
                                         // ty::Const
                                         // + ty: &codec::singlebyte::SingleByteEncoding
                                         // + val: Unevaluated(MAC_CYRILLIC, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:310:22: 310:39
                                         // + literal: Const { ty: &codec::singlebyte::SingleByteEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1276 ~ encoding[5d2c]::all::MAC_CYRILLIC), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _135 = _136;                     // scope 0 at src/label.rs:310:22: 310:39
        _134 = move _135 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:310:22: 310:39
        StorageDead(_135);               // scope 0 at src/label.rs:310:38: 310:39
        _133 = _134;                     // scope 0 at src/label.rs:310:22: 310:54
        _132 = move _133 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:310:22: 310:54
        StorageDead(_133);               // scope 0 at src/label.rs:310:53: 310:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _132; // scope 0 at src/label.rs:310:17: 310:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:310:17: 310:55
        StorageDead(_136);               // scope 0 at src/label.rs:310:54: 310:55
        StorageDead(_134);               // scope 0 at src/label.rs:310:54: 310:55
        StorageDead(_132);               // scope 0 at src/label.rs:310:54: 310:55
        goto -> bb38;                    // scope 0 at src/label.rs:310:54: 310:55
    }

    bb29: {
        StorageLive(_137);               // scope 0 at src/label.rs:311:29: 311:56
        StorageLive(_138);               // scope 0 at src/label.rs:311:29: 311:56
        StorageLive(_139);               // scope 0 at src/label.rs:311:29: 311:56
        StorageLive(_140);               // scope 0 at src/label.rs:311:29: 311:41
        StorageLive(_141);               // scope 0 at src/label.rs:311:29: 311:41
        _141 = const GB18030;            // scope 0 at src/label.rs:311:29: 311:41
                                         // ty::Const
                                         // + ty: &codec::simpchinese::GB18030Encoding
                                         // + val: Unevaluated(GB18030, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:311:29: 311:41
                                         // + literal: Const { ty: &codec::simpchinese::GB18030Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1285 ~ encoding[5d2c]::all::GB18030), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _140 = _141;                     // scope 0 at src/label.rs:311:29: 311:41
        _139 = move _140 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:311:29: 311:41
        StorageDead(_140);               // scope 0 at src/label.rs:311:40: 311:41
        _138 = _139;                     // scope 0 at src/label.rs:311:29: 311:56
        _137 = move _138 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:311:29: 311:56
        StorageDead(_138);               // scope 0 at src/label.rs:311:55: 311:56
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _137; // scope 0 at src/label.rs:311:24: 311:57
        discriminant(_0) = 1;            // scope 0 at src/label.rs:311:24: 311:57
        StorageDead(_141);               // scope 0 at src/label.rs:311:56: 311:57
        StorageDead(_139);               // scope 0 at src/label.rs:311:56: 311:57
        StorageDead(_137);               // scope 0 at src/label.rs:311:56: 311:57
        goto -> bb38;                    // scope 0 at src/label.rs:311:56: 311:57
    }

    bb30: {
        StorageLive(_142);               // scope 0 at src/label.rs:312:23: 312:45
        StorageLive(_143);               // scope 0 at src/label.rs:312:23: 312:45
        StorageLive(_144);               // scope 0 at src/label.rs:312:23: 312:45
        StorageLive(_145);               // scope 0 at src/label.rs:312:23: 312:30
        StorageLive(_146);               // scope 0 at src/label.rs:312:23: 312:30
        _146 = const HZ;                 // scope 0 at src/label.rs:312:23: 312:30
                                         // ty::Const
                                         // + ty: &codec::simpchinese::HZEncoding
                                         // + val: Unevaluated(HZ, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:312:23: 312:30
                                         // + literal: Const { ty: &codec::simpchinese::HZEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1286 ~ encoding[5d2c]::all::HZ), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _145 = _146;                     // scope 0 at src/label.rs:312:23: 312:30
        _144 = move _145 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:312:23: 312:30
        StorageDead(_145);               // scope 0 at src/label.rs:312:29: 312:30
        _143 = _144;                     // scope 0 at src/label.rs:312:23: 312:45
        _142 = move _143 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:312:23: 312:45
        StorageDead(_143);               // scope 0 at src/label.rs:312:44: 312:45
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _142; // scope 0 at src/label.rs:312:18: 312:46
        discriminant(_0) = 1;            // scope 0 at src/label.rs:312:18: 312:46
        StorageDead(_146);               // scope 0 at src/label.rs:312:45: 312:46
        StorageDead(_144);               // scope 0 at src/label.rs:312:45: 312:46
        StorageDead(_142);               // scope 0 at src/label.rs:312:45: 312:46
        goto -> bb38;                    // scope 0 at src/label.rs:312:45: 312:46
    }

    bb31: {
        StorageLive(_147);               // scope 0 at src/label.rs:313:21: 313:50
        StorageLive(_148);               // scope 0 at src/label.rs:313:21: 313:50
        StorageLive(_149);               // scope 0 at src/label.rs:313:21: 313:50
        StorageLive(_150);               // scope 0 at src/label.rs:313:21: 313:35
        StorageLive(_151);               // scope 0 at src/label.rs:313:21: 313:35
        _151 = const BIG5_2003;          // scope 0 at src/label.rs:313:21: 313:35
                                         // ty::Const
                                         // + ty: &codec::tradchinese::BigFive2003Encoding
                                         // + val: Unevaluated(BIG5_2003, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:313:21: 313:35
                                         // + literal: Const { ty: &codec::tradchinese::BigFive2003Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1287 ~ encoding[5d2c]::all::BIG5_2003), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _150 = _151;                     // scope 0 at src/label.rs:313:21: 313:35
        _149 = move _150 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:313:21: 313:35
        StorageDead(_150);               // scope 0 at src/label.rs:313:34: 313:35
        _148 = _149;                     // scope 0 at src/label.rs:313:21: 313:50
        _147 = move _148 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:313:21: 313:50
        StorageDead(_148);               // scope 0 at src/label.rs:313:49: 313:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _147; // scope 0 at src/label.rs:313:16: 313:51
        discriminant(_0) = 1;            // scope 0 at src/label.rs:313:16: 313:51
        StorageDead(_151);               // scope 0 at src/label.rs:313:50: 313:51
        StorageDead(_149);               // scope 0 at src/label.rs:313:50: 313:51
        StorageDead(_147);               // scope 0 at src/label.rs:313:50: 313:51
        goto -> bb38;                    // scope 0 at src/label.rs:313:50: 313:51
    }

    bb32: {
        StorageLive(_152);               // scope 0 at src/label.rs:314:23: 314:49
        StorageLive(_153);               // scope 0 at src/label.rs:314:23: 314:49
        StorageLive(_154);               // scope 0 at src/label.rs:314:23: 314:49
        StorageLive(_155);               // scope 0 at src/label.rs:314:23: 314:34
        StorageLive(_156);               // scope 0 at src/label.rs:314:23: 314:34
        _156 = const EUC_JP;             // scope 0 at src/label.rs:314:23: 314:34
                                         // ty::Const
                                         // + ty: &codec::japanese::EUCJPEncoding
                                         // + val: Unevaluated(EUC_JP, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:314:23: 314:34
                                         // + literal: Const { ty: &codec::japanese::EUCJPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1281 ~ encoding[5d2c]::all::EUC_JP), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _155 = _156;                     // scope 0 at src/label.rs:314:23: 314:34
        _154 = move _155 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:314:23: 314:34
        StorageDead(_155);               // scope 0 at src/label.rs:314:33: 314:34
        _153 = _154;                     // scope 0 at src/label.rs:314:23: 314:49
        _152 = move _153 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:314:23: 314:49
        StorageDead(_153);               // scope 0 at src/label.rs:314:48: 314:49
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _152; // scope 0 at src/label.rs:314:18: 314:50
        discriminant(_0) = 1;            // scope 0 at src/label.rs:314:18: 314:50
        StorageDead(_156);               // scope 0 at src/label.rs:314:49: 314:50
        StorageDead(_154);               // scope 0 at src/label.rs:314:49: 314:50
        StorageDead(_152);               // scope 0 at src/label.rs:314:49: 314:50
        goto -> bb38;                    // scope 0 at src/label.rs:314:49: 314:50
    }

    bb33: {
        StorageLive(_157);               // scope 0 at src/label.rs:315:23: 315:54
        StorageLive(_158);               // scope 0 at src/label.rs:315:23: 315:54
        StorageLive(_159);               // scope 0 at src/label.rs:315:23: 315:54
        StorageLive(_160);               // scope 0 at src/label.rs:315:23: 315:39
        StorageLive(_161);               // scope 0 at src/label.rs:315:23: 315:39
        _161 = const ISO_2022_JP;        // scope 0 at src/label.rs:315:23: 315:39
                                         // ty::Const
                                         // + ty: &codec::japanese::ISO2022JPEncoding
                                         // + val: Unevaluated(ISO_2022_JP, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:315:23: 315:39
                                         // + literal: Const { ty: &codec::japanese::ISO2022JPEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1283 ~ encoding[5d2c]::all::ISO_2022_JP), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _160 = _161;                     // scope 0 at src/label.rs:315:23: 315:39
        _159 = move _160 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:315:23: 315:39
        StorageDead(_160);               // scope 0 at src/label.rs:315:38: 315:39
        _158 = _159;                     // scope 0 at src/label.rs:315:23: 315:54
        _157 = move _158 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:315:23: 315:54
        StorageDead(_158);               // scope 0 at src/label.rs:315:53: 315:54
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _157; // scope 0 at src/label.rs:315:18: 315:55
        discriminant(_0) = 1;            // scope 0 at src/label.rs:315:18: 315:55
        StorageDead(_161);               // scope 0 at src/label.rs:315:54: 315:55
        StorageDead(_159);               // scope 0 at src/label.rs:315:54: 315:55
        StorageDead(_157);               // scope 0 at src/label.rs:315:54: 315:55
        goto -> bb38;                    // scope 0 at src/label.rs:315:54: 315:55
    }

    bb34: {
        StorageLive(_162);               // scope 0 at src/label.rs:316:21: 316:52
        StorageLive(_163);               // scope 0 at src/label.rs:316:21: 316:52
        StorageLive(_164);               // scope 0 at src/label.rs:316:21: 316:52
        StorageLive(_165);               // scope 0 at src/label.rs:316:21: 316:37
        StorageLive(_166);               // scope 0 at src/label.rs:316:21: 316:37
        _166 = const WINDOWS_31J;        // scope 0 at src/label.rs:316:21: 316:37
                                         // ty::Const
                                         // + ty: &codec::japanese::Windows31JEncoding
                                         // + val: Unevaluated(WINDOWS_31J, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:316:21: 316:37
                                         // + literal: Const { ty: &codec::japanese::Windows31JEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1282 ~ encoding[5d2c]::all::WINDOWS_31J), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _165 = _166;                     // scope 0 at src/label.rs:316:21: 316:37
        _164 = move _165 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:316:21: 316:37
        StorageDead(_165);               // scope 0 at src/label.rs:316:36: 316:37
        _163 = _164;                     // scope 0 at src/label.rs:316:21: 316:52
        _162 = move _163 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:316:21: 316:52
        StorageDead(_163);               // scope 0 at src/label.rs:316:51: 316:52
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _162; // scope 0 at src/label.rs:316:16: 316:53
        discriminant(_0) = 1;            // scope 0 at src/label.rs:316:16: 316:53
        StorageDead(_166);               // scope 0 at src/label.rs:316:52: 316:53
        StorageDead(_164);               // scope 0 at src/label.rs:316:52: 316:53
        StorageDead(_162);               // scope 0 at src/label.rs:316:52: 316:53
        goto -> bb38;                    // scope 0 at src/label.rs:316:52: 316:53
    }

    bb35: {
        StorageLive(_167);               // scope 0 at src/label.rs:317:21: 317:52
        StorageLive(_168);               // scope 0 at src/label.rs:317:21: 317:52
        StorageLive(_169);               // scope 0 at src/label.rs:317:21: 317:52
        StorageLive(_170);               // scope 0 at src/label.rs:317:21: 317:37
        StorageLive(_171);               // scope 0 at src/label.rs:317:21: 317:37
        _171 = const WINDOWS_949;        // scope 0 at src/label.rs:317:21: 317:37
                                         // ty::Const
                                         // + ty: &codec::korean::Windows949Encoding
                                         // + val: Unevaluated(WINDOWS_949, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:317:21: 317:37
                                         // + literal: Const { ty: &codec::korean::Windows949Encoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1280 ~ encoding[5d2c]::all::WINDOWS_949), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _170 = _171;                     // scope 0 at src/label.rs:317:21: 317:37
        _169 = move _170 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:317:21: 317:37
        StorageDead(_170);               // scope 0 at src/label.rs:317:36: 317:37
        _168 = _169;                     // scope 0 at src/label.rs:317:21: 317:52
        _167 = move _168 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:317:21: 317:52
        StorageDead(_168);               // scope 0 at src/label.rs:317:51: 317:52
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _167; // scope 0 at src/label.rs:317:16: 317:53
        discriminant(_0) = 1;            // scope 0 at src/label.rs:317:16: 317:53
        StorageDead(_171);               // scope 0 at src/label.rs:317:52: 317:53
        StorageDead(_169);               // scope 0 at src/label.rs:317:52: 317:53
        StorageDead(_167);               // scope 0 at src/label.rs:317:52: 317:53
        goto -> bb38;                    // scope 0 at src/label.rs:317:52: 317:53
    }

    bb36: {
        StorageLive(_172);               // scope 0 at src/label.rs:318:22: 318:50
        StorageLive(_173);               // scope 0 at src/label.rs:318:22: 318:50
        StorageLive(_174);               // scope 0 at src/label.rs:318:22: 318:50
        StorageLive(_175);               // scope 0 at src/label.rs:318:22: 318:35
        StorageLive(_176);               // scope 0 at src/label.rs:318:22: 318:35
        _176 = const UTF_16BE;           // scope 0 at src/label.rs:318:22: 318:35
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16BEEncoding
                                         // + val: Unevaluated(UTF_16BE, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:318:22: 318:35
                                         // + literal: Const { ty: &codec::utf_16::UTF16BEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1279 ~ encoding[5d2c]::all::UTF_16BE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _175 = _176;                     // scope 0 at src/label.rs:318:22: 318:35
        _174 = move _175 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:318:22: 318:35
        StorageDead(_175);               // scope 0 at src/label.rs:318:34: 318:35
        _173 = _174;                     // scope 0 at src/label.rs:318:22: 318:50
        _172 = move _173 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:318:22: 318:50
        StorageDead(_173);               // scope 0 at src/label.rs:318:49: 318:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _172; // scope 0 at src/label.rs:318:17: 318:51
        discriminant(_0) = 1;            // scope 0 at src/label.rs:318:17: 318:51
        StorageDead(_176);               // scope 0 at src/label.rs:318:50: 318:51
        StorageDead(_174);               // scope 0 at src/label.rs:318:50: 318:51
        StorageDead(_172);               // scope 0 at src/label.rs:318:50: 318:51
        goto -> bb38;                    // scope 0 at src/label.rs:318:50: 318:51
    }

    bb37: {
        StorageLive(_177);               // scope 0 at src/label.rs:319:22: 319:50
        StorageLive(_178);               // scope 0 at src/label.rs:319:22: 319:50
        StorageLive(_179);               // scope 0 at src/label.rs:319:22: 319:50
        StorageLive(_180);               // scope 0 at src/label.rs:319:22: 319:35
        StorageLive(_181);               // scope 0 at src/label.rs:319:22: 319:35
        _181 = const UTF_16LE;           // scope 0 at src/label.rs:319:22: 319:35
                                         // ty::Const
                                         // + ty: &codec::utf_16::UTF16LEEncoding
                                         // + val: Unevaluated(UTF_16LE, [], None)
                                         // mir::Constant
                                         // + span: src/label.rs:319:22: 319:35
                                         // + literal: Const { ty: &codec::utf_16::UTF16LEEncoding, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:1278 ~ encoding[5d2c]::all::UTF_16LE), const_param_did: None }, substs_: Some([]), promoted: None }) }
        _180 = _181;                     // scope 0 at src/label.rs:319:22: 319:35
        _179 = move _180 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:319:22: 319:35
        StorageDead(_180);               // scope 0 at src/label.rs:319:34: 319:35
        _178 = _179;                     // scope 0 at src/label.rs:319:22: 319:50
        _177 = move _178 as &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync (Pointer(Unsize)); // scope 0 at src/label.rs:319:22: 319:50
        StorageDead(_178);               // scope 0 at src/label.rs:319:49: 319:50
        ((_0 as Some).0: &dyn encoding_types::Encoding + std::marker::Send + std::marker::Sync) = move _177; // scope 0 at src/label.rs:319:17: 319:51
        discriminant(_0) = 1;            // scope 0 at src/label.rs:319:17: 319:51
        StorageDead(_181);               // scope 0 at src/label.rs:319:50: 319:51
        StorageDead(_179);               // scope 0 at src/label.rs:319:50: 319:51
        StorageDead(_177);               // scope 0 at src/label.rs:319:50: 319:51
        goto -> bb38;                    // scope 0 at src/label.rs:319:50: 319:51
    }

    bb38: {
        return;                          // scope 0 at src/label.rs:322:2: 322:2
    }
}

fn utf_8::<impl at src/codec/utf_8.rs:141:1: 209:2>::is_ascii_compatible(_1: &UTF8Decoder) -> bool {
    debug self => _1;                    // in scope 0 at src/codec/utf_8.rs:143:28: 143:33
    let mut _0: bool;                    // return place in scope 0 at src/codec/utf_8.rs:143:38: 143:42

    bb0: {
        _0 = const true;                 // scope 0 at src/codec/utf_8.rs:143:45: 143:49
        return;                          // scope 0 at src/codec/utf_8.rs:143:51: 143:51
    }
}

fn japanese::<impl at src/codec/japanese.rs:87:10: 87:15>::clone(_1: &EUCJP0212Decoder) -> EUCJP0212Decoder {
    debug self => _1;                    // in scope 0 at src/codec/japanese.rs:87:10: 87:15
    let mut _0: codec::japanese::EUCJP0212Decoder; // return place in scope 0 at src/codec/japanese.rs:87:10: 87:15
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at src/codec/japanese.rs:87:10: 87:15
        return;                          // scope 0 at src/codec/japanese.rs:87:15: 87:15
    }
}

fn iso2022jp::transient::EscapeMiddle24(_1: &mut StatefulDecoderHelper<iso2022jp::State, T>) -> iso2022jp::State {
    debug ctx => _1;                     // in scope 0 at src/util.rs:223:35: 223:39
    let mut _0: codec::japanese::iso2022jp::State; // return place in scope 0 at src/util.rs:223:77: 223:89
    let mut _2: std::option::Option<u8>; // in scope 0 at src/util.rs:224:31: 224:45
    let mut _3: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/util.rs:224:31: 224:38
    let mut _4: isize;                   // in scope 0 at src/util.rs:225:29: 225:33
    let _5: u8;                          // in scope 0 at src/util.rs:226:34: 226:35
    let mut _6: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:955:37: 955:40
    let mut _7: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:956:34: 956:37
    let mut _8: &mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>; // in scope 0 at src/codec/japanese.rs:957:19: 957:22
    scope 1 {
        debug c => _5;                   // in scope 1 at src/util.rs:226:34: 226:35
    }

    bb0: {
        StorageLive(_2);                 // scope 0 at src/util.rs:224:31: 224:45
        StorageLive(_3);                 // scope 0 at src/util.rs:224:31: 224:38
        _3 = &mut (*_1);                 // scope 0 at src/util.rs:224:31: 224:38
        _2 = StatefulDecoderHelper::<iso2022jp::State, T>::read(move _3) -> bb1; // scope 0 at src/util.rs:224:31: 224:45
                                         // mir::Constant
                                         // + span: src/util.rs:224:39: 224:43
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>) -> std::option::Option<u8> {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::read}, val: Value(Scalar(<ZST>)) }
    }

    bb1: {
        StorageDead(_3);                 // scope 0 at src/util.rs:224:44: 224:45
        _4 = discriminant(_2);           // scope 0 at src/util.rs:224:31: 224:45
        switchInt(move _4) -> [0_isize: bb4, 1_isize: bb2, otherwise: bb3]; // scope 0 at src/util.rs:224:25: 224:45
    }

    bb2: {
        StorageLive(_5);                 // scope 0 at src/util.rs:226:34: 226:35
        _5 = ((_2 as Some).0: u8);       // scope 0 at src/util.rs:226:34: 226:35
        switchInt(_5) -> [64_u8: bb6, 66_u8: bb6, 40_u8: bb8, otherwise: bb5]; // scope 1 at src/util.rs:226:40: 226:47
    }

    bb3: {
        unreachable;                     // scope 0 at src/util.rs:224:31: 224:45
    }

    bb4: {
        discriminant(_0) = 5;            // scope 0 at src/util.rs:225:44: 225:62
        goto -> bb12;                    // scope 0 at src/util.rs:225:61: 225:62
    }

    bb5: {
        StorageLive(_8);                 // scope 1 at src/codec/japanese.rs:957:19: 957:22
        _8 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:957:19: 957:22
        _0 = StatefulDecoderHelper::<iso2022jp::State, T>::backup_and_err(move _8, const 2_usize, const "invalid sequence") -> bb10; // scope 1 at src/codec/japanese.rs:957:19: 957:60
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:957:23: 957:37
                                         // + literal: Const { ty: for<'r> fn(&'r mut util::StatefulDecoderHelper<codec::japanese::iso2022jp::State, T>, usize, &'static str) -> codec::japanese::iso2022jp::State {util::StatefulDecoderHelper::<codec::japanese::iso2022jp::State, T>::backup_and_err}, val: Value(Scalar(<ZST>)) }
                                         // ty::Const
                                         // + ty: &str
                                         // + val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 })
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:957:41: 957:59
                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [105, 110, 118, 97, 108, 105, 100, 32, 115, 101, 113, 117, 101, 110, 99, 101], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 16 }) }
    }

    bb6: {
        StorageLive(_6);                 // scope 1 at src/codec/japanese.rs:955:37: 955:40
        _6 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:955:37: 955:40
        _0 = iso2022jp::transient::Lead0208::<T>(move _6) -> bb7; // scope 1 at src/codec/japanese.rs:955:28: 955:41
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:955:28: 955:36
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::Lead0208::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb7: {
        StorageDead(_6);                 // scope 1 at src/codec/japanese.rs:955:40: 955:41
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:955:40: 955:41
    }

    bb8: {
        StorageLive(_7);                 // scope 1 at src/codec/japanese.rs:956:34: 956:37
        _7 = &mut (*_1);                 // scope 1 at src/codec/japanese.rs:956:34: 956:37
        _0 = iso2022jp::transient::EscapeFinal::<T>(move _7) -> bb9; // scope 1 at src/codec/japanese.rs:956:22: 956:38
                                         // mir::Constant
                                         // + span: src/codec/japanese.rs:956:22: 956:33
                                         // + literal: Const { ty: for<'r, 's> fn(&'r mut util::StatefulDecoderHelper<'s, codec::japanese::iso2022jp::State, T>) -> codec::japanese::iso2022jp::State {codec::japanese::iso2022jp::transient::EscapeFinal::<T>}, val: Value(Scalar(<ZST>)) }
    }

    bb9: {
        StorageDead(_7);                 // scope 1 at src/codec/japanese.rs:956:37: 956:38
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:956:37: 956:38
    }

    bb10: {
        StorageDead(_8);                 // scope 1 at src/codec/japanese.rs:957:59: 957:60
        goto -> bb11;                    // scope 1 at src/codec/japanese.rs:957:59: 957:60
    }

    bb11: {
        StorageDead(_5);                 // scope 0 at src/util.rs:226:81: 226:82
        goto -> bb12;                    // scope 0 at src/util.rs:226:81: 226:82
    }

    bb12: {
        StorageDead(_2);                 // scope 0 at src/util.rs:228:21: 228:22
        return;                          // scope 0 at src/util.rs:228:22: 228:22
    }
}

fn bigfive2003::<impl at src/util.rs:157:22: 157:31>::eq(_1: &bigfive2003::State, _2: &bigfive2003::State) -> bool {
    debug self => _1;                    // in scope 0 at src/util.rs:157:22: 157:31
    debug other => _2;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _0: bool;                    // return place in scope 0 at src/util.rs:157:22: 157:31
    let _3: isize;                       // in scope 0 at src/util.rs:157:22: 157:31
    let mut _4: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _5: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _7: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let _8: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _9: bool;                    // in scope 0 at src/util.rs:157:22: 157:31
    let mut _10: bool;                   // in scope 0 at src/util.rs:157:22: 157:31
    let mut _11: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _12: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _13: (&codec::tradchinese::bigfive2003::State, &codec::tradchinese::bigfive2003::State); // in scope 0 at src/util.rs:157:22: 157:31
    let mut _14: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _15: &codec::tradchinese::bigfive2003::State; // in scope 0 at src/util.rs:157:22: 157:31
    let mut _16: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _17: isize;                  // in scope 0 at src/util.rs:157:22: 157:31
    let mut _22: bool;                   // in scope 0 at src/util.rs:164:25: 164:27
    let mut _23: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _24: &();                    // in scope 0 at src/util.rs:164:25: 164:27
    let mut _25: bool;                   // in scope 0 at src/util.rs:164:32: 164:35
    let mut _26: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    let mut _27: u8;                     // in scope 0 at src/util.rs:164:32: 164:35
    scope 1 {
        debug __self_vi => _3;           // in scope 1 at src/util.rs:157:22: 157:31
        let _6: isize;                   // in scope 1 at src/util.rs:157:22: 157:31
        scope 2 {
            debug __arg_1_vi => _6;      // in scope 2 at src/util.rs:157:22: 157:31
            let _18: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _19: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            let _20: &();                // in scope 2 at src/util.rs:164:25: 164:27
            let _21: &u8;                // in scope 2 at src/util.rs:164:32: 164:35
            scope 3 {
                debug __self_0 => _18;   // in scope 3 at src/util.rs:164:25: 164:27
                debug __self_1 => _19;   // in scope 3 at src/util.rs:164:32: 164:35
                debug __arg_1_0 => _20;  // in scope 3 at src/util.rs:164:25: 164:27
                debug __arg_1_1 => _21;  // in scope 3 at src/util.rs:164:32: 164:35
            }
        }
    }

    bb0: {
        StorageLive(_3);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_4);                 // scope 0 at src/util.rs:157:22: 157:31
        StorageLive(_5);                 // scope 0 at src/util.rs:157:22: 157:31
        _5 = _1;                         // scope 0 at src/util.rs:157:22: 157:31
        _4 = _5;                         // scope 0 at src/util.rs:157:22: 157:31
        _3 = discriminant((*_4));        // scope 0 at src/util.rs:157:22: 157:31
        StorageDead(_4);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageDead(_5);                 // scope 0 at src/util.rs:157:30: 157:31
        StorageLive(_6);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_7);                 // scope 1 at src/util.rs:157:22: 157:31
        StorageLive(_8);                 // scope 1 at src/util.rs:157:22: 157:31
        _8 = _2;                         // scope 1 at src/util.rs:157:22: 157:31
        _7 = _8;                         // scope 1 at src/util.rs:157:22: 157:31
        _6 = discriminant((*_7));        // scope 1 at src/util.rs:157:22: 157:31
        StorageDead(_7);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_8);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageLive(_9);                 // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_10);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_11);                // scope 2 at src/util.rs:157:22: 157:31
        _11 = _3;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_12);                // scope 2 at src/util.rs:157:22: 157:31
        _12 = _6;                        // scope 2 at src/util.rs:157:22: 157:31
        _10 = Eq(move _11, move _12);    // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_12);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_11);                // scope 2 at src/util.rs:157:30: 157:31
        _9 = move _10;                   // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_10);                // scope 2 at src/util.rs:157:30: 157:31
        switchInt(move _9) -> [false: bb10, otherwise: bb1]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb1: {
        StorageLive(_13);                // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_14);                // scope 2 at src/util.rs:157:22: 157:31
        _14 = _1;                        // scope 2 at src/util.rs:157:22: 157:31
        StorageLive(_15);                // scope 2 at src/util.rs:157:22: 157:31
        _15 = _2;                        // scope 2 at src/util.rs:157:22: 157:31
        (_13.0: &codec::tradchinese::bigfive2003::State) = move _14; // scope 2 at src/util.rs:157:22: 157:31
        (_13.1: &codec::tradchinese::bigfive2003::State) = move _15; // scope 2 at src/util.rs:157:22: 157:31
        StorageDead(_15);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_14);                // scope 2 at src/util.rs:157:30: 157:31
        _17 = discriminant((*(_13.0: &codec::tradchinese::bigfive2003::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _17) -> [1_isize: bb3, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb2: {
        _0 = const true;                 // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:22: 157:31
    }

    bb3: {
        _16 = discriminant((*(_13.1: &codec::tradchinese::bigfive2003::State))); // scope 2 at src/util.rs:157:22: 157:31
        switchInt(move _16) -> [1_isize: bb4, otherwise: bb2]; // scope 2 at src/util.rs:157:22: 157:31
    }

    bb4: {
        StorageLive(_18);                // scope 2 at src/util.rs:164:25: 164:27
        _18 = &(((*(_13.0: &codec::tradchinese::bigfive2003::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_19);                // scope 2 at src/util.rs:164:32: 164:35
        _19 = &(((*(_13.0: &codec::tradchinese::bigfive2003::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_20);                // scope 2 at src/util.rs:164:25: 164:27
        _20 = &(((*(_13.1: &codec::tradchinese::bigfive2003::State)) as S1).0: ()); // scope 2 at src/util.rs:164:25: 164:27
        StorageLive(_21);                // scope 2 at src/util.rs:164:32: 164:35
        _21 = &(((*(_13.1: &codec::tradchinese::bigfive2003::State)) as S1).1: u8); // scope 2 at src/util.rs:164:32: 164:35
        StorageLive(_22);                // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_23);                // scope 3 at src/util.rs:164:25: 164:27
        _23 = _18;                       // scope 3 at src/util.rs:164:25: 164:27
        StorageLive(_24);                // scope 3 at src/util.rs:164:25: 164:27
        _24 = _20;                       // scope 3 at src/util.rs:164:25: 164:27
        _22 = <() as PartialEq>::eq(move _23, move _24) -> bb8; // scope 3 at src/util.rs:164:25: 164:27
                                         // mir::Constant
                                         // + span: src/util.rs:164:25: 164:27
                                         // + literal: Const { ty: for<'r, 's> fn(&'r (), &'s ()) -> bool {<() as std::cmp::PartialEq>::eq}, val: Value(Scalar(<ZST>)) }
    }

    bb5: {
        _0 = const false;                // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb6: {
        StorageLive(_25);                // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_26);                // scope 3 at src/util.rs:164:32: 164:35
        _26 = (*_19);                    // scope 3 at src/util.rs:164:32: 164:35
        StorageLive(_27);                // scope 3 at src/util.rs:164:32: 164:35
        _27 = (*_21);                    // scope 3 at src/util.rs:164:32: 164:35
        _25 = Eq(move _26, move _27);    // scope 3 at src/util.rs:164:32: 164:35
        StorageDead(_27);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_26);                // scope 3 at src/util.rs:164:34: 164:35
        _0 = move _25;                   // scope 3 at src/util.rs:164:32: 164:35
        goto -> bb7;                     // scope 3 at src/util.rs:164:32: 164:35
    }

    bb7: {
        StorageDead(_25);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_22);                // scope 3 at src/util.rs:164:34: 164:35
        StorageDead(_21);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_20);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_19);                // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_18);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb9;                     // scope 2 at src/util.rs:157:30: 157:31
    }

    bb8: {
        StorageDead(_24);                // scope 3 at src/util.rs:164:26: 164:27
        StorageDead(_23);                // scope 3 at src/util.rs:164:26: 164:27
        switchInt(move _22) -> [false: bb5, otherwise: bb6]; // scope 3 at src/util.rs:164:32: 164:35
    }

    bb9: {
        StorageDead(_13);                // scope 2 at src/util.rs:157:30: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb10: {
        _0 = const false;                // scope 2 at src/util.rs:157:22: 157:31
        goto -> bb11;                    // scope 2 at src/util.rs:157:22: 157:31
    }

    bb11: {
        StorageDead(_9);                 // scope 2 at src/util.rs:157:30: 157:31
        StorageDead(_6);                 // scope 1 at src/util.rs:157:30: 157:31
        StorageDead(_3);                 // scope 0 at src/util.rs:157:30: 157:31
        return;                          // scope 0 at src/util.rs:157:31: 157:31
    }
}
